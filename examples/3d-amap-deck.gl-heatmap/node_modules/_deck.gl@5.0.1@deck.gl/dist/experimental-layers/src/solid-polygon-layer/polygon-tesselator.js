'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PolygonTesselator = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

// Handles tesselation of polygons with holes
// - 2D surfaces
// - 2D outlines
// - 3D surfaces (top and sides only)
// - 3D wireframes (not yet)


var _polygon = require('./polygon');

var Polygon = _interopRequireWildcard(_polygon);

var _deck = require('deck.gl');

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var fillArray = _deck.experimental.fillArray,
    fp64ify = _deck.experimental.fp64ify;

// Maybe deck.gl or luma.gl needs to export this

function getPickingColor(index) {
  index++;
  return [index & 255, index >> 8 & 255, index >> 16 & 255];
}

var DEFAULT_COLOR = [0, 0, 0, 255]; // Black

// This class is set up to allow querying one attribute at a time
// the way the AttributeManager expects it

var PolygonTesselator = exports.PolygonTesselator = function () {
  function PolygonTesselator(_ref) {
    var polygons = _ref.polygons,
        IndexType = _ref.IndexType;

    _classCallCheck(this, PolygonTesselator);

    // Normalize all polygons
    polygons = polygons.map(function (polygon) {
      return Polygon.normalize(polygon);
    });

    // Count all polygon vertices
    var pointCount = getPointCount(polygons);

    this.polygons = polygons;
    this.pointCount = pointCount;
    this.IndexType = IndexType;

    // TODO: dynamically decide IndexType in tesselator?
    // Check if the vertex count excedes index type limit
    if (IndexType === Uint16Array && pointCount > 65535) {
      throw new Error("Vertex count exceeds browser's limit");
    }

    this.attributes = {
      pickingColors: calculatePickingColors({ polygons: polygons, pointCount: pointCount })
    };
  }

  _createClass(PolygonTesselator, [{
    key: 'updatePositions',
    value: function updatePositions(_ref2) {
      var fp64 = _ref2.fp64,
          extruded = _ref2.extruded;
      var attributes = this.attributes,
          polygons = this.polygons,
          pointCount = this.pointCount;


      attributes.positions = attributes.positions || new Float32Array(pointCount * 3);
      attributes.nextPositions = attributes.nextPositions || new Float32Array(pointCount * 3);

      if (fp64) {
        // We only need x, y component
        attributes.positions64xyLow = attributes.positions64xyLow || new Float32Array(pointCount * 2);
        attributes.nextPositions64xyLow = attributes.nextPositions64xyLow || new Float32Array(pointCount * 2);
      }

      _updatePositions({ cache: attributes, polygons: polygons, extruded: extruded, fp64: fp64 });
    }
  }, {
    key: 'indices',
    value: function indices() {
      var polygons = this.polygons,
          IndexType = this.IndexType;

      return calculateIndices({ polygons: polygons, IndexType: IndexType });
    }
  }, {
    key: 'positions',
    value: function positions() {
      return this.attributes.positions;
    }
  }, {
    key: 'positions64xyLow',
    value: function positions64xyLow() {
      return this.attributes.positions64xyLow;
    }
  }, {
    key: 'nextPositions',
    value: function nextPositions() {
      return this.attributes.nextPositions;
    }
  }, {
    key: 'nextPositions64xyLow',
    value: function nextPositions64xyLow() {
      return this.attributes.nextPositions64xyLow;
    }
  }, {
    key: 'elevations',
    value: function elevations() {
      var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref3$key = _ref3.key,
          key = _ref3$key === undefined ? 'elevations' : _ref3$key,
          _ref3$getElevation = _ref3.getElevation,
          getElevation = _ref3$getElevation === undefined ? function (x) {
        return 100;
      } : _ref3$getElevation;

      var attributes = this.attributes,
          polygons = this.polygons,
          pointCount = this.pointCount;

      var values = updateElevations({ cache: attributes[key], polygons: polygons, pointCount: pointCount, getElevation: getElevation });
      attributes[key] = values;
      return values;
    }
  }, {
    key: 'colors',
    value: function colors() {
      var _ref4 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref4$key = _ref4.key,
          key = _ref4$key === undefined ? 'colors' : _ref4$key,
          _ref4$getColor = _ref4.getColor,
          getColor = _ref4$getColor === undefined ? function (x) {
        return DEFAULT_COLOR;
      } : _ref4$getColor;

      var attributes = this.attributes,
          polygons = this.polygons,
          pointCount = this.pointCount;

      var values = updateColors({ cache: attributes[key], polygons: polygons, pointCount: pointCount, getColor: getColor });
      attributes[key] = values;
      return values;
    }
  }, {
    key: 'pickingColors',
    value: function pickingColors() {
      return this.attributes.pickingColors;
    }
  }]);

  return PolygonTesselator;
}();

// Count number of points in a list of complex polygons


function getPointCount(polygons) {
  return polygons.reduce(function (points, polygon) {
    return points + Polygon.getVertexCount(polygon);
  }, 0);
}

// COunt number of triangles in a list of complex polygons
function getTriangleCount(polygons) {
  return polygons.reduce(function (triangles, polygon) {
    return triangles + Polygon.getTriangleCount(polygon);
  }, 0);
}

// Returns the offsets of each complex polygon in the combined array of all polygons
function getPolygonOffsets(polygons) {
  var offsets = new Array(polygons.length + 1);
  offsets[0] = 0;
  var offset = 0;
  polygons.forEach(function (polygon, i) {
    offset += Polygon.getVertexCount(polygon);
    offsets[i + 1] = offset;
  });
  return offsets;
}

function calculateIndices(_ref5) {
  var polygons = _ref5.polygons,
      _ref5$IndexType = _ref5.IndexType,
      IndexType = _ref5$IndexType === undefined ? Uint32Array : _ref5$IndexType;

  // Calculate length of index array (3 * number of triangles)
  var indexCount = 3 * getTriangleCount(polygons);
  var offsets = getPolygonOffsets(polygons);

  // Allocate the attribute
  var attribute = new IndexType(indexCount);

  // 1. get triangulated indices for the internal areas
  // 2. offset them by the number of indices in previous polygons
  var i = 0;
  polygons.forEach(function (polygon, polygonIndex) {
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = Polygon.getSurfaceIndices(polygon)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var index = _step.value;

        attribute[i++] = index + offsets[polygonIndex];
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
  });

  return attribute;
}

function _updatePositions(_ref6) {
  var _ref6$cache = _ref6.cache,
      positions = _ref6$cache.positions,
      positions64xyLow = _ref6$cache.positions64xyLow,
      nextPositions = _ref6$cache.nextPositions,
      nextPositions64xyLow = _ref6$cache.nextPositions64xyLow,
      polygons = _ref6.polygons,
      extruded = _ref6.extruded,
      fp64 = _ref6.fp64;

  // Flatten out all the vertices of all the sub subPolygons
  var i = 0;
  var nextI = 0;
  var startVertex = null;

  var pushStartVertex = function pushStartVertex(x, y, z, xLow, yLow) {
    if (extruded) {
      // Save first vertex for setting nextPositions at the end of the loop
      startVertex = { x: x, y: y, z: z, xLow: xLow, yLow: yLow };
    }
  };

  var popStartVertex = function popStartVertex() {
    if (startVertex) {
      nextPositions[nextI * 3] = startVertex.x;
      nextPositions[nextI * 3 + 1] = startVertex.y;
      nextPositions[nextI * 3 + 2] = startVertex.z;
      if (fp64) {
        nextPositions64xyLow[nextI * 2] = startVertex.xLow;
        nextPositions64xyLow[nextI * 2 + 1] = startVertex.yLow;
      }
      nextI++;
    }
    startVertex = null;
  };

  polygons.forEach(function (polygon, polygonIndex) {
    Polygon.forEachVertex(polygon, function (vertex, vertexIndex) {
      // eslint-disable-line
      var x = vertex[0];
      var y = vertex[1];
      var z = vertex[2] || 0;
      var xLow = void 0;
      var yLow = void 0;

      positions[i * 3] = x;
      positions[i * 3 + 1] = y;
      positions[i * 3 + 2] = z;
      if (fp64) {
        xLow = fp64ify(x)[1];
        yLow = fp64ify(y)[1];
        positions64xyLow[i * 2] = xLow;
        positions64xyLow[i * 2 + 1] = yLow;
      }
      i++;

      if (extruded && vertexIndex > 0) {
        nextPositions[nextI * 3] = x;
        nextPositions[nextI * 3 + 1] = y;
        nextPositions[nextI * 3 + 2] = z;
        if (fp64) {
          nextPositions64xyLow[nextI * 2] = xLow;
          nextPositions64xyLow[nextI * 2 + 1] = yLow;
        }
        nextI++;
      }
      if (vertexIndex === 0) {
        popStartVertex();
        pushStartVertex(x, y, z, xLow, yLow);
      }
    });
  });
  popStartVertex();
}

function updateElevations(_ref7) {
  var cache = _ref7.cache,
      polygons = _ref7.polygons,
      pointCount = _ref7.pointCount,
      getElevation = _ref7.getElevation;

  var elevations = cache || new Float32Array(pointCount);
  var i = 0;
  polygons.forEach(function (complexPolygon, polygonIndex) {
    // Calculate polygon color
    var height = getElevation(polygonIndex);

    var vertexCount = Polygon.getVertexCount(complexPolygon);
    fillArray({ target: elevations, source: [height], start: i, count: vertexCount });
    i += vertexCount;
  });
  return elevations;
}

function updateColors(_ref8) {
  var cache = _ref8.cache,
      polygons = _ref8.polygons,
      pointCount = _ref8.pointCount,
      getColor = _ref8.getColor;

  var colors = cache || new Uint8ClampedArray(pointCount * 4);
  var i = 0;
  polygons.forEach(function (complexPolygon, polygonIndex) {
    // Calculate polygon color
    var color = getColor(polygonIndex);
    if (isNaN(color[3])) {
      color[3] = 255;
    }

    var vertexCount = Polygon.getVertexCount(complexPolygon);
    fillArray({ target: colors, source: color, start: i, count: vertexCount });
    i += color.length * vertexCount;
  });
  return colors;
}

function calculatePickingColors(_ref9) {
  var polygons = _ref9.polygons,
      pointCount = _ref9.pointCount;

  var attribute = new Uint8ClampedArray(pointCount * 3);
  var i = 0;
  polygons.forEach(function (complexPolygon, polygonIndex) {
    var color = getPickingColor(polygonIndex);
    var vertexCount = Polygon.getVertexCount(complexPolygon);
    fillArray({ target: attribute, source: color, start: i, count: vertexCount });
    i += color.length * vertexCount;
  });
  return attribute;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9leHBlcmltZW50YWwtbGF5ZXJzL3NyYy9zb2xpZC1wb2x5Z29uLWxheWVyL3BvbHlnb24tdGVzc2VsYXRvci5qcyJdLCJuYW1lcyI6WyJQb2x5Z29uIiwiZmlsbEFycmF5IiwiZnA2NGlmeSIsImdldFBpY2tpbmdDb2xvciIsImluZGV4IiwiREVGQVVMVF9DT0xPUiIsIlBvbHlnb25UZXNzZWxhdG9yIiwicG9seWdvbnMiLCJJbmRleFR5cGUiLCJtYXAiLCJub3JtYWxpemUiLCJwb2x5Z29uIiwicG9pbnRDb3VudCIsImdldFBvaW50Q291bnQiLCJVaW50MTZBcnJheSIsIkVycm9yIiwiYXR0cmlidXRlcyIsInBpY2tpbmdDb2xvcnMiLCJjYWxjdWxhdGVQaWNraW5nQ29sb3JzIiwiZnA2NCIsImV4dHJ1ZGVkIiwicG9zaXRpb25zIiwiRmxvYXQzMkFycmF5IiwibmV4dFBvc2l0aW9ucyIsInBvc2l0aW9uczY0eHlMb3ciLCJuZXh0UG9zaXRpb25zNjR4eUxvdyIsInVwZGF0ZVBvc2l0aW9ucyIsImNhY2hlIiwiY2FsY3VsYXRlSW5kaWNlcyIsImtleSIsImdldEVsZXZhdGlvbiIsInZhbHVlcyIsInVwZGF0ZUVsZXZhdGlvbnMiLCJnZXRDb2xvciIsInVwZGF0ZUNvbG9ycyIsInJlZHVjZSIsInBvaW50cyIsImdldFZlcnRleENvdW50IiwiZ2V0VHJpYW5nbGVDb3VudCIsInRyaWFuZ2xlcyIsImdldFBvbHlnb25PZmZzZXRzIiwib2Zmc2V0cyIsIkFycmF5IiwibGVuZ3RoIiwib2Zmc2V0IiwiZm9yRWFjaCIsImkiLCJVaW50MzJBcnJheSIsImluZGV4Q291bnQiLCJhdHRyaWJ1dGUiLCJwb2x5Z29uSW5kZXgiLCJnZXRTdXJmYWNlSW5kaWNlcyIsIm5leHRJIiwic3RhcnRWZXJ0ZXgiLCJwdXNoU3RhcnRWZXJ0ZXgiLCJ4IiwieSIsInoiLCJ4TG93IiwieUxvdyIsInBvcFN0YXJ0VmVydGV4IiwiZm9yRWFjaFZlcnRleCIsInZlcnRleCIsInZlcnRleEluZGV4IiwiZWxldmF0aW9ucyIsImNvbXBsZXhQb2x5Z29uIiwiaGVpZ2h0IiwidmVydGV4Q291bnQiLCJ0YXJnZXQiLCJzb3VyY2UiLCJzdGFydCIsImNvdW50IiwiY29sb3JzIiwiVWludDhDbGFtcGVkQXJyYXkiLCJjb2xvciIsImlzTmFOIl0sIm1hcHBpbmdzIjoiOzs7Ozs7O3FqQkFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTs7SUFBWUEsTzs7QUFDWjs7Ozs7O0lBQ09DLFMsc0JBQUFBLFM7SUFBV0MsTyxzQkFBQUEsTzs7QUFFbEI7O0FBQ0EsU0FBU0MsZUFBVCxDQUF5QkMsS0FBekIsRUFBZ0M7QUFDOUJBO0FBQ0EsU0FBTyxDQUFDQSxRQUFRLEdBQVQsRUFBZUEsU0FBUyxDQUFWLEdBQWUsR0FBN0IsRUFBbUNBLFNBQVMsRUFBVixHQUFnQixHQUFsRCxDQUFQO0FBQ0Q7O0FBRUQsSUFBTUMsZ0JBQWdCLENBQUMsQ0FBRCxFQUFJLENBQUosRUFBTyxDQUFQLEVBQVUsR0FBVixDQUF0QixDLENBQXNDOztBQUV0QztBQUNBOztJQUNhQyxpQixXQUFBQSxpQjtBQUNYLG1DQUFtQztBQUFBLFFBQXRCQyxRQUFzQixRQUF0QkEsUUFBc0I7QUFBQSxRQUFaQyxTQUFZLFFBQVpBLFNBQVk7O0FBQUE7O0FBQ2pDO0FBQ0FELGVBQVdBLFNBQVNFLEdBQVQsQ0FBYTtBQUFBLGFBQVdULFFBQVFVLFNBQVIsQ0FBa0JDLE9BQWxCLENBQVg7QUFBQSxLQUFiLENBQVg7O0FBRUE7QUFDQSxRQUFNQyxhQUFhQyxjQUFjTixRQUFkLENBQW5COztBQUVBLFNBQUtBLFFBQUwsR0FBZ0JBLFFBQWhCO0FBQ0EsU0FBS0ssVUFBTCxHQUFrQkEsVUFBbEI7QUFDQSxTQUFLSixTQUFMLEdBQWlCQSxTQUFqQjs7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O0FBQ0FoRSxjQUFVLEVBQUNtRSxRQUFRSSxNQUFULEVBQWlCSCxRQUFRSyxLQUF6QixFQUFnQ0osT0FBT3hCLENBQXZDLEVBQTBDeUIsT0FBT0osV0FBakQsRUFBVjtBQUNBckIsU0FBSzRCLE1BQU0vQixNQUFOLEdBQWV3QixXQUFwQjtBQUNELEdBVkQ7QUFXQSxTQUFPSyxNQUFQO0FBQ0Q7O0FBRUQsU0FBU3RELHNCQUFULFFBQXdEO0FBQUEsTUFBdkJYLFFBQXVCLFNBQXZCQSxRQUF1QjtBQUFBLE1BQWJLLFVBQWEsU0FBYkEsVUFBYTs7QUFDdEQsTUFBTXFDLFlBQVksSUFBSXdCLGlCQUFKLENBQXNCN0QsYUFBYSxDQUFuQyxDQUFsQjtBQUNBLE1BQUlrQyxJQUFJLENBQVI7QUFDQXZDLFdBQVNzQyxPQUFULENBQWlCLFVBQUNvQixjQUFELEVBQWlCZixZQUFqQixFQUFrQztBQUNqRCxRQUFNd0IsUUFBUXZFLGdCQUFnQitDLFlBQWhCLENBQWQ7QUFDQSxRQUFNaUIsY0FBY25FLFFBQVFxQyxjQUFSLENBQXVCNEIsY0FBdkIsQ0FBcEI7QUFDQWhFLGNBQVUsRUFBQ21FLFFBQVFuQixTQUFULEVBQW9Cb0IsUUFBUUssS0FBNUIsRUFBbUNKLE9BQU94QixDQUExQyxFQUE2Q3lCLE9BQU9KLFdBQXBELEVBQVY7QUFDQXJCLFNBQUs0QixNQUFNL0IsTUFBTixHQUFld0IsV0FBcEI7QUFDRCxHQUxEO0FBTUEsU0FBT2xCLFNBQVA7QUFDRCIsImZpbGUiOiJwb2x5Z29uLXRlc3NlbGF0b3IuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIDIwMTUgLSAyMDE3IFViZXIgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbi8vIFRIRSBTT0ZUV0FSRS5cblxuLy8gSGFuZGxlcyB0ZXNzZWxhdGlvbiBvZiBwb2x5Z29ucyB3aXRoIGhvbGVzXG4vLyAtIDJEIHN1cmZhY2VzXG4vLyAtIDJEIG91dGxpbmVzXG4vLyAtIDNEIHN1cmZhY2VzICh0b3AgYW5kIHNpZGVzIG9ubHkpXG4vLyAtIDNEIHdpcmVmcmFtZXMgKG5vdCB5ZXQpXG5pbXBvcnQgKiBhcyBQb2x5Z29uIGZyb20gJy4vcG9seWdvbic7XG5pbXBvcnQge2V4cGVyaW1lbnRhbH0gZnJvbSAnZGVjay5nbCc7XG5jb25zdCB7ZmlsbEFycmF5LCBmcDY0aWZ5fSA9IGV4cGVyaW1lbnRhbDtcblxuLy8gTWF5YmUgZGVjay5nbCBvciBsdW1hLmdsIG5lZWRzIHRvIGV4cG9ydCB0aGlzXG5mdW5jdGlvbiBnZXRQaWNraW5nQ29sb3IoaW5kZXgpIHtcbiAgaW5kZXgrKztcbiAgcmV0dXJuIFtpbmRleCAmIDI1NSwgKGluZGV4ID4+IDgpICYgMjU1LCAoaW5kZXggPj4gMTYpICYgMjU1XTtcbn1cblxuY29uc3QgREVGQVVMVF9DT0xPUiA9IFswLCAwLCAwLCAyNTVdOyAvLyBCbGFja1xuXG4vLyBUaGlzIGNsYXNzIGlzIHNldCB1cCB0byBhbGxvdyBxdWVyeWluZyBvbmUgYXR0cmlidXRlIGF0IGEgdGltZVxuLy8gdGhlIHdheSB0aGUgQXR0cmlidXRlTWFuYWdlciBleHBlY3RzIGl0XG5leHBvcnQgY2xhc3MgUG9seWdvblRlc3NlbGF0b3Ige1xuICBjb25zdHJ1Y3Rvcih7cG9seWdvbnMsIEluZGV4VHlwZX0pIHtcbiAgICAvLyBOb3JtYWxpemUgYWxsIHBvbHlnb25zXG4gICAgcG9seWdvbnMgPSBwb2x5Z29ucy5tYXAocG9seWdvbiA9PiBQb2x5Z29uLm5vcm1hbGl6ZShwb2x5Z29uKSk7XG5cbiAgICAvLyBDb3VudCBhbGwgcG9seWdvbiB2ZXJ0aWNlc1xuICAgIGNvbnN0IHBvaW50Q291bnQgPSBnZXRQb2ludENvdW50KHBvbHlnb25zKTtcblxuICAgIHRoaXMucG9seWdvbnMgPSBwb2x5Z29ucztcbiAgICB0aGlzLnBvaW50Q291bnQgPSBwb2ludENvdW50O1xuICAgIHRoaXMuSW5kZXhUeXBlID0gSW5kZXhUeXBlO1xuXG4gICAgLy8gVE9ETzogZHluYW1pY2FsbHkgZGVjaWRlIEluZGV4VHlwZSBpbiB0ZXNzZWxhdG9yP1xuICAgIC8vIENoZWNrIGlmIHRoZSB2ZXJ0ZXggY291bnQgZXhjZWRlcyBpbmRleCB0eXBlIGxpbWl0XG4gICAgaWYgKEluZGV4VHlwZSA9PT0gVWludDE2QXJyYXkgJiYgcG9pbnRDb3VudCA+IDY1NTM1KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJWZXJ0ZXggY291bnQgZXhjZWVkcyBicm93c2VyJ3MgbGltaXRcIik7XG4gICAgfVxuXG4gICAgdGhpcy5hdHRyaWJ1dGVzID0ge1xuICAgICAgcGlja2luZ0NvbG9yczogY2FsY3VsYXRlUGlja2luZ0NvbG9ycyh7cG9seWdvbnMsIHBvaW50Q291bnR9KVxuICAgIH07XG4gIH1cblxuICB1cGRhdGVQb3NpdGlvbnMoe2ZwNjQsIGV4dHJ1ZGVkfSkge1xuICAgIGNvbnN0IHthdHRyaWJ1dGVzLCBwb2x5Z29ucywgcG9pbnRDb3VudH0gPSB0aGlzO1xuXG4gICAgYXR0cmlidXRlcy5wb3NpdGlvbnMgPSBhdHRyaWJ1dGVzLnBvc2l0aW9ucyB8fCBuZXcgRmxvYXQzMkFycmF5KHBvaW50Q291bnQgKiAzKTtcbiAgICBhdHRyaWJ1dGVzLm5leHRQb3NpdGlvbnMgPSBhdHRyaWJ1dGVzLm5leHRQb3NpdGlvbnMgfHwgbmV3IEZsb2F0MzJBcnJheShwb2ludENvdW50ICogMyk7XG5cbiAgICBpZiAoZnA2NCkge1xuICAgICAgLy8gV2Ugb25seSBuZWVkIHgsIHkgY29tcG9uZW50XG4gICAgICBhdHRyaWJ1dGVzLnBvc2l0aW9uczY0eHlMb3cgPSBhdHRyaWJ1dGVzLnBvc2l0aW9uczY0eHlMb3cgfHwgbmV3IEZsb2F0MzJBcnJheShwb2ludENvdW50ICogMik7XG4gICAgICBhdHRyaWJ1dGVzLm5leHRQb3NpdGlvbnM2NHh5TG93ID1cbiAgICAgICAgYXR0cmlidXRlcy5uZXh0UG9zaXRpb25zNjR4eUxvdyB8fCBuZXcgRmxvYXQzMkFycmF5KHBvaW50Q291bnQgKiAyKTtcbiAgICB9XG5cbiAgICB1cGRhdGVQb3NpdGlvbnMoe2NhY2hlOiBhdHRyaWJ1dGVzLCBwb2x5Z29ucywgZXh0cnVkZWQsIGZwNjR9KTtcbiAgfVxuXG4gIGluZGljZXMoKSB7XG4gICAgY29uc3Qge3BvbHlnb25zLCBJbmRleFR5cGV9ID0gdGhpcztcbiAgICByZXR1cm4gY2FsY3VsYXRlSW5kaWNlcyh7cG9seWdvbnMsIEluZGV4VHlwZX0pO1xuICB9XG5cbiAgcG9zaXRpb25zKCkge1xuICAgIHJldHVybiB0aGlzLmF0dHJpYnV0ZXMucG9zaXRpb25zO1xuICB9XG4gIHBvc2l0aW9uczY0eHlMb3coKSB7XG4gICAgcmV0dXJuIHRoaXMuYXR0cmlidXRlcy5wb3NpdGlvbnM2NHh5TG93O1xuICB9XG5cbiAgbmV4dFBvc2l0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5hdHRyaWJ1dGVzLm5leHRQb3NpdGlvbnM7XG4gIH1cbiAgbmV4dFBvc2l0aW9uczY0eHlMb3coKSB7XG4gICAgcmV0dXJuIHRoaXMuYXR0cmlidXRlcy5uZXh0UG9zaXRpb25zNjR4eUxvdztcbiAgfVxuXG4gIGVsZXZhdGlvbnMoe2tleSA9ICdlbGV2YXRpb25zJywgZ2V0RWxldmF0aW9uID0geCA9PiAxMDB9ID0ge30pIHtcbiAgICBjb25zdCB7YXR0cmlidXRlcywgcG9seWdvbnMsIHBvaW50Q291bnR9ID0gdGhpcztcbiAgICBjb25zdCB2YWx1ZXMgPSB1cGRhdGVFbGV2YXRpb25zKHtjYWNoZTogYXR0cmlidXRlc1trZXldLCBwb2x5Z29ucywgcG9pbnRDb3VudCwgZ2V0RWxldmF0aW9ufSk7XG4gICAgYXR0cmlidXRlc1trZXldID0gdmFsdWVzO1xuICAgIHJldHVybiB2YWx1ZXM7XG4gIH1cblxuICBjb2xvcnMoe2tleSA9ICdjb2xvcnMnLCBnZXRDb2xvciA9IHggPT4gREVGQVVMVF9DT0xPUn0gPSB7fSkge1xuICAgIGNvbnN0IHthdHRyaWJ1dGVzLCBwb2x5Z29ucywgcG9pbnRDb3VudH0gPSB0aGlzO1xuICAgIGNvbnN0IHZhbHVlcyA9IHVwZGF0ZUNvbG9ycyh7Y2FjaGU6IGF0dHJpYnV0ZXNba2V5XSwgcG9seWdvbnMsIHBvaW50Q291bnQsIGdldENvbG9yfSk7XG4gICAgYXR0cmlidXRlc1trZXldID0gdmFsdWVzO1xuICAgIHJldHVybiB2YWx1ZXM7XG4gIH1cblxuICBwaWNraW5nQ29sb3JzKCkge1xuICAgIHJldHVybiB0aGlzLmF0dHJpYnV0ZXMucGlja2luZ0NvbG9ycztcbiAgfVxufVxuXG4vLyBDb3VudCBudW1iZXIgb2YgcG9pbnRzIGluIGEgbGlzdCBvZiBjb21wbGV4IHBvbHlnb25zXG5mdW5jdGlvbiBnZXRQb2ludENvdW50KHBvbHlnb25zKSB7XG4gIHJldHVybiBwb2x5Z29ucy5yZWR1Y2UoKHBvaW50cywgcG9seWdvbikgPT4gcG9pbnRzICsgUG9seWdvbi5nZXRWZXJ0ZXhDb3VudChwb2x5Z29uKSwgMCk7XG59XG5cbi8vIENPdW50IG51bWJlciBvZiB0cmlhbmdsZXMgaW4gYSBsaXN0IG9mIGNvbXBsZXggcG9seWdvbnNcbmZ1bmN0aW9uIGdldFRyaWFuZ2xlQ291bnQocG9seWdvbnMpIHtcbiAgcmV0dXJuIHBvbHlnb25zLnJlZHVjZSgodHJpYW5nbGVzLCBwb2x5Z29uKSA9PiB0cmlhbmdsZXMgKyBQb2x5Z29uLmdldFRyaWFuZ2xlQ291bnQocG9seWdvbiksIDApO1xufVxuXG4vLyBSZXR1cm5zIHRoZSBvZmZzZXRzIG9mIGVhY2ggY29tcGxleCBwb2x5Z29uIGluIHRoZSBjb21iaW5lZCBhcnJheSBvZiBhbGwgcG9seWdvbnNcbmZ1bmN0aW9uIGdldFBvbHlnb25PZmZzZXRzKHBvbHlnb25zKSB7XG4gIGNvbnN0IG9mZnNldHMgPSBuZXcgQXJyYXkocG9seWdvbnMubGVuZ3RoICsgMSk7XG4gIG9mZnNldHNbMF0gPSAwO1xuICBsZXQgb2Zmc2V0ID0gMDtcbiAgcG9seWdvbnMuZm9yRWFjaCgocG9seWdvbiwgaSkgPT4ge1xuICAgIG9mZnNldCArPSBQb2x5Z29uLmdldFZlcnRleENvdW50KHBvbHlnb24pO1xuICAgIG9mZnNldHNbaSArIDFdID0gb2Zmc2V0O1xuICB9KTtcbiAgcmV0dXJuIG9mZnNldHM7XG59XG5cbmZ1bmN0aW9uIGNhbGN1bGF0ZUluZGljZXMoe3BvbHlnb25zLCBJbmRleFR5cGUgPSBVaW50MzJBcnJheX0pIHtcbiAgLy8gQ2FsY3VsYXRlIGxlbmd0aCBvZiBpbmRleCBhcnJheSAoMyAqIG51bWJlciBvZiB0cmlhbmdsZXMpXG4gIGNvbnN0IGluZGV4Q291bnQgPSAzICogZ2V0VHJpYW5nbGVDb3VudChwb2x5Z29ucyk7XG4gIGNvbnN0IG9mZnNldHMgPSBnZXRQb2x5Z29uT2Zmc2V0cyhwb2x5Z29ucyk7XG5cbiAgLy8gQWxsb2NhdGUgdGhlIGF0dHJpYnV0ZVxuICBjb25zdCBhdHRyaWJ1dGUgPSBuZXcgSW5kZXhUeXBlKGluZGV4Q291bnQpO1xuXG4gIC8vIDEuIGdldCB0cmlhbmd1bGF0ZWQgaW5kaWNlcyBmb3IgdGhlIGludGVybmFsIGFyZWFzXG4gIC8vIDIuIG9mZnNldCB0aGVtIGJ5IHRoZSBudW1iZXIgb2YgaW5kaWNlcyBpbiBwcmV2aW91cyBwb2x5Z29uc1xuICBsZXQgaSA9IDA7XG4gIHBvbHlnb25zLmZvckVhY2goKHBvbHlnb24sIHBvbHlnb25JbmRleCkgPT4ge1xuICAgIGZvciAoY29uc3QgaW5kZXggb2YgUG9seWdvbi5nZXRTdXJmYWNlSW5kaWNlcyhwb2x5Z29uKSkge1xuICAgICAgYXR0cmlidXRlW2krK10gPSBpbmRleCArIG9mZnNldHNbcG9seWdvbkluZGV4XTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBhdHRyaWJ1dGU7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVBvc2l0aW9ucyh7XG4gIGNhY2hlOiB7cG9zaXRpb25zLCBwb3NpdGlvbnM2NHh5TG93LCBuZXh0UG9zaXRpb25zLCBuZXh0UG9zaXRpb25zNjR4eUxvd30sXG4gIHBvbHlnb25zLFxuICBleHRydWRlZCxcbiAgZnA2NFxufSkge1xuICAvLyBGbGF0dGVuIG91dCBhbGwgdGhlIHZlcnRpY2VzIG9mIGFsbCB0aGUgc3ViIHN1YlBvbHlnb25zXG4gIGxldCBpID0gMDtcbiAgbGV0IG5leHRJID0gMDtcbiAgbGV0IHN0YXJ0VmVydGV4ID0gbnVsbDtcblxuICBjb25zdCBwdXNoU3RhcnRWZXJ0ZXggPSAoeCwgeSwgeiwgeExvdywgeUxvdykgPT4ge1xuICAgIGlmIChleHRydWRlZCkge1xuICAgICAgLy8gU2F2ZSBmaXJzdCB2ZXJ0ZXggZm9yIHNldHRpbmcgbmV4dFBvc2l0aW9ucyBhdCB0aGUgZW5kIG9mIHRoZSBsb29wXG4gICAgICBzdGFydFZlcnRleCA9IHt4LCB5LCB6LCB4TG93LCB5TG93fTtcbiAgICB9XG4gIH07XG5cbiAgY29uc3QgcG9wU3RhcnRWZXJ0ZXggPSAoKSA9PiB7XG4gICAgaWYgKHN0YXJ0VmVydGV4KSB7XG4gICAgICBuZXh0UG9zaXRpb25zW25leHRJICogM10gPSBzdGFydFZlcnRleC54O1xuICAgICAgbmV4dFBvc2l0aW9uc1tuZXh0SSAqIDMgKyAxXSA9IHN0YXJ0VmVydGV4Lnk7XG4gICAgICBuZXh0UG9zaXRpb25zW25leHRJICogMyArIDJdID0gc3RhcnRWZXJ0ZXguejtcbiAgICAgIGlmIChmcDY0KSB7XG4gICAgICAgIG5leHRQb3NpdGlvbnM2NHh5TG93W25leHRJICogMl0gPSBzdGFydFZlcnRleC54TG93O1xuICAgICAgICBuZXh0UG9zaXRpb25zNjR4eUxvd1tuZXh0SSAqIDIgKyAxXSA9IHN0YXJ0VmVydGV4LnlMb3c7XG4gICAgICB9XG4gICAgICBuZXh0SSsrO1xuICAgIH1cbiAgICBzdGFydFZlcnRleCA9IG51bGw7XG4gIH07XG5cbiAgcG9seWdvbnMuZm9yRWFjaCgocG9seWdvbiwgcG9seWdvbkluZGV4KSA9PiB7XG4gICAgUG9seWdvbi5mb3JFYWNoVmVydGV4KHBvbHlnb24sICh2ZXJ0ZXgsIHZlcnRleEluZGV4KSA9PiB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICBjb25zdCB4ID0gdmVydGV4WzBdO1xuICAgICAgY29uc3QgeSA9IHZlcnRleFsxXTtcbiAgICAgIGNvbnN0IHogPSB2ZXJ0ZXhbMl0gfHwgMDtcbiAgICAgIGxldCB4TG93O1xuICAgICAgbGV0IHlMb3c7XG5cbiAgICAgIHBvc2l0aW9uc1tpICogM10gPSB4O1xuICAgICAgcG9zaXRpb25zW2kgKiAzICsgMV0gPSB5O1xuICAgICAgcG9zaXRpb25zW2kgKiAzICsgMl0gPSB6O1xuICAgICAgaWYgKGZwNjQpIHtcbiAgICAgICAgeExvdyA9IGZwNjRpZnkoeClbMV07XG4gICAgICAgIHlMb3cgPSBmcDY0aWZ5KHkpWzFdO1xuICAgICAgICBwb3NpdGlvbnM2NHh5TG93W2kgKiAyXSA9IHhMb3c7XG4gICAgICAgIHBvc2l0aW9uczY0eHlMb3dbaSAqIDIgKyAxXSA9IHlMb3c7XG4gICAgICB9XG4gICAgICBpKys7XG5cbiAgICAgIGlmIChleHRydWRlZCAmJiB2ZXJ0ZXhJbmRleCA+IDApIHtcbiAgICAgICAgbmV4dFBvc2l0aW9uc1tuZXh0SSAqIDNdID0geDtcbiAgICAgICAgbmV4dFBvc2l0aW9uc1tuZXh0SSAqIDMgKyAxXSA9IHk7XG4gICAgICAgIG5leHRQb3NpdGlvbnNbbmV4dEkgKiAzICsgMl0gPSB6O1xuICAgICAgICBpZiAoZnA2NCkge1xuICAgICAgICAgIG5leHRQb3NpdGlvbnM2NHh5TG93W25leHRJICogMl0gPSB4TG93O1xuICAgICAgICAgIG5leHRQb3NpdGlvbnM2NHh5TG93W25leHRJICogMiArIDFdID0geUxvdztcbiAgICAgICAgfVxuICAgICAgICBuZXh0SSsrO1xuICAgICAgfVxuICAgICAgaWYgKHZlcnRleEluZGV4ID09PSAwKSB7XG4gICAgICAgIHBvcFN0YXJ0VmVydGV4KCk7XG4gICAgICAgIHB1c2hTdGFydFZlcnRleCh4LCB5LCB6LCB4TG93LCB5TG93KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG4gIHBvcFN0YXJ0VmVydGV4KCk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUVsZXZhdGlvbnMoe2NhY2hlLCBwb2x5Z29ucywgcG9pbnRDb3VudCwgZ2V0RWxldmF0aW9ufSkge1xuICBjb25zdCBlbGV2YXRpb25zID0gY2FjaGUgfHwgbmV3IEZsb2F0MzJBcnJheShwb2ludENvdW50KTtcbiAgbGV0IGkgPSAwO1xuICBwb2x5Z29ucy5mb3JFYWNoKChjb21wbGV4UG9seWdvbiwgcG9seWdvbkluZGV4KSA9PiB7XG4gICAgLy8gQ2FsY3VsYXRlIHBvbHlnb24gY29sb3JcbiAgICBjb25zdCBoZWlnaHQgPSBnZXRFbGV2YXRpb24ocG9seWdvbkluZGV4KTtcblxuICAgIGNvbnN0IHZlcnRleENvdW50ID0gUG9seWdvbi5nZXRWZXJ0ZXhDb3VudChjb21wbGV4UG9seWdvbik7XG4gICAgZmlsbEFycmF5KHt0YXJnZXQ6IGVsZXZhdGlvbnMsIHNvdXJjZTogW2hlaWdodF0sIHN0YXJ0OiBpLCBjb3VudDogdmVydGV4Q291bnR9KTtcbiAgICBpICs9IHZlcnRleENvdW50O1xuICB9KTtcbiAgcmV0dXJuIGVsZXZhdGlvbnM7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUNvbG9ycyh7Y2FjaGUsIHBvbHlnb25zLCBwb2ludENvdW50LCBnZXRDb2xvcn0pIHtcbiAgY29uc3QgY29sb3JzID0gY2FjaGUgfHwgbmV3IFVpbnQ4Q2xhbXBlZEFycmF5KHBvaW50Q291bnQgKiA0KTtcbiAgbGV0IGkgPSAwO1xuICBwb2x5Z29ucy5mb3JFYWNoKChjb21wbGV4UG9seWdvbiwgcG9seWdvbkluZGV4KSA9PiB7XG4gICAgLy8gQ2FsY3VsYXRlIHBvbHlnb24gY29sb3JcbiAgICBjb25zdCBjb2xvciA9IGdldENvbG9yKHBvbHlnb25JbmRleCk7XG4gICAgaWYgKGlzTmFOKGNvbG9yWzNdKSkge1xuICAgICAgY29sb3JbM10gPSAyNTU7XG4gICAgfVxuXG4gICAgY29uc3QgdmVydGV4Q291bnQgPSBQb2x5Z29uLmdldFZlcnRleENvdW50KGNvbXBsZXhQb2x5Z29uKTtcbiAgICBmaWxsQXJyYXkoe3RhcmdldDogY29sb3JzLCBzb3VyY2U6IGNvbG9yLCBzdGFydDogaSwgY291bnQ6IHZlcnRleENvdW50fSk7XG4gICAgaSArPSBjb2xvci5sZW5ndGggKiB2ZXJ0ZXhDb3VudDtcbiAgfSk7XG4gIHJldHVybiBjb2xvcnM7XG59XG5cbmZ1bmN0aW9uIGNhbGN1bGF0ZVBpY2tpbmdDb2xvcnMoe3BvbHlnb25zLCBwb2ludENvdW50fSkge1xuICBjb25zdCBhdHRyaWJ1dGUgPSBuZXcgVWludDhDbGFtcGVkQXJyYXkocG9pbnRDb3VudCAqIDMpO1xuICBsZXQgaSA9IDA7XG4gIHBvbHlnb25zLmZvckVhY2goKGNvbXBsZXhQb2x5Z29uLCBwb2x5Z29uSW5kZXgpID0+IHtcbiAgICBjb25zdCBjb2xvciA9IGdldFBpY2tpbmdDb2xvcihwb2x5Z29uSW5kZXgpO1xuICAgIGNvbnN0IHZlcnRleENvdW50ID0gUG9seWdvbi5nZXRWZXJ0ZXhDb3VudChjb21wbGV4UG9seWdvbik7XG4gICAgZmlsbEFycmF5KHt0YXJnZXQ6IGF0dHJpYnV0ZSwgc291cmNlOiBjb2xvciwgc3RhcnQ6IGksIGNvdW50OiB2ZXJ0ZXhDb3VudH0pO1xuICAgIGkgKz0gY29sb3IubGVuZ3RoICogdmVydGV4Q291bnQ7XG4gIH0pO1xuICByZXR1cm4gYXR0cmlidXRlO1xufVxuIl19