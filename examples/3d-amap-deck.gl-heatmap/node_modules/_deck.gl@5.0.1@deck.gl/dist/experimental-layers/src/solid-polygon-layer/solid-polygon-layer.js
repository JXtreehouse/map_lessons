'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _deck = require('deck.gl');

var _luma = require('luma.gl');

var _polygonTesselator = require('./polygon-tesselator');

var _solidPolygonLayerVertex = require('./solid-polygon-layer-vertex.glsl');

var _solidPolygonLayerVertex2 = _interopRequireDefault(_solidPolygonLayerVertex);

var _solidPolygonLayerVertex3 = require('./solid-polygon-layer-vertex-64.glsl');

var _solidPolygonLayerVertex4 = _interopRequireDefault(_solidPolygonLayerVertex3);

var _solidPolygonLayerFragment = require('./solid-polygon-layer-fragment.glsl');

var _solidPolygonLayerFragment2 = _interopRequireDefault(_solidPolygonLayerFragment);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

var enable64bitSupport = _deck.experimental.enable64bitSupport,
    get = _deck.experimental.get;

// Polygon geometry generation is managed by the polygon tesselator

var defaultLineColor = [0x0, 0x0, 0x0, 0xff];
var defaultFillColor = [0x0, 0x0, 0x0, 0xff];

var defaultProps = {
  filled: true,
  // Whether to extrude
  extruded: false,
  // Whether to draw a GL.LINES wireframe of the polygon
  wireframe: false,
  fp64: false,

  // elevation multiplier
  elevationScale: 1,

  // Accessor for polygon geometry
  getPolygon: function getPolygon(f) {
    return get(f, 'polygon') || get(f, 'geometry.coordinates');
  },
  // Accessor for extrusion height
  getElevation: function getElevation(f) {
    return get(f, 'elevation') || get(f, 'properties.height') || 0;
  },
  // Accessor for colors
  getFillColor: function getFillColor(f) {
    return get(f, 'fillColor') || get(f, 'properties.color') || defaultFillColor;
  },
  getLineColor: function getLineColor(f) {
    return get(f, 'lineColor') || get(f, 'properties.color') || defaultLineColor;
  },

  // Optional settings for 'lighting' shader module
  lightSettings: {
    lightsPosition: [-122.45, 37.75, 8000, -122.0, 38.0, 5000],
    ambientRatio: 0.05,
    diffuseRatio: 0.6,
    specularRatio: 0.8,
    lightsStrength: [2.0, 0.0, 0.0, 0.0],
    numberOfLights: 2
  }
};

// Side model attributes
var SIDE_FILL_POSITIONS = new Float32Array([
// top left corner
0, 1,
// bottom left corner
0, 0,
// top right corner
1, 1,
// bottom right corner
1, 0]);
var SIDE_WIRE_POSITIONS = new Float32Array([
// top right corner
1, 1,
// top left corner
0, 1,
// bottom left corner
0, 0,
// bottom right corner
1, 0]);

// Model types
var ATTRIBUTE_MAPS = {
  TOP: {
    indices: { instanced: false },
    positions: { instanced: false },
    positions64xyLow: { instanced: false },
    elevations: { instanced: false },
    fillColors: { name: 'colors', instanced: false },
    pickingColors: { instanced: false }
  },
  SIDE: {
    positions: { instanced: true },
    positions64xyLow: { instanced: true },
    nextPositions: { instanced: true },
    nextPositions64xyLow: { instanced: true },
    elevations: { instanced: true },
    fillColors: { name: 'colors', instanced: true },
    pickingColors: { instanced: true }
  },
  WIRE: {
    positions: { instanced: true },
    positions64xyLow: { instanced: true },
    nextPositions: { instanced: true },
    nextPositions64xyLow: { instanced: true },
    elevations: { instanced: true },
    lineColors: { name: 'colors', instanced: true },
    pickingColors: { instanced: true }
  }
};

var SolidPolygonLayer = function (_Layer) {
  _inherits(SolidPolygonLayer, _Layer);

  function SolidPolygonLayer() {
    _classCallCheck(this, SolidPolygonLayer);

    return _possibleConstructorReturn(this, (SolidPolygonLayer.__proto__ || Object.getPrototypeOf(SolidPolygonLayer)).apply(this, arguments));
  }

  _createClass(SolidPolygonLayer, [{
    key: 'getShaders',
    value: function getShaders() {
      return enable64bitSupport(this.props) ? { vs: _solidPolygonLayerVertex4.default, fs: _solidPolygonLayerFragment2.default, modules: ['project64', 'lighting', 'picking'] } : { vs: _solidPolygonLayerVertex2.default, fs: _solidPolygonLayerFragment2.default, modules: ['lighting', 'picking'] }; // 'project' module added by default.
    }
  }, {
    key: 'initializeState',
    value: function initializeState() {
      var gl = this.context.gl;

      this.setState({
        numInstances: 0,
        IndexType: gl.getExtension('OES_element_index_uint') ? Uint32Array : Uint16Array
      });

      var attributeManager = this.state.attributeManager;

      var noAlloc = true;
      /* eslint-disable max-len */
      attributeManager.add({
        indices: { size: 1, isIndexed: true, update: this.calculateIndices, noAlloc: noAlloc },
        positions: {
          size: 3,
          accessor: ['extruded', 'fp64'],
          update: this.calculatePositions,
          noAlloc: noAlloc
        },
        nextPositions: {
          size: 3,
          accessor: ['extruded', 'fp64'],
          update: this.calculateNextPositions,
          noAlloc: noAlloc
        },
        elevations: {
          size: 1,
          accessor: ['extruded', 'getElevation'],
          update: this.calculateElevations,
          noAlloc: noAlloc
        },
        fillColors: {
          alias: 'colors',
          size: 4,
          type: _luma.GL.UNSIGNED_BYTE,
          accessor: 'getFillColor',
          update: this.calculateFillColors,
          noAlloc: noAlloc
        },
        lineColors: {
          alias: 'colors',
          size: 4,
          type: _luma.GL.UNSIGNED_BYTE,
          accessor: 'getLineColor',
          update: this.calculateLineColors,
          noAlloc: noAlloc
        },
        pickingColors: { size: 3, type: _luma.GL.UNSIGNED_BYTE, update: this.calculatePickingColors, noAlloc: noAlloc }
      });
      /* eslint-enable max-len */
    }
  }, {
    key: 'updateAttribute',
    value: function updateAttribute(_ref) {
      var props = _ref.props,
          oldProps = _ref.oldProps;

      if (props.fp64 !== oldProps.fp64) {
        var attributeManager = this.state.attributeManager;


        if (props.fp64 && props.coordinateSystem === _deck.COORDINATE_SYSTEM.LNGLAT) {
          /* eslint-disable max-len */
          attributeManager.add({
            positions64xyLow: { size: 2, accessor: 'fp64', update: this.calculatePositionsLow },
            nextPositions64xyLow: { size: 2, accessor: 'fp64', update: this.calculateNextPositionsLow }
          });
          /* eslint-enable max-len */
        } else {
          attributeManager.remove(['positions64xyLow', 'nextPositions64xyLow']);
        }
      }
    }
  }, {
    key: 'draw',
    value: function draw(_ref2) {
      var uniforms = _ref2.uniforms;
      var _props = this.props,
          extruded = _props.extruded,
          lightSettings = _props.lightSettings,
          elevationScale = _props.elevationScale;


      var renderUniforms = Object.assign({}, uniforms, {
        extruded: extruded ? 1.0 : 0.0,
        elevationScale: elevationScale
      }, lightSettings);

      this.state.models.forEach(function (model) {
        model.render(renderUniforms);
      });
    }
  }, {
    key: 'updateState',
    value: function updateState(updateParams) {
      _get(SolidPolygonLayer.prototype.__proto__ || Object.getPrototypeOf(SolidPolygonLayer.prototype), 'updateState', this).call(this, updateParams);

      this.updateGeometry(updateParams);
      this.updateAttribute(updateParams);

      var props = updateParams.props,
          oldProps = updateParams.oldProps;


      var regenerateModels = props.fp64 !== oldProps.fp64 || props.filled !== oldProps.filled || props.extruded !== oldProps.extruded || props.wireframe !== oldProps.wireframe;

      if (regenerateModels) {
        this.setState(Object.assign({
          // Set a flag to set attributes to new models
          modelsChanged: true
        }, this._getModels(this.context.gl)));
      }

      if (props.extruded !== oldProps.extruded) {
        this.state.attributeManager.invalidate('extruded');
      }
      if (props.fp64 !== oldProps.fp64) {
        this.state.attributeManager.invalidate('fp64');
      }
    }
  }, {
    key: 'updateGeometry',
    value: function updateGeometry(_ref3) {
      var props = _ref3.props,
          oldProps = _ref3.oldProps,
          changeFlags = _ref3.changeFlags;

      var geometryConfigChanged = changeFlags.dataChanged || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getPolygon);

      // When the geometry config  or the data is changed,
      // tessellator needs to be invoked
      if (geometryConfigChanged) {
        // TODO - avoid creating a temporary array here: let the tesselator iterate
        var polygons = props.data.map(props.getPolygon);

        this.setState({
          polygonTesselator: new _polygonTesselator.PolygonTesselator({ polygons: polygons, IndexType: this.state.IndexType })
        });

        this.state.attributeManager.invalidateAll();
      }

      if (geometryConfigChanged || props.extruded !== oldProps.extruded || props.fp64 !== oldProps.fp64) {
        this.state.polygonTesselator.updatePositions({
          fp64: props.fp64,
          extruded: props.extruded
        });
      }
    }
  }, {
    key: 'updateAttributes',
    value: function updateAttributes(props) {
      var _state = this.state,
          attributeManager = _state.attributeManager,
          modelsChanged = _state.modelsChanged;

      // Figure out data length

      attributeManager.update({
        data: props.data,
        numInstances: 0,
        props: props,
        buffers: props,
        context: this,
        // Don't worry about non-attribute props
        ignoreUnknownAttributes: true
      });

      if (modelsChanged) {
        this._updateAttributes(attributeManager.attributes);
        // clear the flag
        this.setState({ modelsChanged: false });
      } else {
        var changedAttributes = attributeManager.getChangedAttributes({ clearChangedFlags: true });
        this._updateAttributes(changedAttributes);
      }
    }
  }, {
    key: '_updateAttributes',
    value: function _updateAttributes(attributes) {
      var modelsByName = this.state.modelsByName;


      for (var modelName in modelsByName) {
        var model = modelsByName[modelName];

        if (modelName === 'TOP') {
          model.setVertexCount(this.state.numVertex);
        } else {
          model.setInstanceCount(this.state.numInstances);
        }

        var attributeMap = ATTRIBUTE_MAPS[modelName];
        var newAttributes = {};
        for (var attributeName in attributes) {
          var attribute = attributes[attributeName];
          var attributeOverride = attributeMap[attributeName];

          if (attributeOverride) {
            var newAttribute = Object.assign({}, attribute, attributeOverride);

            // Hack: elevations is ignored when not extruded
            // TODO/xiaoji: replace with generic vertex
            newAttribute.instanced |= !this.props.extruded && attributeName === 'elevations';
            newAttributes[attributeOverride.name || attributeName] = newAttribute;
          }
        }
        model.setAttributes(newAttributes);
      }
    }
  }, {
    key: '_getModels',
    value: function _getModels(gl) {
      var _props2 = this.props,
          id = _props2.id,
          filled = _props2.filled,
          extruded = _props2.extruded,
          wireframe = _props2.wireframe;


      var models = {};

      if (filled) {
        models.TOP = new _luma.Model(gl, Object.assign({}, this.getShaders(), {
          id: id + '-top',
          geometry: new _luma.Geometry({
            drawMode: _luma.GL.TRIANGLES,
            attributes: {
              vertexPositions: { size: 2, instanced: 1, value: new Float32Array([0, 1]) },
              nextPositions: { size: 3, instanced: 1, value: new Float32Array(3) },
              nextPositions64xyLow: { size: 2, instanced: 1, value: new Float32Array(2) }
            }
          }),
          uniforms: {
            isSideVertex: 0
          },
          instanceCount: 1,
          vertexCount: 0,
          isInstanced: true,
          isIndexed: true,
          shaderCache: this.context.shaderCache
        }));
      }
      if (filled && extruded) {
        models.SIDE = new _luma.Model(gl, Object.assign({}, this.getShaders(), {
          id: id + '-side',
          geometry: new _luma.Geometry({
            drawMode: _luma.GL.TRIANGLE_STRIP,
            vertexCount: 4,
            attributes: {
              vertexPositions: { size: 2, value: SIDE_FILL_POSITIONS }
            }
          }),
          uniforms: {
            isSideVertex: 1
          },
          isInstanced: true,
          shaderCache: this.context.shaderCache
        }));
      }
      if (extruded && wireframe) {
        models.WIRE = new _luma.Model(gl, Object.assign({}, this.getShaders(), {
          id: id + '-wire',
          geometry: new _luma.Geometry({
            drawMode: _luma.GL.LINE_STRIP,
            vertexCount: 4,
            attributes: {
              vertexPositions: { size: 2, value: SIDE_WIRE_POSITIONS }
            }
          }),
          uniforms: {
            isSideVertex: 1
          },
          isInstanced: true,
          shaderCache: this.context.shaderCache
        }));
      }

      return {
        models: [models.WIRE, models.SIDE, models.TOP].filter(Boolean),
        modelsByName: models
      };
    }
  }, {
    key: 'calculateIndices',
    value: function calculateIndices(attribute) {
      attribute.value = this.state.polygonTesselator.indices();
      attribute.target = _luma.GL.ELEMENT_ARRAY_BUFFER;
      var numVertex = attribute.value.length / attribute.size;
      this.setState({ numVertex: numVertex });
    }
  }, {
    key: 'calculatePositions',
    value: function calculatePositions(attribute) {
      attribute.value = this.state.polygonTesselator.positions();
      var numInstances = attribute.value.length / attribute.size;
      this.setState({ numInstances: numInstances });
    }
  }, {
    key: 'calculatePositionsLow',
    value: function calculatePositionsLow(attribute) {
      attribute.value = this.state.polygonTesselator.positions64xyLow();
    }
  }, {
    key: 'calculateNextPositions',
    value: function calculateNextPositions(attribute) {
      attribute.value = this.state.polygonTesselator.nextPositions();
    }
  }, {
    key: 'calculateNextPositionsLow',
    value: function calculateNextPositionsLow(attribute) {
      attribute.value = this.state.polygonTesselator.nextPositions64xyLow();
    }
  }, {
    key: 'calculateElevations',
    value: function calculateElevations(attribute) {
      var _this2 = this;

      if (this.props.extruded) {
        attribute.value = this.state.polygonTesselator.elevations({
          getElevation: function getElevation(polygonIndex) {
            return _this2.props.getElevation(_this2.props.data[polygonIndex]);
          }
        });
      } else {
        attribute.value = new Float32Array(1);
      }
    }
  }, {
    key: 'calculateFillColors',
    value: function calculateFillColors(attribute) {
      var _this3 = this;

      attribute.value = this.state.polygonTesselator.colors({
        key: 'fillColors',
        getColor: function getColor(polygonIndex) {
          return _this3.props.getFillColor(_this3.props.data[polygonIndex]);
        }
      });
    }
  }, {
    key: 'calculateLineColors',
    value: function calculateLineColors(attribute) {
      var _this4 = this;

      attribute.value = this.state.polygonTesselator.colors({
        key: 'lineColors',
        getColor: function getColor(polygonIndex) {
          return _this4.props.getLineColor(_this4.props.data[polygonIndex]);
        }
      });
    }

    // Override the default picking colors calculation

  }, {
    key: 'calculatePickingColors',
    value: function calculatePickingColors(attribute) {
      attribute.value = this.state.polygonTesselator.pickingColors();
    }
  }]);

  return SolidPolygonLayer;
}(_deck.Layer);

exports.default = SolidPolygonLayer;


SolidPolygonLayer.layerName = 'SolidPolygonLayer';
SolidPolygonLayer.defaultProps = defaultProps;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9leHBlcmltZW50YWwtbGF5ZXJzL3NyYy9zb2xpZC1wb2x5Z29uLWxheWVyL3NvbGlkLXBvbHlnb24tbGF5ZXIuanMiXSwibmFtZXMiOlsiZW5hYmxlNjRiaXRTdXBwb3J0IiwiZ2V0IiwiZGVmYXVsdExpbmVDb2xvciIsImRlZmF1bHRGaWxsQ29sb3IiLCJkZWZhdWx0UHJvcHMiLCJmaWxsZWQiLCJleHRydWRlZCIsIndpcmVmcmFtZSIsImZwNjQiLCJlbGV2YXRpb25TY2FsZSIsImdldFBvbHlnb24iLCJmIiwiZ2V0RWxldmF0aW9uIiwiZ2V0RmlsbENvbG9yIiwiZ2V0TGluZUNvbG9yIiwibGlnaHRTZXR0aW5ncyIsImxpZ2h0c1Bvc2l0aW9uIiwiYW1iaWVudFJhdGlvIiwiZGlmZnVzZVJhdGlvIiwic3BlY3VsYXJSYXRpbyIsImxpZ2h0c1N0cmVuZ3RoIiwibnVtYmVyT2ZMaWdodHMiLCJTSURFX0ZJTExfUE9TSVRJT05TIiwiRmxvYXQzMkFycmF5IiwiU0lERV9XSVJFX1BPU0lUSU9OUyIsIkFUVFJJQlVURV9NQVBTIiwiVE9QIiwiaW5kaWNlcyIsImluc3RhbmNlZCIsInBvc2l0aW9ucyIsInBvc2l0aW9uczY0eHlMb3ciLCJlbGV2YXRpb25zIiwiZmlsbENvbG9ycyIsIm5hbWUiLCJwaWNraW5nQ29sb3JzIiwiU0lERSIsIm5leHRQb3NpdGlvbnMiLCJuZXh0UG9zaXRpb25zNjR4eUxvdyIsIldJUkUiLCJsaW5lQ29sb3JzIiwiU29saWRQb2x5Z29uTGF5ZXIiLCJwcm9wcyIsInZzIiwiZnMiLCJtb2R1bGVzIiwiZ2wiLCJjb250ZXh0Iiwic2V0U3RhdGUiLCJudW1JbnN0YW5jZXMiLCJJbmRleFR5cGUiLCJnZXRFeHRlbnNpb24iLCJVaW50MzJBcnJheSIsIlVpbnQxNkFycmF5IiwiYXR0cmlidXRlTWFuYWdlciIsInN0YXRlIiwibm9BbGxvYyIsImFkZCIsInNpemUiLCJpc0luZGV4ZWQiLCJ1cGRhdGUiLCJjYWxjdWxhdGVJbmRpY2VzIiwiYWNjZXNzb3IiLCJjYWxjdWxhdGVQb3NpdGlvbnMiLCJjYWxjdWxhdGVOZXh0UG9zaXRpb25zIiwiY2FsY3VsYXRlRWxldmF0aW9ucyIsImFsaWFzIiwidHlwZSIsIlVOU0lHTkVEX0JZVEUiLCJjYWxjdWxhdGVGaWxsQ29sb3JzIiwiY2FsY3VsYXRlTGluZUNvbG9ycyIsImNhbGN1bGF0ZVBpY2tpbmdDb2xvcnMiLCJvbGRQcm9wcyIsImNvb3JkaW5hdGVTeXN0ZW0iLCJMTkdMQVQiLCJjYWxjdWxhdGVQb3NpdGlvbnNMb3ciLCJjYWxjdWxhdGVOZXh0UG9zaXRpb25zTG93IiwicmVtb3ZlIiwidW5pZm9ybXMiLCJyZW5kZXJVbmlmb3JtcyIsIk9iamVjdCIsImFzc2lnbiIsIm1vZGVscyIsImZvckVhY2giLCJtb2RlbCIsInJlbmRlciIsInVwZGF0ZVBhcmFtcyIsInVwZGF0ZUdlb21ldHJ5IiwidXBkYXRlQXR0cmlidXRlIiwicmVnZW5lcmF0ZU1vZGVscyIsIm1vZGVsc0NoYW5nZWQiLCJfZ2V0TW9kZWxzIiwiaW52YWxpZGF0ZSIsImNoYW5nZUZsYWdzIiwiZ2VvbWV0cnlDb25maWdDaGFuZ2VkIiwiZGF0YUNoYW5nZWQiLCJ1cGRhdGVUcmlnZ2Vyc0NoYW5nZWQiLCJhbGwiLCJwb2x5Z29ucyIsImRhdGEiLCJtYXAiLCJwb2x5Z29uVGVzc2VsYXRvciIsImludmFsaWRhdGVBbGwiLCJ1cGRhdGVQb3NpdGlvbnMiLCJidWZmZXJzIiwiaWdub3JlVW5rbm93bkF0dHJpYnV0ZXMiLCJfdXBkYXRlQXR0cmlidXRlcyIsImF0dHJpYnV0ZXMiLCJjaGFuZ2VkQXR0cmlidXRlcyIsImdldENoYW5nZWRBdHRyaWJ1dGVzIiwiY2xlYXJDaGFuZ2VkRmxhZ3MiLCJtb2RlbHNCeU5hbWUiLCJtb2RlbE5hbWUiLCJzZXRWZXJ0ZXhDb3VudCIsIm51bVZlcnRleCIsInNldEluc3RhbmNlQ291bnQiLCJhdHRyaWJ1dGVNYXAiLCJuZXdBdHRyaWJ1dGVzIiwiYXR0cmlidXRlTmFtZSIsImF0dHJpYnV0ZSIsImF0dHJpYnV0ZU92ZXJyaWRlIiwibmV3QXR0cmlidXRlIiwic2V0QXR0cmlidXRlcyIsImlkIiwiZ2V0U2hhZGVycyIsImdlb21ldHJ5IiwiZHJhd01vZGUiLCJUUklBTkdMRVMiLCJ2ZXJ0ZXhQb3NpdGlvbnMiLCJ2YWx1ZSIsImlzU2lkZVZlcnRleCIsImluc3RhbmNlQ291bnQiLCJ2ZXJ0ZXhDb3VudCIsImlzSW5zdGFuY2VkIiwic2hhZGVyQ2FjaGUiLCJUUklBTkdMRV9TVFJJUCIsIkxJTkVfU1RSSVAiLCJmaWx0ZXIiLCJCb29sZWFuIiwidGFyZ2V0IiwiRUxFTUVOVF9BUlJBWV9CVUZGRVIiLCJsZW5ndGgiLCJwb2x5Z29uSW5kZXgiLCJjb2xvcnMiLCJrZXkiLCJnZXRDb2xvciIsImxheWVyTmFtZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQW9CQTs7QUFFQTs7QUFHQTs7QUFFQTs7OztBQUNBOzs7O0FBQ0E7Ozs7Ozs7Ozs7K2VBN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztJQUdPQSxrQixzQkFBQUEsa0I7SUFBb0JDLEcsc0JBQUFBLEc7O0FBRzNCOztBQU9BLElBQU1DLG1CQUFtQixDQUFDLEdBQUQsRUFBTSxHQUFOLEVBQVcsR0FBWCxFQUFnQixJQUFoQixDQUF6QjtBQUNBLElBQU1DLG1CQUFtQixDQUFDLEdBQUQsRUFBTSxHQUFOLEVBQVcsR0FBWCxFQUFnQixJQUFoQixDQUF6Qjs7QUFFQSxJQUFNQyxlQUFlO0FBQ25CQyxVQUFRLElBRFc7QUFFbkI7QUFDQUMsWUFBVSxLQUhTO0FBSW5CO0FBQ0FDLGFBQVcsS0FMUTtBQU1uQkMsUUFBTSxLQU5hOztBQVFuQjtBQUNBQyxrQkFBZ0IsQ0FURzs7QUFXbkI7QUFDQUMsY0FBWTtBQUFBLFdBQUtULElBQUlVLENBQUosRUFBTyxTQUFQLEtBQXFCVixJQUFJVSxDQUFKLEVBQU8sc0JB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LGFBQUssWUFEK0M7QUFFcERDLGtCQUFVO0FBQUEsaUJBQWdCLE9BQUt2RyxLQUFMLENBQVczQixZQUFYLENBQXdCLE9BQUsyQixLQUFMLENBQVd5RCxJQUFYLENBQWdCMkMsWUFBaEIsQ0FBeEIsQ0FBaEI7QUFBQTtBQUYwQyxPQUFwQyxDQUFsQjtBQUlEOztBQUVEOzs7OzJDQUN1QnZCLFMsRUFBVztBQUNoQ0EsZ0JBQVVVLEtBQVYsR0FBa0IsS0FBSzFFLEtBQUwsQ0FBVzhDLGlCQUFYLENBQTZCbEUsYUFBN0IsRUFBbEI7QUFDRDs7Ozs7O2tCQWxWa0JNLGlCOzs7QUFxVnJCQSxrQkFBa0J5RyxTQUFsQixHQUE4QixtQkFBOUI7QUFDQXpHLGtCQUFrQnBDLFlBQWxCLEdBQWlDQSxZQUFqQyIsImZpbGUiOiJzb2xpZC1wb2x5Z29uLWxheWVyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSAyMDE1IC0gMjAxNyBVYmVyIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbi8vIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbi8vIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbi8vIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbi8vIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4vLyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4vLyBUSEUgU09GVFdBUkUuXG5cbmltcG9ydCB7Q09PUkRJTkFURV9TWVNURU0sIExheWVyLCBleHBlcmltZW50YWx9IGZyb20gJ2RlY2suZ2wnO1xuY29uc3Qge2VuYWJsZTY0Yml0U3VwcG9ydCwgZ2V0fSA9IGV4cGVyaW1lbnRhbDtcbmltcG9ydCB7R0wsIE1vZGVsLCBHZW9tZXRyeX0gZnJvbSAnbHVtYS5nbCc7XG5cbi8vIFBvbHlnb24gZ2VvbWV0cnkgZ2VuZXJhdGlvbiBpcyBtYW5hZ2VkIGJ5IHRoZSBwb2x5Z29uIHRlc3NlbGF0b3JcbmltcG9ydCB7UG9seWdvblRlc3NlbGF0b3J9IGZyb20gJy4vcG9seWdvbi10ZXNzZWxhdG9yJztcblxuaW1wb3J0IHZzIGZyb20gJy4vc29saWQtcG9seWdvbi1sYXllci12ZXJ0ZXguZ2xzbCc7XG5pbXBvcnQgdnM2NCBmcm9tICcuL3NvbGlkLXBvbHlnb24tbGF5ZXItdmVydGV4LTY0Lmdsc2wnO1xuaW1wb3J0IGZzIGZyb20gJy4vc29saWQtcG9seWdvbi1sYXllci1mcmFnbWVudC5nbHNsJztcblxuY29uc3QgZGVmYXVsdExpbmVDb2xvciA9IFsweDAsIDB4MCwgMHgwLCAweGZmXTtcbmNvbnN0IGRlZmF1bHRGaWxsQ29sb3IgPSBbMHgwLCAweDAsIDB4MCwgMHhmZl07XG5cbmNvbnN0IGRlZmF1bHRQcm9wcyA9IHtcbiAgZmlsbGVkOiB0cnVlLFxuICAvLyBXaGV0aGVyIHRvIGV4dHJ1ZGVcbiAgZXh0cnVkZWQ6IGZhbHNlLFxuICAvLyBXaGV0aGVyIHRvIGRyYXcgYSBHTC5MSU5FUyB3aXJlZnJhbWUgb2YgdGhlIHBvbHlnb25cbiAgd2lyZWZyYW1lOiBmYWxzZSxcbiAgZnA2NDogZmFsc2UsXG5cbiAgLy8gZWxldmF0aW9uIG11bHRpcGxpZXJcbiAgZWxldmF0aW9uU2NhbGU6IDEsXG5cbiAgLy8gQWNjZXNzb3IgZm9yIHBvbHlnb24gZ2VvbWV0cnlcbiAgZ2V0UG9seWdvbjogZiA9PiBnZXQoZiwgJ3BvbHlnb24nKSB8fCBnZXQoZiwgJ2dlb21ldHJ5LmNvb3JkaW5hdGVzJyksXG4gIC8vIEFjY2Vzc29yIGZvciBleHRydXNpb24gaGVpZ2h0XG4gIGdldEVsZXZhdGlvbjogZiA9PiBnZXQoZiwgJ2VsZXZhdGlvbicpIHx8IGdldChmLCAncHJvcGVydGllcy5oZWlnaHQnKSB8fCAwLFxuICAvLyBBY2Nlc3NvciBmb3IgY29sb3JzXG4gIGdldEZpbGxDb2xvcjogZiA9PiBnZXQoZiwgJ2ZpbGxDb2xvcicpIHx8IGdldChmLCAncHJvcGVydGllcy5jb2xvcicpIHx8IGRlZmF1bHRGaWxsQ29sb3IsXG4gIGdldExpbmVDb2xvcjogZiA9PiBnZXQoZiwgJ2xpbmVDb2xvcicpIHx8IGdldChmLCAncHJvcGVydGllcy5jb2xvcicpIHx8IGRlZmF1bHRMaW5lQ29sb3IsXG5cbiAgLy8gT3B0aW9uYWwgc2V0dGluZ3MgZm9yICdsaWdodGluZycgc2hhZGVyIG1vZHVsZVxuICBsaWdodFNldHRpbmdzOiB7XG4gICAgbGlnaHRzUG9zaXRpb246IFstMTIyLjQ1LCAzNy43NSwgODAwMCwgLTEyMi4wLCAzOC4wLCA1MDAwXSxcbiAgICBhbWJpZW50UmF0aW86IDAuMDUsXG4gICAgZGlmZnVzZVJhdGlvOiAwLjYsXG4gICAgc3BlY3VsYXJSYXRpbzogMC44LFxuICAgIGxpZ2h0c1N0cmVuZ3RoOiBbMi4wLCAwLjAsIDAuMCwgMC4wXSxcbiAgICBudW1iZXJPZkxpZ2h0czogMlxuICB9XG59O1xuXG4vLyBTaWRlIG1vZGVsIGF0dHJpYnV0ZXNcbmNvbnN0IFNJREVfRklMTF9QT1NJVElPTlMgPSBuZXcgRmxvYXQzMkFycmF5KFtcbiAgLy8gdG9wIGxlZnQgY29ybmVyXG4gIDAsXG4gIDEsXG4gIC8vIGJvdHRvbSBsZWZ0IGNvcm5lclxuICAwLFxuICAwLFxuICAvLyB0b3AgcmlnaHQgY29ybmVyXG4gIDEsXG4gIDEsXG4gIC8vIGJvdHRvbSByaWdodCBjb3JuZXJcbiAgMSxcbiAgMFxuXSk7XG5jb25zdCBTSURFX1dJUkVfUE9TSVRJT05TID0gbmV3IEZsb2F0MzJBcnJheShbXG4gIC8vIHRvcCByaWdodCBjb3JuZXJcbiAgMSxcbiAgMSxcbiAgLy8gdG9wIGxlZnQgY29ybmVyXG4gIDAsXG4gIDEsXG4gIC8vIGJvdHRvbSBsZWZ0IGNvcm5lclxuICAwLFxuICAwLFxuICAvLyBib3R0b20gcmlnaHQgY29ybmVyXG4gIDEsXG4gIDBcbl0pO1xuXG4vLyBNb2RlbCB0eXBlc1xuY29uc3QgQVRUUklCVVRFX01BUFMgPSB7XG4gIFRPUDoge1xuICAgIGluZGljZXM6IHtpbnN0YW5jZWQ6IGZhbHNlfSxcbiAgICBwb3NpdGlvbnM6IHtpbnN0YW5jZWQ6IGZhbHNlfSxcbiAgICBwb3NpdGlvbnM2NHh5TG93OiB7aW5zdGFuY2VkOiBmYWxzZX0sXG4gICAgZWxldmF0aW9uczoge2luc3RhbmNlZDogZmFsc2V9LFxuICAgIGZpbGxDb2xvcnM6IHtuYW1lOiAnY29sb3JzJywgaW5zdGFuY2VkOiBmYWxzZX0sXG4gICAgcGlja2luZ0NvbG9yczoge2luc3RhbmNlZDogZmFsc2V9XG4gIH0sXG4gIFNJREU6IHtcbiAgICBwb3NpdGlvbnM6IHtpbnN0YW5jZWQ6IHRydWV9LFxuICAgIHBvc2l0aW9uczY0eHlMb3c6IHtpbnN0YW5jZWQ6IHRydWV9LFxuICAgIG5leHRQb3NpdGlvbnM6IHtpbnN0YW5jZWQ6IHRydWV9LFxuICAgIG5leHRQb3NpdGlvbnM2NHh5TG93OiB7aW5zdGFuY2VkOiB0cnVlfSxcbiAgICBlbGV2YXRpb25zOiB7aW5zdGFuY2VkOiB0cnVlfSxcbiAgICBmaWxsQ29sb3JzOiB7bmFtZTogJ2NvbG9ycycsIGluc3RhbmNlZDogdHJ1ZX0sXG4gICAgcGlja2luZ0NvbG9yczoge2luc3RhbmNlZDogdHJ1ZX1cbiAgfSxcbiAgV0lSRToge1xuICAgIHBvc2l0aW9uczoge2luc3RhbmNlZDogdHJ1ZX0sXG4gICAgcG9zaXRpb25zNjR4eUxvdzoge2luc3RhbmNlZDogdHJ1ZX0sXG4gICAgbmV4dFBvc2l0aW9uczoge2luc3RhbmNlZDogdHJ1ZX0sXG4gICAgbmV4dFBvc2l0aW9uczY0eHlMb3c6IHtpbnN0YW5jZWQ6IHRydWV9LFxuICAgIGVsZXZhdGlvbnM6IHtpbnN0YW5jZWQ6IHRydWV9LFxuICAgIGxpbmVDb2xvcnM6IHtuYW1lOiAnY29sb3JzJywgaW5zdGFuY2VkOiB0cnVlfSxcbiAgICBwaWNraW5nQ29sb3JzOiB7aW5zdGFuY2VkOiB0cnVlfVxuICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTb2xpZFBvbHlnb25MYXllciBleHRlbmRzIExheWVyIHtcbiAgZ2V0U2hhZGVycygpIHtcbiAgICByZXR1cm4gZW5hYmxlNjRiaXRTdXBwb3J0KHRoaXMucHJvcHMpXG4gICAgICA/IHt2czogdnM2NCwgZnMsIG1vZHVsZXM6IFsncHJvamVjdDY0JywgJ2xpZ2h0aW5nJywgJ3BpY2tpbmcnXX1cbiAgICAgIDoge3ZzLCBmcywgbW9kdWxlczogWydsaWdodGluZycsICdwaWNraW5nJ119OyAvLyAncHJvamVjdCcgbW9kdWxlIGFkZGVkIGJ5IGRlZmF1bHQuXG4gIH1cblxuICBpbml0aWFsaXplU3RhdGUoKSB7XG4gICAgY29uc3Qge2dsfSA9IHRoaXMuY29udGV4dDtcbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIG51bUluc3RhbmNlczogMCxcbiAgICAgIEluZGV4VHlwZTogZ2wuZ2V0RXh0ZW5zaW9uKCdPRVNfZWxlbWVudF9pbmRleF91aW50JykgPyBVaW50MzJBcnJheSA6IFVpbnQxNkFycmF5XG4gICAgfSk7XG5cbiAgICBjb25zdCB7YXR0cmlidXRlTWFuYWdlcn0gPSB0aGlzLnN0YXRlO1xuICAgIGNvbnN0IG5vQWxsb2MgPSB0cnVlO1xuICAgIC8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4gKi9cbiAgICBhdHRyaWJ1dGVNYW5hZ2VyLmFkZCh7XG4gICAgICBpbmRpY2VzOiB7c2l6ZTogMSwgaXNJbmRleGVkOiB0cnVlLCB1cGRhdGU6IHRoaXMuY2FsY3VsYXRlSW5kaWNlcywgbm9BbGxvY30sXG4gICAgICBwb3NpdGlvbnM6IHtcbiAgICAgICAgc2l6ZTogMyxcbiAgICAgICAgYWNjZXNzb3I6IFsnZXh0cnVkZWQnLCAnZnA2NCddLFxuICAgICAgICB1cGRhdGU6IHRoaXMuY2FsY3VsYXRlUG9zaXRpb25zLFxuICAgICAgICBub0FsbG9jXG4gICAgICB9LFxuICAgICAgbmV4dFBvc2l0aW9uczoge1xuICAgICAgICBzaXplOiAzLFxuICAgICAgICBhY2Nlc3NvcjogWydleHRydWRlZCcsICdmcDY0J10sXG4gICAgICAgIHVwZGF0ZTogdGhpcy5jYWxjdWxhdGVOZXh0UG9zaXRpb25zLFxuICAgICAgICBub0FsbG9jXG4gICAgICB9LFxuICAgICAgZWxldmF0aW9uczoge1xuICAgICAgICBzaXplOiAxLFxuICAgICAgICBhY2Nlc3NvcjogWydleHRydWRlZCcsICdnZXRFbGV2YXRpb24nXSxcbiAgICAgICAgdXBkYXRlOiB0aGlzLmNhbGN1bGF0ZUVsZXZhdGlvbnMsXG4gICAgICAgIG5vQWxsb2NcbiAgICAgIH0sXG4gICAgICBmaWxsQ29sb3JzOiB7XG4gICAgICAgIGFsaWFzOiAnY29sb3JzJyxcbiAgICAgICAgc2l6ZTogNCxcbiAgICAgICAgdHlwZTogR0wuVU5TSUdORURfQllURSxcbiAgICAgICAgYWNjZXNzb3I6ICdnZXRGaWxsQ29sb3InLFxuICAgICAgICB1cGRhdGU6IHRoaXMuY2FsY3VsYXRlRmlsbENvbG9ycyxcbiAgICAgICAgbm9BbGxvY1xuICAgICAgfSxcbiAgICAgIGxpbmVDb2xvcnM6IHtcbiAgICAgICAgYWxpYXM6ICdjb2xvcnMnLFxuICAgICAgICBzaXplOiA0LFxuICAgICAgICB0eXBlOiBHTC5VTlNJR05FRF9CWVRFLFxuICAgICAgICBhY2Nlc3NvcjogJ2dldExpbmVDb2xvcicsXG4gICAgICAgIHVwZGF0ZTogdGhpcy5jYWxjdWxhdGVMaW5lQ29sb3JzLFxuICAgICAgICBub0FsbG9jXG4gICAgICB9LFxuICAgICAgcGlja2luZ0NvbG9yczoge3NpemU6IDMsIHR5cGU6IEdMLlVOU0lHTkVEX0JZVEUsIHVwZGF0ZTogdGhpcy5jYWxjdWxhdGVQaWNraW5nQ29sb3JzLCBub0FsbG9jfVxuICAgIH0pO1xuICAgIC8qIGVzbGludC1lbmFibGUgbWF4LWxlbiAqL1xuICB9XG5cbiAgdXBkYXRlQXR0cmlidXRlKHtwcm9wcywgb2xkUHJvcHN9KSB7XG4gICAgaWYgKHByb3BzLmZwNjQgIT09IG9sZFByb3BzLmZwNjQpIHtcbiAgICAgIGNvbnN0IHthdHRyaWJ1dGVNYW5hZ2VyfSA9IHRoaXMuc3RhdGU7XG5cbiAgICAgIGlmIChwcm9wcy5mcDY0ICYmIHByb3BzLmNvb3JkaW5hdGVTeXN0ZW0gPT09IENPT1JESU5BVEVfU1lTVEVNLkxOR0xBVCkge1xuICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuICovXG4gICAgICAgIGF0dHJpYnV0ZU1hbmFnZXIuYWRkKHtcbiAgICAgICAgICBwb3NpdGlvbnM2NHh5TG93OiB7c2l6ZTogMiwgYWNjZXNzb3I6ICdmcDY0JywgdXBkYXRlOiB0aGlzLmNhbGN1bGF0ZVBvc2l0aW9uc0xvd30sXG4gICAgICAgICAgbmV4dFBvc2l0aW9uczY0eHlMb3c6IHtzaXplOiAyLCBhY2Nlc3NvcjogJ2ZwNjQnLCB1cGRhdGU6IHRoaXMuY2FsY3VsYXRlTmV4dFBvc2l0aW9uc0xvd31cbiAgICAgICAgfSk7XG4gICAgICAgIC8qIGVzbGludC1lbmFibGUgbWF4LWxlbiAqL1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXR0cmlidXRlTWFuYWdlci5yZW1vdmUoWydwb3NpdGlvbnM2NHh5TG93JywgJ25leHRQb3NpdGlvbnM2NHh5TG93J10pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGRyYXcoe3VuaWZvcm1zfSkge1xuICAgIGNvbnN0IHtleHRydWRlZCwgbGlnaHRTZXR0aW5ncywgZWxldmF0aW9uU2NhbGV9ID0gdGhpcy5wcm9wcztcblxuICAgIGNvbnN0IHJlbmRlclVuaWZvcm1zID0gT2JqZWN0LmFzc2lnbihcbiAgICAgIHt9LFxuICAgICAgdW5pZm9ybXMsXG4gICAgICB7XG4gICAgICAgIGV4dHJ1ZGVkOiBleHRydWRlZCA/IDEuMCA6IDAuMCxcbiAgICAgICAgZWxldmF0aW9uU2NhbGVcbiAgICAgIH0sXG4gICAgICBsaWdodFNldHRpbmdzXG4gICAgKTtcblxuICAgIHRoaXMuc3RhdGUubW9kZWxzLmZvckVhY2gobW9kZWwgPT4ge1xuICAgICAgbW9kZWwucmVuZGVyKHJlbmRlclVuaWZvcm1zKTtcbiAgICB9KTtcbiAgfVxuXG4gIHVwZGF0ZVN0YXRlKHVwZGF0ZVBhcmFtcykge1xuICAgIHN1cGVyLnVwZGF0ZVN0YXRlKHVwZGF0ZVBhcmFtcyk7XG5cbiAgICB0aGlzLnVwZGF0ZUdlb21ldHJ5KHVwZGF0ZVBhcmFtcyk7XG4gICAgdGhpcy51cGRhdGVBdHRyaWJ1dGUodXBkYXRlUGFyYW1zKTtcblxuICAgIGNvbnN0IHtwcm9wcywgb2xkUHJvcHN9ID0gdXBkYXRlUGFyYW1zO1xuXG4gICAgY29uc3QgcmVnZW5lcmF0ZU1vZGVscyA9XG4gICAgICBwcm9wcy5mcDY0ICE9PSBvbGRQcm9wcy5mcDY0IHx8XG4gICAgICBwcm9wcy5maWxsZWQgIT09IG9sZFByb3BzLmZpbGxlZCB8fFxuICAgICAgcHJvcHMuZXh0cnVkZWQgIT09IG9sZFByb3BzLmV4dHJ1ZGVkIHx8XG4gICAgICBwcm9wcy53aXJlZnJhbWUgIT09IG9sZFByb3BzLndpcmVmcmFtZTtcblxuICAgIGlmIChyZWdlbmVyYXRlTW9kZWxzKSB7XG4gICAgICB0aGlzLnNldFN0YXRlKFxuICAgICAgICBPYmplY3QuYXNzaWduKFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIC8vIFNldCBhIGZsYWcgdG8gc2V0IGF0dHJpYnV0ZXMgdG8gbmV3IG1vZGVsc1xuICAgICAgICAgICAgbW9kZWxzQ2hhbmdlZDogdHJ1ZVxuICAgICAgICAgIH0sXG4gICAgICAgICAgdGhpcy5fZ2V0TW9kZWxzKHRoaXMuY29udGV4dC5nbClcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAocHJvcHMuZXh0cnVkZWQgIT09IG9sZFByb3BzLmV4dHJ1ZGVkKSB7XG4gICAgICB0aGlzLnN0YXRlLmF0dHJpYnV0ZU1hbmFnZXIuaW52YWxpZGF0ZSgnZXh0cnVkZWQnKTtcbiAgICB9XG4gICAgaWYgKHByb3BzLmZwNjQgIT09IG9sZFByb3BzLmZwNjQpIHtcbiAgICAgIHRoaXMuc3RhdGUuYXR0cmlidXRlTWFuYWdlci5pbnZhbGlkYXRlKCdmcDY0Jyk7XG4gICAgfVxuICB9XG5cbiAgdXBkYXRlR2VvbWV0cnkoe3Byb3BzLCBvbGRQcm9wcywgY2hhbmdlRmxhZ3N9KSB7XG4gICAgY29uc3QgZ2VvbWV0cnlDb25maWdDaGFuZ2VkID1cbiAgICAgIGNoYW5nZUZsYWdzLmRhdGFDaGFuZ2VkIHx8XG4gICAgICAoY2hhbmdlRmxhZ3MudXBkYXRlVHJpZ2dlcnNDaGFuZ2VkICYmXG4gICAgICAgIChjaGFuZ2VGbGFncy51cGRhdGVUcmlnZ2Vyc0NoYW5nZWQuYWxsIHx8IGNoYW5nZUZsYWdzLnVwZGF0ZVRyaWdnZXJzQ2hhbmdlZC5nZXRQb2x5Z29uKSk7XG5cbiAgICAvLyBXaGVuIHRoZSBnZW9tZXRyeSBjb25maWcgIG9yIHRoZSBkYXRhIGlzIGNoYW5nZWQsXG4gICAgLy8gdGVzc2VsbGF0b3IgbmVlZHMgdG8gYmUgaW52b2tlZFxuICAgIGlmIChnZW9tZXRyeUNvbmZpZ0NoYW5nZWQpIHtcbiAgICAgIC8vIFRPRE8gLSBhdm9pZCBjcmVhdGluZyBhIHRlbXBvcmFyeSBhcnJheSBoZXJlOiBsZXQgdGhlIHRlc3NlbGF0b3IgaXRlcmF0ZVxuICAgICAgY29uc3QgcG9seWdvbnMgPSBwcm9wcy5kYXRhLm1hcChwcm9wcy5nZXRQb2x5Z29uKTtcblxuICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIHBvbHlnb25UZXNzZWxhdG9yOiBuZXcgUG9seWdvblRlc3NlbGF0b3Ioe3BvbHlnb25zLCBJbmRleFR5cGU6IHRoaXMuc3RhdGUuSW5kZXhUeXBlfSlcbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLnN0YXRlLmF0dHJpYnV0ZU1hbmFnZXIuaW52YWxpZGF0ZUFsbCgpO1xuICAgIH1cblxuICAgIGlmIChcbiAgICAgIGdlb21ldHJ5Q29uZmlnQ2hhbmdlZCB8fFxuICAgICAgcHJvcHMuZXh0cnVkZWQgIT09IG9sZFByb3BzLmV4dHJ1ZGVkIHx8XG4gICAgICBwcm9wcy5mcDY0ICE9PSBvbGRQcm9wcy5mcDY0XG4gICAgKSB7XG4gICAgICB0aGlzLnN0YXRlLnBvbHlnb25UZXNzZWxhdG9yLnVwZGF0ZVBvc2l0aW9ucyh7XG4gICAgICAgIGZwNjQ6IHByb3BzLmZwNjQsXG4gICAgICAgIGV4dHJ1ZGVkOiBwcm9wcy5leHRydWRlZFxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgdXBkYXRlQXR0cmlidXRlcyhwcm9wcykge1xuICAgIGNvbnN0IHthdHRyaWJ1dGVNYW5hZ2VyLCBtb2RlbHNDaGFuZ2VkfSA9IHRoaXMuc3RhdGU7XG5cbiAgICAvLyBGaWd1cmUgb3V0IGRhdGEgbGVuZ3RoXG4gICAgYXR0cmlidXRlTWFuYWdlci51cGRhdGUoe1xuICAgICAgZGF0YTogcHJvcHMuZGF0YSxcbiAgICAgIG51bUluc3RhbmNlczogMCxcbiAgICAgIHByb3BzLFxuICAgICAgYnVmZmVyczogcHJvcHMsXG4gICAgICBjb250ZXh0OiB0aGlzLFxuICAgICAgLy8gRG9uJ3Qgd29ycnkgYWJvdXQgbm9uLWF0dHJpYnV0ZSBwcm9wc1xuICAgICAgaWdub3JlVW5rbm93bkF0dHJpYnV0ZXM6IHRydWVcbiAgICB9KTtcblxuICAgIGlmIChtb2RlbHNDaGFuZ2VkKSB7XG4gICAgICB0aGlzLl91cGRhdGVBdHRyaWJ1dGVzKGF0dHJpYnV0ZU1hbmFnZXIuYXR0cmlidXRlcyk7XG4gICAgICAvLyBjbGVhciB0aGUgZmxhZ1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7bW9kZWxzQ2hhbmdlZDogZmFsc2V9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgY2hhbmdlZEF0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVNYW5hZ2VyLmdldENoYW5nZWRBdHRyaWJ1dGVzKHtjbGVhckNoYW5nZWRGbGFnczogdHJ1ZX0pO1xuICAgICAgdGhpcy5fdXBkYXRlQXR0cmlidXRlcyhjaGFuZ2VkQXR0cmlidXRlcyk7XG4gICAgfVxuICB9XG5cbiAgX3VwZGF0ZUF0dHJpYnV0ZXMoYXR0cmlidXRlcykge1xuICAgIGNvbnN0IHttb2RlbHNCeU5hbWV9ID0gdGhpcy5zdGF0ZTtcblxuICAgIGZvciAoY29uc3QgbW9kZWxOYW1lIGluIG1vZGVsc0J5TmFtZSkge1xuICAgICAgY29uc3QgbW9kZWwgPSBtb2RlbHNCeU5hbWVbbW9kZWxOYW1lXTtcblxuICAgICAgaWYgKG1vZGVsTmFtZSA9PT0gJ1RPUCcpIHtcbiAgICAgICAgbW9kZWwuc2V0VmVydGV4Q291bnQodGhpcy5zdGF0ZS5udW1WZXJ0ZXgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbW9kZWwuc2V0SW5zdGFuY2VDb3VudCh0aGlzLnN0YXRlLm51bUluc3RhbmNlcyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGF0dHJpYnV0ZU1hcCA9IEFUVFJJQlVURV9NQVBTW21vZGVsTmFtZV07XG4gICAgICBjb25zdCBuZXdBdHRyaWJ1dGVzID0ge307XG4gICAgICBmb3IgKGNvbnN0IGF0dHJpYnV0ZU5hbWUgaW4gYXR0cmlidXRlcykge1xuICAgICAgICBjb25zdCBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzW2F0dHJpYnV0ZU5hbWVdO1xuICAgICAgICBjb25zdCBhdHRyaWJ1dGVPdmVycmlkZSA9IGF0dHJpYnV0ZU1hcFthdHRyaWJ1dGVOYW1lXTtcblxuICAgICAgICBpZiAoYXR0cmlidXRlT3ZlcnJpZGUpIHtcbiAgICAgICAgICBjb25zdCBuZXdBdHRyaWJ1dGUgPSBPYmplY3QuYXNzaWduKHt9LCBhdHRyaWJ1dGUsIGF0dHJpYnV0ZU92ZXJyaWRlKTtcblxuICAgICAgICAgIC8vIEhhY2s6IGVsZXZhdGlvbnMgaXMgaWdub3JlZCB3aGVuIG5vdCBleHRydWRlZFxuICAgICAgICAgIC8vIFRPRE8veGlhb2ppOiByZXBsYWNlIHdpdGggZ2VuZXJpYyB2ZXJ0ZXhcbiAgICAgICAgICBuZXdBdHRyaWJ1dGUuaW5zdGFuY2VkIHw9ICF0aGlzLnByb3BzLmV4dHJ1ZGVkICYmIGF0dHJpYnV0ZU5hbWUgPT09ICdlbGV2YXRpb25zJztcbiAgICAgICAgICBuZXdBdHRyaWJ1dGVzW2F0dHJpYnV0ZU92ZXJyaWRlLm5hbWUgfHwgYXR0cmlidXRlTmFtZV0gPSBuZXdBdHRyaWJ1dGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG1vZGVsLnNldEF0dHJpYnV0ZXMobmV3QXR0cmlidXRlcyk7XG4gICAgfVxuICB9XG5cbiAgX2dldE1vZGVscyhnbCkge1xuICAgIGNvbnN0IHtpZCwgZmlsbGVkLCBleHRydWRlZCwgd2lyZWZyYW1lfSA9IHRoaXMucHJvcHM7XG5cbiAgICBjb25zdCBtb2RlbHMgPSB7fTtcblxuICAgIGlmIChmaWxsZWQpIHtcbiAgICAgIG1vZGVscy5UT1AgPSBuZXcgTW9kZWwoXG4gICAgICAgIGdsLFxuICAgICAgICBPYmplY3QuYXNzaWduKHt9LCB0aGlzLmdldFNoYWRlcnMoKSwge1xuICAgICAgICAgIGlkOiBgJHtpZH0tdG9wYCxcbiAgICAgICAgICBnZW9tZXRyeTogbmV3IEdlb21ldHJ5KHtcbiAgICAgICAgICAgIGRyYXdNb2RlOiBHTC5UUklBTkdMRVMsXG4gICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgIHZlcnRleFBvc2l0aW9uczoge3NpemU6IDIsIGluc3RhbmNlZDogMSwgdmFsdWU6IG5ldyBGbG9hdDMyQXJyYXkoWzAsIDFdKX0sXG4gICAgICAgICAgICAgIG5leHRQb3NpdGlvbnM6IHtzaXplOiAzLCBpbnN0YW5jZWQ6IDEsIHZhbHVlOiBuZXcgRmxvYXQzMkFycmF5KDMpfSxcbiAgICAgICAgICAgICAgbmV4dFBvc2l0aW9uczY0eHlMb3c6IHtzaXplOiAyLCBpbnN0YW5jZWQ6IDEsIHZhbHVlOiBuZXcgRmxvYXQzMkFycmF5KDIpfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pLFxuICAgICAgICAgIHVuaWZvcm1zOiB7XG4gICAgICAgICAgICBpc1NpZGVWZXJ0ZXg6IDBcbiAgICAgICAgICB9LFxuICAgICAgICAgIGluc3RhbmNlQ291bnQ6IDEsXG4gICAgICAgICAgdmVydGV4Q291bnQ6IDAsXG4gICAgICAgICAgaXNJbnN0YW5jZWQ6IHRydWUsXG4gICAgICAgICAgaXNJbmRleGVkOiB0cnVlLFxuICAgICAgICAgIHNoYWRlckNhY2hlOiB0aGlzLmNvbnRleHQuc2hhZGVyQ2FjaGVcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChmaWxsZWQgJiYgZXh0cnVkZWQpIHtcbiAgICAgIG1vZGVscy5TSURFID0gbmV3IE1vZGVsKFxuICAgICAgICBnbCxcbiAgICAgICAgT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5nZXRTaGFkZXJzKCksIHtcbiAgICAgICAgICBpZDogYCR7aWR9LXNpZGVgLFxuICAgICAgICAgIGdlb21ldHJ5OiBuZXcgR2VvbWV0cnkoe1xuICAgICAgICAgICAgZHJhd01vZGU6IEdMLlRSSUFOR0xFX1NUUklQLFxuICAgICAgICAgICAgdmVydGV4Q291bnQ6IDQsXG4gICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgIHZlcnRleFBvc2l0aW9uczoge3NpemU6IDIsIHZhbHVlOiBTSURFX0ZJTExfUE9TSVRJT05TfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pLFxuICAgICAgICAgIHVuaWZvcm1zOiB7XG4gICAgICAgICAgICBpc1NpZGVWZXJ0ZXg6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIGlzSW5zdGFuY2VkOiB0cnVlLFxuICAgICAgICAgIHNoYWRlckNhY2hlOiB0aGlzLmNvbnRleHQuc2hhZGVyQ2FjaGVcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChleHRydWRlZCAmJiB3aXJlZnJhbWUpIHtcbiAgICAgIG1vZGVscy5XSVJFID0gbmV3IE1vZGVsKFxuICAgICAgICBnbCxcbiAgICAgICAgT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5nZXRTaGFkZXJzKCksIHtcbiAgICAgICAgICBpZDogYCR7aWR9LXdpcmVgLFxuICAgICAgICAgIGdlb21ldHJ5OiBuZXcgR2VvbWV0cnkoe1xuICAgICAgICAgICAgZHJhd01vZGU6IEdMLkxJTkVfU1RSSVAsXG4gICAgICAgICAgICB2ZXJ0ZXhDb3VudDogNCxcbiAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgdmVydGV4UG9zaXRpb25zOiB7c2l6ZTogMiwgdmFsdWU6IFNJREVfV0lSRV9QT1NJVElPTlN9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSksXG4gICAgICAgICAgdW5pZm9ybXM6IHtcbiAgICAgICAgICAgIGlzU2lkZVZlcnRleDogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgaXNJbnN0YW5jZWQ6IHRydWUsXG4gICAgICAgICAgc2hhZGVyQ2FjaGU6IHRoaXMuY29udGV4dC5zaGFkZXJDYWNoZVxuICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgbW9kZWxzOiBbbW9kZWxzLldJUkUsIG1vZGVscy5TSURFLCBtb2RlbHMuVE9QXS5maWx0ZXIoQm9vbGVhbiksXG4gICAgICBtb2RlbHNCeU5hbWU6IG1vZGVsc1xuICAgIH07XG4gIH1cblxuICBjYWxjdWxhdGVJbmRpY2VzKGF0dHJpYnV0ZSkge1xuICAgIGF0dHJpYnV0ZS52YWx1ZSA9IHRoaXMuc3RhdGUucG9seWdvblRlc3NlbGF0b3IuaW5kaWNlcygpO1xuICAgIGF0dHJpYnV0ZS50YXJnZXQgPSBHTC5FTEVNRU5UX0FSUkFZX0JVRkZFUjtcbiAgICBjb25zdCBudW1WZXJ0ZXggPSBhdHRyaWJ1dGUudmFsdWUubGVuZ3RoIC8gYXR0cmlidXRlLnNpemU7XG4gICAgdGhpcy5zZXRTdGF0ZSh7bnVtVmVydGV4fSk7XG4gIH1cblxuICBjYWxjdWxhdGVQb3NpdGlvbnMoYXR0cmlidXRlKSB7XG4gICAgYXR0cmlidXRlLnZhbHVlID0gdGhpcy5zdGF0ZS5wb2x5Z29uVGVzc2VsYXRvci5wb3NpdGlvbnMoKTtcbiAgICBjb25zdCBudW1JbnN0YW5jZXMgPSBhdHRyaWJ1dGUudmFsdWUubGVuZ3RoIC8gYXR0cmlidXRlLnNpemU7XG4gICAgdGhpcy5zZXRTdGF0ZSh7bnVtSW5zdGFuY2VzfSk7XG4gIH1cbiAgY2FsY3VsYXRlUG9zaXRpb25zTG93KGF0dHJpYnV0ZSkge1xuICAgIGF0dHJpYnV0ZS52YWx1ZSA9IHRoaXMuc3RhdGUucG9seWdvblRlc3NlbGF0b3IucG9zaXRpb25zNjR4eUxvdygpO1xuICB9XG5cbiAgY2FsY3VsYXRlTmV4dFBvc2l0aW9ucyhhdHRyaWJ1dGUpIHtcbiAgICBhdHRyaWJ1dGUudmFsdWUgPSB0aGlzLnN0YXRlLnBvbHlnb25UZXNzZWxhdG9yLm5leHRQb3NpdGlvbnMoKTtcbiAgfVxuICBjYWxjdWxhdGVOZXh0UG9zaXRpb25zTG93KGF0dHJpYnV0ZSkge1xuICAgIGF0dHJpYnV0ZS52YWx1ZSA9IHRoaXMuc3RhdGUucG9seWdvblRlc3NlbGF0b3IubmV4dFBvc2l0aW9uczY0eHlMb3coKTtcbiAgfVxuXG4gIGNhbGN1bGF0ZUVsZXZhdGlvbnMoYXR0cmlidXRlKSB7XG4gICAgaWYgKHRoaXMucHJvcHMuZXh0cnVkZWQpIHtcbiAgICAgIGF0dHJpYnV0ZS52YWx1ZSA9IHRoaXMuc3RhdGUucG9seWdvblRlc3NlbGF0b3IuZWxldmF0aW9ucyh7XG4gICAgICAgIGdldEVsZXZhdGlvbjogcG9seWdvbkluZGV4ID0+IHRoaXMucHJvcHMuZ2V0RWxldmF0aW9uKHRoaXMucHJvcHMuZGF0YVtwb2x5Z29uSW5kZXhdKVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGF0dHJpYnV0ZS52YWx1ZSA9IG5ldyBGbG9hdDMyQXJyYXkoMSk7XG4gICAgfVxuICB9XG5cbiAgY2FsY3VsYXRlRmlsbENvbG9ycyhhdHRyaWJ1dGUpIHtcbiAgICBhdHRyaWJ1dGUudmFsdWUgPSB0aGlzLnN0YXRlLnBvbHlnb25UZXNzZWxhdG9yLmNvbG9ycyh7XG4gICAgICBrZXk6ICdmaWxsQ29sb3JzJyxcbiAgICAgIGdldENvbG9yOiBwb2x5Z29uSW5kZXggPT4gdGhpcy5wcm9wcy5nZXRGaWxsQ29sb3IodGhpcy5wcm9wcy5kYXRhW3BvbHlnb25JbmRleF0pXG4gICAgfSk7XG4gIH1cbiAgY2FsY3VsYXRlTGluZUNvbG9ycyhhdHRyaWJ1dGUpIHtcbiAgICBhdHRyaWJ1dGUudmFsdWUgPSB0aGlzLnN0YXRlLnBvbHlnb25UZXNzZWxhdG9yLmNvbG9ycyh7XG4gICAgICBrZXk6ICdsaW5lQ29sb3JzJyxcbiAgICAgIGdldENvbG9yOiBwb2x5Z29uSW5kZXggPT4gdGhpcy5wcm9wcy5nZXRMaW5lQ29sb3IodGhpcy5wcm9wcy5kYXRhW3BvbHlnb25JbmRleF0pXG4gICAgfSk7XG4gIH1cblxuICAvLyBPdmVycmlkZSB0aGUgZGVmYXVsdCBwaWNraW5nIGNvbG9ycyBjYWxjdWxhdGlvblxuICBjYWxjdWxhdGVQaWNraW5nQ29sb3JzKGF0dHJpYnV0ZSkge1xuICAgIGF0dHJpYnV0ZS52YWx1ZSA9IHRoaXMuc3RhdGUucG9seWdvblRlc3NlbGF0b3IucGlja2luZ0NvbG9ycygpO1xuICB9XG59XG5cblNvbGlkUG9seWdvbkxheWVyLmxheWVyTmFtZSA9ICdTb2xpZFBvbHlnb25MYXllcic7XG5Tb2xpZFBvbHlnb25MYXllci5kZWZhdWx0UHJvcHMgPSBkZWZhdWx0UHJvcHM7XG4iXX0=