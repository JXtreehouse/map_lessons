'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PolygonTesselatorExtruded = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

var _polygon = require('./polygon');

var Polygon = _interopRequireWildcard(_polygon);

var _core = require('../../core');

var _earcut = require('earcut');

var _earcut2 = _interopRequireDefault(_earcut);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var fp64ify = _core.experimental.fp64ify,
    fillArray = _core.experimental.fillArray;


function getPickingColor(index) {
  return [index + 1 & 255, index + 1 >> 8 & 255, index + 1 >> 8 >> 8 & 255];
}

function arrayPush(array, values) {
  var length = values.length;
  var offset = array.length;

  for (var index = 0; index < length; index++) {
    array[offset++] = values[index];
  }
  return array;
}

function flatten(values, level) {
  var result = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];

  if (level > 1) {
    values.forEach(function (v) {
      return flatten(v, level - 1, result);
    });
  } else {
    arrayPush(result, values);
  }
  return result;
}

var DEFAULT_COLOR = [0, 0, 0, 255]; // Black

var PolygonTesselatorExtruded = exports.PolygonTesselatorExtruded = function () {
  function PolygonTesselatorExtruded(_ref) {
    var polygons = _ref.polygons,
        _ref$getHeight = _ref.getHeight,
        getHeight = _ref$getHeight === undefined ? function (x) {
      return 1000;
    } : _ref$getHeight,
        _ref$getColor = _ref.getColor,
        getColor = _ref$getColor === undefined ? function (x) {
      return DEFAULT_COLOR;
    } : _ref$getColor,
        _ref$wireframe = _ref.wireframe,
        wireframe = _ref$wireframe === undefined ? false : _ref$wireframe,
        _ref$fp = _ref.fp64,
        fp64 = _ref$fp === undefined ? false : _ref$fp;

    _classCallCheck(this, PolygonTesselatorExtruded);

    this.fp64 = fp64;

    // Expensive operation, convert all polygons to arrays
    polygons = polygons.map(function (complexPolygon, polygonIndex) {
      var height = getHeight(polygonIndex) || 0;
      return Polygon.normalize(complexPolygon).map(function (polygon) {
        return polygon.map(function (coord) {
          return [coord[0], coord[1], height];
        });
      });
    });

    var groupedVertices = polygons;
    this.groupedVertices = polygons;
    var pointCount = getPointCount(polygons);
    this.pointCount = pointCount;
    this.wireframe = wireframe;

    this.attributes = {};

    var positionsJS = calculatePositionsJS({ groupedVertices: groupedVertices, pointCount: pointCount, wireframe: wireframe });
    Object.assign(this.attributes, {
      positions: calculatePositions(positionsJS, this.fp64),
      indices: calculateIndices({ groupedVertices: groupedVertices, wireframe: wireframe }),
      normals: calculateNormals({ groupedVertices: groupedVertices, pointCount: pointCount, wireframe: wireframe }),
      // colors: calculateColors({groupedVertices, wireframe, getColor}),
      pickingColors: calculatePickingColors({ groupedVertices: groupedVertices, pointCount: pointCount, wireframe: wireframe })
    });
  }

  _createClass(PolygonTesselatorExtruded, [{
    key: 'indices',
    value: function indices() {
      return this.attributes.indices;
    }
  }, {
    key: 'positions',
    value: function positions() {
      return this.attributes.positions;
    }
  }, {
    key: 'normals',
    value: function normals() {
      return this.attributes.normals;
    }
  }, {
    key: 'colors',
    value: function colors() {
      var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref2$getColor = _ref2.getColor,
          getColor = _ref2$getColor === undefined ? function (x) {
        return DEFAULT_COLOR;
      } : _ref2$getColor;

      var groupedVertices = this.groupedVertices,
          pointCount = this.pointCount,
          wireframe = this.wireframe;

      return calculateColors({ groupedVertices: groupedVertices, pointCount: pointCount, wireframe: wireframe, getColor: getColor });
    }
  }, {
    key: 'pickingColors',
    value: function pickingColors() {
      return this.attributes.pickingColors;
    }

    // updateTriggers: {
    //   positions: ['getHeight'],
    //   colors: ['getColors']
    //   pickingColors: 'none'
    // }

  }]);

  return PolygonTesselatorExtruded;
}();

// Count number of points in a list of complex polygons


function getPointCount(polygons) {
  return polygons.reduce(function (points, polygon) {
    return points + Polygon.getVertexCount(polygon);
  }, 0);
}

function calculateIndices(_ref3) {
  var groupedVertices = _ref3.groupedVertices,
      _ref3$wireframe = _ref3.wireframe,
      wireframe = _ref3$wireframe === undefined ? false : _ref3$wireframe;

  // adjust index offset for multiple polygons
  var multiplier = wireframe ? 2 : 5;
  var offsets = [];
  groupedVertices.reduce(function (vertexIndex, vertices) {
    offsets.push(vertexIndex);
    return vertexIndex + Polygon.getVertexCount(vertices) * multiplier;
  }, 0);

  var indices = groupedVertices.map(function (vertices, polygonIndex) {
    return wireframe ? // 1. get sequentially ordered indices of each polygons wireframe
    // 2. offset them by the number of indices in previous polygons
    calculateContourIndices(vertices, offsets[polygonIndex]) : // 1. get triangulated indices for the internal areas
    // 2. offset them by the number of indices in previous polygons
    calculateSurfaceIndices(vertices, offsets[polygonIndex]);
  });

  return new Uint32Array(flatten(indices, 2));
}

// Calculate a flat position array in JS - can be mapped to 32 or 64 bit typed arrays
// Remarks:
// * each top vertex is on 3 surfaces
// * each bottom vertex is on 2 surfaces
function calculatePositionsJS(_ref4) {
  var groupedVertices = _ref4.groupedVertices,
      pointCount = _ref4.pointCount,
      _ref4$wireframe = _ref4.wireframe,
      wireframe = _ref4$wireframe === undefined ? false : _ref4$wireframe;

  var multiplier = wireframe ? 2 : 5;
  var positions = new Float32Array(pointCount * 3 * multiplier);
  var vertexIndex = 0;

  groupedVertices.forEach(function (vertices) {
    var topVertices = flatten(vertices, 3);

    var baseVertices = topVertices.slice(0);
    var i = topVertices.length - 1;
    while (i > 0) {
      baseVertices[i] = 0;
      i -= 3;
    }
    var len = topVertices.length;

    if (wireframe) {
      fillArray({ target: positions, source: topVertices, start: vertexIndex });
      fillArray({ target: positions, source: baseVertices, start: vertexIndex + len });
    } else {
      fillArray({ target: positions, source: topVertices, start: vertexIndex, count: 3 });
      fillArray({
        target: positions,
        source: baseVertices,
        start: vertexIndex + len * 3,
        count: 2
      });
    }
    vertexIndex += len * multiplier;
  });

  return positions;
}

function calculatePositions(positionsJS, fp64) {
  var positionLow = void 0;
  if (fp64) {
    // We only need x, y component
    var vertexCount = positionsJS.length / 3;
    positionLow = new Float32Array(vertexCount * 2);
    for (var i = 0; i < vertexCount; i++) {
      positionLow[i * 2 + 0] = fp64ify(positionsJS[i * 3 + 0])[1];
      positionLow[i * 2 + 1] = fp64ify(positionsJS[i * 3 + 1])[1];
    }
  }
  return { positions: positionsJS, positions64xyLow: positionLow };
}

function calculateNormals(_ref5) {
  var groupedVertices = _ref5.groupedVertices,
      pointCount = _ref5.pointCount,
      wireframe = _ref5.wireframe;

  var up = [0, 0, 1];
  var multiplier = wireframe ? 2 : 5;

  var normals = new Float32Array(pointCount * 3 * multiplier);
  var vertexIndex = 0;

  if (wireframe) {
    return fillArray({ target: normals, source: up, count: pointCount * multiplier });
  }

  groupedVertices.map(function (vertices, polygonIndex) {
    var vertexCount = Polygon.getVertexCount(vertices);

    fillArray({ target: normals, source: up, start: vertexIndex, count: vertexCount });
    vertexIndex += vertexCount * 3;

    var sideNormalsForward = [];
    var sideNormalsBackward = [];

    vertices.forEach(function (polygon) {
      var sideNormals = calculateSideNormals(polygon);
      var firstNormal = sideNormals.slice(0, 3);

      arrayPush(sideNormalsForward, sideNormals);
      arrayPush(sideNormalsForward, firstNormal);

      arrayPush(sideNormalsBackward, firstNormal);
      arrayPush(sideNormalsBackward, sideNormals);
    });

    fillArray({
      target: normals,
      start: vertexIndex,
      count: 2,
      source: sideNormalsForward.concat(sideNormalsBackward)
    });
    vertexIndex += vertexCount * 3 * 4;
  });

  return normals;
}

function calculateSideNormals(vertices) {
  var normals = [];

  var lastVertice = null;
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = vertices[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var vertice = _step.value;

      if (lastVertice) {
        // vertex[i-1], vertex[i]
        var n = getNormal(lastVertice, vertice);
        arrayPush(normals, n);
      }
      lastVertice = vertice;
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return normals;
}

function calculateColors(_ref6) {
  var groupedVertices = _ref6.groupedVertices,
      pointCount = _ref6.pointCount,
      getColor = _ref6.getColor,
      _ref6$wireframe = _ref6.wireframe,
      wireframe = _ref6$wireframe === undefined ? false : _ref6$wireframe;

  var multiplier = wireframe ? 2 : 5;
  var colors = new Uint8ClampedArray(pointCount * 4 * multiplier);
  var vertexIndex = 0;

  groupedVertices.forEach(function (complexPolygon, polygonIndex) {
    var color = getColor(polygonIndex);
    color[3] = Number.isFinite(color[3]) ? color[3] : 255;

    var numVertices = Polygon.getVertexCount(complexPolygon);

    fillArray({ target: colors, source: color, start: vertexIndex, count: numVertices * multiplier });
    vertexIndex += color.length * numVertices * multiplier;
  });

  return colors;
}

function calculatePickingColors(_ref7) {
  var groupedVertices = _ref7.groupedVertices,
      pointCount = _ref7.pointCount,
      _ref7$wireframe = _ref7.wireframe,
      wireframe = _ref7$wireframe === undefined ? false : _ref7$wireframe;

  var multiplier = wireframe ? 2 : 5;
  var colors = new Uint8ClampedArray(pointCount * 3 * multiplier);
  var vertexIndex = 0;

  groupedVertices.forEach(function (vertices, polygonIndex) {
    var numVertices = Polygon.getVertexCount(vertices);
    var color = getPickingColor(polygonIndex);

    fillArray({ target: colors, source: color, start: vertexIndex, count: numVertices * multiplier });
    vertexIndex += color.length * numVertices * multiplier;
  });
  return colors;
}

function calculateContourIndices(vertices, offset) {
  var stride = Polygon.getVertexCount(vertices);
  var indices = [];

  vertices.forEach(function (polygon) {
    indices.push(offset);
    var numVertices = polygon.length;

    // polygon top
    // use vertex pairs for GL.LINES => [0, 1, 1, 2, 2, ..., n-1, n-1, 0]
    for (var i = 1; i < numVertices - 1; i++) {
      indices.push(i + offset, i + offset);
    }
    indices.push(offset);

    // polygon sides
    for (var _i = 0; _i < numVertices - 1; _i++) {
      indices.push(_i + offset, _i + stride + offset);
    }

    offset += numVertices;
  });

  return indices;
}

function drawSurfaceRectangle(targetArray, offset, stride) {
  targetArray.push(offset + stride, offset + stride * 3, offset + stride * 2 + 1, offset + stride * 2 + 1, offset + stride * 3, offset + stride * 4 + 1);
}

function calculateSurfaceIndices(vertices, offset) {
  var stride = Polygon.getVertexCount(vertices);

  var holes = null;
  var holeCount = vertices.length - 1;

  if (holeCount) {
    holes = [];
    var vertexIndex = 0;
    for (var i = 0; i < holeCount; i++) {
      vertexIndex += vertices[i].length;
      holes[i] = vertexIndex;
    }
  }

  var indices = (0, _earcut2.default)(flatten(vertices, 3), holes, 3).map(function (index) {
    return index + offset;
  });

  vertices.forEach(function (polygon) {
    var numVertices = polygon.length;

    // polygon sides
    for (var _i2 = 0; _i2 < numVertices - 1; _i2++) {
      drawSurfaceRectangle(indices, offset + _i2, stride);
    }

    offset += numVertices;
  });

  return indices;
}

// helpers

// get normal vector of line segment
function getNormal(p1, p2) {
  return [p1[1] - p2[1], p2[0] - p1[0], 0];
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9jb3JlLWxheWVycy9zb2xpZC1wb2x5Z29uLWxheWVyL3BvbHlnb24tdGVzc2VsYXRvci1leHRydWRlZC5qcyJdLCJuYW1lcyI6WyJQb2x5Z29uIiwiZnA2NGlmeSIsImZpbGxBcnJheSIsImdldFBpY2tpbmdDb2xvciIsImluZGV4IiwiYXJyYXlQdXNoIiwiYXJyYXkiLCJ2YWx1ZXMiLCJsZW5ndGgiLCJvZmZzZXQiLCJmbGF0dGVuIiwibGV2ZWwiLCJyZXN1bHQiLCJmb3JFYWNoIiwidiIsIkRFRkFVTFRfQ09MT1IiLCJQb2x5Z29uVGVzc2VsYXRvckV4dHJ1ZGVkIiwicG9seWdvbnMiLCJnZXRIZWlnaHQiLCJnZXRDb2xvciIsIndpcmVmcmFtZSIsImZwNjQiLCJtYXAiLCJjb21wbGV4UG9seWdvbiIsInBvbHlnb25JbmRleCIsImhlaWdodCIsIm5vcm1hbGl6ZSIsInBvbHlnb24iLCJjb29yZCIsImdyb3VwZWRWZXJ0aWNlcyIsInBvaW50Q291bnQiLCJnZXRQb2ludENvdW50IiwiYXR0cmlidXRlcyIsInBvc2l0aW9uc0pTIiwiY2FsY3VsYXRlUG9zaXRpb25zSlMiLCJPYmplY3QiLCJhc3NpZ24iLCJwb3NpdGlvbnMiLCJjYWxjdWxhdGVQb3NpdGlvbnMiLCJpbmRpY2VzIiwiY2FsY3VsYXRlSW5kaWNlcyIsIm5vcm1hbHMiLCJjYWxjdWxhdGVOb3JtYWxzIiwicGlja2luZ0NvbG9ycyIsImNhbGN1bGF0ZVBpY2tpbmdDb2xvcnMiLCJjYWxjdWxhdGVDb2xvcnMiLCJyZWR1Y2UiLCJwb2ludHMiLCJnZXRWZXJ0ZXhDb3VudCIsIm11bHRpcGxpZXIiLCJvZmZzZXRzIiwidmVydGV4SW5kZXgiLCJ2ZXJ0aWNlcyIsInB1c2giLCJjYWxjdWxhdGVDb250b3VySW5kaWNlcyIsImNhbGN1bGF0ZVN1cmZhY2VJbmRpY2VzIiwiVWludDMyQXJyYXkiLCJGbG9hdDMyQXJyYXkiLCJ0b3BWZXJ0aWNlcyIsImJhc2VWZXJ0aWNlcyIsInNsaWNlIiwiaSIsImxlbiIsInRhcmdldCIsInNvdXJjZSIsInN0YXJ0IiwiY291bnQiLCJwb3NpdGlvbkxvdyIsInZlcnRleENvdW50IiwicG9zaXRpb25zNjR4eUxvdyIsInVwIiwic2lkZU5vcm1hbHNGb3J3YXJkIiwic2lkZU5vcm1hbHNCYWNrd2FyZCIsInNpZGVOb3JtYWxzIiwiY2FsY3VsYXRlU2lkZU5vcm1hbHMiLCJmaXJzdE5vcm1hbCIsImNvbmNhdCIsImxhc3RWZXJ0aWNlIiwidmVydGljZSIsIm4iLCJnZXROb3JtYWwiLCJjb2xvcnMiLCJVaW50OENsYW1wZWRBcnJheSIsImNvbG9yIiwiTnVtYmVyIiwiaXNGaW5pdGUiLCJudW1WZXJ0aWNlcyIsInN0cmlkZSIsImRyYXdTdXJmYWNlUmVjdGFuZ2xlIiwidGFyZ2V0QXJyYXkiLCJob2xlcyIsImhvbGVDb3VudCIsInAxIiwicDIiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7cWpCQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztJQUFZQSxPOztBQUNaOztBQUVBOzs7Ozs7Ozs7O0lBRE9DLE8sc0JBQUFBLE87SUFBU0MsUyxzQkFBQUEsUzs7O0FBR2hCLFNBQVNDLGVBQVQsQ0FBeUJDLEtBQXpCLEVBQWdDO0FBQzlCLFNBQU8sQ0FBRUEsUUFBUSxDQUFULEdBQWMsR0FBZixFQUFzQkEsUUFBUSxDQUFULElBQWUsQ0FBaEIsR0FBcUIsR0FBekMsRUFBaURBLFFBQVEsQ0FBVCxJQUFlLENBQWhCLElBQXNCLENBQXZCLEdBQTRCLEdBQTFFLENBQVA7QUFDRDs7QUFFRCxTQUFTQyxTQUFULENBQW1CQyxLQUFuQixFQUEwQkMsTUFBMUIsRUFBa0M7QUFDaEMsTUFBTUMsU0FBU0QsT0FBT0MsTUFBdEI7QUFDQSxNQUFJQyxTQUFTSCxNQUFNRSxNQUFuQjs7QUFFQSxPQUFLLElBQUlKLFFBQVEsQ0FBakIsRUFBb0JBLFFB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QyxPQUFQO0FBQ0Q7O0FBRUQ7O0FBRUE7QUFDQSxTQUFTeUMsU0FBVCxDQUFtQlksRUFBbkIsRUFBdUJDLEVBQXZCLEVBQTJCO0FBQ3pCLFNBQU8sQ0FBQ0QsR0FBRyxDQUFILElBQVFDLEdBQUcsQ0FBSCxDQUFULEVBQWdCQSxHQUFHLENBQUgsSUFBUUQsR0FBRyxDQUFILENBQXhCLEVBQStCLENBQS9CLENBQVA7QUFDRCIsImZpbGUiOiJwb2x5Z29uLXRlc3NlbGF0b3ItZXh0cnVkZWQuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIDIwMTUgLSAyMDE3IFViZXIgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbi8vIFRIRSBTT0ZUV0FSRS5cblxuaW1wb3J0ICogYXMgUG9seWdvbiBmcm9tICcuL3BvbHlnb24nO1xuaW1wb3J0IHtleHBlcmltZW50YWx9IGZyb20gJy4uLy4uL2NvcmUnO1xuY29uc3Qge2ZwNjRpZnksIGZpbGxBcnJheX0gPSBleHBlcmltZW50YWw7XG5pbXBvcnQgZWFyY3V0IGZyb20gJ2VhcmN1dCc7XG5cbmZ1bmN0aW9uIGdldFBpY2tpbmdDb2xvcihpbmRleCkge1xuICByZXR1cm4gWyhpbmRleCArIDEpICYgMjU1LCAoKGluZGV4ICsgMSkgPj4gOCkgJiAyNTUsICgoKGluZGV4ICsgMSkgPj4gOCkgPj4gOCkgJiAyNTVdO1xufVxuXG5mdW5jdGlvbiBhcnJheVB1c2goYXJyYXksIHZhbHVlcykge1xuICBjb25zdCBsZW5ndGggPSB2YWx1ZXMubGVuZ3RoO1xuICBsZXQgb2Zmc2V0ID0gYXJyYXkubGVuZ3RoO1xuXG4gIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICBhcnJheVtvZmZzZXQrK10gPSB2YWx1ZXNbaW5kZXhdO1xuICB9XG4gIHJldHVybiBhcnJheTtcbn1cblxuZnVuY3Rpb24gZmxhdHRlbih2YWx1ZXMsIGxldmVsLCByZXN1bHQgPSBbXSkge1xuICBpZiAobGV2ZWwgPiAxKSB7XG4gICAgdmFsdWVzLmZvckVhY2godiA9PiBmbGF0dGVuKHYsIGxldmVsIC0gMSwgcmVzdWx0KSk7XG4gIH0gZWxzZSB7XG4gICAgYXJyYXlQdXNoKHJlc3VsdCwgdmFsdWVzKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5jb25zdCBERUZBVUxUX0NPTE9SID0gWzAsIDAsIDAsIDI1NV07IC8vIEJsYWNrXG5cbmV4cG9ydCBjbGFzcyBQb2x5Z29uVGVzc2VsYXRvckV4dHJ1ZGVkIHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIHBvbHlnb25zLFxuICAgIGdldEhlaWdodCA9IHggPT4gMTAwMCxcbiAgICBnZXRDb2xvciA9IHggPT4gREVGQVVMVF9DT0xPUixcbiAgICB3aXJlZnJhbWUgPSBmYWxzZSxcbiAgICBmcDY0ID0gZmFsc2VcbiAgfSkge1xuICAgIHRoaXMuZnA2NCA9IGZwNjQ7XG5cbiAgICAvLyBFeHBlbnNpdmUgb3BlcmF0aW9uLCBjb252ZXJ0IGFsbCBwb2x5Z29ucyB0byBhcnJheXNcbiAgICBwb2x5Z29ucyA9IHBvbHlnb25zLm1hcCgoY29tcGxleFBvbHlnb24sIHBvbHlnb25JbmRleCkgPT4ge1xuICAgICAgY29uc3QgaGVpZ2h0ID0gZ2V0SGVpZ2h0KHBvbHlnb25JbmRleCkgfHwgMDtcbiAgICAgIHJldHVybiBQb2x5Z29uLm5vcm1hbGl6ZShjb21wbGV4UG9seWdvbikubWFwKHBvbHlnb24gPT5cbiAgICAgICAgcG9seWdvbi5tYXAoY29vcmQgPT4gW2Nvb3JkWzBdLCBjb29yZFsxXSwgaGVpZ2h0XSlcbiAgICAgICk7XG4gICAgfSk7XG5cbiAgICBjb25zdCBncm91cGVkVmVydGljZXMgPSBwb2x5Z29ucztcbiAgICB0aGlzLmdyb3VwZWRWZXJ0aWNlcyA9IHBvbHlnb25zO1xuICAgIGNvbnN0IHBvaW50Q291bnQgPSBnZXRQb2ludENvdW50KHBvbHlnb25zKTtcbiAgICB0aGlzLnBvaW50Q291bnQgPSBwb2ludENvdW50O1xuICAgIHRoaXMud2lyZWZyYW1lID0gd2lyZWZyYW1lO1xuXG4gICAgdGhpcy5hdHRyaWJ1dGVzID0ge307XG5cbiAgICBjb25zdCBwb3NpdGlvbnNKUyA9IGNhbGN1bGF0ZVBvc2l0aW9uc0pTKHtncm91cGVkVmVydGljZXMsIHBvaW50Q291bnQsIHdpcmVmcmFtZX0pO1xuICAgIE9iamVjdC5hc3NpZ24odGhpcy5hdHRyaWJ1dGVzLCB7XG4gICAgICBwb3NpdGlvbnM6IGNhbGN1bGF0ZVBvc2l0aW9ucyhwb3NpdGlvbnNKUywgdGhpcy5mcDY0KSxcbiAgICAgIGluZGljZXM6IGNhbGN1bGF0ZUluZGljZXMoe2dyb3VwZWRWZXJ0aWNlcywgd2lyZWZyYW1lfSksXG4gICAgICBub3JtYWxzOiBjYWxjdWxhdGVOb3JtYWxzKHtncm91cGVkVmVydGljZXMsIHBvaW50Q291bnQsIHdpcmVmcmFtZX0pLFxuICAgICAgLy8gY29sb3JzOiBjYWxjdWxhdGVDb2xvcnMoe2dyb3VwZWRWZXJ0aWNlcywgd2lyZWZyYW1lLCBnZXRDb2xvcn0pLFxuICAgICAgcGlja2luZ0NvbG9yczogY2FsY3VsYXRlUGlja2luZ0NvbG9ycyh7Z3JvdXBlZFZlcnRpY2VzLCBwb2ludENvdW50LCB3aXJlZnJhbWV9KVxuICAgIH0pO1xuICB9XG5cbiAgaW5kaWNlcygpIHtcbiAgICByZXR1cm4gdGhpcy5hdHRyaWJ1dGVzLmluZGljZXM7XG4gIH1cblxuICBwb3NpdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuYXR0cmlidXRlcy5wb3NpdGlvbnM7XG4gIH1cblxuICBub3JtYWxzKCkge1xuICAgIHJldHVybiB0aGlzLmF0dHJpYnV0ZXMubm9ybWFscztcbiAgfVxuXG4gIGNvbG9ycyh7Z2V0Q29sb3IgPSB4ID0+IERFRkFVTFRfQ09MT1J9ID0ge30pIHtcbiAgICBjb25zdCB7Z3JvdXBlZFZlcnRpY2VzLCBwb2ludENvdW50LCB3aXJlZnJhbWV9ID0gdGhpcztcbiAgICByZXR1cm4gY2FsY3VsYXRlQ29sb3JzKHtncm91cGVkVmVydGljZXMsIHBvaW50Q291bnQsIHdpcmVmcmFtZSwgZ2V0Q29sb3J9KTtcbiAgfVxuXG4gIHBpY2tpbmdDb2xvcnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuYXR0cmlidXRlcy5waWNraW5nQ29sb3JzO1xuICB9XG5cbiAgLy8gdXBkYXRlVHJpZ2dlcnM6IHtcbiAgLy8gICBwb3NpdGlvbnM6IFsnZ2V0SGVpZ2h0J10sXG4gIC8vICAgY29sb3JzOiBbJ2dldENvbG9ycyddXG4gIC8vICAgcGlja2luZ0NvbG9yczogJ25vbmUnXG4gIC8vIH1cbn1cblxuLy8gQ291bnQgbnVtYmVyIG9mIHBvaW50cyBpbiBhIGxpc3Qgb2YgY29tcGxleCBwb2x5Z29uc1xuZnVuY3Rpb24gZ2V0UG9pbnRDb3VudChwb2x5Z29ucykge1xuICByZXR1cm4gcG9seWdvbnMucmVkdWNlKChwb2ludHMsIHBvbHlnb24pID0+IHBvaW50cyArIFBvbHlnb24uZ2V0VmVydGV4Q291bnQocG9seWdvbiksIDApO1xufVxuXG5mdW5jdGlvbiBjYWxjdWxhdGVJbmRpY2VzKHtncm91cGVkVmVydGljZXMsIHdpcmVmcmFtZSA9IGZhbHNlfSkge1xuICAvLyBhZGp1c3QgaW5kZXggb2Zmc2V0IGZvciBtdWx0aXBsZSBwb2x5Z29uc1xuICBjb25zdCBtdWx0aXBsaWVyID0gd2lyZWZyYW1lID8gMiA6IDU7XG4gIGNvbnN0IG9mZnNldHMgPSBbXTtcbiAgZ3JvdXBlZFZlcnRpY2VzLnJlZHVjZSgodmVydGV4SW5kZXgsIHZlcnRpY2VzKSA9PiB7XG4gICAgb2Zmc2V0cy5wdXNoKHZlcnRleEluZGV4KTtcbiAgICByZXR1cm4gdmVydGV4SW5kZXggKyBQb2x5Z29uLmdldFZlcnRleENvdW50KHZlcnRpY2VzKSAqIG11bHRpcGxpZXI7XG4gIH0sIDApO1xuXG4gIGNvbnN0IGluZGljZXMgPSBncm91cGVkVmVydGljZXMubWFwKFxuICAgICh2ZXJ0aWNlcywgcG9seWdvbkluZGV4KSA9PlxuICAgICAgd2lyZWZyYW1lXG4gICAgICAgID8gLy8gMS4gZ2V0IHNlcXVlbnRpYWxseSBvcmRlcmVkIGluZGljZXMgb2YgZWFjaCBwb2x5Z29ucyB3aXJlZnJhbWVcbiAgICAgICAgICAvLyAyLiBvZmZzZXQgdGhlbSBieSB0aGUgbnVtYmVyIG9mIGluZGljZXMgaW4gcHJldmlvdXMgcG9seWdvbnNcbiAgICAgICAgICBjYWxjdWxhdGVDb250b3VySW5kaWNlcyh2ZXJ0aWNlcywgb2Zmc2V0c1twb2x5Z29uSW5kZXhdKVxuICAgICAgICA6IC8vIDEuIGdldCB0cmlhbmd1bGF0ZWQgaW5kaWNlcyBmb3IgdGhlIGludGVybmFsIGFyZWFzXG4gICAgICAgICAgLy8gMi4gb2Zmc2V0IHRoZW0gYnkgdGhlIG51bWJlciBvZiBpbmRpY2VzIGluIHByZXZpb3VzIHBvbHlnb25zXG4gICAgICAgICAgY2FsY3VsYXRlU3VyZmFjZUluZGljZXModmVydGljZXMsIG9mZnNldHNbcG9seWdvbkluZGV4XSlcbiAgKTtcblxuICByZXR1cm4gbmV3IFVpbnQzMkFycmF5KGZsYXR0ZW4oaW5kaWNlcywgMikpO1xufVxuXG4vLyBDYWxjdWxhdGUgYSBmbGF0IHBvc2l0aW9uIGFycmF5IGluIEpTIC0gY2FuIGJlIG1hcHBlZCB0byAzMiBvciA2NCBiaXQgdHlwZWQgYXJyYXlzXG4vLyBSZW1hcmtzOlxuLy8gKiBlYWNoIHRvcCB2ZXJ0ZXggaXMgb24gMyBzdXJmYWNlc1xuLy8gKiBlYWNoIGJvdHRvbSB2ZXJ0ZXggaXMgb24gMiBzdXJmYWNlc1xuZnVuY3Rpb24gY2FsY3VsYXRlUG9zaXRpb25zSlMoe2dyb3VwZWRWZXJ0aWNlcywgcG9pbnRDb3VudCwgd2lyZWZyYW1lID0gZmFsc2V9KSB7XG4gIGNvbnN0IG11bHRpcGxpZXIgPSB3aXJlZnJhbWUgPyAyIDogNTtcbiAgY29uc3QgcG9zaXRpb25zID0gbmV3IEZsb2F0MzJBcnJheShwb2ludENvdW50ICogMyAqIG11bHRpcGxpZXIpO1xuICBsZXQgdmVydGV4SW5kZXggPSAwO1xuXG4gIGdyb3VwZWRWZXJ0aWNlcy5mb3JFYWNoKHZlcnRpY2VzID0+IHtcbiAgICBjb25zdCB0b3BWZXJ0aWNlcyA9IGZsYXR0ZW4odmVydGljZXMsIDMpO1xuXG4gICAgY29uc3QgYmFzZVZlcnRpY2VzID0gdG9wVmVydGljZXMuc2xpY2UoMCk7XG4gICAgbGV0IGkgPSB0b3BWZXJ0aWNlcy5sZW5ndGggLSAxO1xuICAgIHdoaWxlIChpID4gMCkge1xuICAgICAgYmFzZVZlcnRpY2VzW2ldID0gMDtcbiAgICAgIGkgLT0gMztcbiAgICB9XG4gICAgY29uc3QgbGVuID0gdG9wVmVydGljZXMubGVuZ3RoO1xuXG4gICAgaWYgKHdpcmVmcmFtZSkge1xuICAgICAgZmlsbEFycmF5KHt0YXJnZXQ6IHBvc2l0aW9ucywgc291cmNlOiB0b3BWZXJ0aWNlcywgc3RhcnQ6IHZlcnRleEluZGV4fSk7XG4gICAgICBmaWxsQXJyYXkoe3RhcmdldDogcG9zaXRpb25zLCBzb3VyY2U6IGJhc2VWZXJ0aWNlcywgc3RhcnQ6IHZlcnRleEluZGV4ICsgbGVufSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZpbGxBcnJheSh7dGFyZ2V0OiBwb3NpdGlvbnMsIHNvdXJjZTogdG9wVmVydGljZXMsIHN0YXJ0OiB2ZXJ0ZXhJbmRleCwgY291bnQ6IDN9KTtcbiAgICAgIGZpbGxBcnJheSh7XG4gICAgICAgIHRhcmdldDogcG9zaXRpb25zLFxuICAgICAgICBzb3VyY2U6IGJhc2VWZXJ0aWNlcyxcbiAgICAgICAgc3RhcnQ6IHZlcnRleEluZGV4ICsgbGVuICogMyxcbiAgICAgICAgY291bnQ6IDJcbiAgICAgIH0pO1xuICAgIH1cbiAgICB2ZXJ0ZXhJbmRleCArPSBsZW4gKiBtdWx0aXBsaWVyO1xuICB9KTtcblxuICByZXR1cm4gcG9zaXRpb25zO1xufVxuXG5mdW5jdGlvbiBjYWxjdWxhdGVQb3NpdGlvbnMocG9zaXRpb25zSlMsIGZwNjQpIHtcbiAgbGV0IHBvc2l0aW9uTG93O1xuICBpZiAoZnA2NCkge1xuICAgIC8vIFdlIG9ubHkgbmVlZCB4LCB5IGNvbXBvbmVudFxuICAgIGNvbnN0IHZlcnRleENvdW50ID0gcG9zaXRpb25zSlMubGVuZ3RoIC8gMztcbiAgICBwb3NpdGlvbkxvdyA9IG5ldyBGbG9hdDMyQXJyYXkodmVydGV4Q291bnQgKiAyKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZlcnRleENvdW50OyBpKyspIHtcbiAgICAgIHBvc2l0aW9uTG93W2kgKiAyICsgMF0gPSBmcDY0aWZ5KHBvc2l0aW9uc0pTW2kgKiAzICsgMF0pWzFdO1xuICAgICAgcG9zaXRpb25Mb3dbaSAqIDIgKyAxXSA9IGZwNjRpZnkocG9zaXRpb25zSlNbaSAqIDMgKyAxXSlbMV07XG4gICAgfVxuICB9XG4gIHJldHVybiB7cG9zaXRpb25zOiBwb3NpdGlvbnNKUywgcG9zaXRpb25zNjR4eUxvdzogcG9zaXRpb25Mb3d9O1xufVxuXG5mdW5jdGlvbiBjYWxjdWxhdGVOb3JtYWxzKHtncm91cGVkVmVydGljZXMsIHBvaW50Q291bnQsIHdpcmVmcmFtZX0pIHtcbiAgY29uc3QgdXAgPSBbMCwgMCwgMV07XG4gIGNvbnN0IG11bHRpcGxpZXIgPSB3aXJlZnJhbWUgPyAyIDogNTtcblxuICBjb25zdCBub3JtYWxzID0gbmV3IEZsb2F0MzJBcnJheShwb2ludENvdW50ICogMyAqIG11bHRpcGxpZXIpO1xuICBsZXQgdmVydGV4SW5kZXggPSAwO1xuXG4gIGlmICh3aXJlZnJhbWUpIHtcbiAgICByZXR1cm4gZmlsbEFycmF5KHt0YXJnZXQ6IG5vcm1hbHMsIHNvdXJjZTogdXAsIGNvdW50OiBwb2ludENvdW50ICogbXVsdGlwbGllcn0pO1xuICB9XG5cbiAgZ3JvdXBlZFZlcnRpY2VzLm1hcCgodmVydGljZXMsIHBvbHlnb25JbmRleCkgPT4ge1xuICAgIGNvbnN0IHZlcnRleENvdW50ID0gUG9seWdvbi5nZXRWZXJ0ZXhDb3VudCh2ZXJ0aWNlcyk7XG5cbiAgICBmaWxsQXJyYXkoe3RhcmdldDogbm9ybWFscywgc291cmNlOiB1cCwgc3RhcnQ6IHZlcnRleEluZGV4LCBjb3VudDogdmVydGV4Q291bnR9KTtcbiAgICB2ZXJ0ZXhJbmRleCArPSB2ZXJ0ZXhDb3VudCAqIDM7XG5cbiAgICBjb25zdCBzaWRlTm9ybWFsc0ZvcndhcmQgPSBbXTtcbiAgICBjb25zdCBzaWRlTm9ybWFsc0JhY2t3YXJkID0gW107XG5cbiAgICB2ZXJ0aWNlcy5mb3JFYWNoKHBvbHlnb24gPT4ge1xuICAgICAgY29uc3Qgc2lkZU5vcm1hbHMgPSBjYWxjdWxhdGVTaWRlTm9ybWFscyhwb2x5Z29uKTtcbiAgICAgIGNvbnN0IGZpcnN0Tm9ybWFsID0gc2lkZU5vcm1hbHMuc2xpY2UoMCwgMyk7XG5cbiAgICAgIGFycmF5UHVzaChzaWRlTm9ybWFsc0ZvcndhcmQsIHNpZGVOb3JtYWxzKTtcbiAgICAgIGFycmF5UHVzaChzaWRlTm9ybWFsc0ZvcndhcmQsIGZpcnN0Tm9ybWFsKTtcblxuICAgICAgYXJyYXlQdXNoKHNpZGVOb3JtYWxzQmFja3dhcmQsIGZpcnN0Tm9ybWFsKTtcbiAgICAgIGFycmF5UHVzaChzaWRlTm9ybWFsc0JhY2t3YXJkLCBzaWRlTm9ybWFscyk7XG4gICAgfSk7XG5cbiAgICBmaWxsQXJyYXkoe1xuICAgICAgdGFyZ2V0OiBub3JtYWxzLFxuICAgICAgc3RhcnQ6IHZlcnRleEluZGV4LFxuICAgICAgY291bnQ6IDIsXG4gICAgICBzb3VyY2U6IHNpZGVOb3JtYWxzRm9yd2FyZC5jb25jYXQoc2lkZU5vcm1hbHNCYWNrd2FyZClcbiAgICB9KTtcbiAgICB2ZXJ0ZXhJbmRleCArPSB2ZXJ0ZXhDb3VudCAqIDMgKiA0O1xuICB9KTtcblxuICByZXR1cm4gbm9ybWFscztcbn1cblxuZnVuY3Rpb24gY2FsY3VsYXRlU2lkZU5vcm1hbHModmVydGljZXMpIHtcbiAgY29uc3Qgbm9ybWFscyA9IFtdO1xuXG4gIGxldCBsYXN0VmVydGljZSA9IG51bGw7XG4gIGZvciAoY29uc3QgdmVydGljZSBvZiB2ZXJ0aWNlcykge1xuICAgIGlmIChsYXN0VmVydGljZSkge1xuICAgICAgLy8gdmVydGV4W2ktMV0sIHZlcnRleFtpXVxuICAgICAgY29uc3QgbiA9IGdldE5vcm1hbChsYXN0VmVydGljZSwgdmVydGljZSk7XG4gICAgICBhcnJheVB1c2gobm9ybWFscywgbik7XG4gICAgfVxuICAgIGxhc3RWZXJ0aWNlID0gdmVydGljZTtcbiAgfVxuXG4gIHJldHVybiBub3JtYWxzO1xufVxuXG5mdW5jdGlvbiBjYWxjdWxhdGVDb2xvcnMoe2dyb3VwZWRWZXJ0aWNlcywgcG9pbnRDb3VudCwgZ2V0Q29sb3IsIHdpcmVmcmFtZSA9IGZhbHNlfSkge1xuICBjb25zdCBtdWx0aXBsaWVyID0gd2lyZWZyYW1lID8gMiA6IDU7XG4gIGNvbnN0IGNvbG9ycyA9IG5ldyBVaW50OENsYW1wZWRBcnJheShwb2ludENvdW50ICogNCAqIG11bHRpcGxpZXIpO1xuICBsZXQgdmVydGV4SW5kZXggPSAwO1xuXG4gIGdyb3VwZWRWZXJ0aWNlcy5mb3JFYWNoKChjb21wbGV4UG9seWdvbiwgcG9seWdvbkluZGV4KSA9PiB7XG4gICAgY29uc3QgY29sb3IgPSBnZXRDb2xvcihwb2x5Z29uSW5kZXgpO1xuICAgIGNvbG9yWzNdID0gTnVtYmVyLmlzRmluaXRlKGNvbG9yWzNdKSA/IGNvbG9yWzNdIDogMjU1O1xuXG4gICAgY29uc3QgbnVtVmVydGljZXMgPSBQb2x5Z29uLmdldFZlcnRleENvdW50KGNvbXBsZXhQb2x5Z29uKTtcblxuICAgIGZpbGxBcnJheSh7dGFyZ2V0OiBjb2xvcnMsIHNvdXJjZTogY29sb3IsIHN0YXJ0OiB2ZXJ0ZXhJbmRleCwgY291bnQ6IG51bVZlcnRpY2VzICogbXVsdGlwbGllcn0pO1xuICAgIHZlcnRleEluZGV4ICs9IGNvbG9yLmxlbmd0aCAqIG51bVZlcnRpY2VzICogbXVsdGlwbGllcjtcbiAgfSk7XG5cbiAgcmV0dXJuIGNvbG9ycztcbn1cblxuZnVuY3Rpb24gY2FsY3VsYXRlUGlja2luZ0NvbG9ycyh7Z3JvdXBlZFZlcnRpY2VzLCBwb2ludENvdW50LCB3aXJlZnJhbWUgPSBmYWxzZX0pIHtcbiAgY29uc3QgbXVsdGlwbGllciA9IHdpcmVmcmFtZSA/IDIgOiA1O1xuICBjb25zdCBjb2xvcnMgPSBuZXcgVWludDhDbGFtcGVkQXJyYXkocG9pbnRDb3VudCAqIDMgKiBtdWx0aXBsaWVyKTtcbiAgbGV0IHZlcnRleEluZGV4ID0gMDtcblxuICBncm91cGVkVmVydGljZXMuZm9yRWFjaCgodmVydGljZXMsIHBvbHlnb25JbmRleCkgPT4ge1xuICAgIGNvbnN0IG51bVZlcnRpY2VzID0gUG9seWdvbi5nZXRWZXJ0ZXhDb3VudCh2ZXJ0aWNlcyk7XG4gICAgY29uc3QgY29sb3IgPSBnZXRQaWNraW5nQ29sb3IocG9seWdvbkluZGV4KTtcblxuICAgIGZpbGxBcnJheSh7dGFyZ2V0OiBjb2xvcnMsIHNvdXJjZTogY29sb3IsIHN0YXJ0OiB2ZXJ0ZXhJbmRleCwgY291bnQ6IG51bVZlcnRpY2VzICogbXVsdGlwbGllcn0pO1xuICAgIHZlcnRleEluZGV4ICs9IGNvbG9yLmxlbmd0aCAqIG51bVZlcnRpY2VzICogbXVsdGlwbGllcjtcbiAgfSk7XG4gIHJldHVybiBjb2xvcnM7XG59XG5cbmZ1bmN0aW9uIGNhbGN1bGF0ZUNvbnRvdXJJbmRpY2VzKHZlcnRpY2VzLCBvZmZzZXQpIHtcbiAgY29uc3Qgc3RyaWRlID0gUG9seWdvbi5nZXRWZXJ0ZXhDb3VudCh2ZXJ0aWNlcyk7XG4gIGNvbnN0IGluZGljZXMgPSBbXTtcblxuICB2ZXJ0aWNlcy5mb3JFYWNoKHBvbHlnb24gPT4ge1xuICAgIGluZGljZXMucHVzaChvZmZzZXQpO1xuICAgIGNvbnN0IG51bVZlcnRpY2VzID0gcG9seWdvbi5sZW5ndGg7XG5cbiAgICAvLyBwb2x5Z29uIHRvcFxuICAgIC8vIHVzZSB2ZXJ0ZXggcGFpcnMgZm9yIEdMLkxJTkVTID0+IFswLCAxLCAxLCAyLCAyLCAuLi4sIG4tMSwgbi0xLCAwXVxuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgbnVtVmVydGljZXMgLSAxOyBpKyspIHtcbiAgICAgIGluZGljZXMucHVzaChpICsgb2Zmc2V0LCBpICsgb2Zmc2V0KTtcbiAgICB9XG4gICAgaW5kaWNlcy5wdXNoKG9mZnNldCk7XG5cbiAgICAvLyBwb2x5Z29uIHNpZGVzXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1WZXJ0aWNlcyAtIDE7IGkrKykge1xuICAgICAgaW5kaWNlcy5wdXNoKGkgKyBvZmZzZXQsIGkgKyBzdHJpZGUgKyBvZmZzZXQpO1xuICAgIH1cblxuICAgIG9mZnNldCArPSBudW1WZXJ0aWNlcztcbiAgfSk7XG5cbiAgcmV0dXJuIGluZGljZXM7XG59XG5cbmZ1bmN0aW9uIGRyYXdTdXJmYWNlUmVjdGFuZ2xlKHRhcmdldEFycmF5LCBvZmZzZXQsIHN0cmlkZSkge1xuICB0YXJnZXRBcnJheS5wdXNoKFxuICAgIG9mZnNldCArIHN0cmlkZSxcbiAgICBvZmZzZXQgKyBzdHJpZGUgKiAzLFxuICAgIG9mZnNldCArIHN0cmlkZSAqIDIgKyAxLFxuICAgIG9mZnNldCArIHN0cmlkZSAqIDIgKyAxLFxuICAgIG9mZnNldCArIHN0cmlkZSAqIDMsXG4gICAgb2Zmc2V0ICsgc3RyaWRlICogNCArIDFcbiAgKTtcbn1cblxuZnVuY3Rpb24gY2FsY3VsYXRlU3VyZmFjZUluZGljZXModmVydGljZXMsIG9mZnNldCkge1xuICBjb25zdCBzdHJpZGUgPSBQb2x5Z29uLmdldFZlcnRleENvdW50KHZlcnRpY2VzKTtcblxuICBsZXQgaG9sZXMgPSBudWxsO1xuICBjb25zdCBob2xlQ291bnQgPSB2ZXJ0aWNlcy5sZW5ndGggLSAxO1xuXG4gIGlmIChob2xlQ291bnQpIHtcbiAgICBob2xlcyA9IFtdO1xuICAgIGxldCB2ZXJ0ZXhJbmRleCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBob2xlQ291bnQ7IGkrKykge1xuICAgICAgdmVydGV4SW5kZXggKz0gdmVydGljZXNbaV0ubGVuZ3RoO1xuICAgICAgaG9sZXNbaV0gPSB2ZXJ0ZXhJbmRleDtcbiAgICB9XG4gIH1cblxuICBjb25zdCBpbmRpY2VzID0gZWFyY3V0KGZsYXR0ZW4odmVydGljZXMsIDMpLCBob2xlcywgMykubWFwKGluZGV4ID0+IGluZGV4ICsgb2Zmc2V0KTtcblxuICB2ZXJ0aWNlcy5mb3JFYWNoKHBvbHlnb24gPT4ge1xuICAgIGNvbnN0IG51bVZlcnRpY2VzID0gcG9seWdvbi5sZW5ndGg7XG5cbiAgICAvLyBwb2x5Z29uIHNpZGVzXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1WZXJ0aWNlcyAtIDE7IGkrKykge1xuICAgICAgZHJhd1N1cmZhY2VSZWN0YW5nbGUoaW5kaWNlcywgb2Zmc2V0ICsgaSwgc3RyaWRlKTtcbiAgICB9XG5cbiAgICBvZmZzZXQgKz0gbnVtVmVydGljZXM7XG4gIH0pO1xuXG4gIHJldHVybiBpbmRpY2VzO1xufVxuXG4vLyBoZWxwZXJzXG5cbi8vIGdldCBub3JtYWwgdmVjdG9yIG9mIGxpbmUgc2VnbWVudFxuZnVuY3Rpb24gZ2V0Tm9ybWFsKHAxLCBwMikge1xuICByZXR1cm4gW3AxWzFdIC0gcDJbMV0sIHAyWzBdIC0gcDFbMF0sIDBdO1xufVxuIl19