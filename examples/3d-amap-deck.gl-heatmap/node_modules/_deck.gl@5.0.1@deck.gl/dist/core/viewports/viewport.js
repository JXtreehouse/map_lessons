'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

var _log = require('../utils/log');

var _log2 = _interopRequireDefault(_log);

var _mathUtils = require('../utils/math-utils');

var _math = require('math.gl');

var _scale = require('gl-mat4/scale');

var _scale2 = _interopRequireDefault(_scale);

var _translate = require('gl-mat4/translate');

var _translate2 = _interopRequireDefault(_translate);

var _multiply = require('gl-mat4/multiply');

var _multiply2 = _interopRequireDefault(_multiply);

var _invert = require('gl-mat4/invert');

var _invert2 = _interopRequireDefault(_invert);

var _perspective = require('gl-mat4/perspective');

var _perspective2 = _interopRequireDefault(_perspective);

var _lerp = require('gl-vec2/lerp');

var _lerp2 = _interopRequireDefault(_lerp);

var _viewportMercatorProject = require('viewport-mercator-project');

var _assert = require('assert');

var _assert2 = _interopRequireDefault(_assert);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var ZERO_VECTOR = [0, 0, 0];

var IDENTITY = (0, _mathUtils.createMat4)();

var DEFAULT_DISTANCE_SCALES = {
  pixelsPerMeter: [1, 1, 1],
  metersPerPixel: [1, 1, 1],
  pixelsPerDegree: [1, 1, 1],
  degreesPerPixel: [1, 1, 1]
};

var DEFAULT_ZOOM = 0;

var ERR_ARGUMENT = 'Illegal argument to Viewport';

var Viewport = function () {
  /**
   * @classdesc
   * Manages coordinate system transformations for deck.gl.
   *
   * Note: The Viewport is immutable in the sense that it only has accessors.
   * A new viewport instance should be created if any parameters have changed.
   */
  /* eslint-disable complexity, max-statements */
  function Viewport() {
    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, Viewport);

    var _opts$id = opts.id,
        id = _opts$id === undefined ? null : _opts$id,
        _opts$x = opts.x,
        x = _opts$x === undefined ? 0 : _opts$x,
        _opts$y = opts.y,
        y = _opts$y === undefined ? 0 : _opts$y,
        _opts$width = opts.width,
        width = _opts$width === undefined ? 1 : _opts$width,
        _opts$height = opts.height,
        height = _opts$height === undefined ? 1 : _opts$height,
        _opts$viewMatrix = opts.viewMatrix,
        viewMatrix = _opts$viewMatrix === undefined ? IDENTITY : _opts$viewMatrix,
        _opts$projectionMatri = opts.projectionMatrix,
        projectionMatrix = _opts$projectionMatri === undefined ? null : _opts$projectionMatri,
        _opts$fovy = opts.fovy,
        fovy = _opts$fovy === undefined ? 75 : _opts$fovy,
        _opts$near = opts.near,
        near = _opts$near === undefined ? 0.1 : _opts$near,
        _opts$far = opts.far,
        far = _opts$far === undefined ? 1000 : _opts$far,
        _opts$longitude = opts.longitude,
        longitude = _opts$longitude === undefined ? null : _opts$longitude,
        _opts$latitude = opts.latitude,
        latitude = _opts$latitude === undefined ? null : _opts$latitude,
        _opts$zoom = opts.zoom,
        zoom = _opts$zoom === undefined ? null : _opts$zoom,
        _opts$position = opts.position,
        position = _opts$position === undefined ? null : _opts$position,
        _opts$modelMatrix = opts.modelMatrix,
        modelMatrix = _opts$modelMatrix === undefined ? null : _opts$modelMatrix,
        _opts$distanceScales = opts.distanceScales,
        distanceScales = _opts$distanceScales === undefined ? null : _opts$distanceScales;


    this.id = id || this.constructor.displayName || 'viewport';

    // Check if we have a geospatial anchor
    this.isGeospatial = Number.isFinite(latitude) && Number.isFinite(longitude);

    // Silently allow apps to send in w,h = 0,0
    this.x = x;
    this.y = y;
    this.width = width || 1;
    this.height = height || 1;

    this.zoom = zoom;
    if (!Number.isFinite(this.zoom)) {
      this.zoom = this.isGeospatial ? (0, _viewportMercatorProject.getMeterZoom)({ latitude: latitude }) : DEFAULT_ZOOM;
    }
    this.scale = Math.pow(2, this.zoom);

    // Calculate distance scales if lng/lat/zoom are provided
    this.distanceScales = this.isGeospatial ? (0, _viewportMercatorProject.getDistanceScales)({ latitude: latitude, longitude: longitude, scale: this.scale }) : distanceScales || DEFAULT_DISTANCE_SCALES;

    this.focalDistance = opts.focalDistance || 1;

    this.distanceScales.metersPerPixel = new _math.Vector3(this.distanceScales.metersPerPixel);
    this.distanceScales.pixelsPerMeter = new _math.Vector3(this.distanceScales.pixelsPerMeter);

    this.position = ZERO_VECTOR;
    this.meterOffset = ZERO_VECTOR;
    if (position) {
      // Apply model matrix if supplied
      this.position = position;
      this.modelMatrix = modelMatrix;
      this.meterOffset = modelMatrix ? modelMatrix.transformVector(position) : position;
    }

    this.viewMatrixUncentered = viewMatrix;

    if (this.isGeospatial) {
      // Determine camera center
      this.center = (0, _viewportMercatorProject.getWorldPosition)({
        longitude: longitude,
        latitude: latitude,
        zoom: this.zoom,
        meterOffset: this.meterOffset
      });

      // Make a centered version of the matrix for projection modes without an offset
      this.viewMatrix = new _math.Matrix4()
      // Apply the uncentered view matrix
      .multiplyRight(this.viewMatrixUncentered)
      // The Mercator world coordinate system is upper left,
      // but GL expects lower left, so we flip it around the center after all transforms are done
      .scale([1, -1, 1])
      // And center it
      .translate(new _math.Vector3(this.center || ZERO_VECTOR).negate());
    } else {
      this.center = position;
      this.viewMatrix = viewMatrix;
    }

    // Create a projection matrix if not supplied
    if (projectionMatrix) {
      this.projectionMatrix = projectionMatrix;
    } else {
      (0, _assert2.default)(Number.isFinite(fovy));
      var DEGREES_TO_RADIANS = Math.PI / 180;
      var fovyRadians = fovy * DEGREES_TO_RADIANS;
      var aspect = this.width / this.height;
      this.projectionMatrix = (0, _perspective2.default)([], fovyRadians, aspect, near, far);
    }

    // Init pixel matrices
    this._initMatrices();

    // Bind methods for easy access
    this.equals = this.equals.bind(this);
    this.project = this.project.bind(this);
    this.unproject = this.unproject.bind(this);
    this.projectFlat = this.projectFlat.bind(this);
    this.unprojectFlat = this.unprojectFlat.bind(this);
    this.getMatrices = this.getMatrices.bind(this);
  }
  /* eslint-enable complexity, max-statements */

  // Two viewports are equal if width and height are identical, and if
  // their view and projection matrices are (approximately) equal.


  _createClass(Viewport, [{
    key: 'equals',
    value: function equals(viewport) {
      if (!(viewport instanceof Viewport)) {
        return false;
      }

      return viewport.width === this.width && viewport.height === this.height && (0, _math.equals)(viewport.projectionMatrix, this.projectionMatrix) && (0, _math.equals)(viewport.viewMatrix, this.viewMatrix);
      // TODO - check distance scales?
    }

    /**
     * Projects xyz (possibly latitude and longitude) to pixel coordinates in window
     * using viewport projection parameters
     * - [longitude, latitude] to [x, y]
     * - [longitude, latitude, Z] => [x, y, z]
     * Note: By default, returns top-left coordinates for canvas/SVG type render
     *
     * @param {Array} lngLatZ - [lng, lat] or [lng, lat, Z]
     * @param {Object} opts - options
     * @param {Object} opts.topLeft=true - Whether projected coords are top left
     * @return {Array} - [x, y] or [x, y, z] in top left coords
     */

  }, {
    key: 'project',
    value: function project(xyz) {
      var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
          _ref$topLeft = _ref.topLeft,
          topLeft = _ref$topLeft === undefined ? true : _ref$topLeft;

      var _xyz = _slicedToArray(xyz, 3),
          x0 = _xyz[0],
          y0 = _xyz[1],
          _xyz$ = _xyz[2],
          z0 = _xyz$ === undefined ? 0 : _xyz$;

      (0, _assert2.default)(Number.isFinite(x0) && Number.isFinite(y0) && Number.isFinite(z0), ERR_ARGUMENT);

      var _projectFlat2 = this.projectFlat([x0, y0]),
          _projectFlat3 = _slicedToArray(_projectFlat2, 2),
          X = _projectFlat3[0],
          Y = _projectFlat3[1];

      var v = (0, _mathUtils.transformVector)(this.pixelProjectionMatrix, [X, Y, z0, 1]);

      var _v = _slicedToArray(v, 2),
          x = _v[0],
          y = _v[1];

      var y2 = topLeft ? y : this.height - y;
      return xyz.length === 2 ? [x, y2] : [x, y2, 0];
    }

    /**
     * Unproject pixel coordinates on screen onto world coordinates,
     * (possibly [lon, lat]) on map.
     * - [x, y] => [lng, lat]
     * - [x, y, z] => [lng, lat, Z]
     * @param {Array} xyz -
     * @param {Object} opts - options
     * @param {Object} opts.topLeft=true - Whether origin is top left
     * @return {Array|null} - [lng, lat, Z] or [X, Y, Z]
     */

  }, {
    key: 'unproject',
    value: function unproject(xyz) {
      var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
          _ref2$topLeft = _ref2.topLeft,
          topLeft = _ref2$topLeft === undefined ? true : _ref2$topLeft;

      var _xyz2 = _slicedToArray(xyz, 3),
          x = _xyz2[0],
          y = _xyz2[1],
          _xyz2$ = _xyz2[2],
          targetZ = _xyz2$ === undefined ? 0 : _xyz2$;

      var y2 = topLeft ? y : this.height - y;

      // since we don't know the correct projected z value for the point,
      // unproject two points to get a line and then find the point on that line with z=0
      var coord0 = (0, _mathUtils.transformVector)(this.pixelUnprojectionMatrix, [x, y2, 0, 1]);
      var coord1 = (0, _mathUtils.transformVector)(this.pixelUnprojectionMatrix, [x, y2, 1, 1]);

      if (!coord0 || !coord1) {
        return null;
      }

      var z0 = coord0[2];
      var z1 = coord1[2];

      var t = z0 === z1 ? 0 : (targetZ - z0) / (z1 - z0);
      var v = (0, _lerp2.default)([], coord0, coord1, t);

      var vUnprojected = this.unprojectFlat(v);
      return xyz.length === 2 ? vUnprojected : [vUnprojected[0], vUnprojected[1], 0];
    }

    // NON_LINEAR PROJECTION HOOKS
    // Used for web meractor projection

    /**
     * Project [lng,lat] on sphere onto [x,y] on 512*512 Mercator Zoom 0 tile.
     * Performs the nonlinear part of the web mercator projection.
     * Remaining projection is done with 4x4 matrices which also handles
     * perspective.
     * @param {Array} lngLat - [lng, lat] coordinates
     *   Specifies a point on the sphere to project onto the map.
     * @return {Array} [x,y] coordinates.
     */

  }, {
    key: 'projectFlat',
    value: function projectFlat(_ref3) {
      var _ref4 = _slicedToArray(_ref3, 2),
          x = _ref4[0],
          y = _ref4[1];

      var scale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.scale;

      return this._projectFlat.apply(this, arguments);
    }

    /**
     * Unproject world point [x,y] on map onto {lat, lon} on sphere
     * @param {object|Vector} xy - object with {x,y} members
     *  representing point on projected map plane
     * @return {GeoCoordinates} - object with {lat,lon} of point on sphere.
     *   Has toArray method if you need a GeoJSON Array.
     *   Per cartographic tradition, lat and lon are specified as degrees.
     */

  }, {
    key: 'unprojectFlat',
    value: function unprojectFlat(xyz) {
      var scale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.scale;

      return this._unprojectFlat.apply(this, arguments);
    }

    // TODO - why do we need these?

  }, {
    key: '_projectFlat',
    value: function _projectFlat(xyz) {
      var scale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.scale;

      return xyz;
    }
  }, {
    key: '_unprojectFlat',
    value: function _unprojectFlat(xyz) {
      var scale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.scale;

      return xyz;
    }
  }, {
    key: 'getMercatorParams',
    value: function getMercatorParams() {
      var lngLat = this._addMetersToLngLat([this.longitude || 0, this.latitude || 0], this.meterOffset);
      return {
        longitude: lngLat[0],
        latitude: lngLat[1]
      };
    }
  }, {
    key: 'isMapSynched',
    value: function isMapSynched() {
      return false;
    }
  }, {
    key: 'getDistanceScales',
    value: function getDistanceScales() {
      var coordinateOrigin = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

      if (coordinateOrigin) {
        return (0, _viewportMercatorProject.getDistanceScales)({
          longitude: coordinateOrigin[0],
          latitude: coordinateOrigin[1],
          scale: this.scale,
          highPrecision: true
        });
      }
      return this.distanceScales;
    }
  }, {
    key: 'getMatrices',
    value: function getMatrices() {
      var _ref5 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref5$modelMatrix = _ref5.modelMatrix,
          modelMatrix = _ref5$modelMatrix === undefined ? null : _ref5$modelMatrix;

      var modelViewProjectionMatrix = this.viewProjectionMatrix;
      var pixelProjectionMatrix = this.pixelProjectionMatrix;
      var pixelUnprojectionMatrix = this.pixelUnprojectionMatrix;

      if (modelMatrix) {
        modelViewProjectionMatrix = (0, _multiply2.default)([], this.viewProjectionMatrix, modelMatrix);
        pixelProjectionMatrix = (0, _multiply2.default)([], this.pixelProjectionMatrix, modelMatrix);
        pixelUnprojectionMatrix = (0, _invert2.default)([], pixelProjectionMatrix);
      }

      var matrices = Object.assign({
        modelViewProjectionMatrix: modelViewProjectionMatrix,
        viewProjectionMatrix: this.viewProjectionMatrix,
        viewMatrix: this.viewMatrix,
        projectionMatrix: this.projectionMatrix,

        // project/unproject between pixels and world
        pixelProjectionMatrix: pixelProjectionMatrix,
        pixelUnprojectionMatrix: pixelUnprojectionMatrix,

        width: this.width,
        height: this.height,
        scale: this.scale
      });

      return matrices;
    }

    // EXPERIMENTAL METHODS

  }, {
    key: 'getCameraPosition',
    value: function getCameraPosition() {
      return this.cameraPosition;
    }
  }, {
    key: 'getCameraDirection',
    value: function getCameraDirection() {
      return this.cameraDirection;
    }
  }, {
    key: 'getCameraUp',
    value: function getCameraUp() {
      return this.cameraUp;
    }

    // TODO - these are duplicating WebMercator methods

  }, {
    key: '_addMetersToLngLat',
    value: function _addMetersToLngLat(lngLatZ, xyz) {
      var _lngLatZ = _slicedToArray(lngLatZ, 3),
          lng = _lngLatZ[0],
          lat = _lngLatZ[1],
          _lngLatZ$ = _lngLatZ[2],
          Z = _lngLatZ$ === undefined ? 0 : _lngLatZ$;

      var _metersToLngLatDelta2 = this._metersToLngLatDelta(xyz),
          _metersToLngLatDelta3 = _slicedToArray(_metersToLngLatDelta2, 3),
          deltaLng = _metersToLngLatDelta3[0],
          deltaLat = _metersToLngLatDelta3[1],
          _metersToLngLatDelta4 = _metersToLngLatDelta3[2],
          deltaZ = _metersToLngLatDelta4 === undefined ? 0 : _metersToLngLatDelta4;

      return lngLatZ.length === 2 ? [lng + deltaLng, lat + deltaLat] : [lng + deltaLng, lat + deltaLat, Z + deltaZ];
    }
  }, {
    key: '_metersToLngLatDelta',
    value: function _metersToLngLatDelta(xyz) {
      var _xyz3 = _slicedToArray(xyz, 3),
          x = _xyz3[0],
          y = _xyz3[1],
          _xyz3$ = _xyz3[2],
          z = _xyz3$ === undefined ? 0 : _xyz3$;

      (0, _assert2.default)(Number.isFinite(x) && Number.isFinite(y) && Number.isFinite(z), ERR_ARGUMENT);
      var _distanceScales = this.distanceScales,
          pixelsPerMeter = _distanceScales.pixelsPerMeter,
          degreesPerPixel = _distanceScales.degreesPerPixel;

      var deltaLng = x * pixelsPerMeter[0] * degreesPerPixel[0];
      var deltaLat = y * pixelsPerMeter[1] * degreesPerPixel[1];
      return xyz.length === 2 ? [deltaLng, deltaLat] : [deltaLng, deltaLat, z];
    }

    // INTERNAL METHODS

  }, {
    key: '_initMatrices',
    value: function _initMatrices() {
      // Note: As usual, matrix operations should be applied in "reverse" order
      // since vectors will be multiplied in from the right during transformation
      var vpm = (0, _mathUtils.createMat4)();
      (0, _multiply2.default)(vpm, vpm, this.projectionMatrix);
      (0, _multiply2.default)(vpm, vpm, this.viewMatrix);
      this.viewProjectionMatrix = vpm;

      // console.log('VPM', this.viewMatrix, this.projectionMatrix, this.viewProjectionMatrix);

      // Calculate inverse view matrix
      this.viewMatrixInverse = (0, _invert2.default)([], this.viewMatrix) || this.viewMatrix;

      // Decompose camera directions

      var _extractCameraVectors = (0, _mathUtils.extractCameraVectors)({
        viewMatrix: this.viewMatrix,
        viewMatrixInverse: this.viewMatrixInverse
      }),
          eye = _extractCameraVectors.eye,
          direction = _extractCameraVectors.direction,
          up = _extractCameraVectors.up;

      this.cameraPosition = eye;
      this.cameraDirection = direction;
      this.cameraUp = up;

      // console.log(this.cameraPosition, this.cameraDirection, this.cameraUp);

      /*
       * Builds matrices that converts preprojected lngLats to screen pixels
       * and vice versa.
       * Note: Currently returns bottom-left coordinates!
       * Note: Starts with the GL projection matrix and adds steps to the
       *       scale and translate that matrix onto the window.
       * Note: WebGL controls clip space to screen projection with gl.viewport
       *       and does not need this step.
       */

      // matrix for conversion from world location to screen (pixel) coordinates
      var m = (0, _mathUtils.createMat4)();
      (0, _scale2.default)(m, m, [this.width / 2, -this.height / 2, 1]);
      (0, _translate2.default)(m, m, [1, -1, 0]);
      (0, _multiply2.default)(m, m, this.viewProjectionMatrix);
      this.pixelProjectionMatrix = m;

      this.pixelUnprojectionMatrix = (0, _invert2.default)((0, _mathUtils.createMat4)(), this.pixelProjectionMatrix);
      if (!this.pixelUnprojectionMatrix) {
        _log2.default.warn('Pixel project matrix not invertible');
        // throw new Error('Pixel project matrix not invertible');
      }
    }
  }]);

  return Viewport;
}();

exports.default = Viewport;


Viewport.displayName = 'Viewport';
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9jb3JlL3ZpZXdwb3J0cy92aWV3cG9ydC5qcyJdLCJuYW1lcyI6WyJaRVJPX1ZFQ1RPUiIsIklERU5USVRZIiwiREVGQVVMVF9ESVNUQU5DRV9TQ0FMRVMiLCJwaXhlbHNQZXJNZXRlciIsIm1ldGVyc1BlclBpeGVsIiwicGl4ZWxzUGVyRGVncmVlIiwiZGVncmVlc1BlclBpeGVsIiwiREVGQVVMVF9aT09NIiwiRVJSX0FSR1VNRU5UIiwiVmlld3BvcnQiLCJvcHRzIiwiaWQiLCJ4IiwieSIsIndpZHRoIiwiaGVpZ2h0Iiwidmlld01hdHJpeCIsInByb2plY3Rpb25NYXRyaXgiLCJmb3Z5IiwibmVhciIsImZhciIsImxvbmdpdHVkZSIsImxhdGl0dWRlIiwiem9vbSIsInBvc2l0aW9uIiwibW9kZWxNYXRyaXgiLCJkaXN0YW5jZVNjYWxlcyIsImNvbnN0cnVjdG9yIiwiZGlzcGxheU5hbWUiLCJpc0dlb3NwYXRpYWwiLCJOdW1iZXIiLCJpc0Zpbml0ZSIsInNjYWxlIiwiTWF0aCIsInBvdyIsImZvY2FsRGlzdGFuY2UiLCJtZXRlck9mZnNldCIsInRyYW5zZm9ybVZlY3RvciIsInZpZXdNYXRyaXhVbmNlbnRlcmVkIiwiY2VudGVyIiwibXVsdGlwbHlSaWdodCIsInRyYW5zbGF0ZSIsIm5lZ2F0ZSIsIkRFR1JFRVNfVE9fUkFESUFOUyIsIlBJIiwiZm92eVJhZGlhbnMiLCJhc3BlY3QiLCJfaW5pdE1hdHJpY2VzIiwiZXF1YWxzIiwiYmluZCIsInByb2plY3QiLCJ1bnByb2plY3QiLCJwcm9qZWN0RmxhdCIsInVucHJvamVjdEZsYXQiLCJnZXRNYXRyaWNlcyIsInZpZXdwb3J0IiwieHl6IiwidG9wTGVmdCIsIngwIiwieTAiLCJ6MCIsIlgiLCJZIiwidiIsInBpeGVsUHJvamVjdGlvbk1hdHJpeCIsInkyIiwibGVuZ3RoIiwidGFyZ2V0WiIsImNvb3JkMCIsInBpeGVsVW5wcm9qZWN0aW9uTWF0cml4IiwiY29vcmQxIiwiejEiLCJ0IiwidlVucHJvamVjdGVkIiwiX3Byb2plY3RGbGF0IiwiYXJndW1lbnRzIiwiX3VucHJvamVjdEZsYXQiLCJsbmdMYXQiLCJfYWRkTWV0ZXJzVG9MbmdMYXQiLCJjb29yZGluYXRlT3JpZ2luIiwiaGlnaFByZWNpc2lvbiIsIm1vZGVsVmlld1Byb2plY3Rpb25NYXRyaXgiLCJ2aWV3UHJvamVjdGlvbk1hdHJpeCIsIm1hdHJpY2VzIiwiT2JqZWN0IiwiYXNzaWduIiwiY2FtZXJhUG9zaXRpb24iLCJjYW1lcmFEaXJlY3Rpb24iLCJjYW1lcmFVcCIsImxuZ0xhdFoiLCJsbmciLCJsYXQiLCJaIiwiX21ldGVyc1RvTG5nTGF0RGVsdGEiLCJkZWx0YUxuZyIsImRlbHRhTGF0IiwiZGVsdGFaIiwieiIsInZwbSIsInZpZXdNYXRyaXhJbnZlcnNlIiwiZXllIiwiZGlyZWN0aW9uIiwidXAiLCJtIiwid2FybiJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7cWpCQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7O0FBQ0E7O0FBRUE7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUVBOzs7O0FBSUE7O0FBRUE7Ozs7Ozs7O0FBSkEsSUFBTUEsY0FBYyxDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sQ0FBUCxDQUFwQjs7QUFNQSxJQUFNQyxXQUFXLDRCQUFqQjs7QUFFQSxJQUFNQywwQkFBMEI7QUFDOUJDLGtCQUFnQixDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sQ0FBUCxDQURjO0FBRTlCQyxrQkFBZ0IsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsQ0FGYztBQUc5QkMsbUJBQWlCLENBQUMsQ0FBRCxFQUFJLENBQUosRUFBTyxDQUFQLENBSGE7QUFJOUJDLG1CQUFpQixDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sQ0FBUDtBQUphLENBQWhDOztB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LEtBQUtLLHVCQUFWLEVBQW1DO0FBQ2pDLHNCQUFJbUMsSUFBSixDQUFTLHFDQUFUO0FBQ0E7QUFDRDtBQUNGOzs7Ozs7a0JBdlhrQi9GLFE7OztBQTBYckJBLFNBQVNtQixXQUFULEdBQXVCLFVBQXZCIiwiZmlsZSI6InZpZXdwb3J0LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSAyMDE1IC0gMjAxNyBVYmVyIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbi8vIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbi8vIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbi8vIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbi8vIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4vLyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4vLyBUSEUgU09GVFdBUkUuXG5cbmltcG9ydCBsb2cgZnJvbSAnLi4vdXRpbHMvbG9nJztcbmltcG9ydCB7dHJhbnNmb3JtVmVjdG9yLCBjcmVhdGVNYXQ0LCBleHRyYWN0Q2FtZXJhVmVjdG9yc30gZnJvbSAnLi4vdXRpbHMvbWF0aC11dGlscyc7XG5cbmltcG9ydCB7TWF0cml4NCwgVmVjdG9yMywgZXF1YWxzfSBmcm9tICdtYXRoLmdsJztcbmltcG9ydCBtYXQ0X3NjYWxlIGZyb20gJ2dsLW1hdDQvc2NhbGUnO1xuaW1wb3J0IG1hdDRfdHJhbnNsYXRlIGZyb20gJ2dsLW1hdDQvdHJhbnNsYXRlJztcbmltcG9ydCBtYXQ0X211bHRpcGx5IGZyb20gJ2dsLW1hdDQvbXVsdGlwbHknO1xuaW1wb3J0IG1hdDRfaW52ZXJ0IGZyb20gJ2dsLW1hdDQvaW52ZXJ0JztcbmltcG9ydCBtYXQ0X3BlcnNwZWN0aXZlIGZyb20gJ2dsLW1hdDQvcGVyc3BlY3RpdmUnO1xuXG5pbXBvcnQgdmVjMl9sZXJwIGZyb20gJ2dsLXZlYzIvbGVycCc7XG5cbmNvbnN0IFpFUk9fVkVDVE9SID0gWzAsIDAsIDBdO1xuXG5pbXBvcnQge2dldERpc3RhbmNlU2NhbGVzLCBnZXRXb3JsZFBvc2l0aW9uLCBnZXRNZXRlclpvb219IGZyb20gJ3ZpZXdwb3J0LW1lcmNhdG9yLXByb2plY3QnO1xuXG5pbXBvcnQgYXNzZXJ0IGZyb20gJ2Fzc2VydCc7XG5cbmNvbnN0IElERU5USVRZID0gY3JlYXRlTWF0NCgpO1xuXG5jb25zdCBERUZBVUxUX0RJU1RBTkNFX1NDQUxFUyA9IHtcbiAgcGl4ZWxzUGVyTWV0ZXI6IFsxLCAxLCAxXSxcbiAgbWV0ZXJzUGVyUGl4ZWw6IFsxLCAxLCAxXSxcbiAgcGl4ZWxzUGVyRGVncmVlOiBbMSwgMSwgMV0sXG4gIGRlZ3JlZXNQZXJQaXhlbDogWzEsIDEsIDFdXG59O1xuXG5jb25zdCBERUZBVUxUX1pPT00gPSAwO1xuXG5jb25zdCBFUlJfQVJHVU1FTlQgPSAnSWxsZWdhbCBhcmd1bWVudCB0byBWaWV3cG9ydCc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFZpZXdwb3J0IHtcbiAgLyoqXG4gICAqIEBjbGFzc2Rlc2NcbiAgICogTWFuYWdlcyBjb29yZGluYXRlIHN5c3RlbSB0cmFuc2Zvcm1hdGlvbnMgZm9yIGRlY2suZ2wuXG4gICAqXG4gICAqIE5vdGU6IFRoZSBWaWV3cG9ydCBpcyBpbW11dGFibGUgaW4gdGhlIHNlbnNlIHRoYXQgaXQgb25seSBoYXMgYWNjZXNzb3JzLlxuICAgKiBBIG5ldyB2aWV3cG9ydCBpbnN0YW5jZSBzaG91bGQgYmUgY3JlYXRlZCBpZiBhbnkgcGFyYW1ldGVycyBoYXZlIGNoYW5nZWQuXG4gICAqL1xuICAvKiBlc2xpbnQtZGlzYWJsZSBjb21wbGV4aXR5LCBtYXgtc3RhdGVtZW50cyAqL1xuICBjb25zdHJ1Y3RvcihvcHRzID0ge30pIHtcbiAgICBjb25zdCB7XG4gICAgICBpZCA9IG51bGwsXG5cbiAgICAgIC8vIFdpbmRvdyB3aWR0aC9oZWlnaHQgaW4gcGl4ZWxzIChmb3IgcGl4ZWwgcHJvamVjdGlvbilcbiAgICAgIHggPSAwLFxuICAgICAgeSA9IDAsXG4gICAgICB3aWR0aCA9IDEsXG4gICAgICBoZWlnaHQgPSAxLFxuXG4gICAgICAvLyB2aWV3IG1hdHJpeFxuICAgICAgdmlld01hdHJpeCA9IElERU5USVRZLFxuXG4gICAgICAvLyBQcm9qZWN0aW9uIG1hdHJpeFxuICAgICAgcHJvamVjdGlvbk1hdHJpeCA9IG51bGwsXG5cbiAgICAgIC8vIFBlcnNwZWN0aXZlIHByb2plY3Rpb24gbWF0cml4IHBhcmFtZXRlcnMsIHVzZWQgaWYgcHJvamVjdGlvbk1hdHJpeCBub3Qgc3VwcGxpZWRcbiAgICAgIGZvdnkgPSA3NSxcbiAgICAgIG5lYXIgPSAwLjEsIC8vIERpc3RhbmNlIG9mIG5lYXIgY2xpcHBpbmcgcGxhbmVcbiAgICAgIGZhciA9IDEwMDAsIC8vIERpc3RhbmNlIG9mIGZhciBjbGlwcGluZyBwbGFuZVxuXG4gICAgICAvLyBBbmNob3I6IGxuZyBsYXQgem9vbSB3aWxsIG1ha2UgdGhpcyB2aWV3cG9ydCB3b3JrIHdpdGggZ2Vvc3BhdGlhbCBjb29yZGluYXRlIHN5c3RlbXNcbiAgICAgIGxvbmdpdHVkZSA9IG51bGwsXG4gICAgICBsYXRpdHVkZSA9IG51bGwsXG4gICAgICB6b29tID0gbnVsbCxcblxuICAgICAgLy8gQW5jaG9yIHBvc2l0aW9uIG9mZnNldCAoaW4gbWV0ZXJzIGZvciBnZW9zcGF0aWFsIHZpZXdwb3J0cylcbiAgICAgIHBvc2l0aW9uID0gbnVsbCxcbiAgICAgIC8vIEEgbW9kZWwgbWF0cml4IHRvIGJlIGFwcGxpZWQgdG8gcG9zaXRpb24sIHRvIG1hdGNoIHRoZSBsYXllciBwcm9wcyBBUElcbiAgICAgIG1vZGVsTWF0cml4ID0gbnVsbCxcblxuICAgICAgZGlzdGFuY2VTY2FsZXMgPSBudWxsXG4gICAgfSA9IG9wdHM7XG5cbiAgICB0aGlzLmlkID0gaWQgfHwgdGhpcy5jb25zdHJ1Y3Rvci5kaXNwbGF5TmFtZSB8fCAndmlld3BvcnQnO1xuXG4gICAgLy8gQ2hlY2sgaWYgd2UgaGF2ZSBhIGdlb3NwYXRpYWwgYW5jaG9yXG4gICAgdGhpcy5pc0dlb3NwYXRpYWwgPSBOdW1iZXIuaXNGaW5pdGUobGF0aXR1ZGUpICYmIE51bWJlci5pc0Zpbml0ZShsb25naXR1ZGUpO1xuXG4gICAgLy8gU2lsZW50bHkgYWxsb3cgYXBwcyB0byBzZW5kIGluIHcsaCA9IDAsMFxuICAgIHRoaXMueCA9IHg7XG4gICAgdGhpcy55ID0geTtcbiAgICB0aGlzLndpZHRoID0gd2lkdGggfHwgMTtcbiAgICB0aGlzLmhlaWdodCA9IGhlaWdodCB8fCAxO1xuXG4gICAgdGhpcy56b29tID0gem9vbTtcbiAgICBpZiAoIU51bWJlci5pc0Zpbml0ZSh0aGlzLnpvb20pKSB7XG4gICAgICB0aGlzLnpvb20gPSB0aGlzLmlzR2Vvc3BhdGlhbCA/IGdldE1ldGVyWm9vbSh7bGF0aXR1ZGV9KSA6IERFRkFVTFRfWk9PTTtcbiAgICB9XG4gICAgdGhpcy5zY2FsZSA9IE1hdGgucG93KDIsIHRoaXMuem9vbSk7XG5cbiAgICAvLyBDYWxjdWxhdGUgZGlzdGFuY2Ugc2NhbGVzIGlmIGxuZy9sYXQvem9vbSBhcmUgcHJvdmlkZWRcbiAgICB0aGlzLmRpc3RhbmNlU2NhbGVzID0gdGhpcy5pc0dlb3NwYXRpYWxcbiAgICAgID8gZ2V0RGlzdGFuY2VTY2FsZXMoe2xhdGl0dWRlLCBsb25naXR1ZGUsIHNjYWxlOiB0aGlzLnNjYWxlfSlcbiAgICAgIDogZGlzdGFuY2VTY2FsZXMgfHwgREVGQVVMVF9ESVNUQU5DRV9TQ0FMRVM7XG5cbiAgICB0aGlzLmZvY2FsRGlzdGFuY2UgPSBvcHRzLmZvY2FsRGlzdGFuY2UgfHwgMTtcblxuICAgIHRoaXMuZGlzdGFuY2VTY2FsZXMubWV0ZXJzUGVyUGl4ZWwgPSBuZXcgVmVjdG9yMyh0aGlzLmRpc3RhbmNlU2NhbGVzLm1ldGVyc1BlclBpeGVsKTtcbiAgICB0aGlzLmRpc3RhbmNlU2NhbGVzLnBpeGVsc1Blck1ldGVyID0gbmV3IFZlY3RvcjModGhpcy5kaXN0YW5jZVNjYWxlcy5waXhlbHNQZXJNZXRlcik7XG5cbiAgICB0aGlzLnBvc2l0aW9uID0gWkVST19WRUNUT1I7XG4gICAgdGhpcy5tZXRlck9mZnNldCA9IFpFUk9fVkVDVE9SO1xuICAgIGlmIChwb3NpdGlvbikge1xuICAgICAgLy8gQXBwbHkgbW9kZWwgbWF0cml4IGlmIHN1cHBsaWVkXG4gICAgICB0aGlzLnBvc2l0aW9uID0gcG9zaXRpb247XG4gICAgICB0aGlzLm1vZGVsTWF0cml4ID0gbW9kZWxNYXRyaXg7XG4gICAgICB0aGlzLm1ldGVyT2Zmc2V0ID0gbW9kZWxNYXRyaXggPyBtb2RlbE1hdHJpeC50cmFuc2Zvcm1WZWN0b3IocG9zaXRpb24pIDogcG9zaXRpb247XG4gICAgfVxuXG4gICAgdGhpcy52aWV3TWF0cml4VW5jZW50ZXJlZCA9IHZpZXdNYXRyaXg7XG5cbiAgICBpZiAodGhpcy5pc0dlb3NwYXRpYWwpIHtcbiAgICAgIC8vIERldGVybWluZSBjYW1lcmEgY2VudGVyXG4gICAgICB0aGlzLmNlbnRlciA9IGdldFdvcmxkUG9zaXRpb24oe1xuICAgICAgICBsb25naXR1ZGUsXG4gICAgICAgIGxhdGl0dWRlLFxuICAgICAgICB6b29tOiB0aGlzLnpvb20sXG4gICAgICAgIG1ldGVyT2Zmc2V0OiB0aGlzLm1ldGVyT2Zmc2V0XG4gICAgICB9KTtcblxuICAgICAgLy8gTWFrZSBhIGNlbnRlcmVkIHZlcnNpb24gb2YgdGhlIG1hdHJpeCBmb3IgcHJvamVjdGlvbiBtb2RlcyB3aXRob3V0IGFuIG9mZnNldFxuICAgICAgdGhpcy52aWV3TWF0cml4ID0gbmV3IE1hdHJpeDQoKVxuICAgICAgICAvLyBBcHBseSB0aGUgdW5jZW50ZXJlZCB2aWV3IG1hdHJpeFxuICAgICAgICAubXVsdGlwbHlSaWdodCh0aGlzLnZpZXdNYXRyaXhVbmNlbnRlcmVkKVxuICAgICAgICAvLyBUaGUgTWVyY2F0b3Igd29ybGQgY29vcmRpbmF0ZSBzeXN0ZW0gaXMgdXBwZXIgbGVmdCxcbiAgICAgICAgLy8gYnV0IEdMIGV4cGVjdHMgbG93ZXIgbGVmdCwgc28gd2UgZmxpcCBpdCBhcm91bmQgdGhlIGNlbnRlciBhZnRlciBhbGwgdHJhbnNmb3JtcyBhcmUgZG9uZVxuICAgICAgICAuc2NhbGUoWzEsIC0xLCAxXSlcbiAgICAgICAgLy8gQW5kIGNlbnRlciBpdFxuICAgICAgICAudHJhbnNsYXRlKG5ldyBWZWN0b3IzKHRoaXMuY2VudGVyIHx8IFpFUk9fVkVDVE9SKS5uZWdhdGUoKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY2VudGVyID0gcG9zaXRpb247XG4gICAgICB0aGlzLnZpZXdNYXRyaXggPSB2aWV3TWF0cml4O1xuICAgIH1cblxuICAgIC8vIENyZWF0ZSBhIHByb2plY3Rpb24gbWF0cml4IGlmIG5vdCBzdXBwbGllZFxuICAgIGlmIChwcm9qZWN0aW9uTWF0cml4KSB7XG4gICAgICB0aGlzLnByb2plY3Rpb25NYXRyaXggPSBwcm9qZWN0aW9uTWF0cml4O1xuICAgIH0gZWxzZSB7XG4gICAgICBhc3NlcnQoTnVtYmVyLmlzRmluaXRlKGZvdnkpKTtcbiAgICAgIGNvbnN0IERFR1JFRVNfVE9fUkFESUFOUyA9IE1hdGguUEkgLyAxODA7XG4gICAgICBjb25zdCBmb3Z5UmFkaWFucyA9IGZvdnkgKiBERUdSRUVTX1RPX1JBRElBTlM7XG4gICAgICBjb25zdCBhc3BlY3QgPSB0aGlzLndpZHRoIC8gdGhpcy5oZWlnaHQ7XG4gICAgICB0aGlzLnByb2plY3Rpb25NYXRyaXggPSBtYXQ0X3BlcnNwZWN0aXZlKFtdLCBmb3Z5UmFkaWFucywgYXNwZWN0LCBuZWFyLCBmYXIpO1xuICAgIH1cblxuICAgIC8vIEluaXQgcGl4ZWwgbWF0cmljZXNcbiAgICB0aGlzLl9pbml0TWF0cmljZXMoKTtcblxuICAgIC8vIEJpbmQgbWV0aG9kcyBmb3IgZWFzeSBhY2Nlc3NcbiAgICB0aGlzLmVxdWFscyA9IHRoaXMuZXF1YWxzLmJpbmQodGhpcyk7XG4gICAgdGhpcy5wcm9qZWN0ID0gdGhpcy5wcm9qZWN0LmJpbmQodGhpcyk7XG4gICAgdGhpcy51bnByb2plY3QgPSB0aGlzLnVucHJvamVjdC5iaW5kKHRoaXMpO1xuICAgIHRoaXMucHJvamVjdEZsYXQgPSB0aGlzLnByb2plY3RGbGF0LmJpbmQodGhpcyk7XG4gICAgdGhpcy51bnByb2plY3RGbGF0ID0gdGhpcy51bnByb2plY3RGbGF0LmJpbmQodGhpcyk7XG4gICAgdGhpcy5nZXRNYXRyaWNlcyA9IHRoaXMuZ2V0TWF0cmljZXMuYmluZCh0aGlzKTtcbiAgfVxuICAvKiBlc2xpbnQtZW5hYmxlIGNvbXBsZXhpdHksIG1heC1zdGF0ZW1lbnRzICovXG5cbiAgLy8gVHdvIHZpZXdwb3J0cyBhcmUgZXF1YWwgaWYgd2lkdGggYW5kIGhlaWdodCBhcmUgaWRlbnRpY2FsLCBhbmQgaWZcbiAgLy8gdGhlaXIgdmlldyBhbmQgcHJvamVjdGlvbiBtYXRyaWNlcyBhcmUgKGFwcHJveGltYXRlbHkpIGVxdWFsLlxuICBlcXVhbHModmlld3BvcnQpIHtcbiAgICBpZiAoISh2aWV3cG9ydCBpbnN0YW5jZW9mIFZpZXdwb3J0KSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiAoXG4gICAgICB2aWV3cG9ydC53aWR0aCA9PT0gdGhpcy53aWR0aCAmJlxuICAgICAgdmlld3BvcnQuaGVpZ2h0ID09PSB0aGlzLmhlaWdodCAmJlxuICAgICAgZXF1YWxzKHZpZXdwb3J0LnByb2plY3Rpb25NYXRyaXgsIHRoaXMucHJvamVjdGlvbk1hdHJpeCkgJiZcbiAgICAgIGVxdWFscyh2aWV3cG9ydC52aWV3TWF0cml4LCB0aGlzLnZpZXdNYXRyaXgpXG4gICAgKTtcbiAgICAvLyBUT0RPIC0gY2hlY2sgZGlzdGFuY2Ugc2NhbGVzP1xuICB9XG5cbiAgLyoqXG4gICAqIFByb2plY3RzIHh5eiAocG9zc2libHkgbGF0aXR1ZGUgYW5kIGxvbmdpdHVkZSkgdG8gcGl4ZWwgY29vcmRpbmF0ZXMgaW4gd2luZG93XG4gICAqIHVzaW5nIHZpZXdwb3J0IHByb2plY3Rpb24gcGFyYW1ldGVyc1xuICAgKiAtIFtsb25naXR1ZGUsIGxhdGl0dWRlXSB0byBbeCwgeV1cbiAgICogLSBbbG9uZ2l0dWRlLCBsYXRpdHVkZSwgWl0gPT4gW3gsIHksIHpdXG4gICAqIE5vdGU6IEJ5IGRlZmF1bHQsIHJldHVybnMgdG9wLWxlZnQgY29vcmRpbmF0ZXMgZm9yIGNhbnZhcy9TVkcgdHlwZSByZW5kZXJcbiAgICpcbiAgICogQHBhcmFtIHtBcnJheX0gbG5nTGF0WiAtIFtsbmcsIGxhdF0gb3IgW2xuZywgbGF0LCBaXVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMudG9wTGVmdD10cnVlIC0gV2hldGhlciBwcm9qZWN0ZWQgY29vcmRzIGFyZSB0b3AgbGVmdFxuICAgKiBAcmV0dXJuIHtBcnJheX0gLSBbeCwgeV0gb3IgW3gsIHksIHpdIGluIHRvcCBsZWZ0IGNvb3Jkc1xuICAgKi9cbiAgcHJvamVjdCh4eXosIHt0b3BMZWZ0ID0gdHJ1ZX0gPSB7fSkge1xuICAgIGNvbnN0IFt4MCwgeTAsIHowID0gMF0gPSB4eXo7XG4gICAgYXNzZXJ0KE51bWJlci5pc0Zpbml0ZSh4MCkgJiYgTnVtYmVyLmlzRmluaXRlKHkwKSAmJiBOdW1iZXIuaXNGaW5pdGUoejApLCBFUlJfQVJHVU1FTlQpO1xuXG4gICAgY29uc3QgW1gsIFldID0gdGhpcy5wcm9qZWN0RmxhdChbeDAsIHkwXSk7XG4gICAgY29uc3QgdiA9IHRyYW5zZm9ybVZlY3Rvcih0aGlzLnBpeGVsUHJvamVjdGlvbk1hdHJpeCwgW1gsIFksIHowLCAxXSk7XG5cbiAgICBjb25zdCBbeCwgeV0gPSB2O1xuICAgIGNvbnN0IHkyID0gdG9wTGVmdCA/IHkgOiB0aGlzLmhlaWdodCAtIHk7XG4gICAgcmV0dXJuIHh5ei5sZW5ndGggPT09IDIgPyBbeCwgeTJdIDogW3gsIHkyLCAwXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVbnByb2plY3QgcGl4ZWwgY29vcmRpbmF0ZXMgb24gc2NyZWVuIG9udG8gd29ybGQgY29vcmRpbmF0ZXMsXG4gICAqIChwb3NzaWJseSBbbG9uLCBsYXRdKSBvbiBtYXAuXG4gICAqIC0gW3gsIHldID0+IFtsbmcsIGxhdF1cbiAgICogLSBbeCwgeSwgel0gPT4gW2xuZywgbGF0LCBaXVxuICAgKiBAcGFyYW0ge0FycmF5fSB4eXogLVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMudG9wTGVmdD10cnVlIC0gV2hldGhlciBvcmlnaW4gaXMgdG9wIGxlZnRcbiAgICogQHJldHVybiB7QXJyYXl8bnVsbH0gLSBbbG5nLCBsYXQsIFpdIG9yIFtYLCBZLCBaXVxuICAgKi9cbiAgdW5wcm9qZWN0KHh5eiwge3RvcExlZnQgPSB0cnVlfSA9IHt9KSB7XG4gICAgY29uc3QgW3gsIHksIHRhcmdldFogPSAwXSA9IHh5ejtcblxuICAgIGNvbnN0IHkyID0gdG9wTGVmdCA/IHkgOiB0aGlzLmhlaWdodCAtIHk7XG5cbiAgICAvLyBzaW5jZSB3ZSBkb24ndCBrbm93IHRoZSBjb3JyZWN0IHByb2plY3RlZCB6IHZhbHVlIGZvciB0aGUgcG9pbnQsXG4gICAgLy8gdW5wcm9qZWN0IHR3byBwb2ludHMgdG8gZ2V0IGEgbGluZSBhbmQgdGhlbiBmaW5kIHRoZSBwb2ludCBvbiB0aGF0IGxpbmUgd2l0aCB6PTBcbiAgICBjb25zdCBjb29yZDAgPSB0cmFuc2Zvcm1WZWN0b3IodGhpcy5waXhlbFVucHJvamVjdGlvbk1hdHJpeCwgW3gsIHkyLCAwLCAxXSk7XG4gICAgY29uc3QgY29vcmQxID0gdHJhbnNmb3JtVmVjdG9yKHRoaXMucGl4ZWxVbnByb2plY3Rpb25NYXRyaXgsIFt4LCB5MiwgMSwgMV0pO1xuXG4gICAgaWYgKCFjb29yZDAgfHwgIWNvb3JkMSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgY29uc3QgejAgPSBjb29yZDBbMl07XG4gICAgY29uc3QgejEgPSBjb29yZDFbMl07XG5cbiAgICBjb25zdCB0ID0gejAgPT09IHoxID8gMCA6ICh0YXJnZXRaIC0gejApIC8gKHoxIC0gejApO1xuICAgIGNvbnN0IHYgPSB2ZWMyX2xlcnAoW10sIGNvb3JkMCwgY29vcmQxLCB0KTtcblxuICAgIGNvbnN0IHZVbnByb2plY3RlZCA9IHRoaXMudW5wcm9qZWN0RmxhdCh2KTtcbiAgICByZXR1cm4geHl6Lmxlbmd0aCA9PT0gMiA/IHZVbnByb2plY3RlZCA6IFt2VW5wcm9qZWN0ZWRbMF0sIHZVbnByb2plY3RlZFsxXSwgMF07XG4gIH1cblxuICAvLyBOT05fTElORUFSIFBST0pFQ1RJT04gSE9PS1NcbiAgLy8gVXNlZCBmb3Igd2ViIG1lcmFjdG9yIHByb2plY3Rpb25cblxuICAvKipcbiAgICogUHJvamVjdCBbbG5nLGxhdF0gb24gc3BoZXJlIG9udG8gW3gseV0gb24gNTEyKjUxMiBNZXJjYXRvciBab29tIDAgdGlsZS5cbiAgICogUGVyZm9ybXMgdGhlIG5vbmxpbmVhciBwYXJ0IG9mIHRoZSB3ZWIgbWVyY2F0b3IgcHJvamVjdGlvbi5cbiAgICogUmVtYWluaW5nIHByb2plY3Rpb24gaXMgZG9uZSB3aXRoIDR4NCBtYXRyaWNlcyB3aGljaCBhbHNvIGhhbmRsZXNcbiAgICogcGVyc3BlY3RpdmUuXG4gICAqIEBwYXJhbSB7QXJyYXl9IGxuZ0xhdCAtIFtsbmcsIGxhdF0gY29vcmRpbmF0ZXNcbiAgICogICBTcGVjaWZpZXMgYSBwb2ludCBvbiB0aGUgc3BoZXJlIHRvIHByb2plY3Qgb250byB0aGUgbWFwLlxuICAgKiBAcmV0dXJuIHtBcnJheX0gW3gseV0gY29vcmRpbmF0ZXMuXG4gICAqL1xuICBwcm9qZWN0RmxhdChbeCwgeV0sIHNjYWxlID0gdGhpcy5zY2FsZSkge1xuICAgIHJldHVybiB0aGlzLl9wcm9qZWN0RmxhdCguLi5hcmd1bWVudHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFVucHJvamVjdCB3b3JsZCBwb2ludCBbeCx5XSBvbiBtYXAgb250byB7bGF0LCBsb259IG9uIHNwaGVyZVxuICAgKiBAcGFyYW0ge29iamVjdHxWZWN0b3J9IHh5IC0gb2JqZWN0IHdpdGgge3gseX0gbWVtYmVyc1xuICAgKiAgcmVwcmVzZW50aW5nIHBvaW50IG9uIHByb2plY3RlZCBtYXAgcGxhbmVcbiAgICogQHJldHVybiB7R2VvQ29vcmRpbmF0ZXN9IC0gb2JqZWN0IHdpdGgge2xhdCxsb259IG9mIHBvaW50IG9uIHNwaGVyZS5cbiAgICogICBIYXMgdG9BcnJheSBtZXRob2QgaWYgeW91IG5lZWQgYSBHZW9KU09OIEFycmF5LlxuICAgKiAgIFBlciBjYXJ0b2dyYXBoaWMgdHJhZGl0aW9uLCBsYXQgYW5kIGxvbiBhcmUgc3BlY2lmaWVkIGFzIGRlZ3JlZXMuXG4gICAqL1xuICB1bnByb2plY3RGbGF0KHh5eiwgc2NhbGUgPSB0aGlzLnNjYWxlKSB7XG4gICAgcmV0dXJuIHRoaXMuX3VucHJvamVjdEZsYXQoLi4uYXJndW1lbnRzKTtcbiAgfVxuXG4gIC8vIFRPRE8gLSB3aHkgZG8gd2UgbmVlZCB0aGVzZT9cbiAgX3Byb2plY3RGbGF0KHh5eiwgc2NhbGUgPSB0aGlzLnNjYWxlKSB7XG4gICAgcmV0dXJuIHh5ejtcbiAgfVxuXG4gIF91bnByb2plY3RGbGF0KHh5eiwgc2NhbGUgPSB0aGlzLnNjYWxlKSB7XG4gICAgcmV0dXJuIHh5ejtcbiAgfVxuXG4gIGdldE1lcmNhdG9yUGFyYW1zKCkge1xuICAgIGNvbnN0IGxuZ0xhdCA9IHRoaXMuX2FkZE1ldGVyc1RvTG5nTGF0KFxuICAgICAgW3RoaXMubG9uZ2l0dWRlIHx8IDAsIHRoaXMubGF0aXR1ZGUgfHwgMF0sXG4gICAgICB0aGlzLm1ldGVyT2Zmc2V0XG4gICAgKTtcbiAgICByZXR1cm4ge1xuICAgICAgbG9uZ2l0dWRlOiBsbmdMYXRbMF0sXG4gICAgICBsYXRpdHVkZTogbG5nTGF0WzFdXG4gICAgfTtcbiAgfVxuXG4gIGlzTWFwU3luY2hlZCgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBnZXREaXN0YW5jZVNjYWxlcyhjb29yZGluYXRlT3JpZ2luID0gbnVsbCkge1xuICAgIGlmIChjb29yZGluYXRlT3JpZ2luKSB7XG4gICAgICByZXR1cm4gZ2V0RGlzdGFuY2VTY2FsZXMoe1xuICAgICAgICBsb25naXR1ZGU6IGNvb3JkaW5hdGVPcmlnaW5bMF0sXG4gICAgICAgIGxhdGl0dWRlOiBjb29yZGluYXRlT3JpZ2luWzFdLFxuICAgICAgICBzY2FsZTogdGhpcy5zY2FsZSxcbiAgICAgICAgaGlnaFByZWNpc2lvbjogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmRpc3RhbmNlU2NhbGVzO1xuICB9XG5cbiAgZ2V0TWF0cmljZXMoe21vZGVsTWF0cml4ID0gbnVsbH0gPSB7fSkge1xuICAgIGxldCBtb2RlbFZpZXdQcm9qZWN0aW9uTWF0cml4ID0gdGhpcy52aWV3UHJvamVjdGlvbk1hdHJpeDtcbiAgICBsZXQgcGl4ZWxQcm9qZWN0aW9uTWF0cml4ID0gdGhpcy5waXhlbFByb2plY3Rpb25NYXRyaXg7XG4gICAgbGV0IHBpeGVsVW5wcm9qZWN0aW9uTWF0cml4ID0gdGhpcy5waXhlbFVucHJvamVjdGlvbk1hdHJpeDtcblxuICAgIGlmIChtb2RlbE1hdHJpeCkge1xuICAgICAgbW9kZWxWaWV3UHJvamVjdGlvbk1hdHJpeCA9IG1hdDRfbXVsdGlwbHkoW10sIHRoaXMudmlld1Byb2plY3Rpb25NYXRyaXgsIG1vZGVsTWF0cml4KTtcbiAgICAgIHBpeGVsUHJvamVjdGlvbk1hdHJpeCA9IG1hdDRfbXVsdGlwbHkoW10sIHRoaXMucGl4ZWxQcm9qZWN0aW9uTWF0cml4LCBtb2RlbE1hdHJpeCk7XG4gICAgICBwaXhlbFVucHJvamVjdGlvbk1hdHJpeCA9IG1hdDRfaW52ZXJ0KFtdLCBwaXhlbFByb2plY3Rpb25NYXRyaXgpO1xuICAgIH1cblxuICAgIGNvbnN0IG1hdHJpY2VzID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICBtb2RlbFZpZXdQcm9qZWN0aW9uTWF0cml4LFxuICAgICAgdmlld1Byb2plY3Rpb25NYXRyaXg6IHRoaXMudmlld1Byb2plY3Rpb25NYXRyaXgsXG4gICAgICB2aWV3TWF0cml4OiB0aGlzLnZpZXdNYXRyaXgsXG4gICAgICBwcm9qZWN0aW9uTWF0cml4OiB0aGlzLnByb2plY3Rpb25NYXRyaXgsXG5cbiAgICAgIC8vIHByb2plY3QvdW5wcm9qZWN0IGJldHdlZW4gcGl4ZWxzIGFuZCB3b3JsZFxuICAgICAgcGl4ZWxQcm9qZWN0aW9uTWF0cml4LFxuICAgICAgcGl4ZWxVbnByb2plY3Rpb25NYXRyaXgsXG5cbiAgICAgIHdpZHRoOiB0aGlzLndpZHRoLFxuICAgICAgaGVpZ2h0OiB0aGlzLmhlaWdodCxcbiAgICAgIHNjYWxlOiB0aGlzLnNjYWxlXG4gICAgfSk7XG5cbiAgICByZXR1cm4gbWF0cmljZXM7XG4gIH1cblxuICAvLyBFWFBFUklNRU5UQUwgTUVUSE9EU1xuXG4gIGdldENhbWVyYVBvc2l0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmNhbWVyYVBvc2l0aW9uO1xuICB9XG5cbiAgZ2V0Q2FtZXJhRGlyZWN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmNhbWVyYURpcmVjdGlvbjtcbiAgfVxuXG4gIGdldENhbWVyYVVwKCkge1xuICAgIHJldHVybiB0aGlzLmNhbWVyYVVwO1xuICB9XG5cbiAgLy8gVE9ETyAtIHRoZXNlIGFyZSBkdXBsaWNhdGluZyBXZWJNZXJjYXRvciBtZXRob2RzXG4gIF9hZGRNZXRlcnNUb0xuZ0xhdChsbmdMYXRaLCB4eXopIHtcbiAgICBjb25zdCBbbG5nLCBsYXQsIFogPSAwXSA9IGxuZ0xhdFo7XG4gICAgY29uc3QgW2RlbHRhTG5nLCBkZWx0YUxhdCwgZGVsdGFaID0gMF0gPSB0aGlzLl9tZXRlcnNUb0xuZ0xhdERlbHRhKHh5eik7XG4gICAgcmV0dXJuIGxuZ0xhdFoubGVuZ3RoID09PSAyXG4gICAgICA/IFtsbmcgKyBkZWx0YUxuZywgbGF0ICsgZGVsdGFMYXRdXG4gICAgICA6IFtsbmcgKyBkZWx0YUxuZywgbGF0ICsgZGVsdGFMYXQsIFogKyBkZWx0YVpdO1xuICB9XG5cbiAgX21ldGVyc1RvTG5nTGF0RGVsdGEoeHl6KSB7XG4gICAgY29uc3QgW3gsIHksIHogPSAwXSA9IHh5ejtcbiAgICBhc3NlcnQoTnVtYmVyLmlzRmluaXRlKHgpICYmIE51bWJlci5pc0Zpbml0ZSh5KSAmJiBOdW1iZXIuaXNGaW5pdGUoeiksIEVSUl9BUkdVTUVOVCk7XG4gICAgY29uc3Qge3BpeGVsc1Blck1ldGVyLCBkZWdyZWVzUGVyUGl4ZWx9ID0gdGhpcy5kaXN0YW5jZVNjYWxlcztcbiAgICBjb25zdCBkZWx0YUxuZyA9IHggKiBwaXhlbHNQZXJNZXRlclswXSAqIGRlZ3JlZXNQZXJQaXhlbFswXTtcbiAgICBjb25zdCBkZWx0YUxhdCA9IHkgKiBwaXhlbHNQZXJNZXRlclsxXSAqIGRlZ3JlZXNQZXJQaXhlbFsxXTtcbiAgICByZXR1cm4geHl6Lmxlbmd0aCA9PT0gMiA/IFtkZWx0YUxuZywgZGVsdGFMYXRdIDogW2RlbHRhTG5nLCBkZWx0YUxhdCwgel07XG4gIH1cblxuICAvLyBJTlRFUk5BTCBNRVRIT0RTXG5cbiAgX2luaXRNYXRyaWNlcygpIHtcbiAgICAvLyBOb3RlOiBBcyB1c3VhbCwgbWF0cml4IG9wZXJhdGlvbnMgc2hvdWxkIGJlIGFwcGxpZWQgaW4gXCJyZXZlcnNlXCIgb3JkZXJcbiAgICAvLyBzaW5jZSB2ZWN0b3JzIHdpbGwgYmUgbXVsdGlwbGllZCBpbiBmcm9tIHRoZSByaWdodCBkdXJpbmcgdHJhbnNmb3JtYXRpb25cbiAgICBjb25zdCB2cG0gPSBjcmVhdGVNYXQ0KCk7XG4gICAgbWF0NF9tdWx0aXBseSh2cG0sIHZwbSwgdGhpcy5wcm9qZWN0aW9uTWF0cml4KTtcbiAgICBtYXQ0X211bHRpcGx5KHZwbSwgdnBtLCB0aGlzLnZpZXdNYXRyaXgpO1xuICAgIHRoaXMudmlld1Byb2plY3Rpb25NYXRyaXggPSB2cG07XG5cbiAgICAvLyBjb25zb2xlLmxvZygnVlBNJywgdGhpcy52aWV3TWF0cml4LCB0aGlzLnByb2plY3Rpb25NYXRyaXgsIHRoaXMudmlld1Byb2plY3Rpb25NYXRyaXgpO1xuXG4gICAgLy8gQ2FsY3VsYXRlIGludmVyc2UgdmlldyBtYXRyaXhcbiAgICB0aGlzLnZpZXdNYXRyaXhJbnZlcnNlID0gbWF0NF9pbnZlcnQoW10sIHRoaXMudmlld01hdHJpeCkgfHwgdGhpcy52aWV3TWF0cml4O1xuXG4gICAgLy8gRGVjb21wb3NlIGNhbWVyYSBkaXJlY3Rpb25zXG4gICAgY29uc3Qge2V5ZSwgZGlyZWN0aW9uLCB1cH0gPSBleHRyYWN0Q2FtZXJhVmVjdG9ycyh7XG4gICAgICB2aWV3TWF0cml4OiB0aGlzLnZpZXdNYXRyaXgsXG4gICAgICB2aWV3TWF0cml4SW52ZXJzZTogdGhpcy52aWV3TWF0cml4SW52ZXJzZVxuICAgIH0pO1xuICAgIHRoaXMuY2FtZXJhUG9zaXRpb24gPSBleWU7XG4gICAgdGhpcy5jYW1lcmFEaXJlY3Rpb24gPSBkaXJlY3Rpb247XG4gICAgdGhpcy5jYW1lcmFVcCA9IHVwO1xuXG4gICAgLy8gY29uc29sZS5sb2codGhpcy5jYW1lcmFQb3NpdGlvbiwgdGhpcy5jYW1lcmFEaXJlY3Rpb24sIHRoaXMuY2FtZXJhVXApO1xuXG4gICAgLypcbiAgICAgKiBCdWlsZHMgbWF0cmljZXMgdGhhdCBjb252ZXJ0cyBwcmVwcm9qZWN0ZWQgbG5nTGF0cyB0byBzY3JlZW4gcGl4ZWxzXG4gICAgICogYW5kIHZpY2UgdmVyc2EuXG4gICAgICogTm90ZTogQ3VycmVudGx5IHJldHVybnMgYm90dG9tLWxlZnQgY29vcmRpbmF0ZXMhXG4gICAgICogTm90ZTogU3RhcnRzIHdpdGggdGhlIEdMIHByb2plY3Rpb24gbWF0cml4IGFuZCBhZGRzIHN0ZXBzIHRvIHRoZVxuICAgICAqICAgICAgIHNjYWxlIGFuZCB0cmFuc2xhdGUgdGhhdCBtYXRyaXggb250byB0aGUgd2luZG93LlxuICAgICAqIE5vdGU6IFdlYkdMIGNvbnRyb2xzIGNsaXAgc3BhY2UgdG8gc2NyZWVuIHByb2plY3Rpb24gd2l0aCBnbC52aWV3cG9ydFxuICAgICAqICAgICAgIGFuZCBkb2VzIG5vdCBuZWVkIHRoaXMgc3RlcC5cbiAgICAgKi9cblxuICAgIC8vIG1hdHJpeCBmb3IgY29udmVyc2lvbiBmcm9tIHdvcmxkIGxvY2F0aW9uIHRvIHNjcmVlbiAocGl4ZWwpIGNvb3JkaW5hdGVzXG4gICAgY29uc3QgbSA9IGNyZWF0ZU1hdDQoKTtcbiAgICBtYXQ0X3NjYWxlKG0sIG0sIFt0aGlzLndpZHRoIC8gMiwgLXRoaXMuaGVpZ2h0IC8gMiwgMV0pO1xuICAgIG1hdDRfdHJhbnNsYXRlKG0sIG0sIFsxLCAtMSwgMF0pO1xuICAgIG1hdDRfbXVsdGlwbHkobSwgbSwgdGhpcy52aWV3UHJvamVjdGlvbk1hdHJpeCk7XG4gICAgdGhpcy5waXhlbFByb2plY3Rpb25NYXRyaXggPSBtO1xuXG4gICAgdGhpcy5waXhlbFVucHJvamVjdGlvbk1hdHJpeCA9IG1hdDRfaW52ZXJ0KGNyZWF0ZU1hdDQoKSwgdGhpcy5waXhlbFByb2plY3Rpb25NYXRyaXgpO1xuICAgIGlmICghdGhpcy5waXhlbFVucHJvamVjdGlvbk1hdHJpeCkge1xuICAgICAgbG9nLndhcm4oJ1BpeGVsIHByb2plY3QgbWF0cml4IG5vdCBpbnZlcnRpYmxlJyk7XG4gICAgICAvLyB0aHJvdyBuZXcgRXJyb3IoJ1BpeGVsIHByb2plY3QgbWF0cml4IG5vdCBpbnZlcnRpYmxlJyk7XG4gICAgfVxuICB9XG59XG5cblZpZXdwb3J0LmRpc3BsYXlOYW1lID0gJ1ZpZXdwb3J0JztcbiJdfQ==