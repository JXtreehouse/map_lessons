'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MAPBOX_LIMITS = undefined;

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _viewState = require('./view-state');

var _viewState2 = _interopRequireDefault(_viewState);

var _webMercatorViewport = require('../viewports/web-mercator-viewport');

var _webMercatorViewport2 = _interopRequireDefault(_webMercatorViewport);

var _assert = require('assert');

var _assert2 = _interopRequireDefault(_assert);

var _mathUtils = require('../utils/math-utils');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

// MAPBOX LIMITS
var MAPBOX_LIMITS = exports.MAPBOX_LIMITS = {
  minZoom: 0,
  maxZoom: 20,
  minPitch: 0,
  maxPitch: 60
};

var defaultState = {
  pitch: 0,
  bearing: 0,
  altitude: 1.5
};

function ensureFinite(value, fallbackValue) {
  return Number.isFinite(value) ? value : fallbackValue;
}

var MapState = function (_ViewState) {
  _inherits(MapState, _ViewState);

  function MapState() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        width = _ref.width,
        height = _ref.height,
        latitude = _ref.latitude,
        longitude = _ref.longitude,
        zoom = _ref.zoom,
        bearing = _ref.bearing,
        pitch = _ref.pitch,
        altitude = _ref.altitude,
        maxZoom = _ref.maxZoom,
        minZoom = _ref.minZoom,
        maxPitch = _ref.maxPitch,
        minPitch = _ref.minPitch,
        startPanLngLat = _ref.startPanLngLat,
        startZoomLngLat = _ref.startZoomLngLat,
        startBearing = _ref.startBearing,
        startPitch = _ref.startPitch,
        startZoom = _ref.startZoom;

    _classCallCheck(this, MapState);

    (0, _assert2.default)(Number.isFinite(longitude), '`longitude` must be supplied');
    (0, _assert2.default)(Number.isFinite(latitude), '`latitude` must be supplied');
    (0, _assert2.default)(Number.isFinite(zoom), '`zoom` must be supplied');

    var _this = _possibleConstructorReturn(this, (MapState.__proto__ || Object.getPrototypeOf(MapState)).call(this, {
      width: width,
      height: height,
      latitude: latitude,
      longitude: longitude,
      zoom: zoom,
      bearing: bearing,
      pitch: pitch,

      altitude: ensureFinite(altitude, defaultState.altitude),
      maxZoom: ensureFinite(maxZoom, MAPBOX_LIMITS.maxZoom),
      minZoom: ensureFinite(minZoom, MAPBOX_LIMITS.minZoom),
      maxPitch: ensureFinite(maxPitch, MAPBOX_LIMITS.maxPitch),
      minPitch: ensureFinite(minPitch, MAPBOX_LIMITS.minPitch)
    }));

    _this._interactiveState = {
      startPanLngLat: startPanLngLat,
      startZoomLngLat: startZoomLngLat,
      startBearing: startBearing,
      startPitch: startPitch,
      startZoom: startZoom
    };
    return _this;
  }

  /* Public API */

  _createClass(MapState, [{
    key: 'getInteractiveState',
    value: function getInteractiveState() {
      return this._interactiveState;
    }

    /**
     * Start panning
     * @param {[Number, Number]} pos - position on screen where the pointer grabs
     */

  }, {
    key: 'panStart',
    value: function panStart(_ref2) {
      var pos = _ref2.pos;

      return this._getUpdatedState({
        startPanLngLat: this._unproject(pos)
      });
    }

    /**
     * Pan
     * @param {[Number, Number]} pos - position on screen where the pointer is
     * @param {[Number, Number], optional} startPos - where the pointer grabbed at
     *   the start of the operation. Must be supplied of `panStart()` was not called
     */

  }, {
    key: 'pan',
    value: function pan(_ref3) {
      var pos = _ref3.pos,
          startPos = _ref3.startPos;

      var startPanLngLat = this._interactiveState.startPanLngLat || this._unproject(startPos);

      // take the start lnglat and put it where the mouse is down.
      (0, _assert2.default)(startPanLngLat, '`startPanLngLat` prop is required ' + 'for mouse pan behavior to calculate where to position the map.');

      var _calculateNewLngLat2 = this._calculateNewLngLat({ startPanLngLat: startPanLngLat, pos: pos }),
          _calculateNewLngLat3 = _slicedToArray(_calculateNewLngLat2, 2),
          longitude = _calculateNewLngLat3[0],
          latitude = _calculateNewLngLat3[1];

      return this._getUpdatedState({
        longitude: longitude,
        latitude: latitude
      });
    }

    /**
     * End panning
     * Must call if `panStart()` was called
     */

  }, {
    key: 'panEnd',
    value: function panEnd() {
      return this._getUpdatedState({
        startPanLngLat: null
      });
    }

    /**
     * Start rotating
     * @param {[Number, Number]} pos - position on screen where the center is
     */

  }, {
    key: 'rotateStart',
    value: function rotateStart(_ref4) {
      var pos = _ref4.pos;

      return this._getUpdatedState({
        startBearing: this._viewportProps.bearing,
        startPitch: this._viewportProps.pitch
      });
    }

    /**
     * Rotate
     * @param {Number} deltaScaleX - a number between [-1, 1] specifying the
     *   change to bearing.
     * @param {Number} deltaScaleY - a number between [-1, 1] specifying the
     *   change to pitch. -1 sets to minPitch and 1 sets to maxPitch.
     */

  }, {
    key: 'rotate',
    value: function rotate(_ref5) {
      var deltaScaleX = _ref5.deltaScaleX,
          deltaScaleY = _ref5.deltaScaleY;

      (0, _assert2.default)(deltaScaleX >= -1 && deltaScaleX <= 1, '`deltaScaleX` must be a number between [-1, 1]');
      (0, _assert2.default)(deltaScaleY >= -1 && deltaScaleY <= 1, '`deltaScaleY` must be a number between [-1, 1]');

      var _interactiveState = this._interactiveState,
          startBearing = _interactiveState.startBearing,
          startPitch = _interactiveState.startPitch;


      if (!Number.isFinite(startBearing)) {
        startBearing = this._viewportProps.bearing;
      }
      if (!Number.isFinite(startPitch)) {
        startPitch = this._viewportProps.pitch;
      }

      var _calculateNewPitchAnd = this._calculateNewPitchAndBearing({
        deltaScaleX: deltaScaleX,
        deltaScaleY: deltaScaleY,
        startBearing: startBearing,
        startPitch: startPitch
      }),
          pitch = _calculateNewPitchAnd.pitch,
          bearing = _calculateNewPitchAnd.bearing;

      return this._getUpdatedState({
        bearing: bearing,
        pitch: pitch
      });
    }

    /**
     * End rotating
     * Must call if `rotateStart()` was called
     */

  }, {
    key: 'rotateEnd',
    value: function rotateEnd() {
      return this._getUpdatedState({
        startBearing: null,
        startPitch: null
      });
    }

    /**
     * Start zooming
     * @param {[Number, Number]} pos - position on screen where the center is
     */

  }, {
    key: 'zoomStart',
    value: function zoomStart(_ref6) {
      var pos = _ref6.pos;

      return this._getUpdatedState({
        startZoomLngLat: this._unproject(pos),
        startZoom: this._viewportProps.zoom
      });
    }

    /**
     * Zoom
     * @param {[Number, Number]} pos - position on screen where the current center is
     * @param {[Number, Number]} startPos - the center position at
     *   the start of the operation. Must be supplied of `zoomStart()` was not called
     * @param {Number} scale - a number between [0, 1] specifying the accumulated
     *   relative scale.
     */

  }, {
    key: 'zoom',
    value: function zoom(_ref7) {
      var pos = _ref7.pos,
          startPos = _ref7.startPos,
          scale = _ref7.scale;

      (0, _assert2.default)(scale > 0, '`scale` must be a positive number');

      // Make sure we zoom around the current mouse position rather than map center
      var startZoomLngLat = this._interactiveState.startZoomLngLat || this._unproject(startPos) || this._unproject(pos);
      var startZoom = this._interactiveState.startZoom;


      if (!Number.isFinite(startZoom)) {
        startZoom = this._viewportProps.zoom;
      }

      // take the start lnglat and put it where the mouse is down.
      (0, _assert2.default)(startZoomLngLat, '`startZoomLngLat` prop is required ' + 'for zoom behavior to calculate where to position the map.');

      var zoom = this._calculateNewZoom({ scale: scale, startZoom: startZoom });

      var zoomedViewport = new _webMercatorViewport2.default(Object.assign({}, this._viewportProps, { zoom: zoom }));

      var _zoomedViewport$getLo = zoomedViewport.getLocationAtPoint({ lngLat: startZoomLngLat, pos: pos }),
          _zoomedViewport$getLo2 = _slicedToArray(_zoomedViewport$getLo, 2),
          longitude = _zoomedViewport$getLo2[0],
          latitude = _zoomedViewport$getLo2[1];

      return this._getUpdatedState({
        zoom: zoom,
        longitude: longitude,
        latitude: latitude
      });
    }

    /**
     * End zooming
     * Must call if `zoomStart()` was called
     */

  }, {
    key: 'zoomEnd',
    value: function zoomEnd() {
      return this._getUpdatedState({
        startZoomLngLat: null,
        startZoom: null
      });
    }
  }, {
    key: 'moveLeft',
    value: function moveLeft() {
      return this._getUpdatedState({
        bearing: this._viewportProps.bearing - 3
      });
    }
  }, {
    key: 'moveRight',
    value: function moveRight() {
      return this._getUpdatedState({
        bearing: this._viewportProps.bearing + 3
      });
    }
  }, {
    key: 'moveForward',
    value: function moveForward() {
      return this._getUpdatedState({
        pitch: this._viewportProps.pitch + 3
      });
    }
  }, {
    key: 'moveBackward',
    value: function moveBackward() {
      return this._getUpdatedState({
        pitch: this._viewportProps.pitch - 3
      });
    }
  }, {
    key: 'zoomIn',
    value: function zoomIn() {
      return this._getUpdatedState({
        zoom: this._viewportProps.zoom + 0.2
      });
    }
  }, {
    key: 'zoomOut',
    value: function zoomOut() {
      return this._getUpdatedState({
        zoom: this._viewportProps.zoom - 0.2
      });
    }

    /* Private methods */

  }, {
    key: '_getUpdatedState',
    value: function _getUpdatedState(newProps) {
      // Update _viewportProps
      return new MapState(Object.assign({}, this._viewportProps, this._interactiveState, newProps));
    }

    // Apply any constraints (mathematical or defined by _viewportProps) to map state

  }, {
    key: '_applyConstraints',
    value: function _applyConstraints(props) {
      // Normalize degrees
      props.longitude = (0, _mathUtils.mod)(props.longitude + 180, 360) - 180;
      props.bearing = (0, _mathUtils.mod)(props.bearing + 180, 360) - 180;

      // Ensure zoom is within specified range
      var maxZoom = props.maxZoom,
          minZoom = props.minZoom,
          zoom = props.zoom;

      props.zoom = zoom > maxZoom ? maxZoom : zoom;
      props.zoom = props.zoom < minZoom ? minZoom : props.zoom;

      // Ensure pitch is within specified range
      var maxPitch = props.maxPitch,
          minPitch = props.minPitch,
          pitch = props.pitch;


      props.pitch = pitch > maxPitch ? maxPitch : pitch;
      props.pitch = props.pitch < minPitch ? minPitch : props.pitch;

      return props;
    }
  }, {
    key: '_unproject',
    value: function _unproject(pos) {
      var viewport = new _webMercatorViewport2.default(this._viewportProps);
      return pos && viewport.unproject(pos, { topLeft: true });
    }

    // Calculate a new lnglat based on pixel dragging position

  }, {
    key: '_calculateNewLngLat',
    value: function _calculateNewLngLat(_ref8) {
      var startPanLngLat = _ref8.startPanLngLat,
          pos = _ref8.pos;

      var viewport = new _webMercatorViewport2.default(this._viewportProps);
      return viewport.getLocationAtPoint({ lngLat: startPanLngLat, pos: pos });
    }

    // Calculates new zoom

  }, {
    key: '_calculateNewZoom',
    value: function _calculateNewZoom(_ref9) {
      var scale = _ref9.scale,
          startZoom = _ref9.startZoom;
      var _viewportProps = this._viewportProps,
          maxZoom = _viewportProps.maxZoom,
          minZoom = _viewportProps.minZoom;

      var zoom = startZoom + Math.log2(scale);
      zoom = zoom > maxZoom ? maxZoom : zoom;
      zoom = zoom < minZoom ? minZoom : zoom;
      return zoom;
    }

    // Calculates a new pitch and bearing from a position (coming from an event)

  }, {
    key: '_calculateNewPitchAndBearing',
    value: function _calculateNewPitchAndBearing(_ref10) {
      var deltaScaleX = _ref10.deltaScaleX,
          deltaScaleY = _ref10.deltaScaleY,
          startBearing = _ref10.startBearing,
          startPitch = _ref10.startPitch;
      var _viewportProps2 = this._viewportProps,
          minPitch = _viewportProps2.minPitch,
          maxPitch = _viewportProps2.maxPitch;


      var bearing = startBearing + 180 * deltaScaleX;
      var pitch = startPitch;
      if (deltaScaleY > 0) {
        // Gradually increase pitch
        pitch = startPitch + deltaScaleY * (maxPitch - startPitch);
      } else if (deltaScaleY < 0) {
        // Gradually decrease pitch
        pitch = startPitch - deltaScaleY * (minPitch - startPitch);
      }

      return {
        pitch: pitch,
        bearing: bearing
      };
    }
  }]);

  return MapState;
}(_viewState2.default);

exports.default = MapState;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9jb3JlL2NvbnRyb2xsZXJzL21hcC1zdGF0ZS5qcyJdLCJuYW1lcyI6WyJNQVBCT1hfTElNSVRTIiwibWluWm9vbSIsIm1heFpvb20iLCJtaW5QaXRjaCIsIm1heFBpdGNoIiwiZGVmYXVsdFN0YXRlIiwicGl0Y2giLCJiZWFyaW5nIiwiYWx0aXR1ZGUiLCJlbnN1cmVGaW5pdGUiLCJ2YWx1ZSIsImZhbGxiYWNrVmFsdWUiLCJOdW1iZXIiLCJpc0Zpbml0ZSIsIk1hcFN0YXRlIiwid2lkdGgiLCJoZWlnaHQiLCJsYXRpdHVkZSIsImxvbmdpdHVkZSIsInpvb20iLCJzdGFydFBhbkxuZ0xhdCIsInN0YXJ0Wm9vbUxuZ0xhdCIsInN0YXJ0QmVhcmluZyIsInN0YXJ0UGl0Y2giLCJzdGFydFpvb20iLCJfaW50ZXJhY3RpdmVTdGF0ZSIsInBvcyIsIl9nZXRVcGRhdGVkU3RhdGUiLCJfdW5wcm9qZWN0Iiwic3RhcnRQb3MiLCJfY2FsY3VsYXRlTmV3TG5nTGF0IiwiX3ZpZXdwb3J0UHJvcHMiLCJkZWx0YVNjYWxlWCIsImRlbHRhU2NhbGVZIiwiX2NhbGN1bGF0ZU5ld1BpdGNoQW5kQmVhcmluZyIsInNjYWxlIiwiX2NhbGN1bGF0ZU5ld1pvb20iLCJ6b29tZWRWaWV3cG9ydCIsIk9iamVjdCIsImFzc2lnbiIsImdldExvY2F0aW9uQXRQb2ludCIsImxuZ0xhdCIsIm5ld1Byb3BzIiwicHJvcHMiLCJ2aWV3cG9ydCIsInVucHJvamVjdCIsInRvcExlZnQiLCJNYXRoIiwibG9nMiJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7Ozs7Ozs7OztBQUVBO0FBQ08sSUFBTUEsd0NBQWdCO0FBQzNCQyxXQUFTLENBRGtCO0FBRTNCQyxXQUFTLEVBRmtCO0FBRzNCQyxZQUFVLENBSGlCO0FBSTNCQyxZQUFVO0FBSmlCLENBQXRCOztBQU9QLElBQU1DLGVBQWU7QUFDbkJDLFNBQU8sQ0FEWTtBQUVu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QyxXQUF3QyxVQUF4Q0EsV0FBd0M7QUFBQSxVQUEzQlgsWUFBMkIsVUFBM0JBLFlBQTJCO0FBQUEsVUFBYkMsVUFBYSxVQUFiQSxVQUFhO0FBQUEsNEJBQ3BELEtBQUtRLGNBRCtDO0FBQUEsVUFDMUU1QixRQUQwRSxtQkFDMUVBLFFBRDBFO0FBQUEsVUFDaEVDLFFBRGdFLG1CQUNoRUEsUUFEZ0U7OztBQUdqRixVQUFNRyxVQUFVZSxlQUFlLE1BQU1VLFdBQXJDO0FBQ0EsVUFBSTFCLFFBQVFpQixVQUFaO0FBQ0EsVUFBSVUsY0FBYyxDQUFsQixFQUFxQjtBQUNuQjtBQUNBM0IsZ0JBQVFpQixhQUFhVSxlQUFlN0IsV0FBV21CLFVBQTFCLENBQXJCO0FBQ0QsT0FIRCxNQUdPLElBQUlVLGNBQWMsQ0FBbEIsRUFBcUI7QUFDMUI7QUFDQTNCLGdCQUFRaUIsYUFBYVUsZUFBZTlCLFdBQVdvQixVQUExQixDQUFyQjtBQUNEOztBQUVELGFBQU87QUFDTGpCLG9CQURLO0FBRUxDO0FBRkssT0FBUDtBQUlEOzs7Ozs7a0JBcFZrQk8sUSIsImZpbGUiOiJtYXAtc3RhdGUuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgVmlld1N0YXRlIGZyb20gJy4vdmlldy1zdGF0ZSc7XG5pbXBvcnQgUGVyc3BlY3RpdmVNZXJjYXRvclZpZXdwb3J0IGZyb20gJy4uL3ZpZXdwb3J0cy93ZWItbWVyY2F0b3Itdmlld3BvcnQnO1xuaW1wb3J0IGFzc2VydCBmcm9tICdhc3NlcnQnO1xuaW1wb3J0IHttb2R9IGZyb20gJy4uL3V0aWxzL21hdGgtdXRpbHMnO1xuXG4vLyBNQVBCT1ggTElNSVRTXG5leHBvcnQgY29uc3QgTUFQQk9YX0xJTUlUUyA9IHtcbiAgbWluWm9vbTogMCxcbiAgbWF4Wm9vbTogMjAsXG4gIG1pblBpdGNoOiAwLFxuICBtYXhQaXRjaDogNjBcbn07XG5cbmNvbnN0IGRlZmF1bHRTdGF0ZSA9IHtcbiAgcGl0Y2g6IDAsXG4gIGJlYXJpbmc6IDAsXG4gIGFsdGl0dWRlOiAxLjVcbn07XG5cbmZ1bmN0aW9uIGVuc3VyZUZpbml0ZSh2YWx1ZSwgZmFsbGJhY2tWYWx1ZSkge1xuICByZXR1cm4gTnVtYmVyLmlzRmluaXRlKHZhbHVlKSA/IHZhbHVlIDogZmFsbGJhY2tWYWx1ZTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTWFwU3RhdGUgZXh0ZW5kcyBWaWV3U3RhdGUge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgLyoqIE1hcGJveCB2aWV3cG9ydCBwcm9wZXJ0aWVzICovXG4gICAgLyoqIFRoZSB3aWR0aCBvZiB0aGUgdmlld3BvcnQgKi9cbiAgICB3aWR0aCxcbiAgICAvKiogVGhlIGhlaWdodCBvZiB0aGUgdmlld3BvcnQgKi9cbiAgICBoZWlnaHQsXG4gICAgLyoqIFRoZSBsYXRpdHVkZSBhdCB0aGUgY2VudGVyIG9mIHRoZSB2aWV3cG9ydCAqL1xuICAgIGxhdGl0dWRlLFxuICAgIC8qKiBUaGUgbG9uZ2l0dWRlIGF0IHRoZSBjZW50ZXIgb2YgdGhlIHZpZXdwb3J0ICovXG4gICAgbG9uZ2l0dWRlLFxuICAgIC8qKiBUaGUgdGlsZSB6b29tIGxldmVsIG9mIHRoZSBtYXAuICovXG4gICAgem9vbSxcbiAgICAvKiogVGhlIGJlYXJpbmcgb2YgdGhlIHZpZXdwb3J0IGluIGRlZ3JlZXMgKi9cbiAgICBiZWFyaW5nLFxuICAgIC8qKiBUaGUgcGl0Y2ggb2YgdGhlIHZpZXdwb3J0IGluIGRlZ3JlZXMgKi9cbiAgICBwaXRjaCxcbiAgICAvKipcbiAgICAgKiBTcGVjaWZ5IHRoZSBhbHRpdHVkZSBvZiB0aGUgdmlld3BvcnQgY2FtZXJhXG4gICAgICogVW5pdDogbWFwIGhlaWdodHMsIGRlZmF1bHQgMS41XG4gICAgICogTm9uLXB1YmxpYyBBUEksIHNlZSBodHRwczovL2dpdGh1Yi5jb20vbWFwYm94L21hcGJveC1nbC1qcy9pc3N1ZXMvMTEzN1xuICAgICAqL1xuICAgIGFsdGl0dWRlLFxuXG4gICAgLyoqIFZpZXdwb3J0IGNvbnN0cmFpbnRzICovXG4gICAgbWF4Wm9vbSxcbiAgICBtaW5ab29tLFxuICAgIG1heFBpdGNoLFxuICAgIG1pblBpdGNoLFxuXG4gICAgLyoqIEludGVyYWN0aW9uIHN0YXRlcywgcmVxdWlyZWQgdG8gY2FsY3VsYXRlIGNoYW5nZSBkdXJpbmcgdHJhbnNmb3JtICovXG4gICAgLyogVGhlIHBvaW50IG9uIG1hcCBiZWluZyBncmFiYmVkIHdoZW4gdGhlIG9wZXJhdGlvbiBmaXJzdCBzdGFydGVkICovXG4gICAgc3RhcnRQYW5MbmdMYXQsXG4gICAgLyogQ2VudGVyIG9mIHRoZSB6b29tIHdoZW4gdGhlIG9wZXJhdGlvbiBmaXJzdCBzdGFydGVkICovXG4gICAgc3RhcnRab29tTG5nTGF0LFxuICAgIC8qKiBCZWFyaW5nIHdoZW4gY3VycmVudCBwZXJzcGVjdGl2ZSByb3RhdGUgb3BlcmF0aW9uIHN0YXJ0ZWQgKi9cbiAgICBzdGFydEJlYXJpbmcsXG4gICAgLyoqIFBpdGNoIHdoZW4gY3VycmVudCBwZXJzcGVjdGl2ZSByb3RhdGUgb3BlcmF0aW9uIHN0YXJ0ZWQgKi9cbiAgICBzdGFydFBpdGNoLFxuICAgIC8qKiBab29tIHdoZW4gY3VycmVudCB6b29tIG9wZXJhdGlvbiBzdGFydGVkICovXG4gICAgc3RhcnRab29tXG4gIH0gPSB7fSkge1xuICAgIGFzc2VydChOdW1iZXIuaXNGaW5pdGUobG9uZ2l0dWRlKSwgJ2Bsb25naXR1ZGVgIG11c3QgYmUgc3VwcGxpZWQnKTtcbiAgICBhc3NlcnQoTnVtYmVyLmlzRmluaXRlKGxhdGl0dWRlKSwgJ2BsYXRpdHVkZWAgbXVzdCBiZSBzdXBwbGllZCcpO1xuICAgIGFzc2VydChOdW1iZXIuaXNGaW5pdGUoem9vbSksICdgem9vbWAgbXVzdCBiZSBzdXBwbGllZCcpO1xuXG4gICAgc3VwZXIoe1xuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHQsXG4gICAgICBsYXRpdHVkZSxcbiAgICAgIGxvbmdpdHVkZSxcbiAgICAgIHpvb20sXG4gICAgICBiZWFyaW5nLFxuICAgICAgcGl0Y2gsXG5cbiAgICAgIGFsdGl0dWRlOiBlbnN1cmVGaW5pdGUoYWx0aXR1ZGUsIGRlZmF1bHRTdGF0ZS5hbHRpdHVkZSksXG4gICAgICBtYXhab29tOiBlbnN1cmVGaW5pdGUobWF4Wm9vbSwgTUFQQk9YX0xJTUlUUy5tYXhab29tKSxcbiAgICAgIG1pblpvb206IGVuc3VyZUZpbml0ZShtaW5ab29tLCBNQVBCT1hfTElNSVRTLm1pblpvb20pLFxuICAgICAgbWF4UGl0Y2g6IGVuc3VyZUZpbml0ZShtYXhQaXRjaCwgTUFQQk9YX0xJTUlUUy5tYXhQaXRjaCksXG4gICAgICBtaW5QaXRjaDogZW5zdXJlRmluaXRlKG1pblBpdGNoLCBNQVBCT1hfTElNSVRTLm1pblBpdGNoKVxuICAgIH0pO1xuXG4gICAgdGhpcy5faW50ZXJhY3RpdmVTdGF0ZSA9IHtcbiAgICAgIHN0YXJ0UGFuTG5nTGF0LFxuICAgICAgc3RhcnRab29tTG5nTGF0LFxuICAgICAgc3RhcnRCZWFyaW5nLFxuICAgICAgc3RhcnRQaXRjaCxcbiAgICAgIHN0YXJ0Wm9vbVxuICAgIH07XG4gIH1cblxuICAvKiBQdWJsaWMgQVBJICovXG5cbiAgZ2V0SW50ZXJhY3RpdmVTdGF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5faW50ZXJhY3RpdmVTdGF0ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdGFydCBwYW5uaW5nXG4gICAqIEBwYXJhbSB7W051bWJlciwgTnVtYmVyXX0gcG9zIC0gcG9zaXRpb24gb24gc2NyZWVuIHdoZXJlIHRoZSBwb2ludGVyIGdyYWJzXG4gICAqL1xuICBwYW5TdGFydCh7cG9zfSkge1xuICAgIHJldHVybiB0aGlzLl9nZXRVcGRhdGVkU3RhdGUoe1xuICAgICAgc3RhcnRQYW5MbmdMYXQ6IHRoaXMuX3VucHJvamVjdChwb3MpXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUGFuXG4gICAqIEBwYXJhbSB7W051bWJlciwgTnVtYmVyXX0gcG9zIC0gcG9zaXRpb24gb24gc2NyZWVuIHdoZXJlIHRoZSBwb2ludGVyIGlzXG4gICAqIEBwYXJhbSB7W051bWJlciwgTnVtYmVyXSwgb3B0aW9uYWx9IHN0YXJ0UG9zIC0gd2hlcmUgdGhlIHBvaW50ZXIgZ3JhYmJlZCBhdFxuICAgKiAgIHRoZSBzdGFydCBvZiB0aGUgb3BlcmF0aW9uLiBNdXN0IGJlIHN1cHBsaWVkIG9mIGBwYW5TdGFydCgpYCB3YXMgbm90IGNhbGxlZFxuICAgKi9cbiAgcGFuKHtwb3MsIHN0YXJ0UG9zfSkge1xuICAgIGNvbnN0IHN0YXJ0UGFuTG5nTGF0ID0gdGhpcy5faW50ZXJhY3RpdmVTdGF0ZS5zdGFydFBhbkxuZ0xhdCB8fCB0aGlzLl91bnByb2plY3Qoc3RhcnRQb3MpO1xuXG4gICAgLy8gdGFrZSB0aGUgc3RhcnQgbG5nbGF0IGFuZCBwdXQgaXQgd2hlcmUgdGhlIG1vdXNlIGlzIGRvd24uXG4gICAgYXNzZXJ0KFxuICAgICAgc3RhcnRQYW5MbmdMYXQsXG4gICAgICAnYHN0YXJ0UGFuTG5nTGF0YCBwcm9wIGlzIHJlcXVpcmVkICcgK1xuICAgICAgICAnZm9yIG1vdXNlIHBhbiBiZWhhdmlvciB0byBjYWxjdWxhdGUgd2hlcmUgdG8gcG9zaXRpb24gdGhlIG1hcC4nXG4gICAgKTtcblxuICAgIGNvbnN0IFtsb25naXR1ZGUsIGxhdGl0dWRlXSA9IHRoaXMuX2NhbGN1bGF0ZU5ld0xuZ0xhdCh7c3RhcnRQYW5MbmdMYXQsIHBvc30pO1xuXG4gICAgcmV0dXJuIHRoaXMuX2dldFVwZGF0ZWRTdGF0ZSh7XG4gICAgICBsb25naXR1ZGUsXG4gICAgICBsYXRpdHVkZVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEVuZCBwYW5uaW5nXG4gICAqIE11c3QgY2FsbCBpZiBgcGFuU3RhcnQoKWAgd2FzIGNhbGxlZFxuICAgKi9cbiAgcGFuRW5kKCkge1xuICAgIHJldHVybiB0aGlzLl9nZXRVcGRhdGVkU3RhdGUoe1xuICAgICAgc3RhcnRQYW5MbmdMYXQ6IG51bGxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdGFydCByb3RhdGluZ1xuICAgKiBAcGFyYW0ge1tOdW1iZXIsIE51bWJlcl19IHBvcyAtIHBvc2l0aW9uIG9uIHNjcmVlbiB3aGVyZSB0aGUgY2VudGVyIGlzXG4gICAqL1xuICByb3RhdGVTdGFydCh7cG9zfSkge1xuICAgIHJldHVybiB0aGlzLl9nZXRVcGRhdGVkU3RhdGUoe1xuICAgICAgc3RhcnRCZWFyaW5nOiB0aGlzLl92aWV3cG9ydFByb3BzLmJlYXJpbmcsXG4gICAgICBzdGFydFBpdGNoOiB0aGlzLl92aWV3cG9ydFByb3BzLnBpdGNoXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUm90YXRlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBkZWx0YVNjYWxlWCAtIGEgbnVtYmVyIGJldHdlZW4gWy0xLCAxXSBzcGVjaWZ5aW5nIHRoZVxuICAgKiAgIGNoYW5nZSB0byBiZWFyaW5nLlxuICAgKiBAcGFyYW0ge051bWJlcn0gZGVsdGFTY2FsZVkgLSBhIG51bWJlciBiZXR3ZWVuIFstMSwgMV0gc3BlY2lmeWluZyB0aGVcbiAgICogICBjaGFuZ2UgdG8gcGl0Y2guIC0xIHNldHMgdG8gbWluUGl0Y2ggYW5kIDEgc2V0cyB0byBtYXhQaXRjaC5cbiAgICovXG4gIHJvdGF0ZSh7ZGVsdGFTY2FsZVgsIGRlbHRhU2NhbGVZfSkge1xuICAgIGFzc2VydChkZWx0YVNjYWxlWCA+PSAtMSAmJiBkZWx0YVNjYWxlWCA8PSAxLCAnYGRlbHRhU2NhbGVYYCBtdXN0IGJlIGEgbnVtYmVyIGJldHdlZW4gWy0xLCAxXScpO1xuICAgIGFzc2VydChkZWx0YVNjYWxlWSA+PSAtMSAmJiBkZWx0YVNjYWxlWSA8PSAxLCAnYGRlbHRhU2NhbGVZYCBtdXN0IGJlIGEgbnVtYmVyIGJldHdlZW4gWy0xLCAxXScpO1xuXG4gICAgbGV0IHtzdGFydEJlYXJpbmcsIHN0YXJ0UGl0Y2h9ID0gdGhpcy5faW50ZXJhY3RpdmVTdGF0ZTtcblxuICAgIGlmICghTnVtYmVyLmlzRmluaXRlKHN0YXJ0QmVhcmluZykpIHtcbiAgICAgIHN0YXJ0QmVhcmluZyA9IHRoaXMuX3ZpZXdwb3J0UHJvcHMuYmVhcmluZztcbiAgICB9XG4gICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUoc3RhcnRQaXRjaCkpIHtcbiAgICAgIHN0YXJ0UGl0Y2ggPSB0aGlzLl92aWV3cG9ydFByb3BzLnBpdGNoO1xuICAgIH1cblxuICAgIGNvbnN0IHtwaXRjaCwgYmVhcmluZ30gPSB0aGlzLl9jYWxjdWxhdGVOZXdQaXRjaEFuZEJlYXJpbmcoe1xuICAgICAgZGVsdGFTY2FsZVgsXG4gICAgICBkZWx0YVNjYWxlWSxcbiAgICAgIHN0YXJ0QmVhcmluZyxcbiAgICAgIHN0YXJ0UGl0Y2hcbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzLl9nZXRVcGRhdGVkU3RhdGUoe1xuICAgICAgYmVhcmluZyxcbiAgICAgIHBpdGNoXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogRW5kIHJvdGF0aW5nXG4gICAqIE11c3QgY2FsbCBpZiBgcm90YXRlU3RhcnQoKWAgd2FzIGNhbGxlZFxuICAgKi9cbiAgcm90YXRlRW5kKCkge1xuICAgIHJldHVybiB0aGlzLl9nZXRVcGRhdGVkU3RhdGUoe1xuICAgICAgc3RhcnRCZWFyaW5nOiBudWxsLFxuICAgICAgc3RhcnRQaXRjaDogbnVsbFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0YXJ0IHpvb21pbmdcbiAgICogQHBhcmFtIHtbTnVtYmVyLCBOdW1iZXJdfSBwb3MgLSBwb3NpdGlvbiBvbiBzY3JlZW4gd2hlcmUgdGhlIGNlbnRlciBpc1xuICAgKi9cbiAgem9vbVN0YXJ0KHtwb3N9KSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldFVwZGF0ZWRTdGF0ZSh7XG4gICAgICBzdGFydFpvb21MbmdMYXQ6IHRoaXMuX3VucHJvamVjdChwb3MpLFxuICAgICAgc3RhcnRab29tOiB0aGlzLl92aWV3cG9ydFByb3BzLnpvb21cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBab29tXG4gICAqIEBwYXJhbSB7W051bWJlciwgTnVtYmVyXX0gcG9zIC0gcG9zaXRpb24gb24gc2NyZWVuIHdoZXJlIHRoZSBjdXJyZW50IGNlbnRlciBpc1xuICAgKiBAcGFyYW0ge1tOdW1iZXIsIE51bWJlcl19IHN0YXJ0UG9zIC0gdGhlIGNlbnRlciBwb3NpdGlvbiBhdFxuICAgKiAgIHRoZSBzdGFydCBvZiB0aGUgb3BlcmF0aW9uLiBNdXN0IGJlIHN1cHBsaWVkIG9mIGB6b29tU3RhcnQoKWAgd2FzIG5vdCBjYWxsZWRcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxlIC0gYSBudW1iZXIgYmV0d2VlbiBbMCwgMV0gc3BlY2lmeWluZyB0aGUgYWNjdW11bGF0ZWRcbiAgICogICByZWxhdGl2ZSBzY2FsZS5cbiAgICovXG4gIHpvb20oe3Bvcywgc3RhcnRQb3MsIHNjYWxlfSkge1xuICAgIGFzc2VydChzY2FsZSA+IDAsICdgc2NhbGVgIG11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXInKTtcblxuICAgIC8vIE1ha2Ugc3VyZSB3ZSB6b29tIGFyb3VuZCB0aGUgY3VycmVudCBtb3VzZSBwb3NpdGlvbiByYXRoZXIgdGhhbiBtYXAgY2VudGVyXG4gICAgY29uc3Qgc3RhcnRab29tTG5nTGF0ID1cbiAgICAgIHRoaXMuX2ludGVyYWN0aXZlU3RhdGUuc3RhcnRab29tTG5nTGF0IHx8IHRoaXMuX3VucHJvamVjdChzdGFydFBvcykgfHwgdGhpcy5fdW5wcm9qZWN0KHBvcyk7XG4gICAgbGV0IHtzdGFydFpvb219ID0gdGhpcy5faW50ZXJhY3RpdmVTdGF0ZTtcblxuICAgIGlmICghTnVtYmVyLmlzRmluaXRlKHN0YXJ0Wm9vbSkpIHtcbiAgICAgIHN0YXJ0Wm9vbSA9IHRoaXMuX3ZpZXdwb3J0UHJvcHMuem9vbTtcbiAgICB9XG5cbiAgICAvLyB0YWtlIHRoZSBzdGFydCBsbmdsYXQgYW5kIHB1dCBpdCB3aGVyZSB0aGUgbW91c2UgaXMgZG93bi5cbiAgICBhc3NlcnQoXG4gICAgICBzdGFydFpvb21MbmdMYXQsXG4gICAgICAnYHN0YXJ0Wm9vbUxuZ0xhdGAgcHJvcCBpcyByZXF1aXJlZCAnICtcbiAgICAgICAgJ2ZvciB6b29tIGJlaGF2aW9yIHRvIGNhbGN1bGF0ZSB3aGVyZSB0byBwb3NpdGlvbiB0aGUgbWFwLidcbiAgICApO1xuXG4gICAgY29uc3Qgem9vbSA9IHRoaXMuX2NhbGN1bGF0ZU5ld1pvb20oe3NjYWxlLCBzdGFydFpvb219KTtcblxuICAgIGNvbnN0IHpvb21lZFZpZXdwb3J0ID0gbmV3IFBlcnNwZWN0aXZlTWVyY2F0b3JWaWV3cG9ydChcbiAgICAgIE9iamVjdC5hc3NpZ24oe30sIHRoaXMuX3ZpZXdwb3J0UHJvcHMsIHt6b29tfSlcbiAgICApO1xuICAgIGNvbnN0IFtsb25naXR1ZGUsIGxhdGl0dWRlXSA9IHpvb21lZFZpZXdwb3J0LmdldExvY2F0aW9uQXRQb2ludCh7bG5nTGF0OiBzdGFydFpvb21MbmdMYXQsIHBvc30pO1xuXG4gICAgcmV0dXJuIHRoaXMuX2dldFVwZGF0ZWRTdGF0ZSh7XG4gICAgICB6b29tLFxuICAgICAgbG9uZ2l0dWRlLFxuICAgICAgbGF0aXR1ZGVcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFbmQgem9vbWluZ1xuICAgKiBNdXN0IGNhbGwgaWYgYHpvb21TdGFydCgpYCB3YXMgY2FsbGVkXG4gICAqL1xuICB6b29tRW5kKCkge1xuICAgIHJldHVybiB0aGlzLl9nZXRVcGRhdGVkU3RhdGUoe1xuICAgICAgc3RhcnRab29tTG5nTGF0OiBudWxsLFxuICAgICAgc3RhcnRab29tOiBudWxsXG4gICAgfSk7XG4gIH1cblxuICBtb3ZlTGVmdCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0VXBkYXRlZFN0YXRlKHtcbiAgICAgIGJlYXJpbmc6IHRoaXMuX3ZpZXdwb3J0UHJvcHMuYmVhcmluZyAtIDNcbiAgICB9KTtcbiAgfVxuXG4gIG1vdmVSaWdodCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0VXBkYXRlZFN0YXRlKHtcbiAgICAgIGJlYXJpbmc6IHRoaXMuX3ZpZXdwb3J0UHJvcHMuYmVhcmluZyArIDNcbiAgICB9KTtcbiAgfVxuXG4gIG1vdmVGb3J3YXJkKCkge1xuICAgIHJldHVybiB0aGlzLl9nZXRVcGRhdGVkU3RhdGUoe1xuICAgICAgcGl0Y2g6IHRoaXMuX3ZpZXdwb3J0UHJvcHMucGl0Y2ggKyAzXG4gICAgfSk7XG4gIH1cblxuICBtb3ZlQmFja3dhcmQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldFVwZGF0ZWRTdGF0ZSh7XG4gICAgICBwaXRjaDogdGhpcy5fdmlld3BvcnRQcm9wcy5waXRjaCAtIDNcbiAgICB9KTtcbiAgfVxuXG4gIHpvb21JbigpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0VXBkYXRlZFN0YXRlKHtcbiAgICAgIHpvb206IHRoaXMuX3ZpZXdwb3J0UHJvcHMuem9vbSArIDAuMlxuICAgIH0pO1xuICB9XG5cbiAgem9vbU91dCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0VXBkYXRlZFN0YXRlKHtcbiAgICAgIHpvb206IHRoaXMuX3ZpZXdwb3J0UHJvcHMuem9vbSAtIDAuMlxuICAgIH0pO1xuICB9XG5cbiAgLyogUHJpdmF0ZSBtZXRob2RzICovXG5cbiAgX2dldFVwZGF0ZWRTdGF0ZShuZXdQcm9wcykge1xuICAgIC8vIFVwZGF0ZSBfdmlld3BvcnRQcm9wc1xuICAgIHJldHVybiBuZXcgTWFwU3RhdGUoT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5fdmlld3BvcnRQcm9wcywgdGhpcy5faW50ZXJhY3RpdmVTdGF0ZSwgbmV3UHJvcHMpKTtcbiAgfVxuXG4gIC8vIEFwcGx5IGFueSBjb25zdHJhaW50cyAobWF0aGVtYXRpY2FsIG9yIGRlZmluZWQgYnkgX3ZpZXdwb3J0UHJvcHMpIHRvIG1hcCBzdGF0ZVxuICBfYXBwbHlDb25zdHJhaW50cyhwcm9wcykge1xuICAgIC8vIE5vcm1hbGl6ZSBkZWdyZWVzXG4gICAgcHJvcHMubG9uZ2l0dWRlID0gbW9kKHByb3BzLmxvbmdpdHVkZSArIDE4MCwgMzYwKSAtIDE4MDtcbiAgICBwcm9wcy5iZWFyaW5nID0gbW9kKHByb3BzLmJlYXJpbmcgKyAxODAsIDM2MCkgLSAxODA7XG5cbiAgICAvLyBFbnN1cmUgem9vbSBpcyB3aXRoaW4gc3BlY2lmaWVkIHJhbmdlXG4gICAgY29uc3Qge21heFpvb20sIG1pblpvb20sIHpvb219ID0gcHJvcHM7XG4gICAgcHJvcHMuem9vbSA9IHpvb20gPiBtYXhab29tID8gbWF4Wm9vbSA6IHpvb207XG4gICAgcHJvcHMuem9vbSA9IHByb3BzLnpvb20gPCBtaW5ab29tID8gbWluWm9vbSA6IHByb3BzLnpvb207XG5cbiAgICAvLyBFbnN1cmUgcGl0Y2ggaXMgd2l0aGluIHNwZWNpZmllZCByYW5nZVxuICAgIGNvbnN0IHttYXhQaXRjaCwgbWluUGl0Y2gsIHBpdGNofSA9IHByb3BzO1xuXG4gICAgcHJvcHMucGl0Y2ggPSBwaXRjaCA+IG1heFBpdGNoID8gbWF4UGl0Y2ggOiBwaXRjaDtcbiAgICBwcm9wcy5waXRjaCA9IHByb3BzLnBpdGNoIDwgbWluUGl0Y2ggPyBtaW5QaXRjaCA6IHByb3BzLnBpdGNoO1xuXG4gICAgcmV0dXJuIHByb3BzO1xuICB9XG5cbiAgX3VucHJvamVjdChwb3MpIHtcbiAgICBjb25zdCB2aWV3cG9ydCA9IG5ldyBQZXJzcGVjdGl2ZU1lcmNhdG9yVmlld3BvcnQodGhpcy5fdmlld3BvcnRQcm9wcyk7XG4gICAgcmV0dXJuIHBvcyAmJiB2aWV3cG9ydC51bnByb2plY3QocG9zLCB7dG9wTGVmdDogdHJ1ZX0pO1xuICB9XG5cbiAgLy8gQ2FsY3VsYXRlIGEgbmV3IGxuZ2xhdCBiYXNlZCBvbiBwaXhlbCBkcmFnZ2luZyBwb3NpdGlvblxuICBfY2FsY3VsYXRlTmV3TG5nTGF0KHtzdGFydFBhbkxuZ0xhdCwgcG9zfSkge1xuICAgIGNvbnN0IHZpZXdwb3J0ID0gbmV3IFBlcnNwZWN0aXZlTWVyY2F0b3JWaWV3cG9ydCh0aGlzLl92aWV3cG9ydFByb3BzKTtcbiAgICByZXR1cm4gdmlld3BvcnQuZ2V0TG9jYXRpb25BdFBvaW50KHtsbmdMYXQ6IHN0YXJ0UGFuTG5nTGF0LCBwb3N9KTtcbiAgfVxuXG4gIC8vIENhbGN1bGF0ZXMgbmV3IHpvb21cbiAgX2NhbGN1bGF0ZU5ld1pvb20oe3NjYWxlLCBzdGFydFpvb219KSB7XG4gICAgY29uc3Qge21heFpvb20sIG1pblpvb219ID0gdGhpcy5fdmlld3BvcnRQcm9wcztcbiAgICBsZXQgem9vbSA9IHN0YXJ0Wm9vbSArIE1hdGgubG9nMihzY2FsZSk7XG4gICAgem9vbSA9IHpvb20gPiBtYXhab29tID8gbWF4Wm9vbSA6IHpvb207XG4gICAgem9vbSA9IHpvb20gPCBtaW5ab29tID8gbWluWm9vbSA6IHpvb207XG4gICAgcmV0dXJuIHpvb207XG4gIH1cblxuICAvLyBDYWxjdWxhdGVzIGEgbmV3IHBpdGNoIGFuZCBiZWFyaW5nIGZyb20gYSBwb3NpdGlvbiAoY29taW5nIGZyb20gYW4gZXZlbnQpXG4gIF9jYWxjdWxhdGVOZXdQaXRjaEFuZEJlYXJpbmcoe2RlbHRhU2NhbGVYLCBkZWx0YVNjYWxlWSwgc3RhcnRCZWFyaW5nLCBzdGFydFBpdGNofSkge1xuICAgIGNvbnN0IHttaW5QaXRjaCwgbWF4UGl0Y2h9ID0gdGhpcy5fdmlld3BvcnRQcm9wcztcblxuICAgIGNvbnN0IGJlYXJpbmcgPSBzdGFydEJlYXJpbmcgKyAxODAgKiBkZWx0YVNjYWxlWDtcbiAgICBsZXQgcGl0Y2ggPSBzdGFydFBpdGNoO1xuICAgIGlmIChkZWx0YVNjYWxlWSA+IDApIHtcbiAgICAgIC8vIEdyYWR1YWxseSBpbmNyZWFzZSBwaXRjaFxuICAgICAgcGl0Y2ggPSBzdGFydFBpdGNoICsgZGVsdGFTY2FsZVkgKiAobWF4UGl0Y2ggLSBzdGFydFBpdGNoKTtcbiAgICB9IGVsc2UgaWYgKGRlbHRhU2NhbGVZIDwgMCkge1xuICAgICAgLy8gR3JhZHVhbGx5IGRlY3JlYXNlIHBpdGNoXG4gICAgICBwaXRjaCA9IHN0YXJ0UGl0Y2ggLSBkZWx0YVNjYWxlWSAqIChtaW5QaXRjaCAtIHN0YXJ0UGl0Y2gpO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBwaXRjaCxcbiAgICAgIGJlYXJpbmdcbiAgICB9O1xuICB9XG59XG4iXX0=