'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // Copyright (c) 2015 Uber Technologies, Inc.

// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:

// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.

// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

var _mapState = require('./map-state');

var _mapState2 = _interopRequireDefault(_mapState);

var _assert = require('assert');

var _assert2 = _interopRequireDefault(_assert);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// EVENT HANDLING PARAMETERS
var ZOOM_ACCEL = 0.01;

var PITCH_MOUSE_THRESHOLD = 5;
var PITCH_ACCEL = 1.2;

var EVENT_TYPES = {
  WHEEL: ['wheel'],
  PAN: ['panstart', 'panmove', 'panend'],
  PINCH: ['pinchstart', 'pinchmove', 'pinchend'],
  DOUBLE_TAP: ['doubletap'],
  KEYBOARD: ['keydown', 'keyup']
};

var ViewportControls = function () {
  /**
   * @classdesc
   * A class that handles events and updates mercator style viewport parameters
   */
  function ViewportControls(ViewportState) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, ViewportControls);

    (0, _assert2.default)(ViewportState);
    this.ViewportState = ViewportState;
    this.viewportState = null;
    this.viewportStateProps = null;
    this.eventManager = null;
    this._events = null;

    this._state = {
      isDragging: false
    };

    this.handleEvent = this.handleEvent.bind(this);

    this.setOptions(options);

    if (this.constructor === ViewportControls) {
      Object.seal(this);
    }
  }

  /**
   * Callback for events
   * @param {hammer.Event} event
   */


  _createClass(ViewportControls, [{
    key: 'handleEvent',
    value: function handleEvent(event) {
      var ViewportState = this.ViewportState;

      this.viewportState = new ViewportState(Object.assign({}, this.viewportStateProps, this._state));

      switch (event.type) {
        case 'panstart':
          return this._onPanStart(event);
        case 'panmove':
          return this._onPan(event);
        case 'panend':
          return this._onPanEnd(event);
        case 'pinchstart':
          return this._onPinchStart(event);
        case 'pinch':
          return this._onPinch(event);
        case 'pinchend':
          return this._onPinchEnd(event);
        case 'doubletap':
          return this._onDoubleTap(event);
        case 'wheel':
          return this._onWheel(event);
        case 'keydown':
          return this._onKeyDown(event);
        case 'keyup':
          return this._onKeyUp(event);
        default:
          return false;
      }
    }

    /* Event utils */
    // Event object: http://hammerjs.github.io/api/#event-object

  }, {
    key: 'getCenter',
    value: function getCenter(event) {
      var _event$offsetCenter = event.offsetCenter,
          x = _event$offsetCenter.x,
          y = _event$offsetCenter.y;

      return [x, y];
    }
  }, {
    key: 'isFunctionKeyPressed',
    value: function isFunctionKeyPressed(event) {
      var srcEvent = event.srcEvent;

      return Boolean(srcEvent.metaKey || srcEvent.altKey || srcEvent.ctrlKey || srcEvent.shiftKey);
    }
  }, {
    key: 'isDragging',
    value: function isDragging() {
      return this._state.isDragging;
    }

    /**
     * Extract interactivity options
     */

  }, {
    key: 'setOptions',
    value: function setOptions(options) {
      var onViewportChange = options.onViewportChange,
          _options$onStateChang = options.onStateChange,
          onStateChange = _options$onStateChang === undefined ? this.onStateChange : _options$onStateChang,
          _options$eventManager = options.eventManager,
          eventManager = _options$eventManager === undefined ? this.eventManager : _options$eventManager,
          _options$scrollZoom = options.scrollZoom,
          scrollZoom = _options$scrollZoom === undefined ? true : _options$scrollZoom,
          _options$dragPan = options.dragPan,
          dragPan = _options$dragPan === undefined ? true : _options$dragPan,
          _options$dragRotate = options.dragRotate,
          dragRotate = _options$dragRotate === undefined ? true : _options$dragRotate,
          _options$doubleClickZ = options.doubleClickZoom,
          doubleClickZoom = _options$doubleClickZ === undefined ? true : _options$doubleClickZ,
          _options$touchZoomRot = options.touchZoomRotate,
          touchZoomRotate = _options$touchZoomRot === undefined ? true : _options$touchZoomRot,
          _options$keyboard = options.keyboard,
          keyboard = _options$keyboard === undefined ? true : _options$keyboard;


      this.onViewportChange = onViewportChange;
      this.onStateChange = onStateChange;
      this.viewportStateProps = options;

      if (this.eventManager !== eventManager) {
        // EventManager has changed
        this.eventManager = eventManager;
        this._events = {};
      }

      // Register/unregister events
      var isInteractive = Boolean(this.onViewportChange);
      this.toggleEvents(EVENT_TYPES.WHEEL, isInteractive && scrollZoom);
      this.toggleEvents(EVENT_TYPES.PAN, isInteractive && (dragPan || dragRotate));
      this.toggleEvents(EVENT_TYPES.PINCH, isInteractive && touchZoomRotate);
      this.toggleEvents(EVENT_TYPES.DOUBLE_TAP, isInteractive && doubleClickZoom);
      this.toggleEvents(EVENT_TYPES.KEYBOARD, isInteractive && keyboard);

      this.scrollZoom = scrollZoom;
      this.dragPan = dragPan;
      this.dragRotate = dragRotate;
      this.doubleClickZoom = doubleClickZoom;
      this.touchZoomRotate = touchZoomRotate;
    }
  }, {
    key: 'toggleEvents',
    value: function toggleEvents(eventNames, enabled) {
      var _this = this;

      if (this.eventManager) {
        eventNames.forEach(function (eventName) {
          if (_this._events[eventName] !== enabled) {
            _this._events[eventName] = enabled;
            if (enabled) {
              _this.eventManager.on(eventName, _this.handleEvent);
            } else {
              _this.eventManager.off(eventName, _this.handleEvent);
            }
          }
        });
      }
    }

    // Private Methods

  }, {
    key: 'setState',
    value: function setState(newState) {
      Object.assign(this._state, newState);
      if (this.onStateChange) {
        this.onStateChange(this._state);
      }
    }

    /* Callback util */
    // formats map state and invokes callback function

  }, {
    key: 'updateViewport',
    value: function updateViewport(newViewportState) {
      var extraState = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      var oldViewport = this.viewportState.getViewportProps();
      var newViewport = newViewportState.getViewportProps();

      if (this.onViewportChange && Object.keys(newViewport).some(function (key) {
        return oldViewport[key] !== newViewport[key];
      })) {
        // Viewport has changed
        var viewport = this.viewportState.getViewport ? this.viewportState.getViewport() : null;
        this.onViewportChange(newViewport, viewport);
      }

      this.setState(Object.assign({}, newViewportState.getInteractiveState(), extraState));
    }

    /* Event handlers */
    // Default handler for the `panstart` event.

  }, {
    key: '_onPanStart',
    value: function _onPanStart(event) {
      var pos = this.getCenter(event);
      var newViewportState = this.viewportState.panStart({ pos: pos }).rotateStart({ pos: pos });
      return this.updateViewport(newViewportState, { isDragging: true });
    }

    // Default handler for the `panmove` event.

  }, {
    key: '_onPan',
    value: function _onPan(event) {
      return this.isFunctionKeyPressed(event) ? this._onPanMove(event) : this._onPanRotate(event);
    }

    // Default handler for the `panend` event.

  }, {
    key: '_onPanEnd',
    value: function _onPanEnd(event) {
      var newViewportState = this.viewportState.panEnd().rotateEnd();
      return this.updateViewport(newViewportState, { isDragging: false });
    }

    // Default handler for panning to move.
    // Called by `_onPan` when panning without function key pressed.

  }, {
    key: '_onPanMove',
    value: function _onPanMove(event) {
      if (!this.dragPan) {
        return false;
      }
      var pos = this.getCenter(event);
      var newViewportState = this.viewportState.pan({ pos: pos });
      return this.updateViewport(newViewportState);
    }

    // Default handler for panning to rotate.
    // Called by `_onPan` when panning with function key pressed.

  }, {
    key: '_onPanRotate',
    value: function _onPanRotate(event) {
      return this.viewportState instanceof _mapState2.default ? this._onPanRotateMap(event) : this._onPanRotateStandard(event);
    }

    // Normal pan to rotate

  }, {
    key: '_onPanRotateStandard',
    value: function _onPanRotateStandard(event) {
      if (!this.dragRotate) {
        return false;
      }

      var deltaX = event.deltaX,
          deltaY = event.deltaY;

      var _viewportState$getVie = this.viewportState.getViewportProps(),
          width = _viewportState$getVie.width,
          height = _viewportState$getVie.height;

      var deltaScaleX = deltaX / width;
      var deltaScaleY = deltaY / height;

      var newViewportState = this.viewportState.rotate({ deltaScaleX: deltaScaleX, deltaScaleY: deltaScaleY });
      return this.updateViewport(newViewportState);
    }

    // Map specific pan to rotate
    // TODO - is this mapStateSpecific?

  }, {
    key: '_onPanRotateMap',
    value: function _onPanRotateMap(event) {
      if (!this.dragRotate) {
        return false;
      }

      var deltaX = event.deltaX,
          deltaY = event.deltaY;

      var _getCenter = this.getCenter(event),
          _getCenter2 = _slicedToArray(_getCenter, 2),
          centerY = _getCenter2[1];

      var startY = centerY - deltaY;

      var _viewportState$getVie2 = this.viewportState.getViewportProps(),
          width = _viewportState$getVie2.width,
          height = _viewportState$getVie2.height;

      var deltaScaleX = deltaX / width;
      var deltaScaleY = 0;

      if (deltaY > 0) {
        if (Math.abs(height - startY) > PITCH_MOUSE_THRESHOLD) {
          // Move from 0 to -1 as we drag upwards
          deltaScaleY = deltaY / (startY - height) * PITCH_ACCEL;
        }
      } else if (deltaY < 0) {
        if (startY > PITCH_MOUSE_THRESHOLD) {
          // Move from 0 to 1 as we drag upwards
          deltaScaleY = 1 - centerY / startY;
        }
      }
      deltaScaleY = Math.min(1, Math.max(-1, deltaScaleY));

      var newMapState = this.viewportState.rotate({ deltaScaleX: deltaScaleX, deltaScaleY: deltaScaleY });
      return this.updateViewport(newMapState);
    }

    // Default handler for the `wheel` event.

  }, {
    key: '_onWheel',
    value: function _onWheel(event) {
      if (!this.scrollZoom) {
        return false;
      }
      event.srcEvent.preventDefault();

      var pos = this.getCenter(event);
      var delta = event.delta;

      // Map wheel delta to relative scale

      var scale = 2 / (1 + Math.exp(-Math.abs(delta * ZOOM_ACCEL)));
      if (delta < 0 && scale !== 0) {
        scale = 1 / scale;
      }

      var newViewportState = this.viewportState.zoom({ pos: pos, scale: scale });
      return this.updateViewport(newViewportState);
    }

    // Default handler for the `pinchstart` event.

  }, {
    key: '_onPinchStart',
    value: function _onPinchStart(event) {
      var pos = this.getCenter(event);
      var newViewportState = this.viewportState.zoomStart({ pos: pos });
      return this.updateViewport(newViewportState, { isDragging: true });
    }

    // Default handler for the `pinch` event.

  }, {
    key: '_onPinch',
    value: function _onPinch(event) {
      if (!this.touchZoomRotate) {
        return false;
      }
      var pos = this.getCenter(event);
      var scale = event.scale;

      var newViewportState = this.viewportState.zoom({ pos: pos, scale: scale });
      return this.updateViewport(newViewportState);
    }

    // Default handler for the `pinchend` event.

  }, {
    key: '_onPinchEnd',
    value: function _onPinchEnd(event) {
      var newViewportState = this.viewportState.zoomEnd();
      return this.updateViewport(newViewportState, { isDragging: false });
    }

    // Default handler for the `doubletap` event.

  }, {
    key: '_onDoubleTap',
    value: function _onDoubleTap(event) {
      if (!this.doubleClickZoom) {
        return false;
      }
      var pos = this.getCenter(event);
      var isZoomOut = this.isFunctionKeyPressed(event);

      var newViewportState = this.viewportState.zoom({ pos: pos, scale: isZoomOut ? 0.5 : 2 });
      return this.updateViewport(newViewportState);
    }
  }, {
    key: '_onKeyDown',
    value: function _onKeyDown(event) {
      if (this.viewportState.isDragging) {
        return;
      }

      var KEY_BINDINGS = {
        w: 'moveForward',
        W: 'moveForward',
        ArrowUp: 'moveForward',

        s: 'moveBackward',
        S: 'moveBackward',
        ArrowDown: 'moveBackward',

        a: 'moveLeft',
        A: 'moveLeft',
        ArrowLeft: 'moveLeft',

        d: 'moveRight',
        D: 'moveRight',
        ArrowRight: 'moveRight',

        '=': 'zoomIn',
        '+': 'zoomIn',

        '-': 'zoomOut',

        '[': 'moveDown',
        ']': 'moveUp'
      };

      // keyCode is deprecated from web standards
      // code is not supported by IE/Edge
      var key = event.key;
      var handler = KEY_BINDINGS[key];
      if (this.viewportState[handler]) {
        var newViewportState = this.viewportState[handler]();
        this.updateViewport(newViewportState);
      }
    }
    /* eslint-enable complexity */

  }, {
    key: '_onKeyUp',
    value: function _onKeyUp(event) {}
  }]);

  return ViewportControls;
}();

exports.default = ViewportControls;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9jb3JlL2NvbnRyb2xsZXJzL3ZpZXdwb3J0LWNvbnRyb2xzLmpzIl0sIm5hbWVzIjpbIlpPT01fQUNDRUwiLCJQSVRDSF9NT1VTRV9USFJFU0hPTEQiLCJQSVRDSF9BQ0NFTCIsIkVWRU5UX1RZUEVTIiwiV0hFRUwiLCJQQU4iLCJQSU5DSCIsIkRPVUJMRV9UQVAiLCJLRVlCT0FSRCIsIlZpZXdwb3J0Q29udHJvbHMiLCJWaWV3cG9ydFN0YXRlIiwib3B0aW9ucyIsInZpZXdwb3J0U3RhdGUiLCJ2aWV3cG9ydFN0YXRlUHJvcHMiLCJldmVudE1hbmFnZXIiLCJfZXZlbnRzIiwiX3N0YXRlIiwiaXNEcmFnZ2luZyIsImhhbmRsZUV2ZW50IiwiYmluZCIsInNldE9wdGlvbnMiLCJjb25zdHJ1Y3RvciIsIk9iamVjdCIsInNlYWwiLCJldmVudCIsImFzc2lnbiIsInR5cGUiLCJfb25QYW5TdGFydCIsIl9vblBhbiIsIl9vblBhbkVuZCIsIl9vblBpbmNoU3RhcnQiLCJfb25QaW5jaCIsIl9vblBpbmNoRW5kIiwiX29uRG91YmxlVGFwIiwiX29uV2hlZWwiLCJfb25LZXlEb3duIiwiX29uS2V5VXAiLCJvZmZzZXRDZW50ZXIiLCJ4IiwieSIsInNyY0V2ZW50IiwiQm9vbGVhbiIsIm1ldGFLZXkiLCJhbHRLZXkiLCJjdHJsS2V5Iiwic2hpZnRLZXkiLCJvblZpZXdwb3J0Q2hhbmdlIiwib25TdGF0ZUNoYW5nZSIsInNjcm9sbFpvb20iLCJkcmFnUGFuIiwiZHJhZ1JvdGF0ZSIsImRvdWJsZUNsaWNrWm9vbSIsInRvdWNoWm9vbVJvdGF0ZSIsImtleWJvYXJkIiwiaXNJbnRlcmFjdGl2ZSIsInRvZ2dsZUV2ZW50cyIsImV2ZW50TmFtZXMiLCJlbmFibGVkIiwiZm9yRWFjaCIsImV2ZW50TmFtZSIsIm9uIiwib2ZmIiwibmV3U3RhdGUiLCJuZXdWaWV3cG9ydFN0YXRlIiwiZXh0cmFTdGF0ZSIsIm9sZFZpZXdwb3J0IiwiZ2V0Vmlld3BvcnRQcm9wcyIsIm5ld1ZpZXdwb3J0Iiwia2V5cyIsInNvbWUiLCJrZXkiLCJ2aWV3cG9ydCIsImdldFZpZXdwb3J0Iiwic2V0U3RhdGUiLCJnZXRJbnRlcmFjdGl2ZVN0YXRlIiwicG9zIiwiZ2V0Q2VudGVyIiwicGFuU3RhcnQiLCJyb3RhdGVTdGFydCIsInVwZGF0ZVZpZXdwb3J0IiwiaXNGdW5jdGlvbktleVByZXNzZWQiLCJfb25QYW5Nb3ZlIiwiX29uUGFuUm90YXRlIiwicGFuRW5kIiwicm90YXRlRW5kIiwicGFuIiwiX29uUGFuUm90YXRlTWFwIiwiX29uUGFuUm90YXRlU3RhbmRhcmQiLCJkZWx0YVgiLCJkZWx0YVkiLCJ3aWR0aCIsImhlaWdodCIsImRlbHRhU2NhbGVYIiwiZGVsdGFTY2FsZVkiLCJyb3RhdGUiLCJjZW50ZXJZIiwic3RhcnRZIiwiTWF0aCIsImFicyIsIm1pbiIsIm1heCIsIm5ld01hcFN0YXRlIiwicHJldmVudERlZmF1bHQiLCJkZWx0YSIsInNjYWxlIiwiZXhwIiwiem9vbSIsInpvb21TdGFydCIsInpvb21FbmQiLCJpc1pvb21PdXQiLCJLRVlfQklORElOR1MiLCJ3IiwiVyIsIkFycm93VXAiLCJzIiwiUyIsIkFycm93RG93biIsImEiLCJBIiwiQXJyb3dMZWZ0IiwiZCIsIkQiLCJBcnJvd1JpZ2h0IiwiaGFuZGxlciJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7cWpCQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7O0FBQ0E7Ozs7Ozs7O0FBRUE7QUFDQSxJQUFNQSxhQUFhLElBQW5COztBQUVBLElBQU1DLHdCQUF3QixDQUE5QjtBQUNBLElBQU1DLGNBQWMsR0FBcEI7O0FBRUEsSUFBTUMsY0FBYztBQUNsQkMsU0FBTyxDQUFDLE9BQUQsQ0FEVztBQUVsQkMsT0FBSyxDQUFDLFVBQUQsRUFBYSxTQUFiLEVBQXdCLFFBQXhCLENBRmE7QUFHbEJDLFNBQU8sQ0FB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QWJnQjtBQWNuQkMsV0FBRyxXQWRnQjtBQWVuQkMsb0JBQVksV0FmTzs7QUFpQm5CLGFBQUssUUFqQmM7QUFrQm5CLGFBQUssUUFsQmM7O0FBb0JuQixhQUFLLFNBcEJjOztBQXNCbkIsYUFBSyxVQXRCYztBQXVCbkIsYUFBSztBQXZCYyxPQUFyQjs7QUEwQkE7QUFDQTtBQUNBLFVBQU1wRCxNQUFNOUMsTUFBTThDLEdBQWxCO0FBQ0EsVUFBTXFELFVBQVViLGFBQWF4QyxHQUFiLENBQWhCO0FBQ0EsVUFBSSxLQUFLMUQsYUFBTCxDQUFtQitHLE9BQW5CLENBQUosRUFBaUM7QUFDL0IsWUFBTTVELG1CQUFtQixLQUFLbkQsYUFBTCxDQUFtQitHLE9BQW5CLEdBQXpCO0FBQ0EsYUFBSzVDLGNBQUwsQ0FBb0JoQixnQkFBcEI7QUFDRDtBQUNGO0FBQ0Q7Ozs7NkJBRVN2QyxLLEVBQU8sQ0FBRTs7Ozs7O2tCQXZWQ2YsZ0IiLCJmaWxlIjoidmlld3BvcnQtY29udHJvbHMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIDIwMTUgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cblxuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuLy8gVEhFIFNPRlRXQVJFLlxuXG5pbXBvcnQgTWFwU3RhdGUgZnJvbSAnLi9tYXAtc3RhdGUnO1xuaW1wb3J0IGFzc2VydCBmcm9tICdhc3NlcnQnO1xuXG4vLyBFVkVOVCBIQU5ETElORyBQQVJBTUVURVJTXG5jb25zdCBaT09NX0FDQ0VMID0gMC4wMTtcblxuY29uc3QgUElUQ0hfTU9VU0VfVEhSRVNIT0xEID0gNTtcbmNvbnN0IFBJVENIX0FDQ0VMID0gMS4yO1xuXG5jb25zdCBFVkVOVF9UWVBFUyA9IHtcbiAgV0hFRUw6IFsnd2hlZWwnXSxcbiAgUEFOOiBbJ3BhbnN0YXJ0JywgJ3Bhbm1vdmUnLCAncGFuZW5kJ10sXG4gIFBJTkNIOiBbJ3BpbmNoc3RhcnQnLCAncGluY2htb3ZlJywgJ3BpbmNoZW5kJ10sXG4gIERPVUJMRV9UQVA6IFsnZG91YmxldGFwJ10sXG4gIEtFWUJPQVJEOiBbJ2tleWRvd24nLCAna2V5dXAnXVxufTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVmlld3BvcnRDb250cm9scyB7XG4gIC8qKlxuICAgKiBAY2xhc3NkZXNjXG4gICAqIEEgY2xhc3MgdGhhdCBoYW5kbGVzIGV2ZW50cyBhbmQgdXBkYXRlcyBtZXJjYXRvciBzdHlsZSB2aWV3cG9ydCBwYXJhbWV0ZXJzXG4gICAqL1xuICBjb25zdHJ1Y3RvcihWaWV3cG9ydFN0YXRlLCBvcHRpb25zID0ge30pIHtcbiAgICBhc3NlcnQoVmlld3BvcnRTdGF0ZSk7XG4gICAgdGhpcy5WaWV3cG9ydFN0YXRlID0gVmlld3BvcnRTdGF0ZTtcbiAgICB0aGlzLnZpZXdwb3J0U3RhdGUgPSBudWxsO1xuICAgIHRoaXMudmlld3BvcnRTdGF0ZVByb3BzID0gbnVsbDtcbiAgICB0aGlzLmV2ZW50TWFuYWdlciA9IG51bGw7XG4gICAgdGhpcy5fZXZlbnRzID0gbnVsbDtcblxuICAgIHRoaXMuX3N0YXRlID0ge1xuICAgICAgaXNEcmFnZ2luZzogZmFsc2VcbiAgICB9O1xuXG4gICAgdGhpcy5oYW5kbGVFdmVudCA9IHRoaXMuaGFuZGxlRXZlbnQuYmluZCh0aGlzKTtcblxuICAgIHRoaXMuc2V0T3B0aW9ucyhvcHRpb25zKTtcblxuICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yID09PSBWaWV3cG9ydENvbnRyb2xzKSB7XG4gICAgICBPYmplY3Quc2VhbCh0aGlzKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2FsbGJhY2sgZm9yIGV2ZW50c1xuICAgKiBAcGFyYW0ge2hhbW1lci5FdmVudH0gZXZlbnRcbiAgICovXG4gIGhhbmRsZUV2ZW50KGV2ZW50KSB7XG4gICAgY29uc3Qge1ZpZXdwb3J0U3RhdGV9ID0gdGhpcztcbiAgICB0aGlzLnZpZXdwb3J0U3RhdGUgPSBuZXcgVmlld3BvcnRTdGF0ZShPYmplY3QuYXNzaWduKHt9LCB0aGlzLnZpZXdwb3J0U3RhdGVQcm9wcywgdGhpcy5fc3RhdGUpKTtcblxuICAgIHN3aXRjaCAoZXZlbnQudHlwZSkge1xuICAgICAgY2FzZSAncGFuc3RhcnQnOlxuICAgICAgICByZXR1cm4gdGhpcy5fb25QYW5TdGFydChldmVudCk7XG4gICAgICBjYXNlICdwYW5tb3ZlJzpcbiAgICAgICAgcmV0dXJuIHRoaXMuX29uUGFuKGV2ZW50KTtcbiAgICAgIGNhc2UgJ3BhbmVuZCc6XG4gICAgICAgIHJldHVybiB0aGlzLl9vblBhbkVuZChldmVudCk7XG4gICAgICBjYXNlICdwaW5jaHN0YXJ0JzpcbiAgICAgICAgcmV0dXJuIHRoaXMuX29uUGluY2hTdGFydChldmVudCk7XG4gICAgICBjYXNlICdwaW5jaCc6XG4gICAgICAgIHJldHVybiB0aGlzLl9vblBpbmNoKGV2ZW50KTtcbiAgICAgIGNhc2UgJ3BpbmNoZW5kJzpcbiAgICAgICAgcmV0dXJuIHRoaXMuX29uUGluY2hFbmQoZXZlbnQpO1xuICAgICAgY2FzZSAnZG91YmxldGFwJzpcbiAgICAgICAgcmV0dXJuIHRoaXMuX29uRG91YmxlVGFwKGV2ZW50KTtcbiAgICAgIGNhc2UgJ3doZWVsJzpcbiAgICAgICAgcmV0dXJuIHRoaXMuX29uV2hlZWwoZXZlbnQpO1xuICAgICAgY2FzZSAna2V5ZG93bic6XG4gICAgICAgIHJldHVybiB0aGlzLl9vbktleURvd24oZXZlbnQpO1xuICAgICAgY2FzZSAna2V5dXAnOlxuICAgICAgICByZXR1cm4gdGhpcy5fb25LZXlVcChldmVudCk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgLyogRXZlbnQgdXRpbHMgKi9cbiAgLy8gRXZlbnQgb2JqZWN0OiBodHRwOi8vaGFtbWVyanMuZ2l0aHViLmlvL2FwaS8jZXZlbnQtb2JqZWN0XG4gIGdldENlbnRlcihldmVudCkge1xuICAgIGNvbnN0IHtvZmZzZXRDZW50ZXI6IHt4LCB5fX0gPSBldmVudDtcbiAgICByZXR1cm4gW3gsIHldO1xuICB9XG5cbiAgaXNGdW5jdGlvbktleVByZXNzZWQoZXZlbnQpIHtcbiAgICBjb25zdCB7c3JjRXZlbnR9ID0gZXZlbnQ7XG4gICAgcmV0dXJuIEJvb2xlYW4oc3JjRXZlbnQubWV0YUtleSB8fCBzcmNFdmVudC5hbHRLZXkgfHwgc3JjRXZlbnQuY3RybEtleSB8fCBzcmNFdmVudC5zaGlmdEtleSk7XG4gIH1cblxuICBpc0RyYWdnaW5nKCkge1xuICAgIHJldHVybiB0aGlzLl9zdGF0ZS5pc0RyYWdnaW5nO1xuICB9XG5cbiAgLyoqXG4gICAqIEV4dHJhY3QgaW50ZXJhY3Rpdml0eSBvcHRpb25zXG4gICAqL1xuICBzZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICBjb25zdCB7XG4gICAgICBvblZpZXdwb3J0Q2hhbmdlLFxuICAgICAgb25TdGF0ZUNoYW5nZSA9IHRoaXMub25TdGF0ZUNoYW5nZSxcbiAgICAgIGV2ZW50TWFuYWdlciA9IHRoaXMuZXZlbnRNYW5hZ2VyLFxuICAgICAgc2Nyb2xsWm9vbSA9IHRydWUsXG4gICAgICBkcmFnUGFuID0gdHJ1ZSxcbiAgICAgIGRyYWdSb3RhdGUgPSB0cnVlLFxuICAgICAgZG91YmxlQ2xpY2tab29tID0gdHJ1ZSxcbiAgICAgIHRvdWNoWm9vbVJvdGF0ZSA9IHRydWUsXG4gICAgICBrZXlib2FyZCA9IHRydWVcbiAgICB9ID0gb3B0aW9ucztcblxuICAgIHRoaXMub25WaWV3cG9ydENoYW5nZSA9IG9uVmlld3BvcnRDaGFuZ2U7XG4gICAgdGhpcy5vblN0YXRlQ2hhbmdlID0gb25TdGF0ZUNoYW5nZTtcbiAgICB0aGlzLnZpZXdwb3J0U3RhdGVQcm9wcyA9IG9wdGlvbnM7XG5cbiAgICBpZiAodGhpcy5ldmVudE1hbmFnZXIgIT09IGV2ZW50TWFuYWdlcikge1xuICAgICAgLy8gRXZlbnRNYW5hZ2VyIGhhcyBjaGFuZ2VkXG4gICAgICB0aGlzLmV2ZW50TWFuYWdlciA9IGV2ZW50TWFuYWdlcjtcbiAgICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuICAgIH1cblxuICAgIC8vIFJlZ2lzdGVyL3VucmVnaXN0ZXIgZXZlbnRzXG4gICAgY29uc3QgaXNJbnRlcmFjdGl2ZSA9IEJvb2xlYW4odGhpcy5vblZpZXdwb3J0Q2hhbmdlKTtcbiAgICB0aGlzLnRvZ2dsZUV2ZW50cyhFVkVOVF9UWVBFUy5XSEVFTCwgaXNJbnRlcmFjdGl2ZSAmJiBzY3JvbGxab29tKTtcbiAgICB0aGlzLnRvZ2dsZUV2ZW50cyhFVkVOVF9UWVBFUy5QQU4sIGlzSW50ZXJhY3RpdmUgJiYgKGRyYWdQYW4gfHwgZHJhZ1JvdGF0ZSkpO1xuICAgIHRoaXMudG9nZ2xlRXZlbnRzKEVWRU5UX1RZUEVTLlBJTkNILCBpc0ludGVyYWN0aXZlICYmIHRvdWNoWm9vbVJvdGF0ZSk7XG4gICAgdGhpcy50b2dnbGVFdmVudHMoRVZFTlRfVFlQRVMuRE9VQkxFX1RBUCwgaXNJbnRlcmFjdGl2ZSAmJiBkb3VibGVDbGlja1pvb20pO1xuICAgIHRoaXMudG9nZ2xlRXZlbnRzKEVWRU5UX1RZUEVTLktFWUJPQVJELCBpc0ludGVyYWN0aXZlICYmIGtleWJvYXJkKTtcblxuICAgIHRoaXMuc2Nyb2xsWm9vbSA9IHNjcm9sbFpvb207XG4gICAgdGhpcy5kcmFnUGFuID0gZHJhZ1BhbjtcbiAgICB0aGlzLmRyYWdSb3RhdGUgPSBkcmFnUm90YXRlO1xuICAgIHRoaXMuZG91YmxlQ2xpY2tab29tID0gZG91YmxlQ2xpY2tab29tO1xuICAgIHRoaXMudG91Y2hab29tUm90YXRlID0gdG91Y2hab29tUm90YXRlO1xuICB9XG5cbiAgdG9nZ2xlRXZlbnRzKGV2ZW50TmFtZXMsIGVuYWJsZWQpIHtcbiAgICBpZiAodGhpcy5ldmVudE1hbmFnZXIpIHtcbiAgICAgIGV2ZW50TmFtZXMuZm9yRWFjaChldmVudE5hbWUgPT4ge1xuICAgICAgICBpZiAodGhpcy5fZXZlbnRzW2V2ZW50TmFtZV0gIT09IGVuYWJsZWQpIHtcbiAgICAgICAgICB0aGlzLl9ldmVudHNbZXZlbnROYW1lXSA9IGVuYWJsZWQ7XG4gICAgICAgICAgaWYgKGVuYWJsZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRNYW5hZ2VyLm9uKGV2ZW50TmFtZSwgdGhpcy5oYW5kbGVFdmVudCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRNYW5hZ2VyLm9mZihldmVudE5hbWUsIHRoaXMuaGFuZGxlRXZlbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLy8gUHJpdmF0ZSBNZXRob2RzXG5cbiAgc2V0U3RhdGUobmV3U3RhdGUpIHtcbiAgICBPYmplY3QuYXNzaWduKHRoaXMuX3N0YXRlLCBuZXdTdGF0ZSk7XG4gICAgaWYgKHRoaXMub25TdGF0ZUNoYW5nZSkge1xuICAgICAgdGhpcy5vblN0YXRlQ2hhbmdlKHRoaXMuX3N0YXRlKTtcbiAgICB9XG4gIH1cblxuICAvKiBDYWxsYmFjayB1dGlsICovXG4gIC8vIGZvcm1hdHMgbWFwIHN0YXRlIGFuZCBpbnZva2VzIGNhbGxiYWNrIGZ1bmN0aW9uXG4gIHVwZGF0ZVZpZXdwb3J0KG5ld1ZpZXdwb3J0U3RhdGUsIGV4dHJhU3RhdGUgPSB7fSkge1xuICAgIGNvbnN0IG9sZFZpZXdwb3J0ID0gdGhpcy52aWV3cG9ydFN0YXRlLmdldFZpZXdwb3J0UHJvcHMoKTtcbiAgICBjb25zdCBuZXdWaWV3cG9ydCA9IG5ld1ZpZXdwb3J0U3RhdGUuZ2V0Vmlld3BvcnRQcm9wcygpO1xuXG4gICAgaWYgKFxuICAgICAgdGhpcy5vblZpZXdwb3J0Q2hhbmdlICYmXG4gICAgICBPYmplY3Qua2V5cyhuZXdWaWV3cG9ydCkuc29tZShrZXkgPT4gb2xkVmlld3BvcnRba2V5XSAhPT0gbmV3Vmlld3BvcnRba2V5XSlcbiAgICApIHtcbiAgICAgIC8vIFZpZXdwb3J0IGhhcyBjaGFuZ2VkXG4gICAgICBjb25zdCB2aWV3cG9ydCA9IHRoaXMudmlld3BvcnRTdGF0ZS5nZXRWaWV3cG9ydCA/IHRoaXMudmlld3BvcnRTdGF0ZS5nZXRWaWV3cG9ydCgpIDogbnVsbDtcbiAgICAgIHRoaXMub25WaWV3cG9ydENoYW5nZShuZXdWaWV3cG9ydCwgdmlld3BvcnQpO1xuICAgIH1cblxuICAgIHRoaXMuc2V0U3RhdGUoT2JqZWN0LmFzc2lnbih7fSwgbmV3Vmlld3BvcnRTdGF0ZS5nZXRJbnRlcmFjdGl2ZVN0YXRlKCksIGV4dHJhU3RhdGUpKTtcbiAgfVxuXG4gIC8qIEV2ZW50IGhhbmRsZXJzICovXG4gIC8vIERlZmF1bHQgaGFuZGxlciBmb3IgdGhlIGBwYW5zdGFydGAgZXZlbnQuXG4gIF9vblBhblN0YXJ0KGV2ZW50KSB7XG4gICAgY29uc3QgcG9zID0gdGhpcy5nZXRDZW50ZXIoZXZlbnQpO1xuICAgIGNvbnN0IG5ld1ZpZXdwb3J0U3RhdGUgPSB0aGlzLnZpZXdwb3J0U3RhdGUucGFuU3RhcnQoe3Bvc30pLnJvdGF0ZVN0YXJ0KHtwb3N9KTtcbiAgICByZXR1cm4gdGhpcy51cGRhdGVWaWV3cG9ydChuZXdWaWV3cG9ydFN0YXRlLCB7aXNEcmFnZ2luZzogdHJ1ZX0pO1xuICB9XG5cbiAgLy8gRGVmYXVsdCBoYW5kbGVyIGZvciB0aGUgYHBhbm1vdmVgIGV2ZW50LlxuICBfb25QYW4oZXZlbnQpIHtcbiAgICByZXR1cm4gdGhpcy5pc0Z1bmN0aW9uS2V5UHJlc3NlZChldmVudCkgPyB0aGlzLl9vblBhbk1vdmUoZXZlbnQpIDogdGhpcy5fb25QYW5Sb3RhdGUoZXZlbnQpO1xuICB9XG5cbiAgLy8gRGVmYXVsdCBoYW5kbGVyIGZvciB0aGUgYHBhbmVuZGAgZXZlbnQuXG4gIF9vblBhbkVuZChldmVudCkge1xuICAgIGNvbnN0IG5ld1ZpZXdwb3J0U3RhdGUgPSB0aGlzLnZpZXdwb3J0U3RhdGUucGFuRW5kKCkucm90YXRlRW5kKCk7XG4gICAgcmV0dXJuIHRoaXMudXBkYXRlVmlld3BvcnQobmV3Vmlld3BvcnRTdGF0ZSwge2lzRHJhZ2dpbmc6IGZhbHNlfSk7XG4gIH1cblxuICAvLyBEZWZhdWx0IGhhbmRsZXIgZm9yIHBhbm5pbmcgdG8gbW92ZS5cbiAgLy8gQ2FsbGVkIGJ5IGBfb25QYW5gIHdoZW4gcGFubmluZyB3aXRob3V0IGZ1bmN0aW9uIGtleSBwcmVzc2VkLlxuICBfb25QYW5Nb3ZlKGV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLmRyYWdQYW4pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgcG9zID0gdGhpcy5nZXRDZW50ZXIoZXZlbnQpO1xuICAgIGNvbnN0IG5ld1ZpZXdwb3J0U3RhdGUgPSB0aGlzLnZpZXdwb3J0U3RhdGUucGFuKHtwb3N9KTtcbiAgICByZXR1cm4gdGhpcy51cGRhdGVWaWV3cG9ydChuZXdWaWV3cG9ydFN0YXRlKTtcbiAgfVxuXG4gIC8vIERlZmF1bHQgaGFuZGxlciBmb3IgcGFubmluZyB0byByb3RhdGUuXG4gIC8vIENhbGxlZCBieSBgX29uUGFuYCB3aGVuIHBhbm5pbmcgd2l0aCBmdW5jdGlvbiBrZXkgcHJlc3NlZC5cbiAgX29uUGFuUm90YXRlKGV2ZW50KSB7XG4gICAgcmV0dXJuIHRoaXMudmlld3BvcnRTdGF0ZSBpbnN0YW5jZW9mIE1hcFN0YXRlXG4gICAgICA/IHRoaXMuX29uUGFuUm90YXRlTWFwKGV2ZW50KVxuICAgICAgOiB0aGlzLl9vblBhblJvdGF0ZVN0YW5kYXJkKGV2ZW50KTtcbiAgfVxuXG4gIC8vIE5vcm1hbCBwYW4gdG8gcm90YXRlXG4gIF9vblBhblJvdGF0ZVN0YW5kYXJkKGV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLmRyYWdSb3RhdGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBjb25zdCB7ZGVsdGFYLCBkZWx0YVl9ID0gZXZlbnQ7XG4gICAgY29uc3Qge3dpZHRoLCBoZWlnaHR9ID0gdGhpcy52aWV3cG9ydFN0YXRlLmdldFZpZXdwb3J0UHJvcHMoKTtcblxuICAgIGNvbnN0IGRlbHRhU2NhbGVYID0gZGVsdGFYIC8gd2lkdGg7XG4gICAgY29uc3QgZGVsdGFTY2FsZVkgPSBkZWx0YVkgLyBoZWlnaHQ7XG5cbiAgICBjb25zdCBuZXdWaWV3cG9ydFN0YXRlID0gdGhpcy52aWV3cG9ydFN0YXRlLnJvdGF0ZSh7ZGVsdGFTY2FsZVgsIGRlbHRhU2NhbGVZfSk7XG4gICAgcmV0dXJuIHRoaXMudXBkYXRlVmlld3BvcnQobmV3Vmlld3BvcnRTdGF0ZSk7XG4gIH1cblxuICAvLyBNYXAgc3BlY2lmaWMgcGFuIHRvIHJvdGF0ZVxuICAvLyBUT0RPIC0gaXMgdGhpcyBtYXBTdGF0ZVNwZWNpZmljP1xuICBfb25QYW5Sb3RhdGVNYXAoZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMuZHJhZ1JvdGF0ZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGNvbnN0IHtkZWx0YVgsIGRlbHRhWX0gPSBldmVudDtcbiAgICBjb25zdCBbLCBjZW50ZXJZXSA9IHRoaXMuZ2V0Q2VudGVyKGV2ZW50KTtcbiAgICBjb25zdCBzdGFydFkgPSBjZW50ZXJZIC0gZGVsdGFZO1xuICAgIGNvbnN0IHt3aWR0aCwgaGVpZ2h0fSA9IHRoaXMudmlld3BvcnRTdGF0ZS5nZXRWaWV3cG9ydFByb3BzKCk7XG5cbiAgICBjb25zdCBkZWx0YVNjYWxlWCA9IGRlbHRhWCAvIHdpZHRoO1xuICAgIGxldCBkZWx0YVNjYWxlWSA9IDA7XG5cbiAgICBpZiAoZGVsdGFZID4gMCkge1xuICAgICAgaWYgKE1hdGguYWJzKGhlaWdodCAtIHN0YXJ0WSkgPiBQSVRDSF9NT1VTRV9USFJFU0hPTEQpIHtcbiAgICAgICAgLy8gTW92ZSBmcm9tIDAgdG8gLTEgYXMgd2UgZHJhZyB1cHdhcmRzXG4gICAgICAgIGRlbHRhU2NhbGVZID0gZGVsdGFZIC8gKHN0YXJ0WSAtIGhlaWdodCkgKiBQSVRDSF9BQ0NFTDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGRlbHRhWSA8IDApIHtcbiAgICAgIGlmIChzdGFydFkgPiBQSVRDSF9NT1VTRV9USFJFU0hPTEQpIHtcbiAgICAgICAgLy8gTW92ZSBmcm9tIDAgdG8gMSBhcyB3ZSBkcmFnIHVwd2FyZHNcbiAgICAgICAgZGVsdGFTY2FsZVkgPSAxIC0gY2VudGVyWSAvIHN0YXJ0WTtcbiAgICAgIH1cbiAgICB9XG4gICAgZGVsdGFTY2FsZVkgPSBNYXRoLm1pbigxLCBNYXRoLm1heCgtMSwgZGVsdGFTY2FsZVkpKTtcblxuICAgIGNvbnN0IG5ld01hcFN0YXRlID0gdGhpcy52aWV3cG9ydFN0YXRlLnJvdGF0ZSh7ZGVsdGFTY2FsZVgsIGRlbHRhU2NhbGVZfSk7XG4gICAgcmV0dXJuIHRoaXMudXBkYXRlVmlld3BvcnQobmV3TWFwU3RhdGUpO1xuICB9XG5cbiAgLy8gRGVmYXVsdCBoYW5kbGVyIGZvciB0aGUgYHdoZWVsYCBldmVudC5cbiAgX29uV2hlZWwoZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMuc2Nyb2xsWm9vbSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBldmVudC5zcmNFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgY29uc3QgcG9zID0gdGhpcy5nZXRDZW50ZXIoZXZlbnQpO1xuICAgIGNvbnN0IHtkZWx0YX0gPSBldmVudDtcblxuICAgIC8vIE1hcCB3aGVlbCBkZWx0YSB0byByZWxhdGl2ZSBzY2FsZVxuICAgIGxldCBzY2FsZSA9IDIgLyAoMSArIE1hdGguZXhwKC1NYXRoLmFicyhkZWx0YSAqIFpPT01fQUNDRUwpKSk7XG4gICAgaWYgKGRlbHRhIDwgMCAmJiBzY2FsZSAhPT0gMCkge1xuICAgICAgc2NhbGUgPSAxIC8gc2NhbGU7XG4gICAgfVxuXG4gICAgY29uc3QgbmV3Vmlld3BvcnRTdGF0ZSA9IHRoaXMudmlld3BvcnRTdGF0ZS56b29tKHtwb3MsIHNjYWxlfSk7XG4gICAgcmV0dXJuIHRoaXMudXBkYXRlVmlld3BvcnQobmV3Vmlld3BvcnRTdGF0ZSk7XG4gIH1cblxuICAvLyBEZWZhdWx0IGhhbmRsZXIgZm9yIHRoZSBgcGluY2hzdGFydGAgZXZlbnQuXG4gIF9vblBpbmNoU3RhcnQoZXZlbnQpIHtcbiAgICBjb25zdCBwb3MgPSB0aGlzLmdldENlbnRlcihldmVudCk7XG4gICAgY29uc3QgbmV3Vmlld3BvcnRTdGF0ZSA9IHRoaXMudmlld3BvcnRTdGF0ZS56b29tU3RhcnQoe3Bvc30pO1xuICAgIHJldHVybiB0aGlzLnVwZGF0ZVZpZXdwb3J0KG5ld1ZpZXdwb3J0U3RhdGUsIHtpc0RyYWdnaW5nOiB0cnVlfSk7XG4gIH1cblxuICAvLyBEZWZhdWx0IGhhbmRsZXIgZm9yIHRoZSBgcGluY2hgIGV2ZW50LlxuICBfb25QaW5jaChldmVudCkge1xuICAgIGlmICghdGhpcy50b3VjaFpvb21Sb3RhdGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgcG9zID0gdGhpcy5nZXRDZW50ZXIoZXZlbnQpO1xuICAgIGNvbnN0IHtzY2FsZX0gPSBldmVudDtcbiAgICBjb25zdCBuZXdWaWV3cG9ydFN0YXRlID0gdGhpcy52aWV3cG9ydFN0YXRlLnpvb20oe3Bvcywgc2NhbGV9KTtcbiAgICByZXR1cm4gdGhpcy51cGRhdGVWaWV3cG9ydChuZXdWaWV3cG9ydFN0YXRlKTtcbiAgfVxuXG4gIC8vIERlZmF1bHQgaGFuZGxlciBmb3IgdGhlIGBwaW5jaGVuZGAgZXZlbnQuXG4gIF9vblBpbmNoRW5kKGV2ZW50KSB7XG4gICAgY29uc3QgbmV3Vmlld3BvcnRTdGF0ZSA9IHRoaXMudmlld3BvcnRTdGF0ZS56b29tRW5kKCk7XG4gICAgcmV0dXJuIHRoaXMudXBkYXRlVmlld3BvcnQobmV3Vmlld3BvcnRTdGF0ZSwge2lzRHJhZ2dpbmc6IGZhbHNlfSk7XG4gIH1cblxuICAvLyBEZWZhdWx0IGhhbmRsZXIgZm9yIHRoZSBgZG91YmxldGFwYCBldmVudC5cbiAgX29uRG91YmxlVGFwKGV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLmRvdWJsZUNsaWNrWm9vbSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBwb3MgPSB0aGlzLmdldENlbnRlcihldmVudCk7XG4gICAgY29uc3QgaXNab29tT3V0ID0gdGhpcy5pc0Z1bmN0aW9uS2V5UHJlc3NlZChldmVudCk7XG5cbiAgICBjb25zdCBuZXdWaWV3cG9ydFN0YXRlID0gdGhpcy52aWV3cG9ydFN0YXRlLnpvb20oe3Bvcywgc2NhbGU6IGlzWm9vbU91dCA/IDAuNSA6IDJ9KTtcbiAgICByZXR1cm4gdGhpcy51cGRhdGVWaWV3cG9ydChuZXdWaWV3cG9ydFN0YXRlKTtcbiAgfVxuXG4gIF9vbktleURvd24oZXZlbnQpIHtcbiAgICBpZiAodGhpcy52aWV3cG9ydFN0YXRlLmlzRHJhZ2dpbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBLRVlfQklORElOR1MgPSB7XG4gICAgICB3OiAnbW92ZUZvcndhcmQnLFxuICAgICAgVzogJ21vdmVGb3J3YXJkJyxcbiAgICAgIEFycm93VXA6ICdtb3ZlRm9yd2FyZCcsXG5cbiAgICAgIHM6ICdtb3ZlQmFja3dhcmQnLFxuICAgICAgUzogJ21vdmVCYWNrd2FyZCcsXG4gICAgICBBcnJvd0Rvd246ICdtb3ZlQmFja3dhcmQnLFxuXG4gICAgICBhOiAnbW92ZUxlZnQnLFxuICAgICAgQTogJ21vdmVMZWZ0JyxcbiAgICAgIEFycm93TGVmdDogJ21vdmVMZWZ0JyxcblxuICAgICAgZDogJ21vdmVSaWdodCcsXG4gICAgICBEOiAnbW92ZVJpZ2h0JyxcbiAgICAgIEFycm93UmlnaHQ6ICdtb3ZlUmlnaHQnLFxuXG4gICAgICAnPSc6ICd6b29tSW4nLFxuICAgICAgJysnOiAnem9vbUluJyxcblxuICAgICAgJy0nOiAnem9vbU91dCcsXG5cbiAgICAgICdbJzogJ21vdmVEb3duJyxcbiAgICAgICddJzogJ21vdmVVcCdcbiAgICB9O1xuXG4gICAgLy8ga2V5Q29kZSBpcyBkZXByZWNhdGVkIGZyb20gd2ViIHN0YW5kYXJkc1xuICAgIC8vIGNvZGUgaXMgbm90IHN1cHBvcnRlZCBieSBJRS9FZGdlXG4gICAgY29uc3Qga2V5ID0gZXZlbnQua2V5O1xuICAgIGNvbnN0IGhhbmRsZXIgPSBLRVlfQklORElOR1Nba2V5XTtcbiAgICBpZiAodGhpcy52aWV3cG9ydFN0YXRlW2hhbmRsZXJdKSB7XG4gICAgICBjb25zdCBuZXdWaWV3cG9ydFN0YXRlID0gdGhpcy52aWV3cG9ydFN0YXRlW2hhbmRsZXJdKCk7XG4gICAgICB0aGlzLnVwZGF0ZVZpZXdwb3J0KG5ld1ZpZXdwb3J0U3RhdGUpO1xuICAgIH1cbiAgfVxuICAvKiBlc2xpbnQtZW5hYmxlIGNvbXBsZXhpdHkgKi9cblxuICBfb25LZXlVcChldmVudCkge31cbn1cbiJdfQ==