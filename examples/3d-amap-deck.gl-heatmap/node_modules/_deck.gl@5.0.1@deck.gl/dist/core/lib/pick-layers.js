'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.pickObject = pickObject;
exports.pickVisibleObjects = pickVisibleObjects;
exports.getClosestFromPickingBuffer = getClosestFromPickingBuffer;

var _drawLayers = require('./draw-layers');

var _log = require('../utils/log');

var _log2 = _interopRequireDefault(_log);

var _assert = require('assert');

var _assert2 = _interopRequireDefault(_assert);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var NO_PICKED_OBJECT = {
  pickedColor: null,
  pickedLayer: null,
  pickedObjectIndex: -1
};

/* eslint-disable max-depth, max-statements */
// Pick the closest object at the given (x,y) coordinate
// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

function pickObject(gl, _ref) {
  var layers = _ref.layers,
      viewports = _ref.viewports,
      x = _ref.x,
      y = _ref.y,
      radius = _ref.radius,
      layerFilter = _ref.layerFilter,
      mode = _ref.mode,
      onViewportActive = _ref.onViewportActive,
      pickingFBO = _ref.pickingFBO,
      lastPickedInfo = _ref.lastPickedInfo,
      useDevicePixels = _ref.useDevicePixels;

  // Convert from canvas top-left to WebGL bottom-left coordinates
  // And compensate for pixelRatio
  var pixelRatio = (0, _drawLayers.getPixelRatio)({ useDevicePixels: useDevicePixels });
  var deviceX = Math.round(x * pixelRatio);
  var deviceY = Math.round(gl.canvas.height - y * pixelRatio);
  var deviceRadius = Math.round(radius * pixelRatio);

  var deviceRect = getPickingRect({
    deviceX: deviceX,
    deviceY: deviceY,
    deviceRadius: deviceRadius,
    deviceWidth: pickingFBO.width,
    deviceHeight: pickingFBO.height
  });

  var pickedColors = deviceRect && drawAndSamplePickingBuffer(gl, {
    layers: layers,
    viewports: viewports,
    onViewportActive: onViewportActive,
    useDevicePixels: useDevicePixels,
    pickingFBO: pickingFBO,
    deviceRect: deviceRect,
    layerFilter: layerFilter,
    redrawReason: mode
  });

  var pickInfo = pickedColors && getClosestFromPickingBuffer(gl, {
    pickedColors: pickedColors,
    layers: layers,
    deviceX: deviceX,
    deviceY: deviceY,
    deviceRadius: deviceRadius,
    deviceRect: deviceRect
  }) || NO_PICKED_OBJECT;

  return processPickInfo({
    pickInfo: pickInfo,
    lastPickedInfo: lastPickedInfo,
    mode: mode,
    layers: layers,
    viewports: viewports,
    x: x,
    y: y,
    deviceX: deviceX,
    deviceY: deviceY,
    pixelRatio: pixelRatio
  });
}

// Pick all objects within the given bounding box
function pickVisibleObjects(gl, _ref2) {
  var layers = _ref2.layers,
      viewports = _ref2.viewports,
      x = _ref2.x,
      y = _ref2.y,
      width = _ref2.width,
      height = _ref2.height,
      mode = _ref2.mode,
      layerFilter = _ref2.layerFilter,
      onViewportActive = _ref2.onViewportActive,
      pickingFBO = _ref2.pickingFBO,
      useDevicePixels = _ref2.useDevicePixels;

  // Convert from canvas top-left to WebGL bottom-left coordinates
  // And compensate for pixelRatio
  var pixelRatio = (0, _drawLayers.getPixelRatio)({ useDevicePixels: useDevicePixels });

  var deviceLeft = Math.round(x * pixelRatio);
  var deviceBottom = Math.round(gl.canvas.height - y * pixelRatio);
  var deviceRight = Math.round((x + width) * pixelRatio);
  var deviceTop = Math.round(gl.canvas.height - (y + height) * pixelRatio);

  var deviceRect = {
    x: deviceLeft,
    y: deviceTop,
    width: deviceRight - deviceLeft,
    height: deviceBottom - deviceTop
  };

  var pickedColors = drawAndSamplePickingBuffer(gl, {
    layers: layers,
    viewports: viewports,
    onViewportActive: onViewportActive,
    pickingFBO: pickingFBO,
    useDevicePixels: useDevicePixels,
    deviceRect: deviceRect,
    layerFilter: layerFilter,
    redrawReason: mode
  });

  var pickInfos = getUniquesFromPickingBuffer(gl, { pickedColors: pickedColors, layers: layers });

  // Only return unique infos, identified by info.object
  var uniqueInfos = new Map();

  pickInfos.forEach(function (pickInfo) {
    var viewport = getViewportFromCoordinates({ viewports: viewports }); // TODO - add coords
    var info = createInfo([pickInfo.x / pixelRatio, pickInfo.y / pixelRatio], viewport);
    info.devicePixel = [pickInfo.x, pickInfo.y];
    info.pixelRatio = pixelRatio;
    info.color = pickInfo.pickedColor;
    info.index = pickInfo.pickedObjectIndex;
    info.picked = true;

    info = getLayerPickingInfo({ layer: pickInfo.pickedLayer, info: info, mode: mode });
    if (!uniqueInfos.has(info.object)) {
      uniqueInfos.set(info.object, info);
    }
  });

  return Array.from(uniqueInfos.values());
}

// HELPER METHODS

// returns pickedColor or null if no pickable layers found.
function drawAndSamplePickingBuffer(gl, _ref3) {
  var layers = _ref3.layers,
      viewports = _ref3.viewports,
      onViewportActive = _ref3.onViewportActive,
      useDevicePixels = _ref3.useDevicePixels,
      pickingFBO = _ref3.pickingFBO,
      deviceRect = _ref3.deviceRect,
      layerFilter = _ref3.layerFilter,
      redrawReason = _ref3.redrawReason;

  (0, _assert2.default)(deviceRect);
  (0, _assert2.default)(Number.isFinite(deviceRect.width) && deviceRect.width > 0, '`width` must be > 0');
  (0, _assert2.default)(Number.isFinite(deviceRect.height) && deviceRect.height > 0, '`height` must be > 0');

  var pickableLayers = layers.filter(function (layer) {
    return layer.isPickable();
  });
  if (pickableLayers.length < 1) {
    return null;
  }

  (0, _drawLayers.drawPickingBuffer)(gl, {
    layers: layers,
    viewports: viewports,
    onViewportActive: onViewportActive,
    useDevicePixels: useDevicePixels,
    pickingFBO: pickingFBO,
    deviceRect: deviceRect,
    layerFilter: layerFilter,
    redrawReason: redrawReason
  });

  // Read from an already rendered picking buffer
  // Returns an Uint8ClampedArray of picked pixels
  var x = deviceRect.x,
      y = deviceRect.y,
      width = deviceRect.width,
      height = deviceRect.height;

  var pickedColors = new Uint8Array(width * height * 4);
  pickingFBO.readPixels({ x: x, y: y, width: width, height: height, pixelArray: pickedColors });
  return pickedColors;
}

// Indentifies which viewport, if any corresponds to x and y
// Returns first viewport if no match
// TODO - need to determine which viewport we are in
// TODO - document concept of "primary viewport" that matches all coords?
// TODO - static method on Viewport class?
function getViewportFromCoordinates(_ref4) {
  var viewports = _ref4.viewports;

  var viewport = viewports[0];
  return viewport;
}

// Calculate a picking rect centered on deviceX and deviceY and clipped to device
// Returns null if pixel is outside of device
function getPickingRect(_ref5) {
  var deviceX = _ref5.deviceX,
      deviceY = _ref5.deviceY,
      deviceRadius = _ref5.deviceRadius,
      deviceWidth = _ref5.deviceWidth,
      deviceHeight = _ref5.deviceHeight;

  var valid = deviceX >= 0 && deviceY >= 0 && deviceX < deviceWidth && deviceY < deviceHeight;

  // x, y out of bounds.
  if (!valid) {
    return null;
  }

  // Create a box of size `radius * 2 + 1` centered at [deviceX, deviceY]
  var x = Math.max(0, deviceX - deviceRadius);
  var y = Math.max(0, deviceY - deviceRadius);
  var width = Math.min(deviceWidth, deviceX + deviceRadius) - x + 1;
  var height = Math.min(deviceHeight, deviceY + deviceRadius) - y + 1;

  return { x: x, y: y, width: width, height: height };
}

// TODO - break this monster function into 3+ parts
function processPickInfo(_ref6) {
  var pickInfo = _ref6.pickInfo,
      lastPickedInfo = _ref6.lastPickedInfo,
      mode = _ref6.mode,
      layers = _ref6.layers,
      viewports = _ref6.viewports,
      x = _ref6.x,
      y = _ref6.y,
      deviceX = _ref6.deviceX,
      deviceY = _ref6.deviceY,
      pixelRatio = _ref6.pixelRatio;
  var pickedColor = pickInfo.pickedColor,
      pickedLayer = pickInfo.pickedLayer,
      pickedObjectIndex = pickInfo.pickedObjectIndex;


  var affectedLayers = pickedLayer ? [pickedLayer] : [];

  if (mode === 'hover') {
    // only invoke onHover events if picked object has changed
    var lastPickedObjectIndex = lastPickedInfo.index;
    var lastPickedLayerId = lastPickedInfo.layerId;
    var pickedLayerId = pickedLayer && pickedLayer.props.id;

    // proceed only if picked object changed
    if (pickedLayerId !== lastPickedLayerId || pickedObjectIndex !== lastPickedObjectIndex) {
      if (pickedLayerId !== lastPickedLayerId) {
        // We cannot store a ref to lastPickedLayer in the context because
        // the state of an outdated layer is no longer valid
        // and the props may have changed
        var lastPickedLayer = layers.find(function (layer) {
          return layer.props.id === lastPickedLayerId;
        });
        if (lastPickedLayer) {
          // Let leave event fire before enter event
          affectedLayers.unshift(lastPickedLayer);
        }
      }

      // Update layer manager context
      lastPickedInfo.layerId = pickedLayerId;
      lastPickedInfo.index = pickedObjectIndex;
    }
  }

  var viewport = getViewportFromCoordinates({ viewports: viewports }); // TODO - add coords

  var baseInfo = createInfo([x, y], viewport);
  baseInfo.devicePixel = [deviceX, deviceY];
  baseInfo.pixelRatio = pixelRatio;

  // Use a Map to store all picking infos.
  // The following two forEach loops are the result of
  // https://github.com/uber/deck.gl/issues/443
  // Please be very careful when changing this pattern
  var infos = new Map();

  affectedLayers.forEach(function (layer) {
    var info = Object.assign({}, baseInfo);

    if (layer === pickedLayer) {
      info.color = pickedColor;
      info.index = pickedObjectIndex;
      info.picked = true;
    }

    info = getLayerPickingInfo({ layer: layer, info: info, mode: mode });

    // This guarantees that there will be only one copy of info for
    // one composite layer
    if (info) {
      infos.set(info.layer.id, info);
    }

    var pickingSelectedColor = layer.props.autoHighlight && pickedLayer === layer ? pickedColor : null;

    var pickingParameters = {
      pickingSelectedColor: pickingSelectedColor
    };

    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = layer.getModels()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var model = _step.value;

        model.updateModuleSettings(pickingParameters);
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
  });

  var unhandledPickInfos = callLayerPickingCallbacks(infos, mode);

  return unhandledPickInfos;
}

// Per-layer event handlers (e.g. onClick, onHover) are provided by the
// user and out of deck.gl's control. It's very much possible that
// the user calls React lifecycle methods in these function, such as
// ReactComponent.setState(). React lifecycle methods sometimes induce
// a re-render and re-generation of props of deck.gl and its layers,
// which invalidates all layers currently passed to this very function.

// Therefore, per-layer event handlers must be invoked at the end
// of the picking operation. NO operation that relies on the states of current
// layers should be called after this code.
function callLayerPickingCallbacks(infos, mode) {
  var unhandledPickInfos = [];

  infos.forEach(function (info) {
    var handled = false;
    switch (mode) {
      case 'click':
        handled = info.layer.props.onClick(info);
        break;
      case 'hover':
        handled = info.layer.props.onHover(info);
        break;
      case 'query':
        break;
      default:
        throw new Error('unknown pick type');
    }

    if (!handled) {
      unhandledPickInfos.push(info);
    }
  });

  return unhandledPickInfos;
}

/**
 * Pick at a specified pixel with a tolerance radius
 * Returns the closest object to the pixel in shape `{pickedColor, pickedLayer, pickedObjectIndex}`
 */
function getClosestFromPickingBuffer(gl, _ref7) {
  var pickedColors = _ref7.pickedColors,
      layers = _ref7.layers,
      deviceX = _ref7.deviceX,
      deviceY = _ref7.deviceY,
      deviceRadius = _ref7.deviceRadius,
      deviceRect = _ref7.deviceRect;

  (0, _assert2.default)(pickedColors);

  // Traverse all pixels in picking results and find the one closest to the supplied
  // [deviceX, deviceY]
  var x = deviceRect.x,
      y = deviceRect.y,
      width = deviceRect.width,
      height = deviceRect.height;

  var minSquareDistanceToCenter = deviceRadius * deviceRadius;
  var closestPixelIndex = -1;
  var i = 0;

  for (var row = 0; row < height; row++) {
    var dy = row + y - deviceY;
    var dy2 = dy * dy;

    if (dy2 > minSquareDistanceToCenter) {
      // skip this row
      i += 4 * width;
    } else {
      for (var col = 0; col < width; col++) {
        // Decode picked layer from color
        var pickedLayerIndex = pickedColors[i + 3] - 1;

        if (pickedLayerIndex >= 0) {
          var dx = col + x - deviceX;
          var d2 = dx * dx + dy2;

          if (d2 <= minSquareDistanceToCenter) {
            minSquareDistanceToCenter = d2;
            closestPixelIndex = i;
          }
        }
        i += 4;
      }
    }
  }

  if (closestPixelIndex >= 0) {
    // Decode picked object index from color
    var _pickedLayerIndex = pickedColors[closestPixelIndex + 3] - 1;
    var pickedColor = pickedColors.slice(closestPixelIndex, closestPixelIndex + 4);
    var pickedLayer = layers[_pickedLayerIndex];
    if (pickedLayer) {
      var pickedObjectIndex = pickedLayer.decodePickingColor(pickedColor);
      return { pickedColor: pickedColor, pickedLayer: pickedLayer, pickedObjectIndex: pickedObjectIndex };
    }
    _log2.default.error('Picked non-existent layer. Is picking buffer corrupt?');
  }

  return NO_PICKED_OBJECT;
}
/* eslint-enable max-depth, max-statements */

/**
 * Examines a picking buffer for unique colors
 * Returns array of unique objects in shape `{x, y, pickedColor, pickedLayer, pickedObjectIndex}`
 */
function getUniquesFromPickingBuffer(gl, _ref8) {
  var pickedColors = _ref8.pickedColors,
      layers = _ref8.layers;

  var uniqueColors = new Map();

  // Traverse all pixels in picking results and get unique colors
  if (pickedColors) {
    for (var i = 0; i < pickedColors.length; i += 4) {
      // Decode picked layer from color
      var pickedLayerIndex = pickedColors[i + 3] - 1;

      if (pickedLayerIndex >= 0) {
        var pickedColor = pickedColors.slice(i, i + 4);
        var colorKey = pickedColor.join(',');
        // eslint-disable-next-line
        if (!uniqueColors.has(colorKey)) {
          var pickedLayer = layers[pickedLayerIndex];
          // eslint-disable-next-line
          if (pickedLayer) {
            uniqueColors.set(colorKey, {
              pickedColor: pickedColor,
              pickedLayer: pickedLayer,
              pickedObjectIndex: pickedLayer.decodePickingColor(pickedColor)
            });
          } else {
            _log2.default.error('Picked non-existent layer. Is picking buffer corrupt?');
          }
        }
      }
    }
  }

  return Array.from(uniqueColors.values());
}

function createInfo(pixel, viewport) {
  // Assign a number of potentially useful props to the "info" object
  return {
    color: null,
    layer: null,
    index: -1,
    picked: false,
    x: pixel[0],
    y: pixel[1],
    pixel: pixel,
    lngLat: viewport.unproject(pixel)
  };
}

// Walk up the layer composite chain to populate the info object
function getLayerPickingInfo(_ref9) {
  var layer = _ref9.layer,
      info = _ref9.info,
      mode = _ref9.mode;

  while (layer && info) {
    // For a composite layer, sourceLayer will point to the sublayer
    // where the event originates from.
    // It provides additional context for the composite layer's
    // getPickingInfo() method to populate the info object
    var sourceLayer = info.layer || layer;
    info.layer = layer;
    // layer.pickLayer() function requires a non-null ```layer.state```
    // object to funtion properly. So the layer refereced here
    // must be the "current" layer, not an "out-dated" / "invalidated" layer
    info = layer.pickLayer({ info: info, mode: mode, sourceLayer: sourceLayer });
    layer = layer.parentLayer;
  }
  return info;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9jb3JlL2xpYi9waWNrLWxheWVycy5qcyJdLCJuYW1lcyI6WyJwaWNrT2JqZWN0IiwicGlja1Zpc2libGVPYmplY3RzIiwiZ2V0Q2xvc2VzdEZyb21QaWNraW5nQnVmZmVyIiwiTk9fUElDS0VEX09CSkVDVCIsInBpY2tlZENvbG9yIiwicGlja2VkTGF5ZXIiLCJwaWNrZWRPYmplY3RJbmRleCIsImdsIiwibGF5ZXJzIiwidmlld3BvcnRzIiwieCIsInkiLCJyYWRpdXMiLCJsYXllckZpbHRlciIsIm1vZGUiLCJvblZpZXdwb3J0QWN0aXZlIiwicGlja2luZ0ZCTyIsImxhc3RQaWNrZWRJbmZvIiwidXNlRGV2aWNlUGl4ZWxzIiwicGl4ZWxSYXRpbyIsImRldmljZVgiLCJNYXRoIiwicm91bmQiLCJkZXZpY2VZIiwiY2FudmFzIiwiaGVpZ2h0IiwiZGV2aWNlUmFkaXVzIiwiZGV2aWNlUmVjdCIsImdldFBpY2tpbmdSZWN0IiwiZGV2aWNlV2lkdGgiLCJ3aWR0aCIsImRldmljZUhlaWdodCIsInBpY2tlZENvbG9ycyIsImRyYXdBbmRTYW1wbGVQaWNraW5nQnVmZmVyIiwicmVkcmF3UmVhc29uIiwicGlja0luZm8iLCJwcm9jZXNzUGlja0luZm8iLCJkZXZpY2VMZWZ0IiwiZGV2aWNlQm90dG9tIiwiZGV2aWNlUmlnaHQiLCJkZXZpY2VUb3AiLCJwaWNrSW5mb3MiLCJnZXRVbmlxdWVzRnJvbVBpY2tpbmdCdWZmZXIiLCJ1bmlxdWVJbmZvcyIsIk1hcCIsImZvckVhY2giLCJ2aWV3cG9ydCIsImdldFZpZXdwb3J0RnJvbUNvb3JkaW5hdGVzIiwiaW5mbyIsImNyZWF0ZUluZm8iLCJkZXZpY2VQaXhlbCIsImNvbG9yIiwiaW5kZXgiLCJwaWNrZWQiLCJnZXRMYXllclBpY2tpbmdJbmZvIiwibGF5ZXIiLCJoYXMiLCJvYmplY3QiLCJzZXQiLCJBcnJheSIsImZyb20iLCJ2YWx1ZXMiLCJOdW1iZXIiLCJpc0Zpbml0ZSIsInBpY2thYmxlTGF5ZXJzIiwiZmlsdGVyIiwiaXNQaWNrYWJsZSIsImxlbmd0aCIsIlVpbnQ4QXJyYXkiLCJyZWFkUGl4ZWxzIiwicGl4ZWxBcnJheSIsInZhbGlkIiwibWF4IiwibWluIiwiYWZmZWN0ZWRMYXllcnMiLCJsYXN0UGlja2VkT2JqZWN0SW5kZXgiLCJsYXN0UGlja2VkTGF5ZXJJZCIsImxheWVySWQiLCJwaWNrZWRMYXllcklkIiwicHJvcHMiLCJpZCIsImxhc3RQaWNrZWRMYXllciIsImZpbmQiLCJ1bnNoaWZ0IiwiYmFzZUluZm8iLCJpbmZvcyIsIk9iamVjdCIsImFzc2lnbiIsInBpY2tpbmdTZWxlY3RlZENvbG9yIiwiYXV0b0hpZ2hsaWdodCIsInBpY2tpbmdQYXJhbWV0ZXJzIiwiZ2V0TW9kZWxzIiwibW9kZWwiLCJ1cGRhdGVNb2R1bGVTZXR0aW5ncyIsInVuaGFuZGxlZFBpY2tJbmZvcyIsImNhbGxMYXllclBpY2tpbmdDYWxsYmFja3MiLCJoYW5kbGVkIiwib25DbGljayIsIm9uSG92ZXIiLCJFcnJvciIsInB1c2giLCJtaW5TcXVhcmVEaXN0YW5jZVRvQ2VudGVyIiwiY2xvc2VzdFBpeGVsSW5kZXgiLCJpIiwicm93IiwiZHkiLCJkeTIiLCJjb2wiLCJwaWNrZWRMYXllckluZGV4IiwiZHgiLCJkMiIsInNsaWNlIiwiZGVjb2RlUGlja2luZ0NvbG9yIiwiZXJyb3IiLCJ1bmlxdWVDb2xvcnMiLCJjb2xvcktleSIsImpvaW4iLCJwaXhlbCIsImxuZ0xhdCIsInVucHJvamVjdCIsInNvdXJjZUxheWVyIiwicGlja0xheWVyIiwicGFyZW50TGF5ZXIiXSwibWFwcGluZ3MiOiI7Ozs7O1FBZ0NnQkEsVSxHQUFBQSxVO1FBdUVBQyxrQixHQUFBQSxrQjtRQTJRQUMsMkIsR0FBQUEsMkI7O0FBOVZoQjs7QUFDQTs7OztBQUNBOzs7Ozs7QUFFQSxJQUFNQyxtQkFBbUI7QUFDdkJDLGVBQWEsSUFEVTtBQUV2QkMsZUFBYSxJQUZVO0FBR3ZCQyxxQkFBbUIsQ0FBQztBQUhHLENBQXpCOztBQU1BO0FB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RjtBQUNGO0FBQ0Y7O0FBRUQsU0FBT3RELE1BQU1DLElBQU4sQ0FBV3NELGFBQWFyRCxNQUFiLEVBQVgsQ0FBUDtBQUNEOztBQUVELFNBQVNaLFVBQVQsQ0FBb0JvRSxLQUFwQixFQUEyQnZFLFFBQTNCLEVBQXFDO0FBQ25DO0FBQ0EsU0FBTztBQUNMSyxXQUFPLElBREY7QUFFTEksV0FBTyxJQUZGO0FBR0xILFdBQU8sQ0FBQyxDQUhIO0FBSUxDLFlBQVEsS0FKSDtBQUtMM0MsT0FBRzJHLE1BQU0sQ0FBTixDQUxFO0FBTUwxRyxPQUFHMEcsTUFBTSxDQUFOLENBTkU7QUFPTEEsZ0JBUEs7QUFRTEMsWUFBUXhFLFNBQVN5RSxTQUFULENBQW1CRixLQUFuQjtBQVJILEdBQVA7QUFVRDs7QUFFRDtBQUNBLFNBQVMvRCxtQkFBVCxRQUFrRDtBQUFBLE1BQXBCQyxLQUFvQixTQUFwQkEsS0FBb0I7QUFBQSxNQUFiUCxJQUFhLFNBQWJBLElBQWE7QUFBQSxNQUFQbEMsSUFBTyxTQUFQQSxJQUFPOztBQUNoRCxTQUFPeUMsU0FBU1AsSUFBaEIsRUFBc0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFNd0UsY0FBY3hFLEtBQUtPLEtBQUwsSUFBY0EsS0FBbEM7QUFDQVAsU0FBS08sS0FBTCxHQUFhQSxLQUFiO0FBQ0E7QUFDQTtBQUNBO0FBQ0FQLFdBQU9PLE1BQU1rRSxTQUFOLENBQWdCLEVBQUN6RSxVQUFELEVBQU9sQyxVQUFQLEVBQWEwRyx3QkFBYixFQUFoQixDQUFQO0FBQ0FqRSxZQUFRQSxNQUFNbUUsV0FBZDtBQUNEO0FBQ0QsU0FBTzFFLElBQVA7QUFDRCIsImZpbGUiOiJwaWNrLWxheWVycy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgMjAxNSAtIDIwMTcgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuLy8gVEhFIFNPRlRXQVJFLlxuXG5pbXBvcnQge2RyYXdQaWNraW5nQnVmZmVyLCBnZXRQaXhlbFJhdGlvfSBmcm9tICcuL2RyYXctbGF5ZXJzJztcbmltcG9ydCBsb2cgZnJvbSAnLi4vdXRpbHMvbG9nJztcbmltcG9ydCBhc3NlcnQgZnJvbSAnYXNzZXJ0JztcblxuY29uc3QgTk9fUElDS0VEX09CSkVDVCA9IHtcbiAgcGlja2VkQ29sb3I6IG51bGwsXG4gIHBpY2tlZExheWVyOiBudWxsLFxuICBwaWNrZWRPYmplY3RJbmRleDogLTFcbn07XG5cbi8qIGVzbGludC1kaXNhYmxlIG1heC1kZXB0aCwgbWF4LXN0YXRlbWVudHMgKi9cbi8vIFBpY2sgdGhlIGNsb3Nlc3Qgb2JqZWN0IGF0IHRoZSBnaXZlbiAoeCx5KSBjb29yZGluYXRlXG5leHBvcnQgZnVuY3Rpb24gcGlja09iamVjdChcbiAgZ2wsXG4gIHtcbiAgICBsYXllcnMsXG4gICAgdmlld3BvcnRzLFxuICAgIHgsXG4gICAgeSxcbiAgICByYWRpdXMsXG4gICAgbGF5ZXJGaWx0ZXIsXG4gICAgbW9kZSxcbiAgICBvblZpZXdwb3J0QWN0aXZlLFxuICAgIHBpY2tpbmdGQk8sXG4gICAgbGFzdFBpY2tlZEluZm8sXG4gICAgdXNlRGV2aWNlUGl4ZWxzXG4gIH1cbikge1xuICAvLyBDb252ZXJ0IGZyb20gY2FudmFzIHRvcC1sZWZ0IHRvIFdlYkdMIGJvdHRvbS1sZWZ0IGNvb3JkaW5hdGVzXG4gIC8vIEFuZCBjb21wZW5zYXRlIGZvciBwaXhlbFJhdGlvXG4gIGNvbnN0IHBpeGVsUmF0aW8gPSBnZXRQaXhlbFJhdGlvKHt1c2VEZXZpY2VQaXhlbHN9KTtcbiAgY29uc3QgZGV2aWNlWCA9IE1hdGgucm91bmQoeCAqIHBpeGVsUmF0aW8pO1xuICBjb25zdCBkZXZpY2VZID0gTWF0aC5yb3VuZChnbC5jYW52YXMuaGVpZ2h0IC0geSAqIHBpeGVsUmF0aW8pO1xuICBjb25zdCBkZXZpY2VSYWRpdXMgPSBNYXRoLnJvdW5kKHJhZGl1cyAqIHBpeGVsUmF0aW8pO1xuXG4gIGNvbnN0IGRldmljZVJlY3QgPSBnZXRQaWNraW5nUmVjdCh7XG4gICAgZGV2aWNlWCxcbiAgICBkZXZpY2VZLFxuICAgIGRldmljZVJhZGl1cyxcbiAgICBkZXZpY2VXaWR0aDogcGlja2luZ0ZCTy53aWR0aCxcbiAgICBkZXZpY2VIZWlnaHQ6IHBpY2tpbmdGQk8uaGVpZ2h0XG4gIH0pO1xuXG4gIGNvbnN0IHBpY2tlZENvbG9ycyA9XG4gICAgZGV2aWNlUmVjdCAmJlxuICAgIGRyYXdBbmRTYW1wbGVQaWNraW5nQnVmZmVyKGdsLCB7XG4gICAgICBsYXllcnMsXG4gICAgICB2aWV3cG9ydHMsXG4gICAgICBvblZpZXdwb3J0QWN0aXZlLFxuICAgICAgdXNlRGV2aWNlUGl4ZWxzLFxuICAgICAgcGlja2luZ0ZCTyxcbiAgICAgIGRldmljZVJlY3QsXG4gICAgICBsYXllckZpbHRlcixcbiAgICAgIHJlZHJhd1JlYXNvbjogbW9kZVxuICAgIH0pO1xuXG4gIGNvbnN0IHBpY2tJbmZvID1cbiAgICAocGlja2VkQ29sb3JzICYmXG4gICAgICBnZXRDbG9zZXN0RnJvbVBpY2tpbmdCdWZmZXIoZ2wsIHtcbiAgICAgICAgcGlja2VkQ29sb3JzLFxuICAgICAgICBsYXllcnMsXG4gICAgICAgIGRldmljZVgsXG4gICAgICAgIGRldmljZVksXG4gICAgICAgIGRldmljZVJhZGl1cyxcbiAgICAgICAgZGV2aWNlUmVjdFxuICAgICAgfSkpIHx8XG4gICAgTk9fUElDS0VEX09CSkVDVDtcblxuICByZXR1cm4gcHJvY2Vzc1BpY2tJbmZvKHtcbiAgICBwaWNrSW5mbyxcbiAgICBsYXN0UGlja2VkSW5mbyxcbiAgICBtb2RlLFxuICAgIGxheWVycyxcbiAgICB2aWV3cG9ydHMsXG4gICAgeCxcbiAgICB5LFxuICAgIGRldmljZVgsXG4gICAgZGV2aWNlWSxcbiAgICBwaXhlbFJhdGlvXG4gIH0pO1xufVxuXG4vLyBQaWNrIGFsbCBvYmplY3RzIHdpdGhpbiB0aGUgZ2l2ZW4gYm91bmRpbmcgYm94XG5leHBvcnQgZnVuY3Rpb24gcGlja1Zpc2libGVPYmplY3RzKFxuICBnbCxcbiAge1xuICAgIGxheWVycyxcbiAgICB2aWV3cG9ydHMsXG4gICAgeCxcbiAgICB5LFxuICAgIHdpZHRoLFxuICAgIGhlaWdodCxcbiAgICBtb2RlLFxuICAgIGxheWVyRmlsdGVyLFxuICAgIG9uVmlld3BvcnRBY3RpdmUsXG4gICAgcGlja2luZ0ZCTyxcbiAgICB1c2VEZXZpY2VQaXhlbHNcbiAgfVxuKSB7XG4gIC8vIENvbnZlcnQgZnJvbSBjYW52YXMgdG9wLWxlZnQgdG8gV2ViR0wgYm90dG9tLWxlZnQgY29vcmRpbmF0ZXNcbiAgLy8gQW5kIGNvbXBlbnNhdGUgZm9yIHBpeGVsUmF0aW9cbiAgY29uc3QgcGl4ZWxSYXRpbyA9IGdldFBpeGVsUmF0aW8oe3VzZURldmljZVBpeGVsc30pO1xuXG4gIGNvbnN0IGRldmljZUxlZnQgPSBNYXRoLnJvdW5kKHggKiBwaXhlbFJhdGlvKTtcbiAgY29uc3QgZGV2aWNlQm90dG9tID0gTWF0aC5yb3VuZChnbC5jYW52YXMuaGVpZ2h0IC0geSAqIHBpeGVsUmF0aW8pO1xuICBjb25zdCBkZXZpY2VSaWdodCA9IE1hdGgucm91bmQoKHggKyB3aWR0aCkgKiBwaXhlbFJhdGlvKTtcbiAgY29uc3QgZGV2aWNlVG9wID0gTWF0aC5yb3VuZChnbC5jYW52YXMuaGVpZ2h0IC0gKHkgKyBoZWlnaHQpICogcGl4ZWxSYXRpbyk7XG5cbiAgY29uc3QgZGV2aWNlUmVjdCA9IHtcbiAgICB4OiBkZXZpY2VMZWZ0LFxuICAgIHk6IGRldmljZVRvcCxcbiAgICB3aWR0aDogZGV2aWNlUmlnaHQgLSBkZXZpY2VMZWZ0LFxuICAgIGhlaWdodDogZGV2aWNlQm90dG9tIC0gZGV2aWNlVG9wXG4gIH07XG5cbiAgY29uc3QgcGlja2VkQ29sb3JzID0gZHJhd0FuZFNhbXBsZVBpY2tpbmdCdWZmZXIoZ2wsIHtcbiAgICBsYXllcnMsXG4gICAgdmlld3BvcnRzLFxuICAgIG9uVmlld3BvcnRBY3RpdmUsXG4gICAgcGlja2luZ0ZCTyxcbiAgICB1c2VEZXZpY2VQaXhlbHMsXG4gICAgZGV2aWNlUmVjdCxcbiAgICBsYXllckZpbHRlcixcbiAgICByZWRyYXdSZWFzb246IG1vZGVcbiAgfSk7XG5cbiAgY29uc3QgcGlja0luZm9zID0gZ2V0VW5pcXVlc0Zyb21QaWNraW5nQnVmZmVyKGdsLCB7cGlja2VkQ29sb3JzLCBsYXllcnN9KTtcblxuICAvLyBPbmx5IHJldHVybiB1bmlxdWUgaW5mb3MsIGlkZW50aWZpZWQgYnkgaW5mby5vYmplY3RcbiAgY29uc3QgdW5pcXVlSW5mb3MgPSBuZXcgTWFwKCk7XG5cbiAgcGlja0luZm9zLmZvckVhY2gocGlja0luZm8gPT4ge1xuICAgIGNvbnN0IHZpZXdwb3J0ID0gZ2V0Vmlld3BvcnRGcm9tQ29vcmRpbmF0ZXMoe3ZpZXdwb3J0c30pOyAvLyBUT0RPIC0gYWRkIGNvb3Jkc1xuICAgIGxldCBpbmZvID0gY3JlYXRlSW5mbyhbcGlja0luZm8ueCAvIHBpeGVsUmF0aW8sIHBpY2tJbmZvLnkgLyBwaXhlbFJhdGlvXSwgdmlld3BvcnQpO1xuICAgIGluZm8uZGV2aWNlUGl4ZWwgPSBbcGlja0luZm8ueCwgcGlja0luZm8ueV07XG4gICAgaW5mby5waXhlbFJhdGlvID0gcGl4ZWxSYXRpbztcbiAgICBpbmZvLmNvbG9yID0gcGlja0luZm8ucGlja2VkQ29sb3I7XG4gICAgaW5mby5pbmRleCA9IHBpY2tJbmZvLnBpY2tlZE9iamVjdEluZGV4O1xuICAgIGluZm8ucGlja2VkID0gdHJ1ZTtcblxuICAgIGluZm8gPSBnZXRMYXllclBpY2tpbmdJbmZvKHtsYXllcjogcGlja0luZm8ucGlja2VkTGF5ZXIsIGluZm8sIG1vZGV9KTtcbiAgICBpZiAoIXVuaXF1ZUluZm9zLmhhcyhpbmZvLm9iamVjdCkpIHtcbiAgICAgIHVuaXF1ZUluZm9zLnNldChpbmZvLm9iamVjdCwgaW5mbyk7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gQXJyYXkuZnJvbSh1bmlxdWVJbmZvcy52YWx1ZXMoKSk7XG59XG5cbi8vIEhFTFBFUiBNRVRIT0RTXG5cbi8vIHJldHVybnMgcGlja2VkQ29sb3Igb3IgbnVsbCBpZiBubyBwaWNrYWJsZSBsYXllcnMgZm91bmQuXG5mdW5jdGlvbiBkcmF3QW5kU2FtcGxlUGlja2luZ0J1ZmZlcihcbiAgZ2wsXG4gIHtcbiAgICBsYXllcnMsXG4gICAgdmlld3BvcnRzLFxuICAgIG9uVmlld3BvcnRBY3RpdmUsXG4gICAgdXNlRGV2aWNlUGl4ZWxzLFxuICAgIHBpY2tpbmdGQk8sXG4gICAgZGV2aWNlUmVjdCxcbiAgICBsYXllckZpbHRlcixcbiAgICByZWRyYXdSZWFzb25cbiAgfVxuKSB7XG4gIGFzc2VydChkZXZpY2VSZWN0KTtcbiAgYXNzZXJ0KE51bWJlci5pc0Zpbml0ZShkZXZpY2VSZWN0LndpZHRoKSAmJiBkZXZpY2VSZWN0LndpZHRoID4gMCwgJ2B3aWR0aGAgbXVzdCBiZSA+IDAnKTtcbiAgYXNzZXJ0KE51bWJlci5pc0Zpbml0ZShkZXZpY2VSZWN0LmhlaWdodCkgJiYgZGV2aWNlUmVjdC5oZWlnaHQgPiAwLCAnYGhlaWdodGAgbXVzdCBiZSA+IDAnKTtcblxuICBjb25zdCBwaWNrYWJsZUxheWVycyA9IGxheWVycy5maWx0ZXIobGF5ZXIgPT4gbGF5ZXIuaXNQaWNrYWJsZSgpKTtcbiAgaWYgKHBpY2thYmxlTGF5ZXJzLmxlbmd0aCA8IDEpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGRyYXdQaWNraW5nQnVmZmVyKGdsLCB7XG4gICAgbGF5ZXJzLFxuICAgIHZpZXdwb3J0cyxcbiAgICBvblZpZXdwb3J0QWN0aXZlLFxuICAgIHVzZURldmljZVBpeGVscyxcbiAgICBwaWNraW5nRkJPLFxuICAgIGRldmljZVJlY3QsXG4gICAgbGF5ZXJGaWx0ZXIsXG4gICAgcmVkcmF3UmVhc29uXG4gIH0pO1xuXG4gIC8vIFJlYWQgZnJvbSBhbiBhbHJlYWR5IHJlbmRlcmVkIHBpY2tpbmcgYnVmZmVyXG4gIC8vIFJldHVybnMgYW4gVWludDhDbGFtcGVkQXJyYXkgb2YgcGlja2VkIHBpeGVsc1xuICBjb25zdCB7eCwgeSwgd2lkdGgsIGhlaWdodH0gPSBkZXZpY2VSZWN0O1xuICBjb25zdCBwaWNrZWRDb2xvcnMgPSBuZXcgVWludDhBcnJheSh3aWR0aCAqIGhlaWdodCAqIDQpO1xuICBwaWNraW5nRkJPLnJlYWRQaXhlbHMoe3gsIHksIHdpZHRoLCBoZWlnaHQsIHBpeGVsQXJyYXk6IHBpY2tlZENvbG9yc30pO1xuICByZXR1cm4gcGlja2VkQ29sb3JzO1xufVxuXG4vLyBJbmRlbnRpZmllcyB3aGljaCB2aWV3cG9ydCwgaWYgYW55IGNvcnJlc3BvbmRzIHRvIHggYW5kIHlcbi8vIFJldHVybnMgZmlyc3Qgdmlld3BvcnQgaWYgbm8gbWF0Y2hcbi8vIFRPRE8gLSBuZWVkIHRvIGRldGVybWluZSB3aGljaCB2aWV3cG9ydCB3ZSBhcmUgaW5cbi8vIFRPRE8gLSBkb2N1bWVudCBjb25jZXB0IG9mIFwicHJpbWFyeSB2aWV3cG9ydFwiIHRoYXQgbWF0Y2hlcyBhbGwgY29vcmRzP1xuLy8gVE9ETyAtIHN0YXRpYyBtZXRob2Qgb24gVmlld3BvcnQgY2xhc3M/XG5mdW5jdGlvbiBnZXRWaWV3cG9ydEZyb21Db29yZGluYXRlcyh7dmlld3BvcnRzfSkge1xuICBjb25zdCB2aWV3cG9ydCA9IHZpZXdwb3J0c1swXTtcbiAgcmV0dXJuIHZpZXdwb3J0O1xufVxuXG4vLyBDYWxjdWxhdGUgYSBwaWNraW5nIHJlY3QgY2VudGVyZWQgb24gZGV2aWNlWCBhbmQgZGV2aWNlWSBhbmQgY2xpcHBlZCB0byBkZXZpY2Vcbi8vIFJldHVybnMgbnVsbCBpZiBwaXhlbCBpcyBvdXRzaWRlIG9mIGRldmljZVxuZnVuY3Rpb24gZ2V0UGlja2luZ1JlY3Qoe2RldmljZVgsIGRldmljZVksIGRldmljZVJhZGl1cywgZGV2aWNlV2lkdGgsIGRldmljZUhlaWdodH0pIHtcbiAgY29uc3QgdmFsaWQgPSBkZXZpY2VYID49IDAgJiYgZGV2aWNlWSA+PSAwICYmIGRldmljZVggPCBkZXZpY2VXaWR0aCAmJiBkZXZpY2VZIDwgZGV2aWNlSGVpZ2h0O1xuXG4gIC8vIHgsIHkgb3V0IG9mIGJvdW5kcy5cbiAgaWYgKCF2YWxpZCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gQ3JlYXRlIGEgYm94IG9mIHNpemUgYHJhZGl1cyAqIDIgKyAxYCBjZW50ZXJlZCBhdCBbZGV2aWNlWCwgZGV2aWNlWV1cbiAgY29uc3QgeCA9IE1hdGgubWF4KDAsIGRldmljZVggLSBkZXZpY2VSYWRpdXMpO1xuICBjb25zdCB5ID0gTWF0aC5tYXgoMCwgZGV2aWNlWSAtIGRldmljZVJhZGl1cyk7XG4gIGNvbnN0IHdpZHRoID0gTWF0aC5taW4oZGV2aWNlV2lkdGgsIGRldmljZVggKyBkZXZpY2VSYWRpdXMpIC0geCArIDE7XG4gIGNvbnN0IGhlaWdodCA9IE1hdGgubWluKGRldmljZUhlaWdodCwgZGV2aWNlWSArIGRldmljZVJhZGl1cykgLSB5ICsgMTtcblxuICByZXR1cm4ge3gsIHksIHdpZHRoLCBoZWlnaHR9O1xufVxuXG4vLyBUT0RPIC0gYnJlYWsgdGhpcyBtb25zdGVyIGZ1bmN0aW9uIGludG8gMysgcGFydHNcbmZ1bmN0aW9uIHByb2Nlc3NQaWNrSW5mbyh7XG4gIHBpY2tJbmZvLFxuICBsYXN0UGlja2VkSW5mbyxcbiAgbW9kZSxcbiAgbGF5ZXJzLFxuICB2aWV3cG9ydHMsXG4gIHgsXG4gIHksXG4gIGRldmljZVgsXG4gIGRldmljZVksXG4gIHBpeGVsUmF0aW9cbn0pIHtcbiAgY29uc3Qge3BpY2tlZENvbG9yLCBwaWNrZWRMYXllciwgcGlja2VkT2JqZWN0SW5kZXh9ID0gcGlja0luZm87XG5cbiAgY29uc3QgYWZmZWN0ZWRMYXllcnMgPSBwaWNrZWRMYXllciA/IFtwaWNrZWRMYXllcl0gOiBbXTtcblxuICBpZiAobW9kZSA9PT0gJ2hvdmVyJykge1xuICAgIC8vIG9ubHkgaW52b2tlIG9uSG92ZXIgZXZlbnRzIGlmIHBpY2tlZCBvYmplY3QgaGFzIGNoYW5nZWRcbiAgICBjb25zdCBsYXN0UGlja2VkT2JqZWN0SW5kZXggPSBsYXN0UGlja2VkSW5mby5pbmRleDtcbiAgICBjb25zdCBsYXN0UGlja2VkTGF5ZXJJZCA9IGxhc3RQaWNrZWRJbmZvLmxheWVySWQ7XG4gICAgY29uc3QgcGlja2VkTGF5ZXJJZCA9IHBpY2tlZExheWVyICYmIHBpY2tlZExheWVyLnByb3BzLmlkO1xuXG4gICAgLy8gcHJvY2VlZCBvbmx5IGlmIHBpY2tlZCBvYmplY3QgY2hhbmdlZFxuICAgIGlmIChwaWNrZWRMYXllcklkICE9PSBsYXN0UGlja2VkTGF5ZXJJZCB8fCBwaWNrZWRPYmplY3RJbmRleCAhPT0gbGFzdFBpY2tlZE9iamVjdEluZGV4KSB7XG4gICAgICBpZiAocGlja2VkTGF5ZXJJZCAhPT0gbGFzdFBpY2tlZExheWVySWQpIHtcbiAgICAgICAgLy8gV2UgY2Fubm90IHN0b3JlIGEgcmVmIHRvIGxhc3RQaWNrZWRMYXllciBpbiB0aGUgY29udGV4dCBiZWNhdXNlXG4gICAgICAgIC8vIHRoZSBzdGF0ZSBvZiBhbiBvdXRkYXRlZCBsYXllciBpcyBubyBsb25nZXIgdmFsaWRcbiAgICAgICAgLy8gYW5kIHRoZSBwcm9wcyBtYXkgaGF2ZSBjaGFuZ2VkXG4gICAgICAgIGNvbnN0IGxhc3RQaWNrZWRMYXllciA9IGxheWVycy5maW5kKGxheWVyID0+IGxheWVyLnByb3BzLmlkID09PSBsYXN0UGlja2VkTGF5ZXJJZCk7XG4gICAgICAgIGlmIChsYXN0UGlja2VkTGF5ZXIpIHtcbiAgICAgICAgICAvLyBMZXQgbGVhdmUgZXZlbnQgZmlyZSBiZWZvcmUgZW50ZXIgZXZlbnRcbiAgICAgICAgICBhZmZlY3RlZExheWVycy51bnNoaWZ0KGxhc3RQaWNrZWRMYXllcik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVXBkYXRlIGxheWVyIG1hbmFnZXIgY29udGV4dFxuICAgICAgbGFzdFBpY2tlZEluZm8ubGF5ZXJJZCA9IHBpY2tlZExheWVySWQ7XG4gICAgICBsYXN0UGlja2VkSW5mby5pbmRleCA9IHBpY2tlZE9iamVjdEluZGV4O1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHZpZXdwb3J0ID0gZ2V0Vmlld3BvcnRGcm9tQ29vcmRpbmF0ZXMoe3ZpZXdwb3J0c30pOyAvLyBUT0RPIC0gYWRkIGNvb3Jkc1xuXG4gIGNvbnN0IGJhc2VJbmZvID0gY3JlYXRlSW5mbyhbeCwgeV0sIHZpZXdwb3J0KTtcbiAgYmFzZUluZm8uZGV2aWNlUGl4ZWwgPSBbZGV2aWNlWCwgZGV2aWNlWV07XG4gIGJhc2VJbmZvLnBpeGVsUmF0aW8gPSBwaXhlbFJhdGlvO1xuXG4gIC8vIFVzZSBhIE1hcCB0byBzdG9yZSBhbGwgcGlja2luZyBpbmZvcy5cbiAgLy8gVGhlIGZvbGxvd2luZyB0d28gZm9yRWFjaCBsb29wcyBhcmUgdGhlIHJlc3VsdCBvZlxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vdWJlci9kZWNrLmdsL2lzc3Vlcy80NDNcbiAgLy8gUGxlYXNlIGJlIHZlcnkgY2FyZWZ1bCB3aGVuIGNoYW5naW5nIHRoaXMgcGF0dGVyblxuICBjb25zdCBpbmZvcyA9IG5ldyBNYXAoKTtcblxuICBhZmZlY3RlZExheWVycy5mb3JFYWNoKGxheWVyID0+IHtcbiAgICBsZXQgaW5mbyA9IE9iamVjdC5hc3NpZ24oe30sIGJhc2VJbmZvKTtcblxuICAgIGlmIChsYXllciA9PT0gcGlja2VkTGF5ZXIpIHtcbiAgICAgIGluZm8uY29sb3IgPSBwaWNrZWRDb2xvcjtcbiAgICAgIGluZm8uaW5kZXggPSBwaWNrZWRPYmplY3RJbmRleDtcbiAgICAgIGluZm8ucGlja2VkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpbmZvID0gZ2V0TGF5ZXJQaWNraW5nSW5mbyh7bGF5ZXIsIGluZm8sIG1vZGV9KTtcblxuICAgIC8vIFRoaXMgZ3VhcmFudGVlcyB0aGF0IHRoZXJlIHdpbGwgYmUgb25seSBvbmUgY29weSBvZiBpbmZvIGZvclxuICAgIC8vIG9uZSBjb21wb3NpdGUgbGF5ZXJcbiAgICBpZiAoaW5mbykge1xuICAgICAgaW5mb3Muc2V0KGluZm8ubGF5ZXIuaWQsIGluZm8pO1xuICAgIH1cblxuICAgIGNvbnN0IHBpY2tpbmdTZWxlY3RlZENvbG9yID1cbiAgICAgIGxheWVyLnByb3BzLmF1dG9IaWdobGlnaHQgJiYgcGlja2VkTGF5ZXIgPT09IGxheWVyID8gcGlja2VkQ29sb3IgOiBudWxsO1xuXG4gICAgY29uc3QgcGlja2luZ1BhcmFtZXRlcnMgPSB7XG4gICAgICBwaWNraW5nU2VsZWN0ZWRDb2xvclxuICAgIH07XG5cbiAgICBmb3IgKGNvbnN0IG1vZGVsIG9mIGxheWVyLmdldE1vZGVscygpKSB7XG4gICAgICBtb2RlbC51cGRhdGVNb2R1bGVTZXR0aW5ncyhwaWNraW5nUGFyYW1ldGVycyk7XG4gICAgfVxuICB9KTtcblxuICBjb25zdCB1bmhhbmRsZWRQaWNrSW5mb3MgPSBjYWxsTGF5ZXJQaWNraW5nQ2FsbGJhY2tzKGluZm9zLCBtb2RlKTtcblxuICByZXR1cm4gdW5oYW5kbGVkUGlja0luZm9zO1xufVxuXG4vLyBQZXItbGF5ZXIgZXZlbnQgaGFuZGxlcnMgKGUuZy4gb25DbGljaywgb25Ib3ZlcikgYXJlIHByb3ZpZGVkIGJ5IHRoZVxuLy8gdXNlciBhbmQgb3V0IG9mIGRlY2suZ2wncyBjb250cm9sLiBJdCdzIHZlcnkgbXVjaCBwb3NzaWJsZSB0aGF0XG4vLyB0aGUgdXNlciBjYWxscyBSZWFjdCBsaWZlY3ljbGUgbWV0aG9kcyBpbiB0aGVzZSBmdW5jdGlvbiwgc3VjaCBhc1xuLy8gUmVhY3RDb21wb25lbnQuc2V0U3RhdGUoKS4gUmVhY3QgbGlmZWN5Y2xlIG1ldGhvZHMgc29tZXRpbWVzIGluZHVjZVxuLy8gYSByZS1yZW5kZXIgYW5kIHJlLWdlbmVyYXRpb24gb2YgcHJvcHMgb2YgZGVjay5nbCBhbmQgaXRzIGxheWVycyxcbi8vIHdoaWNoIGludmFsaWRhdGVzIGFsbCBsYXllcnMgY3VycmVudGx5IHBhc3NlZCB0byB0aGlzIHZlcnkgZnVuY3Rpb24uXG5cbi8vIFRoZXJlZm9yZSwgcGVyLWxheWVyIGV2ZW50IGhhbmRsZXJzIG11c3QgYmUgaW52b2tlZCBhdCB0aGUgZW5kXG4vLyBvZiB0aGUgcGlja2luZyBvcGVyYXRpb24uIE5PIG9wZXJhdGlvbiB0aGF0IHJlbGllcyBvbiB0aGUgc3RhdGVzIG9mIGN1cnJlbnRcbi8vIGxheWVycyBzaG91bGQgYmUgY2FsbGVkIGFmdGVyIHRoaXMgY29kZS5cbmZ1bmN0aW9uIGNhbGxMYXllclBpY2tpbmdDYWxsYmFja3MoaW5mb3MsIG1vZGUpIHtcbiAgY29uc3QgdW5oYW5kbGVkUGlja0luZm9zID0gW107XG5cbiAgaW5mb3MuZm9yRWFjaChpbmZvID0+IHtcbiAgICBsZXQgaGFuZGxlZCA9IGZhbHNlO1xuICAgIHN3aXRjaCAobW9kZSkge1xuICAgICAgY2FzZSAnY2xpY2snOlxuICAgICAgICBoYW5kbGVkID0gaW5mby5sYXllci5wcm9wcy5vbkNsaWNrKGluZm8pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2hvdmVyJzpcbiAgICAgICAgaGFuZGxlZCA9IGluZm8ubGF5ZXIucHJvcHMub25Ib3ZlcihpbmZvKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdxdWVyeSc6XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bmtub3duIHBpY2sgdHlwZScpO1xuICAgIH1cblxuICAgIGlmICghaGFuZGxlZCkge1xuICAgICAgdW5oYW5kbGVkUGlja0luZm9zLnB1c2goaW5mbyk7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gdW5oYW5kbGVkUGlja0luZm9zO1xufVxuXG4vKipcbiAqIFBpY2sgYXQgYSBzcGVjaWZpZWQgcGl4ZWwgd2l0aCBhIHRvbGVyYW5jZSByYWRpdXNcbiAqIFJldHVybnMgdGhlIGNsb3Nlc3Qgb2JqZWN0IHRvIHRoZSBwaXhlbCBpbiBzaGFwZSBge3BpY2tlZENvbG9yLCBwaWNrZWRMYXllciwgcGlja2VkT2JqZWN0SW5kZXh9YFxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q2xvc2VzdEZyb21QaWNraW5nQnVmZmVyKFxuICBnbCxcbiAge3BpY2tlZENvbG9ycywgbGF5ZXJzLCBkZXZpY2VYLCBkZXZpY2VZLCBkZXZpY2VSYWRpdXMsIGRldmljZVJlY3R9XG4pIHtcbiAgYXNzZXJ0KHBpY2tlZENvbG9ycyk7XG5cbiAgLy8gVHJhdmVyc2UgYWxsIHBpeGVscyBpbiBwaWNraW5nIHJlc3VsdHMgYW5kIGZpbmQgdGhlIG9uZSBjbG9zZXN0IHRvIHRoZSBzdXBwbGllZFxuICAvLyBbZGV2aWNlWCwgZGV2aWNlWV1cbiAgY29uc3Qge3gsIHksIHdpZHRoLCBoZWlnaHR9ID0gZGV2aWNlUmVjdDtcbiAgbGV0IG1pblNxdWFyZURpc3RhbmNlVG9DZW50ZXIgPSBkZXZpY2VSYWRpdXMgKiBkZXZpY2VSYWRpdXM7XG4gIGxldCBjbG9zZXN0UGl4ZWxJbmRleCA9IC0xO1xuICBsZXQgaSA9IDA7XG5cbiAgZm9yIChsZXQgcm93ID0gMDsgcm93IDwgaGVpZ2h0OyByb3crKykge1xuICAgIGNvbnN0IGR5ID0gcm93ICsgeSAtIGRldmljZVk7XG4gICAgY29uc3QgZHkyID0gZHkgKiBkeTtcblxuICAgIGlmIChkeTIgPiBtaW5TcXVhcmVEaXN0YW5jZVRvQ2VudGVyKSB7XG4gICAgICAvLyBza2lwIHRoaXMgcm93XG4gICAgICBpICs9IDQgKiB3aWR0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChsZXQgY29sID0gMDsgY29sIDwgd2lkdGg7IGNvbCsrKSB7XG4gICAgICAgIC8vIERlY29kZSBwaWNrZWQgbGF5ZXIgZnJvbSBjb2xvclxuICAgICAgICBjb25zdCBwaWNrZWRMYXllckluZGV4ID0gcGlja2VkQ29sb3JzW2kgKyAzXSAtIDE7XG5cbiAgICAgICAgaWYgKHBpY2tlZExheWVySW5kZXggPj0gMCkge1xuICAgICAgICAgIGNvbnN0IGR4ID0gY29sICsgeCAtIGRldmljZVg7XG4gICAgICAgICAgY29uc3QgZDIgPSBkeCAqIGR4ICsgZHkyO1xuXG4gICAgICAgICAgaWYgKGQyIDw9IG1pblNxdWFyZURpc3RhbmNlVG9DZW50ZXIpIHtcbiAgICAgICAgICAgIG1pblNxdWFyZURpc3RhbmNlVG9DZW50ZXIgPSBkMjtcbiAgICAgICAgICAgIGNsb3Nlc3RQaXhlbEluZGV4ID0gaTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaSArPSA0O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChjbG9zZXN0UGl4ZWxJbmRleCA+PSAwKSB7XG4gICAgLy8gRGVjb2RlIHBpY2tlZCBvYmplY3QgaW5kZXggZnJvbSBjb2xvclxuICAgIGNvbnN0IHBpY2tlZExheWVySW5kZXggPSBwaWNrZWRDb2xvcnNbY2xvc2VzdFBpeGVsSW5kZXggKyAzXSAtIDE7XG4gICAgY29uc3QgcGlja2VkQ29sb3IgPSBwaWNrZWRDb2xvcnMuc2xpY2UoY2xvc2VzdFBpeGVsSW5kZXgsIGNsb3Nlc3RQaXhlbEluZGV4ICsgNCk7XG4gICAgY29uc3QgcGlja2VkTGF5ZXIgPSBsYXllcnNbcGlja2VkTGF5ZXJJbmRleF07XG4gICAgaWYgKHBpY2tlZExheWVyKSB7XG4gICAgICBjb25zdCBwaWNrZWRPYmplY3RJbmRleCA9IHBpY2tlZExheWVyLmRlY29kZVBpY2tpbmdDb2xvcihwaWNrZWRDb2xvcik7XG4gICAgICByZXR1cm4ge3BpY2tlZENvbG9yLCBwaWNrZWRMYXllciwgcGlja2VkT2JqZWN0SW5kZXh9O1xuICAgIH1cbiAgICBsb2cuZXJyb3IoJ1BpY2tlZCBub24tZXhpc3RlbnQgbGF5ZXIuIElzIHBpY2tpbmcgYnVmZmVyIGNvcnJ1cHQ/Jyk7XG4gIH1cblxuICByZXR1cm4gTk9fUElDS0VEX09CSkVDVDtcbn1cbi8qIGVzbGludC1lbmFibGUgbWF4LWRlcHRoLCBtYXgtc3RhdGVtZW50cyAqL1xuXG4vKipcbiAqIEV4YW1pbmVzIGEgcGlja2luZyBidWZmZXIgZm9yIHVuaXF1ZSBjb2xvcnNcbiAqIFJldHVybnMgYXJyYXkgb2YgdW5pcXVlIG9iamVjdHMgaW4gc2hhcGUgYHt4LCB5LCBwaWNrZWRDb2xvciwgcGlja2VkTGF5ZXIsIHBpY2tlZE9iamVjdEluZGV4fWBcbiAqL1xuZnVuY3Rpb24gZ2V0VW5pcXVlc0Zyb21QaWNraW5nQnVmZmVyKGdsLCB7cGlja2VkQ29sb3JzLCBsYXllcnN9KSB7XG4gIGNvbnN0IHVuaXF1ZUNvbG9ycyA9IG5ldyBNYXAoKTtcblxuICAvLyBUcmF2ZXJzZSBhbGwgcGl4ZWxzIGluIHBpY2tpbmcgcmVzdWx0cyBhbmQgZ2V0IHVuaXF1ZSBjb2xvcnNcbiAgaWYgKHBpY2tlZENvbG9ycykge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGlja2VkQ29sb3JzLmxlbmd0aDsgaSArPSA0KSB7XG4gICAgICAvLyBEZWNvZGUgcGlja2VkIGxheWVyIGZyb20gY29sb3JcbiAgICAgIGNvbnN0IHBpY2tlZExheWVySW5kZXggPSBwaWNrZWRDb2xvcnNbaSArIDNdIC0gMTtcblxuICAgICAgaWYgKHBpY2tlZExheWVySW5kZXggPj0gMCkge1xuICAgICAgICBjb25zdCBwaWNrZWRDb2xvciA9IHBpY2tlZENvbG9ycy5zbGljZShpLCBpICsgNCk7XG4gICAgICAgIGNvbnN0IGNvbG9yS2V5ID0gcGlja2VkQ29sb3Iuam9pbignLCcpO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgICAgaWYgKCF1bmlxdWVDb2xvcnMuaGFzKGNvbG9yS2V5KSkge1xuICAgICAgICAgIGNvbnN0IHBpY2tlZExheWVyID0gbGF5ZXJzW3BpY2tlZExheWVySW5kZXhdO1xuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgICAgIGlmIChwaWNrZWRMYXllcikge1xuICAgICAgICAgICAgdW5pcXVlQ29sb3JzLnNldChjb2xvcktleSwge1xuICAgICAgICAgICAgICBwaWNrZWRDb2xvcixcbiAgICAgICAgICAgICAgcGlja2VkTGF5ZXIsXG4gICAgICAgICAgICAgIHBpY2tlZE9iamVjdEluZGV4OiBwaWNrZWRMYXllci5kZWNvZGVQaWNraW5nQ29sb3IocGlja2VkQ29sb3IpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbG9nLmVycm9yKCdQaWNrZWQgbm9uLWV4aXN0ZW50IGxheWVyLiBJcyBwaWNraW5nIGJ1ZmZlciBjb3JydXB0PycpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBBcnJheS5mcm9tKHVuaXF1ZUNvbG9ycy52YWx1ZXMoKSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUluZm8ocGl4ZWwsIHZpZXdwb3J0KSB7XG4gIC8vIEFzc2lnbiBhIG51bWJlciBvZiBwb3RlbnRpYWxseSB1c2VmdWwgcHJvcHMgdG8gdGhlIFwiaW5mb1wiIG9iamVjdFxuICByZXR1cm4ge1xuICAgIGNvbG9yOiBudWxsLFxuICAgIGxheWVyOiBudWxsLFxuICAgIGluZGV4OiAtMSxcbiAgICBwaWNrZWQ6IGZhbHNlLFxuICAgIHg6IHBpeGVsWzBdLFxuICAgIHk6IHBpeGVsWzFdLFxuICAgIHBpeGVsLFxuICAgIGxuZ0xhdDogdmlld3BvcnQudW5wcm9qZWN0KHBpeGVsKVxuICB9O1xufVxuXG4vLyBXYWxrIHVwIHRoZSBsYXllciBjb21wb3NpdGUgY2hhaW4gdG8gcG9wdWxhdGUgdGhlIGluZm8gb2JqZWN0XG5mdW5jdGlvbiBnZXRMYXllclBpY2tpbmdJbmZvKHtsYXllciwgaW5mbywgbW9kZX0pIHtcbiAgd2hpbGUgKGxheWVyICYmIGluZm8pIHtcbiAgICAvLyBGb3IgYSBjb21wb3NpdGUgbGF5ZXIsIHNvdXJjZUxheWVyIHdpbGwgcG9pbnQgdG8gdGhlIHN1YmxheWVyXG4gICAgLy8gd2hlcmUgdGhlIGV2ZW50IG9yaWdpbmF0ZXMgZnJvbS5cbiAgICAvLyBJdCBwcm92aWRlcyBhZGRpdGlvbmFsIGNvbnRleHQgZm9yIHRoZSBjb21wb3NpdGUgbGF5ZXInc1xuICAgIC8vIGdldFBpY2tpbmdJbmZvKCkgbWV0aG9kIHRvIHBvcHVsYXRlIHRoZSBpbmZvIG9iamVjdFxuICAgIGNvbnN0IHNvdXJjZUxheWVyID0gaW5mby5sYXllciB8fCBsYXllcjtcbiAgICBpbmZvLmxheWVyID0gbGF5ZXI7XG4gICAgLy8gbGF5ZXIucGlja0xheWVyKCkgZnVuY3Rpb24gcmVxdWlyZXMgYSBub24tbnVsbCBgYGBsYXllci5zdGF0ZWBgYFxuICAgIC8vIG9iamVjdCB0byBmdW50aW9uIHByb3Blcmx5LiBTbyB0aGUgbGF5ZXIgcmVmZXJlY2VkIGhlcmVcbiAgICAvLyBtdXN0IGJlIHRoZSBcImN1cnJlbnRcIiBsYXllciwgbm90IGFuIFwib3V0LWRhdGVkXCIgLyBcImludmFsaWRhdGVkXCIgbGF5ZXJcbiAgICBpbmZvID0gbGF5ZXIucGlja0xheWVyKHtpbmZvLCBtb2RlLCBzb3VyY2VMYXllcn0pO1xuICAgIGxheWVyID0gbGF5ZXIucGFyZW50TGF5ZXI7XG4gIH1cbiAgcmV0dXJuIGluZm87XG59XG4iXX0=