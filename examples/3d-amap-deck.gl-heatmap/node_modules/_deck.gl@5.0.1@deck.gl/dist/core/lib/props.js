'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.diffProps = diffProps;
exports.compareProps = compareProps;
exports.getDefaultProps = getDefaultProps;
exports.mergeDefaultProps = mergeDefaultProps;

var _log = require('../utils/log');

var _log2 = _interopRequireDefault(_log);

var _assert = require('assert');

var _assert2 = _interopRequireDefault(_assert);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Returns an object with "change flags", either false or strings indicating reason for change
function diffProps(props, oldProps) {
  // First check if any props have changed (ignore props that will be examined separately)
  var propsChangedReason = compareProps({
    newProps: props,
    oldProps: oldProps,
    ignoreProps: { data: null, updateTriggers: null }
  });

  // Now check if any data related props have changed
  var dataChangedReason = diffDataProps(props, oldProps);

  // Check update triggers to determine if any attributes need regeneration
  // Note - if data has changed, all attributes will need regeneration, so skip this step
  var updateTriggersChangedReason = false;
  if (!dataChangedReason) {
    updateTriggersChangedReason = diffUpdateTriggers(props, oldProps);
  }

  return {
    dataChanged: dataChangedReason,
    propsChanged: propsChangedReason,
    updateTriggersChanged: updateTriggersChangedReason
  };
}

/**
 * Performs equality by iterating through keys on an object and returning false
 * when any key has values which are not strictly equal between the arguments.
 * @param {Object} opt.oldProps - object with old key/value pairs
 * @param {Object} opt.newProps - object with new key/value pairs
 * @param {Object} opt.ignoreProps={} - object, keys that should not be compared
 * @returns {null|String} - null when values of all keys are strictly equal.
 *   if unequal, returns a string explaining what changed.
 */
/* eslint-disable max-statements, max-depth, complexity */
function compareProps() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      newProps = _ref.newProps,
      oldProps = _ref.oldProps,
      _ref$ignoreProps = _ref.ignoreProps,
      ignoreProps = _ref$ignoreProps === undefined ? {} : _ref$ignoreProps,
      _ref$shallowComparePr = _ref.shallowCompareProps,
      shallowCompareProps = _ref$shallowComparePr === undefined ? {} : _ref$shallowComparePr,
      _ref$triggerName = _ref.triggerName,
      triggerName = _ref$triggerName === undefined ? 'props' : _ref$triggerName;

  (0, _assert2.default)(oldProps !== undefined && newProps !== undefined, 'compareProps args');

  // shallow equality => deep equality
  if (oldProps === newProps) {
    return null;
  }

  // TODO - do we need these checks? Should never happen...
  if ((typeof newProps === 'undefined' ? 'undefined' : _typeof(newProps)) !== 'object' || newProps === null) {
    return triggerName + ' changed shallowly';
  }

  if ((typeof oldProps === 'undefined' ? 'undefined' : _typeof(oldProps)) !== 'object' || oldProps === null) {
    return triggerName + ' changed shallowly';
  }

  // Test if new props different from old props
  for (var key in oldProps) {
    if (!(key in ignoreProps)) {
      if (!newProps.hasOwnProperty(key)) {
        return triggerName + '.' + key + ' dropped: ' + oldProps[key] + ' -> undefined';
      }

      // If object has an equals function, invoke it
      var equals = newProps[key] && oldProps[key] && newProps[key].equals;
      if (equals && !equals.call(newProps[key], oldProps[key])) {
        return triggerName + '.' + key + ' changed deeply: ' + oldProps[key] + ' -> ' + newProps[key];
      }

      // If both new and old value are functions, ignore differences
      if (key in shallowCompareProps) {
        var type = _typeof(newProps[key]);
        if (type === 'function' && typeof oldProps[key] === 'function') {
          equals = true;
        }
      }

      if (!equals && oldProps[key] !== newProps[key]) {
        return triggerName + '.' + key + ' changed shallowly: ' + oldProps[key] + ' -> ' + newProps[key];
      }
    }
  }

  // Test if any new props have been added
  for (var _key in newProps) {
    if (!(_key in ignoreProps)) {
      if (!oldProps.hasOwnProperty(_key)) {
        return triggerName + '.' + _key + ' added: undefined -> ' + newProps[_key];
      }
    }
  }

  return null;
}
/* eslint-enable max-statements, max-depth, complexity */

// HELPERS

// The comparison of the data prop requires special handling
// the dataComparator should be used if supplied
function diffDataProps(props, oldProps) {
  if (oldProps === null) {
    return 'oldProps is null, initial diff';
  }

  // Support optional app defined comparison of data
  var dataComparator = props.dataComparator;

  if (dataComparator) {
    if (!dataComparator(props.data, oldProps.data)) {
      return 'Data comparator detected a change';
    }
    // Otherwise, do a shallow equal on props
  } else if (props.data !== oldProps.data) {
    return 'A new data container was supplied';
  }

  return null;
}

// Checks if any update triggers have changed
// also calls callback to invalidate attributes accordingly.
function diffUpdateTriggers(props, oldProps) {
  if (oldProps === null) {
    return 'oldProps is null, initial diff';
  }

  // If the 'all' updateTrigger fires, ignore testing others
  if ('all' in props.updateTriggers) {
    var diffReason = diffUpdateTrigger(oldProps, props, 'all');
    if (diffReason) {
      return { all: true };
    }
  }

  var triggerChanged = {};
  var reason = false;
  // If the 'all' updateTrigger didn't fire, need to check all others
  for (var triggerName in props.updateTriggers) {
    if (triggerName !== 'all') {
      var _diffReason = diffUpdateTrigger(oldProps, props, triggerName);
      if (_diffReason) {
        triggerChanged[triggerName] = true;
        reason = triggerChanged;
      }
    }
  }

  return reason;
}

function diffUpdateTrigger(props, oldProps, triggerName) {
  var newTriggers = props.updateTriggers[triggerName] || {};
  var oldTriggers = oldProps.updateTriggers[triggerName] || {};
  var diffReason = compareProps({
    oldProps: oldTriggers,
    newProps: newTriggers,
    triggerName: triggerName
  });
  return diffReason;
}

// Constructors have their super class constructors as prototypes
function getOwnProperty(object, prop) {
  return Object.prototype.hasOwnProperty.call(object, prop) && object[prop];
}

/*
 * Return merged default props stored on layers constructor, create them if needed
 */
function getDefaultProps(layer) {
  // TODO - getOwnProperty is very slow, reduces layer construction speed 3x
  var mergedDefaultProps = getOwnProperty(layer.constructor, 'mergedDefaultProps');
  if (mergedDefaultProps) {
    return mergedDefaultProps;
  }
  return mergeDefaultProps(layer);
}

/*
 * Walk a prototype chain and merge all default props from any 'defaultProps' objects
 */
function mergeDefaultProps(object) {
  var objectNameKey = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'layerName';

  var subClassConstructor = object.constructor;
  var objectName = getOwnProperty(subClassConstructor, objectNameKey);
  if (!objectName) {
    _log2.default.once(0, object.constructor.name + ' does not specify a ' + objectNameKey);
  }

  // Use the object's constructor name as default id prop.
  // Note that constructor names are substituted during minification and may not be "human readable"
  var mergedDefaultProps = {
    id: objectName || object.constructor.name
  };

  // Reverse shadowing
  // TODO - Rewrite to stop when mergedDefaultProps is available on parent?
  while (object) {
    var objectDefaultProps = getOwnProperty(object.constructor, 'defaultProps');
    Object.freeze(objectDefaultProps);
    if (objectDefaultProps) {
      mergedDefaultProps = Object.assign({}, objectDefaultProps, mergedDefaultProps);
    }
    object = Object.getPrototypeOf(object);
  }

  Object.freeze(mergedDefaultProps);

  // Store for quick lookup
  subClassConstructor.mergedDefaultProps = mergedDefaultProps;

  (0, _assert2.default)(mergeDefaultProps);
  return mergedDefaultProps;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9jb3JlL2xpYi9wcm9wcy5qcyJdLCJuYW1lcyI6WyJkaWZmUHJvcHMiLCJjb21wYXJlUHJvcHMiLCJnZXREZWZhdWx0UHJvcHMiLCJtZXJnZURlZmF1bHRQcm9wcyIsInByb3BzIiwib2xkUHJvcHMiLCJwcm9wc0NoYW5nZWRSZWFzb24iLCJuZXdQcm9wcyIsImlnbm9yZVByb3BzIiwiZGF0YSIsInVwZGF0ZVRyaWdnZXJzIiwiZGF0YUNoYW5nZWRSZWFzb24iLCJkaWZmRGF0YVByb3BzIiwidXBkYXRlVHJpZ2dlcnNDaGFuZ2VkUmVhc29uIiwiZGlmZlVwZGF0ZVRyaWdnZXJzIiwiZGF0YUNoYW5nZWQiLCJwcm9wc0NoYW5nZWQiLCJ1cGRhdGVUcmlnZ2Vyc0NoYW5nZWQiLCJzaGFsbG93Q29tcGFyZVByb3BzIiwidHJpZ2dlck5hbWUiLCJ1bmRlZmluZWQiLCJrZXkiLCJoYXNPd25Qcm9wZXJ0eSIsImVxdWFscyIsImNhbGwiLCJ0eXBlIiwiZGF0YUNvbXBhcmF0b3IiLCJkaWZmUmVhc29uIiwiZGlmZlVwZGF0ZVRyaWdnZXIiLCJhbGwiLCJ0cmlnZ2VyQ2hhbmdlZCIsInJlYXNvbiIsIm5ld1RyaWdnZXJzIiwib2xkVHJpZ2dlcnMiLCJnZXRPd25Qcm9wZXJ0eSIsIm9iamVjdCIsInByb3AiLCJPYmplY3QiLCJwcm90b3R5cGUiLCJsYXllciIsIm1lcmdlZERlZmF1bHRQcm9wcyIsImNvbnN0cnVjdG9yIiwib2JqZWN0TmFtZUtleSIsInN1YkNsYXNzQ29uc3RydWN0b3IiLCJvYmplY3ROYW1lIiwib25jZSIsIm5hbWUiLCJpZCIsIm9iamVjdERlZmF1bHRQcm9wcyIsImZyZWV6ZSIsImFzc2lnbiIsImdldFByb3RvdHlwZU9mIl0sIm1hcHBpbmdzIjoiOzs7Ozs7OztRQUlnQkEsUyxHQUFBQSxTO1FBbUNBQyxZLEdBQUFBLFk7UUF3SUFDLGUsR0FBQUEsZTtRQVlBQyxpQixHQUFBQSxpQjs7QUEzTGhCOzs7O0FBQ0E7Ozs7OztBQUVBO0FBQ08sU0FBU0gsU0FBVCxDQUFtQkksS0FBbkIsRUFBMEJDLFFBQTFCLEVBQW9DO0FBQ3pDO0FBQ0EsTUFBTUMscUJBQXFCTCxhQUFhO0FBQ3RDTSxjQUFVSCxLQUQ0QjtBQUV0Q0Msc0JBRnNDO0FBR3RDRyxpQkFBYSxFQUFDQyxNQUFNLElBQVAsRUFBYUMsZ0JBQWdCLElBQTdCO0FBSHlCLEdBQWIsQ0FBM0I7O0FBTUE7QUFDQSxNQUFNQyxvQkFBb0JDLGNBQWNSLEtBQWQsRUFBcUJDLFFBQXJCLENBQTFCOztBQUVBO0FBQ0E7QUFDQSxNQUFJUSw4QkFBOEIsS0FBbEM7QUFDQSxNQUFJLENBQUNGLGlCQUFMLEVBQXdCO0FBQ3RCRSxrQ0FBOEJDLG1CQUFtQlYsS0FBbkIsRUFBMEJDLFFBQTFCLENBQTlCO0FBQ0Q7O0FBRUQsU0FBTztBQUNMVSxpQkFBYUosaUJBRFI7QUFFTEssa0JBQWNWLGtCQUZUO0FBR0xXLDJCQUF1Qko7QUFIbEIsR0FBUDtBQUtEOztBQUVEOzs7Ozs7Ozs7QUFTQTtBQUNPLFNBQVNaLFlBQVQsR0FNQztBQUFBLGlGQUFKLEVBQUk7QUFBQSxNQUxOTSxRQUtNLFFBTE5BLFFBS007QUFBQSxNQUpORixRQUlNLFFBSk5BLFFBSU07QUFBQSw4QkFITkcsV0FHTTtBQUFBLE1BSE5BLFdBR00sb0NBSFEsRUFHUjtBQUFBLG1DQUZOVSxtQkFFTTtBQUFBLE1BRk5BLG1CQUVNLHlDQUZnQixFQUVoQjtBQUFBLDhCQUROQyxXQUNNO0FBQUEsTUFETkEsV0FDTSxvQ0FEUSxPQUNSOztBQUNOLHdCQUFPZCxhQUFhZSxTQUFiLElBQTBCYixhQUFhYSxTQUE5QyxFQUF5RCxtQkFBekQ7O0FBRUE7QUFDQSxNQUFJZixhQUFhRSxRQUFqQixFQUEyQjtBQUN6QixXQUFPLElBQVA7QUFDRDs7QUFFRDtBQUNBLE1BQUksUUFBT0EsUUFBUCx5Q0FBT0EsUUFBUCxPQUFvQixRQUFwQixJQUFnQ0EsYUFBYSxJQUFqRCxFQUF1RDtBQUNyRCxXQUFVWSxXQUFWO0FBQ0Q7O0FBRUQsTUFBSSxRQUFPZCxRQUFQLHlDQUFPQSxRQUFQLE9BQW9CLFFBQXBCLElBQWdDQSxhQUFhLElBQWpELEVBQXVEO0FBQ3JELFdBQVVjLFdBQVY7QUFDRDs7QUFFRDtBQUNBLE9BQUssSUFBTUUsR0FBWCxJQUFrQmhCLFFBQWxCLEVBQTRCO0FBQzFCLFFBQUksRUFBRWdCLE9BQU9iLFdBQVQsQ0FBSixFQUEyQjtBQUN6QixVQUFJLENBQUNELFNBQVNlLGNBQVQsQ0FBd0JELEdBQXhCLENBQUwsRUFBbUM7QUFDakMsZUFBVUYsV0FBVixTQUF5QkUsR0FBekIsa0JBQXlDaEIsU0FBU2dCLEdBQVQsQ0FBekM7QUFDRDs7QUFFRDtBQUNBLFVBQUlFLFNBQVNoQixTQUFTYyxHQUFULEtBQWlCaEIsU0FBU2dCLEdBQVQsQ0FBakIsSUFBa0NkLFNBQVNjLEdBQVQsRUFBY0UsTUFBN0Q7QUFDQSxVQUFJQSxVQUFVLENBQUNBLE9BQU9DLElBQVAsQ0FBWWpCLFNBQVNjLEdBQVQsQ0FBWixFQUEyQmhCLFNBQVNnQixHQUFULENBQTNCLENBQWYsRUFBMEQ7QUFDeEQsZUFBVUYsV0FBVixTQUF5QkUsR0FBekIseUJBQWdEaEIsU0FBU2dCLEdBQVQsQ0FBaEQsWUFBb0VkLFNBQVNjLEdBQVQsQ0FBcEU7QUFDRDs7QUFFRDtBQUNBLFVBQUlBLE9BQU9ILG1CQUFYLEVBQWdDO0FBQzlCLFlBQU1PLGVBQWNsQixTQUFTYyxHQUFULENBQWQsQ0FBTjtBQUNBLFlBQUlJLFNBQVMsVUFBVCxJQUF1QixPQUFPcEIsU0FBU2dCLEdBQVQsQ0FBUCxLQUF5QixVQUFwRCxFQUFnRTtBQUM5REUsbUJBQVMsSUFBVDtBQUNEO0FBQ0Y7O0FBRUQsVUFBSSxDQUFDQSxNQUFELElBQVdsQixTQUFTZ0IsR0FBVCxNQUFrQmQsU0FBU2MsR0FBVCxDQUFqQyxFQUFnRDtBQUM5QyxlQUFVRixXQUFWLFNBQXlCRSxHQUF6Qiw0QkFBbURoQixTQUFTZ0IsR0FBVCxDQUFuRCxZQUF1RWQsU0FBU2MsR0FBVCxDQUF2RTtBQUNEO0FBQ0Y7QUFDRjs7QUFFRDtBQUNBLE9BQUssSUFBTUEsSUFBWCxJQUFrQmQsUUFBbEIsRUFBNEI7QUFDMUIsUUFBSSxFQUFFYyxRQUFPYixXQUFULENBQUosRUFBMkI7QUFDekIsVUFBSSxDQUFDSCxTQUFTaUIsY0FBVCxDQUF3QkQsSUFBeEIsQ0FBTCxFQUFtQztBQUNqQyxlQUFVRixXQUFWLFNBQXlCRSxJQUF6Qiw2QkFBb0RkLFNBQVNjLElBQVQsQ0FBcEQ7QUFDRDtBQUNGO0FBQ0Y7O0FBRUQsU0FBTyxJQUFQO0FBQ0Q7QUFDRDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsU0FBU1QsYUFBVCxDQUF1QlIsS0FBdkIsRUFBOEJDLFFBQTlCLEVBQXdDO0FBQ3RDLE1BQUlBLGFBQWEsSUFBakIsRUFBdUI7QUFDckIsV0FBTyxnQ0FBUDtBQUNEOztBQUVEO0FBTHNDLE1BTS9CcUIsY0FOK0IsR0FNYnRCLEtBTmEsQ0FNL0JzQixjQU4rQjs7QUFPdEMsTUFBSUEsY0FBSixFQUFvQjtBQUNsQixRQUFJLENBQUNBLGVBQWV0QixNQUFNSyxJQUFyQixFQUEyQkosU0FBU0ksSUFBcEMsQ0FBTCxFQUFnRDtBQUM5QyxhQUFPLG1DQUFQO0FBQ0Q7QUFDRDtBQUNELEdBTEQsTUFLTyxJQUFJTCxNQUFNSyxJQUFOLEtBQWVKLFNBQVNJLElBQTVCLEVBQWtDO0FBQ3ZDLFdBQU8sbUNBQVA7QUFDRDs7QUFFRCxTQUFPLElBQVA7QUFDRDs7QUFFRDtBQUNBO0FBQ0EsU0FBU0ssa0JBQVQsQ0FBNEJWLEtBQTVCLEVBQW1DQyxRQUFuQyxFQUE2QztBQUMzQyxNQUFJQSxhQUFhLElBQWpCLEVBQXVCO0FBQ3JCLFdBQU8sZ0NBQVA7QUFDRDs7QUFFRDtBQUNBLE1BQUksU0FBU0QsTUFBTU0sY0FBbkIsRUFBbUM7QUFDakMsUUFBTWlCLGFBQWFDLGtCQUFrQnZCLFFBQWxCLEVBQTRCRCxLQUE1QixFQUFtQyxLQUFuQyxDQUFuQjtBQUNBLFFBQUl1QixVQUFKLEVBQWdCO0FBQ2QsYUFBTyxFQUFDRSxLQUFLLElBQU4sRUFBUDtBQUNEO0FBQ0Y7O0FBRUQsTUFBTUMsaUJBQWlCLEVBQXZCO0FBQ0EsTUFBSUMsU0FBUyxLQUFiO0FBQ0E7QUFDQSxPQUFLLElBQU1aLFdBQVgsSUFBMEJmLE1BQU1NLGNBQWhDLEVBQWdEO0FBQzlDLFFBQUlTLGdCQUFnQixLQUFwQixFQUEyQjtBQUN6QixVQUFNUSxjQUFhQyxrQkFBa0J2QixRQUFsQixFQUE0QkQsS0FBNUIsRUFBbUNlLFdBQW5DLENBQW5CO0FBQ0EsVUFBSVEsV0FBSixFQUFnQjtBQUNkRyx1QkFBZVgsV0FBZixJQUE4QixJQUE5QjtBQUNBWSxpQkFBU0QsY0FBVDtBQUNEO0FBQ0Y7QUFDRjs7QUFFRCxTQUFPQyxNQUFQO0FBQ0Q7O0FBRUQsU0FBU0gsaUJBQVQsQ0FBMkJ4QixLQUEzQixFQUFrQ0MsUUFBbEMsRUFBNENjLFdBQTVDLEVBQXlEO0FBQ3ZELE1BQU1hLGNBQWM1QixNQUFNTSxjQUFOLENBQXFCUyxXQUFyQixLQUFxQyxFQUF6RDtBQUNBLE1BQU1jLGNBQWM1QixTQUFTSyxjQUFULENBQXdCUyxXQUF4QixLQUF3QyxFQUE1RDtBQUNBLE1BQU1RLGFBQWExQixhQUFhO0FBQzlCSSxjQUFVNEIsV0FEb0I7QUFFOUIxQixjQUFVeUIsV0FGb0I7QUFHOUJiO0FBSDhCLEdBQWIsQ0FBbkI7QUFLQSxTQUFPUSxVQUFQO0FBQ0Q7O0FBRUQ7QUFDQSxTQUFTTyxjQUFULENBQXdCQyxNQUF4QixFQUFnQ0MsSUFBaEMsRUFBc0M7QUFDcEMsU0FBT0MsT0FBT0MsU0FBUCxDQUFpQmhCLGNBQWpCLENBQWdDRSxJQUFoQyxDQUFxQ1csTUFBckMsRUFBNkNDLElBQTdDLEtBQXNERCxPQUFPQyxJQUFQLENBQTdEO0FBQ0Q7O0FBRUQ7OztBQUdPLFNBQVNsQyxlQUFULENBQXlCcUMsS0FBekIsRUFBZ0M7QUFDckM7QUFDQSxNQUFNQyxxQkFBcUJOLGVBQWVLLE1BQU1FLFdBQXJCLEVBQWtDLG9CQUFsQyxDQUEzQjtBQUNBLE1BQUlELGtCQUFKLEVBQXdCO0FBQ3RCLFdBQU9BLGtCQUFQO0FBQ0Q7QUFDRCxTQUFPckMsa0JBQWtCb0MsS0FBbEIsQ0FBUDtBQUNEOztBQUVEOzs7QUFHTyxTQUFTcEMsaUJBQVQsQ0FBMkJnQyxNQUEzQixFQUFnRTtBQUFBLE1BQTdCTyxhQUE2Qix1RUFBYixXQUFhOztBQUNyRSxNQUFNQyxzQkFBc0JSLE9BQU9NLFdBQW5DO0FBQ0EsTUFBTUcsYUFBYVYsZUFBZVMsbUJBQWYsRUFBb0NELGFBQXBDLENBQW5CO0FBQ0EsTUFBSSxDQUFDRSxVQUFMLEVBQWlCO0FBQ2Ysa0JBQUlDLElBQUosQ0FBUyxDQUFULEVBQWVWLE9BQU9NLFdBQVAsQ0FBbUJLLElBQWxDLDRCQUE2REosYUFBN0Q7QUFDRDs7QUFFRDtBQUNBO0FBQ0EsTUFBSUYscUJBQXFCO0FBQ3ZCTyxRQUFJSCxjQUFjVCxPQUFPTSxXQUFQLENBQW1CSztBQURkLEdBQXpCOztBQUlBO0FBQ0E7QUFDQSxTQUFPWCxNQUFQLEVBQWU7QUFDYixRQUFNYSxxQkFBcUJkLGVBQWVDLE9BQU9NLFdBQXRCLEVBQW1DLGNBQW5DLENBQTNCO0FBQ0FKLFdBQU9ZLE1BQVAsQ0FBY0Qsa0JBQWQ7QUFDQSxRQUFJQSxrQkFBSixFQUF3QjtBQUN0QlIsMkJBQXFCSCxPQUFPYSxNQUFQLENBQWMsRUFBZCxFQUFrQkYsa0JBQWxCLEVBQXNDUixrQkFBdEMsQ0FBckI7QUFDRDtBQUNETCxhQUFTRSxPQUFPYyxjQUFQLENBQXNCaEIsTUFBdEIsQ0FBVDtBQUNEOztBQUVERSxTQUFPWSxNQUFQLENBQWNULGtCQUFkOztBQUVBO0FBQ0FHLHNCQUFvQkgsa0JBQXBCLEdBQXlDQSxrQkFBekM7O0FBRUEsd0JBQU9yQyxpQkFBUDtBQUNBLFNBQU9xQyxrQkFBUDtBQUNEIiwiZmlsZSI6InByb3BzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGxvZyBmcm9tICcuLi91dGlscy9sb2cnO1xuaW1wb3J0IGFzc2VydCBmcm9tICdhc3NlcnQnO1xuXG4vLyBSZXR1cm5zIGFuIG9iamVjdCB3aXRoIFwiY2hhbmdlIGZsYWdzXCIsIGVpdGhlciBmYWxzZSBvciBzdHJpbmdzIGluZGljYXRpbmcgcmVhc29uIGZvciBjaGFuZ2VcbmV4cG9ydCBmdW5jdGlvbiBkaWZmUHJvcHMocHJvcHMsIG9sZFByb3BzKSB7XG4gIC8vIEZpcnN0IGNoZWNrIGlmIGFueSBwcm9wcyBoYXZlIGNoYW5nZWQgKGlnbm9yZSBwcm9wcyB0aGF0IHdpbGwgYmUgZXhhbWluZWQgc2VwYXJhdGVseSlcbiAgY29uc3QgcHJvcHNDaGFuZ2VkUmVhc29uID0gY29tcGFyZVByb3BzKHtcbiAgICBuZXdQcm9wczogcHJvcHMsXG4gICAgb2xkUHJvcHMsXG4gICAgaWdub3JlUHJvcHM6IHtkYXRhOiBudWxsLCB1cGRhdGVUcmlnZ2VyczogbnVsbH1cbiAgfSk7XG5cbiAgLy8gTm93IGNoZWNrIGlmIGFueSBkYXRhIHJlbGF0ZWQgcHJvcHMgaGF2ZSBjaGFuZ2VkXG4gIGNvbnN0IGRhdGFDaGFuZ2VkUmVhc29uID0gZGlmZkRhdGFQcm9wcyhwcm9wcywgb2xkUHJvcHMpO1xuXG4gIC8vIENoZWNrIHVwZGF0ZSB0cmlnZ2VycyB0byBkZXRlcm1pbmUgaWYgYW55IGF0dHJpYnV0ZXMgbmVlZCByZWdlbmVyYXRpb25cbiAgLy8gTm90ZSAtIGlmIGRhdGEgaGFzIGNoYW5nZWQsIGFsbCBhdHRyaWJ1dGVzIHdpbGwgbmVlZCByZWdlbmVyYXRpb24sIHNvIHNraXAgdGhpcyBzdGVwXG4gIGxldCB1cGRhdGVUcmlnZ2Vyc0NoYW5nZWRSZWFzb24gPSBmYWxzZTtcbiAgaWYgKCFkYXRhQ2hhbmdlZFJlYXNvbikge1xuICAgIHVwZGF0ZVRyaWdnZXJzQ2hhbmdlZFJlYXNvbiA9IGRpZmZVcGRhdGVUcmlnZ2Vycyhwcm9wcywgb2xkUHJvcHMpO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBkYXRhQ2hhbmdlZDogZGF0YUNoYW5nZWRSZWFzb24sXG4gICAgcHJvcHNDaGFuZ2VkOiBwcm9wc0NoYW5nZWRSZWFzb24sXG4gICAgdXBkYXRlVHJpZ2dlcnNDaGFuZ2VkOiB1cGRhdGVUcmlnZ2Vyc0NoYW5nZWRSZWFzb25cbiAgfTtcbn1cblxuLyoqXG4gKiBQZXJmb3JtcyBlcXVhbGl0eSBieSBpdGVyYXRpbmcgdGhyb3VnaCBrZXlzIG9uIGFuIG9iamVjdCBhbmQgcmV0dXJuaW5nIGZhbHNlXG4gKiB3aGVuIGFueSBrZXkgaGFzIHZhbHVlcyB3aGljaCBhcmUgbm90IHN0cmljdGx5IGVxdWFsIGJldHdlZW4gdGhlIGFyZ3VtZW50cy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHQub2xkUHJvcHMgLSBvYmplY3Qgd2l0aCBvbGQga2V5L3ZhbHVlIHBhaXJzXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0Lm5ld1Byb3BzIC0gb2JqZWN0IHdpdGggbmV3IGtleS92YWx1ZSBwYWlyc1xuICogQHBhcmFtIHtPYmplY3R9IG9wdC5pZ25vcmVQcm9wcz17fSAtIG9iamVjdCwga2V5cyB0aGF0IHNob3VsZCBub3QgYmUgY29tcGFyZWRcbiAqIEByZXR1cm5zIHtudWxsfFN0cmluZ30gLSBudWxsIHdoZW4gdmFsdWVzIG9mIGFsbCBrZXlzIGFyZSBzdHJpY3RseSBlcXVhbC5cbiAqICAgaWYgdW5lcXVhbCwgcmV0dXJucyBhIHN0cmluZyBleHBsYWluaW5nIHdoYXQgY2hhbmdlZC5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbWF4LXN0YXRlbWVudHMsIG1heC1kZXB0aCwgY29tcGxleGl0eSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbXBhcmVQcm9wcyh7XG4gIG5ld1Byb3BzLFxuICBvbGRQcm9wcyxcbiAgaWdub3JlUHJvcHMgPSB7fSxcbiAgc2hhbGxvd0NvbXBhcmVQcm9wcyA9IHt9LFxuICB0cmlnZ2VyTmFtZSA9ICdwcm9wcydcbn0gPSB7fSkge1xuICBhc3NlcnQob2xkUHJvcHMgIT09IHVuZGVmaW5lZCAmJiBuZXdQcm9wcyAhPT0gdW5kZWZpbmVkLCAnY29tcGFyZVByb3BzIGFyZ3MnKTtcblxuICAvLyBzaGFsbG93IGVxdWFsaXR5ID0+IGRlZXAgZXF1YWxpdHlcbiAgaWYgKG9sZFByb3BzID09PSBuZXdQcm9wcykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gVE9ETyAtIGRvIHdlIG5lZWQgdGhlc2UgY2hlY2tzPyBTaG91bGQgbmV2ZXIgaGFwcGVuLi4uXG4gIGlmICh0eXBlb2YgbmV3UHJvcHMgIT09ICdvYmplY3QnIHx8IG5ld1Byb3BzID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGAke3RyaWdnZXJOYW1lfSBjaGFuZ2VkIHNoYWxsb3dseWA7XG4gIH1cblxuICBpZiAodHlwZW9mIG9sZFByb3BzICE9PSAnb2JqZWN0JyB8fCBvbGRQcm9wcyA9PT0gbnVsbCkge1xuICAgIHJldHVybiBgJHt0cmlnZ2VyTmFtZX0gY2hhbmdlZCBzaGFsbG93bHlgO1xuICB9XG5cbiAgLy8gVGVzdCBpZiBuZXcgcHJvcHMgZGlmZmVyZW50IGZyb20gb2xkIHByb3BzXG4gIGZvciAoY29uc3Qga2V5IGluIG9sZFByb3BzKSB7XG4gICAgaWYgKCEoa2V5IGluIGlnbm9yZVByb3BzKSkge1xuICAgICAgaWYgKCFuZXdQcm9wcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgIHJldHVybiBgJHt0cmlnZ2VyTmFtZX0uJHtrZXl9IGRyb3BwZWQ6ICR7b2xkUHJvcHNba2V5XX0gLT4gdW5kZWZpbmVkYDtcbiAgICAgIH1cblxuICAgICAgLy8gSWYgb2JqZWN0IGhhcyBhbiBlcXVhbHMgZnVuY3Rpb24sIGludm9rZSBpdFxuICAgICAgbGV0IGVxdWFscyA9IG5ld1Byb3BzW2tleV0gJiYgb2xkUHJvcHNba2V5XSAmJiBuZXdQcm9wc1trZXldLmVxdWFscztcbiAgICAgIGlmIChlcXVhbHMgJiYgIWVxdWFscy5jYWxsKG5ld1Byb3BzW2tleV0sIG9sZFByb3BzW2tleV0pKSB7XG4gICAgICAgIHJldHVybiBgJHt0cmlnZ2VyTmFtZX0uJHtrZXl9IGNoYW5nZWQgZGVlcGx5OiAke29sZFByb3BzW2tleV19IC0+ICR7bmV3UHJvcHNba2V5XX1gO1xuICAgICAgfVxuXG4gICAgICAvLyBJZiBib3RoIG5ldyBhbmQgb2xkIHZhbHVlIGFyZSBmdW5jdGlvbnMsIGlnbm9yZSBkaWZmZXJlbmNlc1xuICAgICAgaWYgKGtleSBpbiBzaGFsbG93Q29tcGFyZVByb3BzKSB7XG4gICAgICAgIGNvbnN0IHR5cGUgPSB0eXBlb2YgbmV3UHJvcHNba2V5XTtcbiAgICAgICAgaWYgKHR5cGUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIG9sZFByb3BzW2tleV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBlcXVhbHMgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghZXF1YWxzICYmIG9sZFByb3BzW2tleV0gIT09IG5ld1Byb3BzW2tleV0pIHtcbiAgICAgICAgcmV0dXJuIGAke3RyaWdnZXJOYW1lfS4ke2tleX0gY2hhbmdlZCBzaGFsbG93bHk6ICR7b2xkUHJvcHNba2V5XX0gLT4gJHtuZXdQcm9wc1trZXldfWA7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gVGVzdCBpZiBhbnkgbmV3IHByb3BzIGhhdmUgYmVlbiBhZGRlZFxuICBmb3IgKGNvbnN0IGtleSBpbiBuZXdQcm9wcykge1xuICAgIGlmICghKGtleSBpbiBpZ25vcmVQcm9wcykpIHtcbiAgICAgIGlmICghb2xkUHJvcHMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICByZXR1cm4gYCR7dHJpZ2dlck5hbWV9LiR7a2V5fSBhZGRlZDogdW5kZWZpbmVkIC0+ICR7bmV3UHJvcHNba2V5XX1gO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuLyogZXNsaW50LWVuYWJsZSBtYXgtc3RhdGVtZW50cywgbWF4LWRlcHRoLCBjb21wbGV4aXR5ICovXG5cbi8vIEhFTFBFUlNcblxuLy8gVGhlIGNvbXBhcmlzb24gb2YgdGhlIGRhdGEgcHJvcCByZXF1aXJlcyBzcGVjaWFsIGhhbmRsaW5nXG4vLyB0aGUgZGF0YUNvbXBhcmF0b3Igc2hvdWxkIGJlIHVzZWQgaWYgc3VwcGxpZWRcbmZ1bmN0aW9uIGRpZmZEYXRhUHJvcHMocHJvcHMsIG9sZFByb3BzKSB7XG4gIGlmIChvbGRQcm9wcyA9PT0gbnVsbCkge1xuICAgIHJldHVybiAnb2xkUHJvcHMgaXMgbnVsbCwgaW5pdGlhbCBkaWZmJztcbiAgfVxuXG4gIC8vIFN1cHBvcnQgb3B0aW9uYWwgYXBwIGRlZmluZWQgY29tcGFyaXNvbiBvZiBkYXRhXG4gIGNvbnN0IHtkYXRhQ29tcGFyYXRvcn0gPSBwcm9wcztcbiAgaWYgKGRhdGFDb21wYXJhdG9yKSB7XG4gICAgaWYgKCFkYXRhQ29tcGFyYXRvcihwcm9wcy5kYXRhLCBvbGRQcm9wcy5kYXRhKSkge1xuICAgICAgcmV0dXJuICdEYXRhIGNvbXBhcmF0b3IgZGV0ZWN0ZWQgYSBjaGFuZ2UnO1xuICAgIH1cbiAgICAvLyBPdGhlcndpc2UsIGRvIGEgc2hhbGxvdyBlcXVhbCBvbiBwcm9wc1xuICB9IGVsc2UgaWYgKHByb3BzLmRhdGEgIT09IG9sZFByb3BzLmRhdGEpIHtcbiAgICByZXR1cm4gJ0EgbmV3IGRhdGEgY29udGFpbmVyIHdhcyBzdXBwbGllZCc7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuLy8gQ2hlY2tzIGlmIGFueSB1cGRhdGUgdHJpZ2dlcnMgaGF2ZSBjaGFuZ2VkXG4vLyBhbHNvIGNhbGxzIGNhbGxiYWNrIHRvIGludmFsaWRhdGUgYXR0cmlidXRlcyBhY2NvcmRpbmdseS5cbmZ1bmN0aW9uIGRpZmZVcGRhdGVUcmlnZ2Vycyhwcm9wcywgb2xkUHJvcHMpIHtcbiAgaWYgKG9sZFByb3BzID09PSBudWxsKSB7XG4gICAgcmV0dXJuICdvbGRQcm9wcyBpcyBudWxsLCBpbml0aWFsIGRpZmYnO1xuICB9XG5cbiAgLy8gSWYgdGhlICdhbGwnIHVwZGF0ZVRyaWdnZXIgZmlyZXMsIGlnbm9yZSB0ZXN0aW5nIG90aGVyc1xuICBpZiAoJ2FsbCcgaW4gcHJvcHMudXBkYXRlVHJpZ2dlcnMpIHtcbiAgICBjb25zdCBkaWZmUmVhc29uID0gZGlmZlVwZGF0ZVRyaWdnZXIob2xkUHJvcHMsIHByb3BzLCAnYWxsJyk7XG4gICAgaWYgKGRpZmZSZWFzb24pIHtcbiAgICAgIHJldHVybiB7YWxsOiB0cnVlfTtcbiAgICB9XG4gIH1cblxuICBjb25zdCB0cmlnZ2VyQ2hhbmdlZCA9IHt9O1xuICBsZXQgcmVhc29uID0gZmFsc2U7XG4gIC8vIElmIHRoZSAnYWxsJyB1cGRhdGVUcmlnZ2VyIGRpZG4ndCBmaXJlLCBuZWVkIHRvIGNoZWNrIGFsbCBvdGhlcnNcbiAgZm9yIChjb25zdCB0cmlnZ2VyTmFtZSBpbiBwcm9wcy51cGRhdGVUcmlnZ2Vycykge1xuICAgIGlmICh0cmlnZ2VyTmFtZSAhPT0gJ2FsbCcpIHtcbiAgICAgIGNvbnN0IGRpZmZSZWFzb24gPSBkaWZmVXBkYXRlVHJpZ2dlcihvbGRQcm9wcywgcHJvcHMsIHRyaWdnZXJOYW1lKTtcbiAgICAgIGlmIChkaWZmUmVhc29uKSB7XG4gICAgICAgIHRyaWdnZXJDaGFuZ2VkW3RyaWdnZXJOYW1lXSA9IHRydWU7XG4gICAgICAgIHJlYXNvbiA9IHRyaWdnZXJDaGFuZ2VkO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZWFzb247XG59XG5cbmZ1bmN0aW9uIGRpZmZVcGRhdGVUcmlnZ2VyKHByb3BzLCBvbGRQcm9wcywgdHJpZ2dlck5hbWUpIHtcbiAgY29uc3QgbmV3VHJpZ2dlcnMgPSBwcm9wcy51cGRhdGVUcmlnZ2Vyc1t0cmlnZ2VyTmFtZV0gfHwge307XG4gIGNvbnN0IG9sZFRyaWdnZXJzID0gb2xkUHJvcHMudXBkYXRlVHJpZ2dlcnNbdHJpZ2dlck5hbWVdIHx8IHt9O1xuICBjb25zdCBkaWZmUmVhc29uID0gY29tcGFyZVByb3BzKHtcbiAgICBvbGRQcm9wczogb2xkVHJpZ2dlcnMsXG4gICAgbmV3UHJvcHM6IG5ld1RyaWdnZXJzLFxuICAgIHRyaWdnZXJOYW1lXG4gIH0pO1xuICByZXR1cm4gZGlmZlJlYXNvbjtcbn1cblxuLy8gQ29uc3RydWN0b3JzIGhhdmUgdGhlaXIgc3VwZXIgY2xhc3MgY29uc3RydWN0b3JzIGFzIHByb3RvdHlwZXNcbmZ1bmN0aW9uIGdldE93blByb3BlcnR5KG9iamVjdCwgcHJvcCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcCkgJiYgb2JqZWN0W3Byb3BdO1xufVxuXG4vKlxuICogUmV0dXJuIG1lcmdlZCBkZWZhdWx0IHByb3BzIHN0b3JlZCBvbiBsYXllcnMgY29uc3RydWN0b3IsIGNyZWF0ZSB0aGVtIGlmIG5lZWRlZFxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0RGVmYXVsdFByb3BzKGxheWVyKSB7XG4gIC8vIFRPRE8gLSBnZXRPd25Qcm9wZXJ0eSBpcyB2ZXJ5IHNsb3csIHJlZHVjZXMgbGF5ZXIgY29uc3RydWN0aW9uIHNwZWVkIDN4XG4gIGNvbnN0IG1lcmdlZERlZmF1bHRQcm9wcyA9IGdldE93blByb3BlcnR5KGxheWVyLmNvbnN0cnVjdG9yLCAnbWVyZ2VkRGVmYXVsdFByb3BzJyk7XG4gIGlmIChtZXJnZWREZWZhdWx0UHJvcHMpIHtcbiAgICByZXR1cm4gbWVyZ2VkRGVmYXVsdFByb3BzO1xuICB9XG4gIHJldHVybiBtZXJnZURlZmF1bHRQcm9wcyhsYXllcik7XG59XG5cbi8qXG4gKiBXYWxrIGEgcHJvdG90eXBlIGNoYWluIGFuZCBtZXJnZSBhbGwgZGVmYXVsdCBwcm9wcyBmcm9tIGFueSAnZGVmYXVsdFByb3BzJyBvYmplY3RzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtZXJnZURlZmF1bHRQcm9wcyhvYmplY3QsIG9iamVjdE5hbWVLZXkgPSAnbGF5ZXJOYW1lJykge1xuICBjb25zdCBzdWJDbGFzc0NvbnN0cnVjdG9yID0gb2JqZWN0LmNvbnN0cnVjdG9yO1xuICBjb25zdCBvYmplY3ROYW1lID0gZ2V0T3duUHJvcGVydHkoc3ViQ2xhc3NDb25zdHJ1Y3Rvciwgb2JqZWN0TmFtZUtleSk7XG4gIGlmICghb2JqZWN0TmFtZSkge1xuICAgIGxvZy5vbmNlKDAsIGAke29iamVjdC5jb25zdHJ1Y3Rvci5uYW1lfSBkb2VzIG5vdCBzcGVjaWZ5IGEgJHtvYmplY3ROYW1lS2V5fWApO1xuICB9XG5cbiAgLy8gVXNlIHRoZSBvYmplY3QncyBjb25zdHJ1Y3RvciBuYW1lIGFzIGRlZmF1bHQgaWQgcHJvcC5cbiAgLy8gTm90ZSB0aGF0IGNvbnN0cnVjdG9yIG5hbWVzIGFyZSBzdWJzdGl0dXRlZCBkdXJpbmcgbWluaWZpY2F0aW9uIGFuZCBtYXkgbm90IGJlIFwiaHVtYW4gcmVhZGFibGVcIlxuICBsZXQgbWVyZ2VkRGVmYXVsdFByb3BzID0ge1xuICAgIGlkOiBvYmplY3ROYW1lIHx8IG9iamVjdC5jb25zdHJ1Y3Rvci5uYW1lXG4gIH07XG5cbiAgLy8gUmV2ZXJzZSBzaGFkb3dpbmdcbiAgLy8gVE9ETyAtIFJld3JpdGUgdG8gc3RvcCB3aGVuIG1lcmdlZERlZmF1bHRQcm9wcyBpcyBhdmFpbGFibGUgb24gcGFyZW50P1xuICB3aGlsZSAob2JqZWN0KSB7XG4gICAgY29uc3Qgb2JqZWN0RGVmYXVsdFByb3BzID0gZ2V0T3duUHJvcGVydHkob2JqZWN0LmNvbnN0cnVjdG9yLCAnZGVmYXVsdFByb3BzJyk7XG4gICAgT2JqZWN0LmZyZWV6ZShvYmplY3REZWZhdWx0UHJvcHMpO1xuICAgIGlmIChvYmplY3REZWZhdWx0UHJvcHMpIHtcbiAgICAgIG1lcmdlZERlZmF1bHRQcm9wcyA9IE9iamVjdC5hc3NpZ24oe30sIG9iamVjdERlZmF1bHRQcm9wcywgbWVyZ2VkRGVmYXVsdFByb3BzKTtcbiAgICB9XG4gICAgb2JqZWN0ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iamVjdCk7XG4gIH1cblxuICBPYmplY3QuZnJlZXplKG1lcmdlZERlZmF1bHRQcm9wcyk7XG5cbiAgLy8gU3RvcmUgZm9yIHF1aWNrIGxvb2t1cFxuICBzdWJDbGFzc0NvbnN0cnVjdG9yLm1lcmdlZERlZmF1bHRQcm9wcyA9IG1lcmdlZERlZmF1bHRQcm9wcztcblxuICBhc3NlcnQobWVyZ2VEZWZhdWx0UHJvcHMpO1xuICByZXR1cm4gbWVyZ2VkRGVmYXVsdFByb3BzO1xufVxuIl19