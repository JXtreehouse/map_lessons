'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

/* eslint-disable guard-for-in */


exports.glArrayFromType = glArrayFromType;

var _stats = require('./stats');

var _stats2 = _interopRequireDefault(_stats);

var _log = require('../utils/log');

var _log2 = _interopRequireDefault(_log);

var _luma = require('luma.gl');

var _assert = require('assert');

var _assert2 = _interopRequireDefault(_assert);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var LOG_START_END_PRIORITY = 1;
var LOG_DETAIL_PRIORITY = 2;

function noop() {}

/* eslint-disable complexity */
function glArrayFromType(glType) {
  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref$clamped = _ref.clamped,
      clamped = _ref$clamped === undefined ? true : _ref$clamped;

  // Sorted in some order of likelihood to reduce amount of comparisons
  switch (glType) {
    case _luma.GL.FLOAT:
      return Float32Array;
    case _luma.GL.UNSIGNED_SHORT:
    case _luma.GL.UNSIGNED_SHORT_5_6_5:
    case _luma.GL.UNSIGNED_SHORT_4_4_4_4:
    case _luma.GL.UNSIGNED_SHORT_5_5_5_1:
      return Uint16Array;
    case _luma.GL.UNSIGNED_INT:
      return Uint32Array;
    case _luma.GL.UNSIGNED_BYTE:
      return clamped ? Uint8ClampedArray : Uint8Array;
    case _luma.GL.BYTE:
      return Int8Array;
    case _luma.GL.SHORT:
      return Int16Array;
    case _luma.GL.INT:
      return Int32Array;
    default:
      throw new Error('Failed to deduce type from array');
  }
}
/* eslint-enable complexity */

// Default loggers
var logFunctions = {
  savedMessages: null,
  timeStart: null,

  onLog: function onLog(_ref2) {
    var level = _ref2.level,
        message = _ref2.message;

    _log2.default.log(level, message);
  },
  onUpdateStart: function onUpdateStart(_ref3) {
    var level = _ref3.level,
        id = _ref3.id,
        numInstances = _ref3.numInstances;

    logFunctions.savedMessages = [];
    logFunctions.timeStart = new Date();
  },
  onUpdate: function onUpdate(_ref4) {
    var level = _ref4.level,
        message = _ref4.message;

    if (logFunctions.savedMessages) {
      logFunctions.savedMessages.push(message);
    }
  },
  onUpdateEnd: function onUpdateEnd(_ref5) {
    var level = _ref5.level,
        id = _ref5.id,
        numInstances = _ref5.numInstances;

    var timeMs = Math.round(new Date() - logFunctions.timeStart);
    var time = timeMs + 'ms';
    _log2.default.group(level, 'Updated attributes for ' + numInstances + ' instances in ' + id + ' in ' + time, {
      collapsed: true
    });
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = logFunctions.savedMessages[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var message = _step.value;

        _log2.default.log(level, message);
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    _log2.default.groupEnd(level, 'Updated attributes for ' + numInstances + ' instances in ' + id + ' in ' + time);
    logFunctions.savedMessages = null;
  }
};

var AttributeManager = function () {
  _createClass(AttributeManager, null, [{
    key: 'setDefaultLogFunctions',

    /**
     * Sets log functions to help trace or time attribute updates.
     * Default logging uses deck logger.
     *
     * `onLog` is called for each attribute.
     *
     * To enable detailed control of timming and e.g. hierarchical logging,
     * hooks are also provided for update start and end.
     *
     * @param {Object} [opts]
     * @param {String} [opts.onLog=] - called to print
     * @param {String} [opts.onUpdateStart=] - called before update() starts
     * @param {String} [opts.onUpdateEnd=] - called after update() ends
     */
    value: function setDefaultLogFunctions() {
      var _ref6 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          onLog = _ref6.onLog,
          onUpdateStart = _ref6.onUpdateStart,
          onUpdate = _ref6.onUpdate,
          onUpdateEnd = _ref6.onUpdateEnd;

      if (onLog !== undefined) {
        logFunctions.onLog = onLog || noop;
      }
      if (onUpdateStart !== undefined) {
        logFunctions.onUpdateStart = onUpdateStart || noop;
      }
      if (onUpdate !== undefined) {
        logFunctions.onUpdate = onUpdate || noop;
      }
      if (onUpdateEnd !== undefined) {
        logFunctions.onUpdateEnd = onUpdateEnd || noop;
      }
    }

    /**
     * @classdesc
     * Automated attribute generation and management. Suitable when a set of
     * vertex shader attributes are generated by iteration over a data array,
     * and updates to these attributes are needed either when the data itself
     * changes, or when other data relevant to the calculations change.
     *
     * - First the application registers descriptions of its dynamic vertex
     *   attributes using AttributeManager.add().
     * - Then, when any change that affects attributes is detected by the
     *   application, the app will call AttributeManager.invalidate().
     * - Finally before it renders, it calls AttributeManager.update() to
     *   ensure that attributes are automatically rebuilt if anything has been
     *   invalidated.
     *
     * The application provided update functions describe how attributes
     * should be updated from a data array and are expected to traverse
     * that data array (or iterable) and fill in the attribute's typed array.
     *
     * Note that the attribute manager intentionally does not do advanced
     * change detection, but instead makes it easy to build such detection
     * by offering the ability to "invalidate" each attribute separately.
     *
     * Summary:
     * - keeps track of valid state for each attribute
     * - auto reallocates attributes when needed
     * - auto updates attributes with registered updater functions
     * - allows overriding with application supplied buffers
     *
     * Limitations:
     * - There are currently no provisions for only invalidating a range of
     *   indices in an attribute.
     *
     * @class
     * @param {Object} [props]
     * @param {String} [props.id] - identifier (for debugging)
     */

  }]);

  function AttributeManager() {
    var _ref7 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref7$id = _ref7.id,
        id = _ref7$id === undefined ? 'attribute-manager' : _ref7$id;

    _classCallCheck(this, AttributeManager);

    this.id = id;

    this.attributes = {};
    this.updateTriggers = {};
    this.accessors = {};
    this.allocedInstances = -1;
    this.needsRedraw = true;

    this.userData = {};
    this.stats = new _stats2.default({ id: 'attr' });

    // For debugging sanity, prevent uninitialized members
    Object.seal(this);
  }

  /**
   * Adds attributes
   * Takes a map of attribute descriptor objects
   * - keys are attribute names
   * - values are objects with attribute fields
   *
   * attribute.size - number of elements per object
   * attribute.updater - number of elements
   * attribute.instanced=0 - is this is an instanced attribute (a.k.a. divisor)
   * attribute.noAlloc=false - if this attribute should not be allocated
   *
   * @example
   * attributeManager.add({
   *   positions: {size: 2, update: calculatePositions}
   *   colors: {size: 3, update: calculateColors}
   * });
   *
   * @param {Object} attributes - attribute map (see above)
   * @param {Object} updaters - separate map of update functions (deprecated)
   */


  _createClass(AttributeManager, [{
    key: 'add',
    value: function add(attributes) {
      var updaters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      this._add(attributes, updaters);
    }

    /**
     * Removes attributes
     * Takes an array of attribute names and delete them from
     * the attribute map if they exists
     *
     * @example
     * attributeManager.remove(['position']);
     *
     * @param {Object} attributeNameArray - attribute name array (see above)
     */

  }, {
    key: 'remove',
    value: function remove(attributeNameArray) {
      for (var i = 0; i < attributeNameArray.length; i++) {
        var name = attributeNameArray[i];
        if (this.attributes[name] !== undefined) {
          delete this.attributes[name];
        }
      }
    }

    /* Marks an attribute for update
     * @param {string} triggerName: attribute or accessor name
     */

  }, {
    key: 'invalidate',
    value: function invalidate(triggerName) {
      var invalidatedAttributes = this._invalidateTrigger(triggerName);

      // For performance tuning
      logFunctions.onLog({
        level: LOG_DETAIL_PRIORITY,
        message: 'invalidated attributes ' + invalidatedAttributes + ' (' + triggerName + ') for ' + this.id,
        id: this.identifier
      });
    }
  }, {
    key: 'invalidateAll',
    value: function invalidateAll() {
      for (var attributeName in this.attributes) {
        this.attributes[attributeName].needsUpdate = true;
      }

      // For performance tuning
      logFunctions.onLog({
        level: LOG_DETAIL_PRIORITY,
        message: 'invalidated all attributes for ' + this.id,
        id: this.identifier
      });
    }
  }, {
    key: '_invalidateTrigger',
    value: function _invalidateTrigger(triggerName) {
      var attributes = this.attributes,
          updateTriggers = this.updateTriggers;

      var invalidatedAttributes = updateTriggers[triggerName];

      if (!invalidatedAttributes) {
        var message = 'invalidating non-existent trigger ' + triggerName + ' for ' + this.id + '\n';
        message += 'Valid triggers: ' + Object.keys(attributes).join(', ');
        _log2.default.warn(message, invalidatedAttributes);
      } else {
        invalidatedAttributes.forEach(function (name) {
          var attribute = attributes[name];
          if (attribute) {
            attribute.needsUpdate = true;
          }
        });
      }
      return invalidatedAttributes;
    }

    /**
     * Ensure all attribute buffers are updated from props or data.
     *
     * Note: Any preallocated buffers in "buffers" matching registered attribute
     * names will be used. No update will happen in this case.
     * Note: Calls onUpdateStart and onUpdateEnd log callbacks before and after.
     *
     * @param {Object} opts - options
     * @param {Object} opts.data - data (iterable object)
     * @param {Object} opts.numInstances - count of data
     * @param {Object} opts.buffers = {} - pre-allocated buffers
     * @param {Object} opts.props - passed to updaters
     * @param {Object} opts.context - Used as "this" context for updaters
     */

  }, {
    key: 'update',
    value: function update() {
      var _ref8 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          data = _ref8.data,
          numInstances = _ref8.numInstances,
          _ref8$props = _ref8.props,
          props = _ref8$props === undefined ? {} : _ref8$props,
          _ref8$buffers = _ref8.buffers,
          buffers = _ref8$buffers === undefined ? {} : _ref8$buffers,
          _ref8$context = _ref8.context,
          context = _ref8$context === undefined ? {} : _ref8$context,
          _ref8$ignoreUnknownAt = _ref8.ignoreUnknownAttributes,
          ignoreUnknownAttributes = _ref8$ignoreUnknownAt === undefined ? false : _ref8$ignoreUnknownAt;

      // First apply any application provided buffers
      this._checkExternalBuffers({ buffers: buffers, ignoreUnknownAttributes: ignoreUnknownAttributes });
      this._setExternalBuffers(buffers);

      // Only initiate alloc/update (and logging) if actually needed
      if (this._analyzeBuffers({ numInstances: numInstances })) {
        logFunctions.onUpdateStart({ level: LOG_START_END_PRIORITY, id: this.id, numInstances: numInstances });
        this.stats.timeStart();
        this._updateBuffers({ numInstances: numInstances, data: data, props: props, context: context });
        this.stats.timeEnd();
        logFunctions.onUpdateEnd({ level: LOG_START_END_PRIORITY, id: this.id, numInstances: numInstances });
      }
    }

    /**
     * Returns all attribute descriptors
     * Note: Format matches luma.gl Model/Program.setAttributes()
     * @return {Object} attributes - descriptors
     */

  }, {
    key: 'getAttributes',
    value: function getAttributes() {
      return this.attributes;
    }

    /**
     * Returns changed attribute descriptors
     * This indicates which WebGLBuggers need to be updated
     * @return {Object} attributes - descriptors
     */

  }, {
    key: 'getChangedAttributes',
    value: function getChangedAttributes(_ref9) {
      var _ref9$clearChangedFla = _ref9.clearChangedFlags,
          clearChangedFlags = _ref9$clearChangedFla === undefined ? false : _ref9$clearChangedFla;
      var attributes = this.attributes;

      var changedAttributes = {};
      for (var attributeName in attributes) {
        var attribute = attributes[attributeName];
        if (attribute.changed) {
          attribute.changed = attribute.changed && !clearChangedFlags;
          changedAttributes[attributeName] = attribute;
        }
      }
      return changedAttributes;
    }

    /**
     * Returns the redraw flag, optionally clearing it.
     * Redraw flag will be set if any attributes attributes changed since
     * flag was last cleared.
     *
     * @param {Object} [opts]
     * @param {String} [opts.clearRedrawFlags=false] - whether to clear the flag
     * @return {false|String} - reason a redraw is needed.
     */

  }, {
    key: 'getNeedsRedraw',
    value: function getNeedsRedraw() {
      var _ref10 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref10$clearRedrawFla = _ref10.clearRedrawFlags,
          clearRedrawFlags = _ref10$clearRedrawFla === undefined ? false : _ref10$clearRedrawFla;

      var redraw = this.needsRedraw;
      this.needsRedraw = this.needsRedraw && !clearRedrawFlags;
      return redraw && this.id;
    }

    /**
     * Sets the redraw flag.
     * @param {Boolean} redraw=true
     * @return {AttributeManager} - for chaining
     */

  }, {
    key: 'setNeedsRedraw',
    value: function setNeedsRedraw() {
      var redraw = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

      this.needsRedraw = true;
      return this;
    }

    // DEPRECATED METHODS

    /**
     * Adds attributes
     * @param {Object} attributes - attribute map (see above)
     * @param {Object} updaters - separate map of update functions (deprecated)
     */

  }, {
    key: 'addInstanced',
    value: function addInstanced(attributes) {
      var updaters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      this._add(attributes, updaters, { instanced: 1 });
    }

    // PROTECTED METHODS - Only to be used by collaborating classes, not by apps

    /**
     * Returns object containing all accessors as keys, with non-null values
     * @return {Object} - accessors object
     */

  }, {
    key: 'getAccessors',
    value: function getAccessors() {
      return this.updateTriggers;
    }

    // PRIVATE METHODS

    // Used to register an attribute

  }, {
    key: '_add',
    value: function _add(attributes) {
      var updaters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      var _extraProps = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

      var newAttributes = {};

      for (var attributeName in attributes) {
        // support for separate update function map
        // For now, just copy any attributes from that map into the main map
        // TODO - Attribute maps are a deprecated feature, remove
        if (attributeName in updaters) {
          attributes[attributeName] = Object.assign({}, attributes[attributeName], updaters[attributeName]);
        }

        var attribute = attributes[attributeName];

        var isIndexed = attribute.isIndexed || attribute.elements;
        var size = attribute.elements && 1 || attribute.size;
        var value = attribute.value || null;

        // Initialize the attribute descriptor, with WebGL and metadata fields
        var attributeData = Object.assign({
          // Ensure that fields are present before Object.seal()
          target: undefined,
          userData: {} // Reserved for application
        },
        // Metadata
        attribute, {
          // State
          isExternalBuffer: false,
          needsAlloc: false,
          needsUpdate: false,
          changed: false,

          // Luma fields
          isIndexed: isIndexed,
          size: size,
          value: value
        }, _extraProps);
        // Sanity - no app fields on our attributes. Use userData instead.
        Object.seal(attributeData);

        // Check all fields and generate helpful error messages
        this._validateAttributeDefinition(attributeName, attributeData);

        // Add to both attributes list (for registration with model)
        newAttributes[attributeName] = attributeData;
      }

      Object.assign(this.attributes, newAttributes);

      this._mapUpdateTriggersToAttributes();
    }

    // build updateTrigger name to attribute name mapping

  }, {
    key: '_mapUpdateTriggersToAttributes',
    value: function _mapUpdateTriggersToAttributes() {
      var _this = this;

      var triggers = {};

      var _loop = function _loop(attributeName) {
        var attribute = _this.attributes[attributeName];
        var accessor = attribute.accessor;

        // Backards compatibility: allow attribute name to be used as update trigger key

        triggers[attributeName] = [attributeName];

        // use accessor name as update trigger key
        if (typeof accessor === 'string') {
          accessor = [accessor];
        }
        if (Array.isArray(accessor)) {
          accessor.forEach(function (accessorName) {
            if (!triggers[accessorName]) {
              triggers[accessorName] = [];
            }
            triggers[accessorName].push(attributeName);
          });
        }
      };

      for (var attributeName in this.attributes) {
        _loop(attributeName);
      }

      this.updateTriggers = triggers;
    }
  }, {
    key: '_validateAttributeDefinition',
    value: function _validateAttributeDefinition(attributeName, attribute) {
      (0, _assert2.default)(attribute.size >= 1 && attribute.size <= 4, 'Attribute definition for ' + attributeName + ' invalid size');

      // Check that either 'accessor' or 'update' is a valid function
      var hasUpdater = attribute.noAlloc || typeof attribute.update === 'function' || typeof attribute.accessor === 'string';
      if (!hasUpdater) {
        throw new Error('Attribute ' + attributeName + ' missing update or accessor');
      }
    }

    // Checks that any attribute buffers in props are valid
    // Note: This is just to help app catch mistakes

  }, {
    key: '_checkExternalBuffers',
    value: function _checkExternalBuffers() {
      var _ref11 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref11$buffers = _ref11.buffers,
          buffers = _ref11$buffers === undefined ? {} : _ref11$buffers,
          _ref11$ignoreUnknownA = _ref11.ignoreUnknownAttributes,
          ignoreUnknownAttributes = _ref11$ignoreUnknownA === undefined ? false : _ref11$ignoreUnknownA;

      var attributes = this.attributes;

      for (var attributeName in buffers) {
        var attribute = attributes[attributeName];
        if (!attribute && !ignoreUnknownAttributes) {
          throw new Error('Unknown attribute prop ' + attributeName);
        }
        // const buffer = buffers[attributeName];
        // TODO - check buffer type
      }
    }

    // Set the buffers for the supplied attributes
    // Update attribute buffers from any attributes in props
    // Detach any previously set buffers, marking all
    // Attributes for auto allocation
    /* eslint-disable max-statements */

  }, {
    key: '_setExternalBuffers',
    value: function _setExternalBuffers(bufferMap) {
      var attributes = this.attributes,
          numInstances = this.numInstances;

      // Copy the refs of any supplied buffers in the props

      for (var attributeName in attributes) {
        var attribute = attributes[attributeName];
        var buffer = bufferMap[attributeName];
        attribute.isExternalBuffer = false;
        if (buffer) {
          var ArrayType = glArrayFromType(attribute.type || _luma.GL.FLOAT);
          if (!(buffer instanceof ArrayType)) {
            throw new Error('Attribute ' + attributeName + ' must be of type ' + ArrayType.name);
          }
          if (attribute.auto && buffer.length <= numInstances * attribute.size) {
            throw new Error('Attribute prop array must match length and size');
          }

          attribute.isExternalBuffer = true;
          attribute.needsUpdate = false;
          if (attribute.value !== buffer) {
            attribute.value = buffer;
            attribute.changed = true;
            this.needsRedraw = true;
          }
        }
      }
    }
    /* eslint-enable max-statements */

    /* Checks that typed arrays for attributes are big enough
     * sets alloc flag if not
     * @return {Boolean} whether any updates are needed
     */

  }, {
    key: '_analyzeBuffers',
    value: function _analyzeBuffers(_ref12) {
      var numInstances = _ref12.numInstances;
      var attributes = this.attributes;

      (0, _assert2.default)(numInstances !== undefined, 'numInstances not defined');

      // Track whether any allocations or updates are needed
      var needsUpdate = false;

      for (var attributeName in attributes) {
        var attribute = attributes[attributeName];
        if (!attribute.isExternalBuffer) {
          // Do we need to reallocate the attribute's typed array?
          var needsAlloc = attribute.value === null || attribute.value.length / attribute.size < numInstances;
          if (needsAlloc && (attribute.update || attribute.accessor)) {
            attribute.needsAlloc = true;
            needsUpdate = true;
          }
          if (attribute.needsUpdate) {
            needsUpdate = true;
          }
        }
      }

      return needsUpdate;
    }

    /**
     * @private
     * Calls update on any buffers that need update
     * TODO? - If app supplied all attributes, no need to iterate over data
     *
     * @param {Object} opts - options
     * @param {Object} opts.data - data (iterable object)
     * @param {Object} opts.numInstances - count of data
     * @param {Object} opts.buffers = {} - pre-allocated buffers
     * @param {Object} opts.props - passed to updaters
     * @param {Object} opts.context - Used as "this" context for updaters
     */
    /* eslint-disable max-statements, complexity */

  }, {
    key: '_updateBuffers',
    value: function _updateBuffers(_ref13) {
      var numInstances = _ref13.numInstances,
          data = _ref13.data,
          props = _ref13.props,
          context = _ref13.context;
      var attributes = this.attributes;

      // Allocate at least one element to ensure a valid buffer

      var allocCount = Math.max(numInstances, 1);

      for (var attributeName in attributes) {
        var attribute = attributes[attributeName];

        // Allocate a new typed array if needed
        if (attribute.needsAlloc) {
          var ArrayType = glArrayFromType(attribute.type || _luma.GL.FLOAT);
          attribute.value = new ArrayType(attribute.size * allocCount);
          logFunctions.onUpdate({
            level: LOG_DETAIL_PRIORITY,
            message: attributeName + ' allocated ' + allocCount,
            id: this.id
          });
          attribute.needsAlloc = false;
          attribute.needsUpdate = true;
        }
      }

      for (var _attributeName in attributes) {
        var _attribute = attributes[_attributeName];
        // Call updater function if needed
        if (_attribute.needsUpdate) {
          this._updateBuffer({ attribute: _attribute, attributeName: _attributeName, numInstances: numInstances, data: data, props: props, context: context });
        }
      }

      this.allocedInstances = allocCount;
    }
  }, {
    key: '_updateBuffer',
    value: function _updateBuffer(_ref14) {
      var attribute = _ref14.attribute,
          attributeName = _ref14.attributeName,
          numInstances = _ref14.numInstances,
          data = _ref14.data,
          props = _ref14.props,
          context = _ref14.context;
      var update = attribute.update,
          accessor = attribute.accessor;


      var timeStart = new Date();
      if (update) {
        // Custom updater - typically for non-instanced layers
        update.call(context, attribute, { data: data, props: props, numInstances: numInstances });
        this._checkAttributeArray(attribute, attributeName);
      } else if (accessor) {
        // Standard updater
        this._updateBufferViaStandardAccessor({ attribute: attribute, data: data, props: props });
        this._checkAttributeArray(attribute, attributeName);
      } else {
        logFunctions.onUpdate({
          level: LOG_DETAIL_PRIORITY,
          message: attributeName + ' missing update function',
          id: this.id
        });
      }
      var timeMs = Math.round(new Date() - timeStart);
      var time = timeMs + 'ms';
      logFunctions.onUpdate({
        level: LOG_DETAIL_PRIORITY,
        message: attributeName + ' updated ' + numInstances + ' ' + time,
        id: this.id
      });

      attribute.needsUpdate = false;
      attribute.changed = true;
      this.needsRedraw = true;
    }
    /* eslint-enable max-statements */

  }, {
    key: '_updateBufferViaStandardAccessor',
    value: function _updateBufferViaStandardAccessor(_ref15) {
      var attribute = _ref15.attribute,
          data = _ref15.data,
          props = _ref15.props;
      var accessor = attribute.accessor,
          value = attribute.value,
          size = attribute.size;

      var accessorFunc = props[accessor];

      (0, _assert2.default)(typeof accessorFunc === 'function', 'accessor "' + accessor + '" is not a function');

      var _attribute$defaultVal = attribute.defaultValue,
          defaultValue = _attribute$defaultVal === undefined ? [0, 0, 0, 0] : _attribute$defaultVal;

      defaultValue = Array.isArray(defaultValue) ? defaultValue : [defaultValue];
      var i = 0;
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = data[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var object = _step2.value;

          var objectValue = accessorFunc(object);
          objectValue = Array.isArray(objectValue) ? objectValue : [objectValue];
          /* eslint-disable no-fallthrough, default-case */
          switch (size) {
            case 4:
              value[i + 3] = Number.isFinite(objectValue[3]) ? objectValue[3] : defaultValue[3];
            case 3:
              value[i + 2] = Number.isFinite(objectValue[2]) ? objectValue[2] : defaultValue[2];
            case 2:
              value[i + 1] = Number.isFinite(objectValue[1]) ? objectValue[1] : defaultValue[1];
            case 1:
              value[i + 0] = Number.isFinite(objectValue[0]) ? objectValue[0] : defaultValue[0];
          }
          i += size;
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }
    }
  }, {
    key: '_checkAttributeArray',
    value: function _checkAttributeArray(attribute, attributeName) {
      var value = attribute.value;

      if (value && value.length >= 4) {
        var valid = Number.isFinite(value[0]) && Number.isFinite(value[1]) && Number.isFinite(value[2]) && Number.isFinite(value[3]);
        if (!valid) {
          throw new Error('Illegal attribute generated for ' + attributeName);
        }
      }
    }
  }]);

  return AttributeManager;
}();

exports.default = AttributeManager;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9jb3JlL2xpYi9hdHRyaWJ1dGUtbWFuYWdlci5qcyJdLCJuYW1lcyI6WyJnbEFycmF5RnJvbVR5cGUiLCJMT0dfU1RBUlRfRU5EX1BSSU9SSVRZIiwiTE9HX0RFVEFJTF9QUklPUklUWSIsIm5vb3AiLCJnbFR5cGUiLCJjbGFtcGVkIiwiRkxPQVQiLCJGbG9hdDMyQXJyYXkiLCJVTlNJR05FRF9TSE9SVCIsIlVOU0lHTkVEX1NIT1JUXzVfNl81IiwiVU5TSUdORURfU0hPUlRfNF80XzRfNCIsIlVOU0lHTkVEX1NIT1JUXzVfNV81XzEiLCJVaW50MTZBcnJheSIsIlVOU0lHTkVEX0lOVCIsIlVpbnQzMkFycmF5IiwiVU5TSUdORURfQllURSIsIlVpbnQ4Q2xhbXBlZEFycmF5IiwiVWludDhBcnJheSIsIkJZVEUiLCJJbnQ4QXJyYXkiLCJTSE9SVCIsIkludDE2QXJyYXkiLCJJTlQiLCJJbnQzMkFycmF5IiwiRXJyb3IiLCJsb2dGdW5jdGlvbnMiLCJzYXZlZE1lc3NhZ2VzIiwidGltZVN0YXJ0Iiwib25Mb2ciLCJsZXZlbCIsIm1lc3NhZ2UiLCJsb2ciLCJvblVwZGF0ZVN0YXJ0IiwiaWQiLCJudW1JbnN0YW5jZXMiLCJEYXRlIiwib25VcGRhdGUiLCJwdXNoIiwib25VcGRhdGVFbmQiLCJ0aW1lTXMiLCJNYXRoIiwicm91bmQiLCJ0aW1lIiwiZ3JvdXAiLCJjb2xsYXBzZWQiLCJncm91cEVuZCIsIkF0dHJpYnV0ZU1hbmFnZXIiLCJ1bmRlZmluZWQiLCJhdHRyaWJ1dGVzIiwidXBkYXRlVHJpZ2dlcnMiLCJhY2Nlc3NvcnMiLCJhbGxvY2VkSW5zdGFuY2VzIiwibmVlZHNSZWRyYXciLCJ1c2VyRGF0YSIsInN0YXRzIiwiT2JqZWN0Iiwic2VhbCIsInVwZGF0ZXJzIiwiX2FkZCIsImF0dHJpYnV0ZU5hbWVBcnJheSIsImkiLCJsZW5ndGgiLCJuYW1lIiwidHJpZ2dlck5hbWUiLCJpbnZhbGlkYXRlZEF0dHJpYnV0ZXMiLCJfaW52YWxpZGF0ZVRyaWdnZXIiLCJpZGVudGlmaWVyIiwiYXR0cmlidXRlTmFtZSIsIm5lZWRzVXBkYXRlIiwia2V5cyIsImpvaW4iLCJ3YXJuIiwiZm9yRWFjaCIsImF0dHJpYnV0ZSIsImRhdGEiLCJwcm9wcyIsImJ1ZmZlcnMiLCJjb250ZXh0IiwiaWdub3JlVW5rbm93bkF0dHJpYnV0ZXMiLCJfY2hlY2tFeHRlcm5hbEJ1ZmZlcnMiLCJfc2V0RXh0ZXJuYWxCdWZmZXJzIiwiX2FuYWx5emVCdWZmZXJzIiwiX3VwZGF0ZUJ1ZmZlcnMiLCJ0aW1lRW5kIiwiY2xlYXJDaGFuZ2VkRmxhZ3MiLCJjaGFuZ2VkQXR0cmlidXRlcyIsImNoYW5nZWQiLCJjbGVhclJlZHJhd0ZsYWdzIiwicmVkcmF3IiwiaW5zdGFuY2VkIiwiX2V4dHJhUHJvcHMiLCJuZXdBdHRyaWJ1dGVzIiwiYXNzaWduIiwiaXNJbmRleGVkIiwiZWxlbWVudHMiLCJzaXplIiwidmFsdWUiLCJhdHRyaWJ1dGVEYXRhIiwidGFyZ2V0IiwiaXNFeHRlcm5hbEJ1ZmZlciIsIm5lZWRzQWxsb2MiLCJfdmFsaWRhdGVBdHRyaWJ1dGVEZWZpbml0aW9uIiwiX21hcFVwZGF0ZVRyaWdnZXJzVG9BdHRyaWJ1dGVzIiwidHJpZ2dlcnMiLCJhY2Nlc3NvciIsIkFycmF5IiwiaXNBcnJheSIsImFjY2Vzc29yTmFtZSIsImhhc1VwZGF0ZXIiLCJub0FsbG9jIiwidXBkYXRlIiwiYnVmZmVyTWFwIiwiYnVmZmVyIiwiQXJyYXlUeXBlIiwidHlwZSIsImF1dG8iLCJhbGxvY0NvdW50IiwibWF4IiwiX3VwZGF0ZUJ1ZmZlciIsImNhbGwiLCJfY2hlY2tBdHRyaWJ1dGVBcnJheSIsIl91cGRhdGVCdWZmZXJWaWFTdGFuZGFyZEFjY2Vzc29yIiwiYWNjZXNzb3JGdW5jIiwiZGVmYXVsdFZhbHVlIiwib2JqZWN0Iiwib2JqZWN0VmFsdWUiLCJOdW1iZXIiLCJpc0Zpbml0ZSIsInZhbGlkIl0sIm1hcHBpbmdzIjoiOzs7Ozs7cWpCQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBQ0UzQixvQkFBTXBDLElBQUksQ0FBVixJQUFla0UsT0FBT0MsUUFBUCxDQUFnQkYsWUFBWSxDQUFaLENBQWhCLElBQWtDQSxZQUFZLENBQVosQ0FBbEMsR0FBbURGLGFBQWEsQ0FBYixDQUFsRTtBQUNGLGlCQUFLLENBQUw7QUFDRTNCLG9CQUFNcEMsSUFBSSxDQUFWLElBQWVrRSxPQUFPQyxRQUFQLENBQWdCRixZQUFZLENBQVosQ0FBaEIsSUFBa0NBLFlBQVksQ0FBWixDQUFsQyxHQUFtREYsYUFBYSxDQUFiLENBQWxFO0FBUko7QUFVQS9ELGVBQUttQyxJQUFMO0FBQ0Q7QUF4QndEO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUF5QjFEOzs7eUNBRW9CdEIsUyxFQUFXTixhLEVBQWU7QUFBQSxVQUN0QzZCLEtBRHNDLEdBQzdCdkIsU0FENkIsQ0FDdEN1QixLQURzQzs7QUFFN0MsVUFBSUEsU0FBU0EsTUFBTW5DLE1BQU4sSUFBZ0IsQ0FBN0IsRUFBZ0M7QUFDOUIsWUFBTW1FLFFBQ0pGLE9BQU9DLFFBQVAsQ0FBZ0IvQixNQUFNLENBQU4sQ0FBaEIsS0FDQThCLE9BQU9DLFFBQVAsQ0FBZ0IvQixNQUFNLENBQU4sQ0FBaEIsQ0FEQSxJQUVBOEIsT0FBT0MsUUFBUCxDQUFnQi9CLE1BQU0sQ0FBTixDQUFoQixDQUZBLElBR0E4QixPQUFPQyxRQUFQLENBQWdCL0IsTUFBTSxDQUFOLENBQWhCLENBSkY7QUFLQSxZQUFJLENBQUNnQyxLQUFMLEVBQVk7QUFDVixnQkFBTSxJQUFJeEcsS0FBSixzQ0FBNkMyQyxhQUE3QyxDQUFOO0FBQ0Q7QUFDRjtBQUNGOzs7Ozs7a0JBeGtCa0JyQixnQiIsImZpbGUiOiJhdHRyaWJ1dGUtbWFuYWdlci5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgMjAxNSAtIDIwMTcgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuLy8gVEhFIFNPRlRXQVJFLlxuXG4vKiBlc2xpbnQtZGlzYWJsZSBndWFyZC1mb3ItaW4gKi9cbmltcG9ydCBTdGF0cyBmcm9tICcuL3N0YXRzJztcbmltcG9ydCBsb2cgZnJvbSAnLi4vdXRpbHMvbG9nJztcbmltcG9ydCB7R0x9IGZyb20gJ2x1bWEuZ2wnO1xuaW1wb3J0IGFzc2VydCBmcm9tICdhc3NlcnQnO1xuXG5jb25zdCBMT0dfU1RBUlRfRU5EX1BSSU9SSVRZID0gMTtcbmNvbnN0IExPR19ERVRBSUxfUFJJT1JJVFkgPSAyO1xuXG5mdW5jdGlvbiBub29wKCkge31cblxuLyogZXNsaW50LWRpc2FibGUgY29tcGxleGl0eSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdsQXJyYXlGcm9tVHlwZShnbFR5cGUsIHtjbGFtcGVkID0gdHJ1ZX0gPSB7fSkge1xuICAvLyBTb3J0ZWQgaW4gc29tZSBvcmRlciBvZiBsaWtlbGlob29kIHRvIHJlZHVjZSBhbW91bnQgb2YgY29tcGFyaXNvbnNcbiAgc3dpdGNoIChnbFR5cGUpIHtcbiAgICBjYXNlIEdMLkZMT0FUOlxuICAgICAgcmV0dXJuIEZsb2F0MzJBcnJheTtcbiAgICBjYXNlIEdMLlVOU0lHTkVEX1NIT1JUOlxuICAgIGNhc2UgR0wuVU5TSUdORURfU0hPUlRfNV82XzU6XG4gICAgY2FzZSBHTC5VTlNJR05FRF9TSE9SVF80XzRfNF80OlxuICAgIGNhc2UgR0wuVU5TSUdORURfU0hPUlRfNV81XzVfMTpcbiAgICAgIHJldHVybiBVaW50MTZBcnJheTtcbiAgICBjYXNlIEdMLlVOU0lHTkVEX0lOVDpcbiAgICAgIHJldHVybiBVaW50MzJBcnJheTtcbiAgICBjYXNlIEdMLlVOU0lHTkVEX0JZVEU6XG4gICAgICByZXR1cm4gY2xhbXBlZCA/IFVpbnQ4Q2xhbXBlZEFycmF5IDogVWludDhBcnJheTtcbiAgICBjYXNlIEdMLkJZVEU6XG4gICAgICByZXR1cm4gSW50OEFycmF5O1xuICAgIGNhc2UgR0wuU0hPUlQ6XG4gICAgICByZXR1cm4gSW50MTZBcnJheTtcbiAgICBjYXNlIEdMLklOVDpcbiAgICAgIHJldHVybiBJbnQzMkFycmF5O1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBkZWR1Y2UgdHlwZSBmcm9tIGFycmF5Jyk7XG4gIH1cbn1cbi8qIGVzbGludC1lbmFibGUgY29tcGxleGl0eSAqL1xuXG4vLyBEZWZhdWx0IGxvZ2dlcnNcbmNvbnN0IGxvZ0Z1bmN0aW9ucyA9IHtcbiAgc2F2ZWRNZXNzYWdlczogbnVsbCxcbiAgdGltZVN0YXJ0OiBudWxsLFxuXG4gIG9uTG9nOiAoe2xldmVsLCBtZXNzYWdlfSkgPT4ge1xuICAgIGxvZy5sb2cobGV2ZWwsIG1lc3NhZ2UpO1xuICB9LFxuICBvblVwZGF0ZVN0YXJ0OiAoe2xldmVsLCBpZCwgbnVtSW5zdGFuY2VzfSkgPT4ge1xuICAgIGxvZ0Z1bmN0aW9ucy5zYXZlZE1lc3NhZ2VzID0gW107XG4gICAgbG9nRnVuY3Rpb25zLnRpbWVTdGFydCA9IG5ldyBEYXRlKCk7XG4gIH0sXG4gIG9uVXBkYXRlOiAoe2xldmVsLCBtZXNzYWdlfSkgPT4ge1xuICAgIGlmIChsb2dGdW5jdGlvbnMuc2F2ZWRNZXNzYWdlcykge1xuICAgICAgbG9nRnVuY3Rpb25zLnNhdmVkTWVzc2FnZXMucHVzaChtZXNzYWdlKTtcbiAgICB9XG4gIH0sXG4gIG9uVXBkYXRlRW5kOiAoe2xldmVsLCBpZCwgbnVtSW5zdGFuY2VzfSkgPT4ge1xuICAgIGNvbnN0IHRpbWVNcyA9IE1hdGgucm91bmQobmV3IERhdGUoKSAtIGxvZ0Z1bmN0aW9ucy50aW1lU3RhcnQpO1xuICAgIGNvbnN0IHRpbWUgPSBgJHt0aW1lTXN9bXNgO1xuICAgIGxvZy5ncm91cChsZXZlbCwgYFVwZGF0ZWQgYXR0cmlidXRlcyBmb3IgJHtudW1JbnN0YW5jZXN9IGluc3RhbmNlcyBpbiAke2lkfSBpbiAke3RpbWV9YCwge1xuICAgICAgY29sbGFwc2VkOiB0cnVlXG4gICAgfSk7XG4gICAgZm9yIChjb25zdCBtZXNzYWdlIG9mIGxvZ0Z1bmN0aW9ucy5zYXZlZE1lc3NhZ2VzKSB7XG4gICAgICBsb2cubG9nKGxldmVsLCBtZXNzYWdlKTtcbiAgICB9XG4gICAgbG9nLmdyb3VwRW5kKGxldmVsLCBgVXBkYXRlZCBhdHRyaWJ1dGVzIGZvciAke251bUluc3RhbmNlc30gaW5zdGFuY2VzIGluICR7aWR9IGluICR7dGltZX1gKTtcbiAgICBsb2dGdW5jdGlvbnMuc2F2ZWRNZXNzYWdlcyA9IG51bGw7XG4gIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEF0dHJpYnV0ZU1hbmFnZXIge1xuICAvKipcbiAgICogU2V0cyBsb2cgZnVuY3Rpb25zIHRvIGhlbHAgdHJhY2Ugb3IgdGltZSBhdHRyaWJ1dGUgdXBkYXRlcy5cbiAgICogRGVmYXVsdCBsb2dnaW5nIHVzZXMgZGVjayBsb2dnZXIuXG4gICAqXG4gICAqIGBvbkxvZ2AgaXMgY2FsbGVkIGZvciBlYWNoIGF0dHJpYnV0ZS5cbiAgICpcbiAgICogVG8gZW5hYmxlIGRldGFpbGVkIGNvbnRyb2wgb2YgdGltbWluZyBhbmQgZS5nLiBoaWVyYXJjaGljYWwgbG9nZ2luZyxcbiAgICogaG9va3MgYXJlIGFsc28gcHJvdmlkZWQgZm9yIHVwZGF0ZSBzdGFydCBhbmQgZW5kLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdHNdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0cy5vbkxvZz1dIC0gY2FsbGVkIHRvIHByaW50XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0cy5vblVwZGF0ZVN0YXJ0PV0gLSBjYWxsZWQgYmVmb3JlIHVwZGF0ZSgpIHN0YXJ0c1xuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdHMub25VcGRhdGVFbmQ9XSAtIGNhbGxlZCBhZnRlciB1cGRhdGUoKSBlbmRzXG4gICAqL1xuICBzdGF0aWMgc2V0RGVmYXVsdExvZ0Z1bmN0aW9ucyh7b25Mb2csIG9uVXBkYXRlU3RhcnQsIG9uVXBkYXRlLCBvblVwZGF0ZUVuZH0gPSB7fSkge1xuICAgIGlmIChvbkxvZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBsb2dGdW5jdGlvbnMub25Mb2cgPSBvbkxvZyB8fCBub29wO1xuICAgIH1cbiAgICBpZiAob25VcGRhdGVTdGFydCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBsb2dGdW5jdGlvbnMub25VcGRhdGVTdGFydCA9IG9uVXBkYXRlU3RhcnQgfHwgbm9vcDtcbiAgICB9XG4gICAgaWYgKG9uVXBkYXRlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGxvZ0Z1bmN0aW9ucy5vblVwZGF0ZSA9IG9uVXBkYXRlIHx8IG5vb3A7XG4gICAgfVxuICAgIGlmIChvblVwZGF0ZUVuZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBsb2dGdW5jdGlvbnMub25VcGRhdGVFbmQgPSBvblVwZGF0ZUVuZCB8fCBub29wO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAY2xhc3NkZXNjXG4gICAqIEF1dG9tYXRlZCBhdHRyaWJ1dGUgZ2VuZXJhdGlvbiBhbmQgbWFuYWdlbWVudC4gU3VpdGFibGUgd2hlbiBhIHNldCBvZlxuICAgKiB2ZXJ0ZXggc2hhZGVyIGF0dHJpYnV0ZXMgYXJlIGdlbmVyYXRlZCBieSBpdGVyYXRpb24gb3ZlciBhIGRhdGEgYXJyYXksXG4gICAqIGFuZCB1cGRhdGVzIHRvIHRoZXNlIGF0dHJpYnV0ZXMgYXJlIG5lZWRlZCBlaXRoZXIgd2hlbiB0aGUgZGF0YSBpdHNlbGZcbiAgICogY2hhbmdlcywgb3Igd2hlbiBvdGhlciBkYXRhIHJlbGV2YW50IHRvIHRoZSBjYWxjdWxhdGlvbnMgY2hhbmdlLlxuICAgKlxuICAgKiAtIEZpcnN0IHRoZSBhcHBsaWNhdGlvbiByZWdpc3RlcnMgZGVzY3JpcHRpb25zIG9mIGl0cyBkeW5hbWljIHZlcnRleFxuICAgKiAgIGF0dHJpYnV0ZXMgdXNpbmcgQXR0cmlidXRlTWFuYWdlci5hZGQoKS5cbiAgICogLSBUaGVuLCB3aGVuIGFueSBjaGFuZ2UgdGhhdCBhZmZlY3RzIGF0dHJpYnV0ZXMgaXMgZGV0ZWN0ZWQgYnkgdGhlXG4gICAqICAgYXBwbGljYXRpb24sIHRoZSBhcHAgd2lsbCBjYWxsIEF0dHJpYnV0ZU1hbmFnZXIuaW52YWxpZGF0ZSgpLlxuICAgKiAtIEZpbmFsbHkgYmVmb3JlIGl0IHJlbmRlcnMsIGl0IGNhbGxzIEF0dHJpYnV0ZU1hbmFnZXIudXBkYXRlKCkgdG9cbiAgICogICBlbnN1cmUgdGhhdCBhdHRyaWJ1dGVzIGFyZSBhdXRvbWF0aWNhbGx5IHJlYnVpbHQgaWYgYW55dGhpbmcgaGFzIGJlZW5cbiAgICogICBpbnZhbGlkYXRlZC5cbiAgICpcbiAgICogVGhlIGFwcGxpY2F0aW9uIHByb3ZpZGVkIHVwZGF0ZSBmdW5jdGlvbnMgZGVzY3JpYmUgaG93IGF0dHJpYnV0ZXNcbiAgICogc2hvdWxkIGJlIHVwZGF0ZWQgZnJvbSBhIGRhdGEgYXJyYXkgYW5kIGFyZSBleHBlY3RlZCB0byB0cmF2ZXJzZVxuICAgKiB0aGF0IGRhdGEgYXJyYXkgKG9yIGl0ZXJhYmxlKSBhbmQgZmlsbCBpbiB0aGUgYXR0cmlidXRlJ3MgdHlwZWQgYXJyYXkuXG4gICAqXG4gICAqIE5vdGUgdGhhdCB0aGUgYXR0cmlidXRlIG1hbmFnZXIgaW50ZW50aW9uYWxseSBkb2VzIG5vdCBkbyBhZHZhbmNlZFxuICAgKiBjaGFuZ2UgZGV0ZWN0aW9uLCBidXQgaW5zdGVhZCBtYWtlcyBpdCBlYXN5IHRvIGJ1aWxkIHN1Y2ggZGV0ZWN0aW9uXG4gICAqIGJ5IG9mZmVyaW5nIHRoZSBhYmlsaXR5IHRvIFwiaW52YWxpZGF0ZVwiIGVhY2ggYXR0cmlidXRlIHNlcGFyYXRlbHkuXG4gICAqXG4gICAqIFN1bW1hcnk6XG4gICAqIC0ga2VlcHMgdHJhY2sgb2YgdmFsaWQgc3RhdGUgZm9yIGVhY2ggYXR0cmlidXRlXG4gICAqIC0gYXV0byByZWFsbG9jYXRlcyBhdHRyaWJ1dGVzIHdoZW4gbmVlZGVkXG4gICAqIC0gYXV0byB1cGRhdGVzIGF0dHJpYnV0ZXMgd2l0aCByZWdpc3RlcmVkIHVwZGF0ZXIgZnVuY3Rpb25zXG4gICAqIC0gYWxsb3dzIG92ZXJyaWRpbmcgd2l0aCBhcHBsaWNhdGlvbiBzdXBwbGllZCBidWZmZXJzXG4gICAqXG4gICAqIExpbWl0YXRpb25zOlxuICAgKiAtIFRoZXJlIGFyZSBjdXJyZW50bHkgbm8gcHJvdmlzaW9ucyBmb3Igb25seSBpbnZhbGlkYXRpbmcgYSByYW5nZSBvZlxuICAgKiAgIGluZGljZXMgaW4gYW4gYXR0cmlidXRlLlxuICAgKlxuICAgKiBAY2xhc3NcbiAgICogQHBhcmFtIHtPYmplY3R9IFtwcm9wc11cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtwcm9wcy5pZF0gLSBpZGVudGlmaWVyIChmb3IgZGVidWdnaW5nKVxuICAgKi9cbiAgY29uc3RydWN0b3Ioe2lkID0gJ2F0dHJpYnV0ZS1tYW5hZ2VyJ30gPSB7fSkge1xuICAgIHRoaXMuaWQgPSBpZDtcblxuICAgIHRoaXMuYXR0cmlidXRlcyA9IHt9O1xuICAgIHRoaXMudXBkYXRlVHJpZ2dlcnMgPSB7fTtcbiAgICB0aGlzLmFjY2Vzc29ycyA9IHt9O1xuICAgIHRoaXMuYWxsb2NlZEluc3RhbmNlcyA9IC0xO1xuICAgIHRoaXMubmVlZHNSZWRyYXcgPSB0cnVlO1xuXG4gICAgdGhpcy51c2VyRGF0YSA9IHt9O1xuICAgIHRoaXMuc3RhdHMgPSBuZXcgU3RhdHMoe2lkOiAnYXR0cid9KTtcblxuICAgIC8vIEZvciBkZWJ1Z2dpbmcgc2FuaXR5LCBwcmV2ZW50IHVuaW5pdGlhbGl6ZWQgbWVtYmVyc1xuICAgIE9iamVjdC5zZWFsKHRoaXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgYXR0cmlidXRlc1xuICAgKiBUYWtlcyBhIG1hcCBvZiBhdHRyaWJ1dGUgZGVzY3JpcHRvciBvYmplY3RzXG4gICAqIC0ga2V5cyBhcmUgYXR0cmlidXRlIG5hbWVzXG4gICAqIC0gdmFsdWVzIGFyZSBvYmplY3RzIHdpdGggYXR0cmlidXRlIGZpZWxkc1xuICAgKlxuICAgKiBhdHRyaWJ1dGUuc2l6ZSAtIG51bWJlciBvZiBlbGVtZW50cyBwZXIgb2JqZWN0XG4gICAqIGF0dHJpYnV0ZS51cGRhdGVyIC0gbnVtYmVyIG9mIGVsZW1lbnRzXG4gICAqIGF0dHJpYnV0ZS5pbnN0YW5jZWQ9MCAtIGlzIHRoaXMgaXMgYW4gaW5zdGFuY2VkIGF0dHJpYnV0ZSAoYS5rLmEuIGRpdmlzb3IpXG4gICAqIGF0dHJpYnV0ZS5ub0FsbG9jPWZhbHNlIC0gaWYgdGhpcyBhdHRyaWJ1dGUgc2hvdWxkIG5vdCBiZSBhbGxvY2F0ZWRcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYXR0cmlidXRlTWFuYWdlci5hZGQoe1xuICAgKiAgIHBvc2l0aW9uczoge3NpemU6IDIsIHVwZGF0ZTogY2FsY3VsYXRlUG9zaXRpb25zfVxuICAgKiAgIGNvbG9yczoge3NpemU6IDMsIHVwZGF0ZTogY2FsY3VsYXRlQ29sb3JzfVxuICAgKiB9KTtcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGF0dHJpYnV0ZXMgLSBhdHRyaWJ1dGUgbWFwIChzZWUgYWJvdmUpXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB1cGRhdGVycyAtIHNlcGFyYXRlIG1hcCBvZiB1cGRhdGUgZnVuY3Rpb25zIChkZXByZWNhdGVkKVxuICAgKi9cbiAgYWRkKGF0dHJpYnV0ZXMsIHVwZGF0ZXJzID0ge30pIHtcbiAgICB0aGlzLl9hZGQoYXR0cmlidXRlcywgdXBkYXRlcnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYXR0cmlidXRlc1xuICAgKiBUYWtlcyBhbiBhcnJheSBvZiBhdHRyaWJ1dGUgbmFtZXMgYW5kIGRlbGV0ZSB0aGVtIGZyb21cbiAgICogdGhlIGF0dHJpYnV0ZSBtYXAgaWYgdGhleSBleGlzdHNcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYXR0cmlidXRlTWFuYWdlci5yZW1vdmUoWydwb3NpdGlvbiddKTtcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGF0dHJpYnV0ZU5hbWVBcnJheSAtIGF0dHJpYnV0ZSBuYW1lIGFycmF5IChzZWUgYWJvdmUpXG4gICAqL1xuICByZW1vdmUoYXR0cmlidXRlTmFtZUFycmF5KSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhdHRyaWJ1dGVOYW1lQXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IG5hbWUgPSBhdHRyaWJ1dGVOYW1lQXJyYXlbaV07XG4gICAgICBpZiAodGhpcy5hdHRyaWJ1dGVzW25hbWVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuYXR0cmlidXRlc1tuYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKiBNYXJrcyBhbiBhdHRyaWJ1dGUgZm9yIHVwZGF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gdHJpZ2dlck5hbWU6IGF0dHJpYnV0ZSBvciBhY2Nlc3NvciBuYW1lXG4gICAqL1xuICBpbnZhbGlkYXRlKHRyaWdnZXJOYW1lKSB7XG4gICAgY29uc3QgaW52YWxpZGF0ZWRBdHRyaWJ1dGVzID0gdGhpcy5faW52YWxpZGF0ZVRyaWdnZXIodHJpZ2dlck5hbWUpO1xuXG4gICAgLy8gRm9yIHBlcmZvcm1hbmNlIHR1bmluZ1xuICAgIGxvZ0Z1bmN0aW9ucy5vbkxvZyh7XG4gICAgICBsZXZlbDogTE9HX0RFVEFJTF9QUklPUklUWSxcbiAgICAgIG1lc3NhZ2U6IGBpbnZhbGlkYXRlZCBhdHRyaWJ1dGVzICR7aW52YWxpZGF0ZWRBdHRyaWJ1dGVzfSAoJHt0cmlnZ2VyTmFtZX0pIGZvciAke3RoaXMuaWR9YCxcbiAgICAgIGlkOiB0aGlzLmlkZW50aWZpZXJcbiAgICB9KTtcbiAgfVxuXG4gIGludmFsaWRhdGVBbGwoKSB7XG4gICAgZm9yIChjb25zdCBhdHRyaWJ1dGVOYW1lIGluIHRoaXMuYXR0cmlidXRlcykge1xuICAgICAgdGhpcy5hdHRyaWJ1dGVzW2F0dHJpYnV0ZU5hbWVdLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBGb3IgcGVyZm9ybWFuY2UgdHVuaW5nXG4gICAgbG9nRnVuY3Rpb25zLm9uTG9nKHtcbiAgICAgIGxldmVsOiBMT0dfREVUQUlMX1BSSU9SSVRZLFxuICAgICAgbWVzc2FnZTogYGludmFsaWRhdGVkIGFsbCBhdHRyaWJ1dGVzIGZvciAke3RoaXMuaWR9YCxcbiAgICAgIGlkOiB0aGlzLmlkZW50aWZpZXJcbiAgICB9KTtcbiAgfVxuXG4gIF9pbnZhbGlkYXRlVHJpZ2dlcih0cmlnZ2VyTmFtZSkge1xuICAgIGNvbnN0IHthdHRyaWJ1dGVzLCB1cGRhdGVUcmlnZ2Vyc30gPSB0aGlzO1xuICAgIGNvbnN0IGludmFsaWRhdGVkQXR0cmlidXRlcyA9IHVwZGF0ZVRyaWdnZXJzW3RyaWdnZXJOYW1lXTtcblxuICAgIGlmICghaW52YWxpZGF0ZWRBdHRyaWJ1dGVzKSB7XG4gICAgICBsZXQgbWVzc2FnZSA9IGBpbnZhbGlkYXRpbmcgbm9uLWV4aXN0ZW50IHRyaWdnZXIgJHt0cmlnZ2VyTmFtZX0gZm9yICR7dGhpcy5pZH1cXG5gO1xuICAgICAgbWVzc2FnZSArPSBgVmFsaWQgdHJpZ2dlcnM6ICR7T2JqZWN0LmtleXMoYXR0cmlidXRlcykuam9pbignLCAnKX1gO1xuICAgICAgbG9nLndhcm4obWVzc2FnZSwgaW52YWxpZGF0ZWRBdHRyaWJ1dGVzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW52YWxpZGF0ZWRBdHRyaWJ1dGVzLmZvckVhY2gobmFtZSA9PiB7XG4gICAgICAgIGNvbnN0IGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXNbbmFtZV07XG4gICAgICAgIGlmIChhdHRyaWJ1dGUpIHtcbiAgICAgICAgICBhdHRyaWJ1dGUubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGludmFsaWRhdGVkQXR0cmlidXRlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBFbnN1cmUgYWxsIGF0dHJpYnV0ZSBidWZmZXJzIGFyZSB1cGRhdGVkIGZyb20gcHJvcHMgb3IgZGF0YS5cbiAgICpcbiAgICogTm90ZTogQW55IHByZWFsbG9jYXRlZCBidWZmZXJzIGluIFwiYnVmZmVyc1wiIG1hdGNoaW5nIHJlZ2lzdGVyZWQgYXR0cmlidXRlXG4gICAqIG5hbWVzIHdpbGwgYmUgdXNlZC4gTm8gdXBkYXRlIHdpbGwgaGFwcGVuIGluIHRoaXMgY2FzZS5cbiAgICogTm90ZTogQ2FsbHMgb25VcGRhdGVTdGFydCBhbmQgb25VcGRhdGVFbmQgbG9nIGNhbGxiYWNrcyBiZWZvcmUgYW5kIGFmdGVyLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMuZGF0YSAtIGRhdGEgKGl0ZXJhYmxlIG9iamVjdClcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMubnVtSW5zdGFuY2VzIC0gY291bnQgb2YgZGF0YVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cy5idWZmZXJzID0ge30gLSBwcmUtYWxsb2NhdGVkIGJ1ZmZlcnNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMucHJvcHMgLSBwYXNzZWQgdG8gdXBkYXRlcnNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMuY29udGV4dCAtIFVzZWQgYXMgXCJ0aGlzXCIgY29udGV4dCBmb3IgdXBkYXRlcnNcbiAgICovXG4gIHVwZGF0ZSh7XG4gICAgZGF0YSxcbiAgICBudW1JbnN0YW5jZXMsXG4gICAgcHJvcHMgPSB7fSxcbiAgICBidWZmZXJzID0ge30sXG4gICAgY29udGV4dCA9IHt9LFxuICAgIGlnbm9yZVVua25vd25BdHRyaWJ1dGVzID0gZmFsc2VcbiAgfSA9IHt9KSB7XG4gICAgLy8gRmlyc3QgYXBwbHkgYW55IGFwcGxpY2F0aW9uIHByb3ZpZGVkIGJ1ZmZlcnNcbiAgICB0aGlzLl9jaGVja0V4dGVybmFsQnVmZmVycyh7YnVmZmVycywgaWdub3JlVW5rbm93bkF0dHJpYnV0ZXN9KTtcbiAgICB0aGlzLl9zZXRFeHRlcm5hbEJ1ZmZlcnMoYnVmZmVycyk7XG5cbiAgICAvLyBPbmx5IGluaXRpYXRlIGFsbG9jL3VwZGF0ZSAoYW5kIGxvZ2dpbmcpIGlmIGFjdHVhbGx5IG5lZWRlZFxuICAgIGlmICh0aGlzLl9hbmFseXplQnVmZmVycyh7bnVtSW5zdGFuY2VzfSkpIHtcbiAgICAgIGxvZ0Z1bmN0aW9ucy5vblVwZGF0ZVN0YXJ0KHtsZXZlbDogTE9HX1NUQVJUX0VORF9QUklPUklUWSwgaWQ6IHRoaXMuaWQsIG51bUluc3RhbmNlc30pO1xuICAgICAgdGhpcy5zdGF0cy50aW1lU3RhcnQoKTtcbiAgICAgIHRoaXMuX3VwZGF0ZUJ1ZmZlcnMoe251bUluc3RhbmNlcywgZGF0YSwgcHJvcHMsIGNvbnRleHR9KTtcbiAgICAgIHRoaXMuc3RhdHMudGltZUVuZCgpO1xuICAgICAgbG9nRnVuY3Rpb25zLm9uVXBkYXRlRW5kKHtsZXZlbDogTE9HX1NUQVJUX0VORF9QUklPUklUWSwgaWQ6IHRoaXMuaWQsIG51bUluc3RhbmNlc30pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFsbCBhdHRyaWJ1dGUgZGVzY3JpcHRvcnNcbiAgICogTm90ZTogRm9ybWF0IG1hdGNoZXMgbHVtYS5nbCBNb2RlbC9Qcm9ncmFtLnNldEF0dHJpYnV0ZXMoKVxuICAgKiBAcmV0dXJuIHtPYmplY3R9IGF0dHJpYnV0ZXMgLSBkZXNjcmlwdG9yc1xuICAgKi9cbiAgZ2V0QXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4gdGhpcy5hdHRyaWJ1dGVzO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgY2hhbmdlZCBhdHRyaWJ1dGUgZGVzY3JpcHRvcnNcbiAgICogVGhpcyBpbmRpY2F0ZXMgd2hpY2ggV2ViR0xCdWdnZXJzIG5lZWQgdG8gYmUgdXBkYXRlZFxuICAgKiBAcmV0dXJuIHtPYmplY3R9IGF0dHJpYnV0ZXMgLSBkZXNjcmlwdG9yc1xuICAgKi9cbiAgZ2V0Q2hhbmdlZEF0dHJpYnV0ZXMoe2NsZWFyQ2hhbmdlZEZsYWdzID0gZmFsc2V9KSB7XG4gICAgY29uc3Qge2F0dHJpYnV0ZXN9ID0gdGhpcztcbiAgICBjb25zdCBjaGFuZ2VkQXR0cmlidXRlcyA9IHt9O1xuICAgIGZvciAoY29uc3QgYXR0cmlidXRlTmFtZSBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgICBjb25zdCBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzW2F0dHJpYnV0ZU5hbWVdO1xuICAgICAgaWYgKGF0dHJpYnV0ZS5jaGFuZ2VkKSB7XG4gICAgICAgIGF0dHJpYnV0ZS5jaGFuZ2VkID0gYXR0cmlidXRlLmNoYW5nZWQgJiYgIWNsZWFyQ2hhbmdlZEZsYWdzO1xuICAgICAgICBjaGFuZ2VkQXR0cmlidXRlc1thdHRyaWJ1dGVOYW1lXSA9IGF0dHJpYnV0ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNoYW5nZWRBdHRyaWJ1dGVzO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHJlZHJhdyBmbGFnLCBvcHRpb25hbGx5IGNsZWFyaW5nIGl0LlxuICAgKiBSZWRyYXcgZmxhZyB3aWxsIGJlIHNldCBpZiBhbnkgYXR0cmlidXRlcyBhdHRyaWJ1dGVzIGNoYW5nZWQgc2luY2VcbiAgICogZmxhZyB3YXMgbGFzdCBjbGVhcmVkLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdHNdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0cy5jbGVhclJlZHJhd0ZsYWdzPWZhbHNlXSAtIHdoZXRoZXIgdG8gY2xlYXIgdGhlIGZsYWdcbiAgICogQHJldHVybiB7ZmFsc2V8U3RyaW5nfSAtIHJlYXNvbiBhIHJlZHJhdyBpcyBuZWVkZWQuXG4gICAqL1xuICBnZXROZWVkc1JlZHJhdyh7Y2xlYXJSZWRyYXdGbGFncyA9IGZhbHNlfSA9IHt9KSB7XG4gICAgY29uc3QgcmVkcmF3ID0gdGhpcy5uZWVkc1JlZHJhdztcbiAgICB0aGlzLm5lZWRzUmVkcmF3ID0gdGhpcy5uZWVkc1JlZHJhdyAmJiAhY2xlYXJSZWRyYXdGbGFncztcbiAgICByZXR1cm4gcmVkcmF3ICYmIHRoaXMuaWQ7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgcmVkcmF3IGZsYWcuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gcmVkcmF3PXRydWVcbiAgICogQHJldHVybiB7QXR0cmlidXRlTWFuYWdlcn0gLSBmb3IgY2hhaW5pbmdcbiAgICovXG4gIHNldE5lZWRzUmVkcmF3KHJlZHJhdyA9IHRydWUpIHtcbiAgICB0aGlzLm5lZWRzUmVkcmF3ID0gdHJ1ZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIERFUFJFQ0FURUQgTUVUSE9EU1xuXG4gIC8qKlxuICAgKiBBZGRzIGF0dHJpYnV0ZXNcbiAgICogQHBhcmFtIHtPYmplY3R9IGF0dHJpYnV0ZXMgLSBhdHRyaWJ1dGUgbWFwIChzZWUgYWJvdmUpXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB1cGRhdGVycyAtIHNlcGFyYXRlIG1hcCBvZiB1cGRhdGUgZnVuY3Rpb25zIChkZXByZWNhdGVkKVxuICAgKi9cbiAgYWRkSW5zdGFuY2VkKGF0dHJpYnV0ZXMsIHVwZGF0ZXJzID0ge30pIHtcbiAgICB0aGlzLl9hZGQoYXR0cmlidXRlcywgdXBkYXRlcnMsIHtpbnN0YW5jZWQ6IDF9KTtcbiAgfVxuXG4gIC8vIFBST1RFQ1RFRCBNRVRIT0RTIC0gT25seSB0byBiZSB1c2VkIGJ5IGNvbGxhYm9yYXRpbmcgY2xhc3Nlcywgbm90IGJ5IGFwcHNcblxuICAvKipcbiAgICogUmV0dXJucyBvYmplY3QgY29udGFpbmluZyBhbGwgYWNjZXNzb3JzIGFzIGtleXMsIHdpdGggbm9uLW51bGwgdmFsdWVzXG4gICAqIEByZXR1cm4ge09iamVjdH0gLSBhY2Nlc3NvcnMgb2JqZWN0XG4gICAqL1xuICBnZXRBY2Nlc3NvcnMoKSB7XG4gICAgcmV0dXJuIHRoaXMudXBkYXRlVHJpZ2dlcnM7XG4gIH1cblxuICAvLyBQUklWQVRFIE1FVEhPRFNcblxuICAvLyBVc2VkIHRvIHJlZ2lzdGVyIGFuIGF0dHJpYnV0ZVxuICBfYWRkKGF0dHJpYnV0ZXMsIHVwZGF0ZXJzID0ge30sIF9leHRyYVByb3BzID0ge30pIHtcbiAgICBjb25zdCBuZXdBdHRyaWJ1dGVzID0ge307XG5cbiAgICBmb3IgKGNvbnN0IGF0dHJpYnV0ZU5hbWUgaW4gYXR0cmlidXRlcykge1xuICAgICAgLy8gc3VwcG9ydCBmb3Igc2VwYXJhdGUgdXBkYXRlIGZ1bmN0aW9uIG1hcFxuICAgICAgLy8gRm9yIG5vdywganVzdCBjb3B5IGFueSBhdHRyaWJ1dGVzIGZyb20gdGhhdCBtYXAgaW50byB0aGUgbWFpbiBtYXBcbiAgICAgIC8vIFRPRE8gLSBBdHRyaWJ1dGUgbWFwcyBhcmUgYSBkZXByZWNhdGVkIGZlYXR1cmUsIHJlbW92ZVxuICAgICAgaWYgKGF0dHJpYnV0ZU5hbWUgaW4gdXBkYXRlcnMpIHtcbiAgICAgICAgYXR0cmlidXRlc1thdHRyaWJ1dGVOYW1lXSA9IE9iamVjdC5hc3NpZ24oXG4gICAgICAgICAge30sXG4gICAgICAgICAgYXR0cmlidXRlc1thdHRyaWJ1dGVOYW1lXSxcbiAgICAgICAgICB1cGRhdGVyc1thdHRyaWJ1dGVOYW1lXVxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzW2F0dHJpYnV0ZU5hbWVdO1xuXG4gICAgICBjb25zdCBpc0luZGV4ZWQgPSBhdHRyaWJ1dGUuaXNJbmRleGVkIHx8IGF0dHJpYnV0ZS5lbGVtZW50cztcbiAgICAgIGNvbnN0IHNpemUgPSAoYXR0cmlidXRlLmVsZW1lbnRzICYmIDEpIHx8IGF0dHJpYnV0ZS5zaXplO1xuICAgICAgY29uc3QgdmFsdWUgPSBhdHRyaWJ1dGUudmFsdWUgfHwgbnVsbDtcblxuICAgICAgLy8gSW5pdGlhbGl6ZSB0aGUgYXR0cmlidXRlIGRlc2NyaXB0b3IsIHdpdGggV2ViR0wgYW5kIG1ldGFkYXRhIGZpZWxkc1xuICAgICAgY29uc3QgYXR0cmlidXRlRGF0YSA9IE9iamVjdC5hc3NpZ24oXG4gICAgICAgIHtcbiAgICAgICAgICAvLyBFbnN1cmUgdGhhdCBmaWVsZHMgYXJlIHByZXNlbnQgYmVmb3JlIE9iamVjdC5zZWFsKClcbiAgICAgICAgICB0YXJnZXQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICB1c2VyRGF0YToge30gLy8gUmVzZXJ2ZWQgZm9yIGFwcGxpY2F0aW9uXG4gICAgICAgIH0sXG4gICAgICAgIC8vIE1ldGFkYXRhXG4gICAgICAgIGF0dHJpYnV0ZSxcbiAgICAgICAge1xuICAgICAgICAgIC8vIFN0YXRlXG4gICAgICAgICAgaXNFeHRlcm5hbEJ1ZmZlcjogZmFsc2UsXG4gICAgICAgICAgbmVlZHNBbGxvYzogZmFsc2UsXG4gICAgICAgICAgbmVlZHNVcGRhdGU6IGZhbHNlLFxuICAgICAgICAgIGNoYW5nZWQ6IGZhbHNlLFxuXG4gICAgICAgICAgLy8gTHVtYSBmaWVsZHNcbiAgICAgICAgICBpc0luZGV4ZWQsXG4gICAgICAgICAgc2l6ZSxcbiAgICAgICAgICB2YWx1ZVxuICAgICAgICB9LFxuICAgICAgICBfZXh0cmFQcm9wc1xuICAgICAgKTtcbiAgICAgIC8vIFNhbml0eSAtIG5vIGFwcCBmaWVsZHMgb24gb3VyIGF0dHJpYnV0ZXMuIFVzZSB1c2VyRGF0YSBpbnN0ZWFkLlxuICAgICAgT2JqZWN0LnNlYWwoYXR0cmlidXRlRGF0YSk7XG5cbiAgICAgIC8vIENoZWNrIGFsbCBmaWVsZHMgYW5kIGdlbmVyYXRlIGhlbHBmdWwgZXJyb3IgbWVzc2FnZXNcbiAgICAgIHRoaXMuX3ZhbGlkYXRlQXR0cmlidXRlRGVmaW5pdGlvbihhdHRyaWJ1dGVOYW1lLCBhdHRyaWJ1dGVEYXRhKTtcblxuICAgICAgLy8gQWRkIHRvIGJvdGggYXR0cmlidXRlcyBsaXN0IChmb3IgcmVnaXN0cmF0aW9uIHdpdGggbW9kZWwpXG4gICAgICBuZXdBdHRyaWJ1dGVzW2F0dHJpYnV0ZU5hbWVdID0gYXR0cmlidXRlRGF0YTtcbiAgICB9XG5cbiAgICBPYmplY3QuYXNzaWduKHRoaXMuYXR0cmlidXRlcywgbmV3QXR0cmlidXRlcyk7XG5cbiAgICB0aGlzLl9tYXBVcGRhdGVUcmlnZ2Vyc1RvQXR0cmlidXRlcygpO1xuICB9XG5cbiAgLy8gYnVpbGQgdXBkYXRlVHJpZ2dlciBuYW1lIHRvIGF0dHJpYnV0ZSBuYW1lIG1hcHBpbmdcbiAgX21hcFVwZGF0ZVRyaWdnZXJzVG9BdHRyaWJ1dGVzKCkge1xuICAgIGNvbnN0IHRyaWdnZXJzID0ge307XG5cbiAgICBmb3IgKGNvbnN0IGF0dHJpYnV0ZU5hbWUgaW4gdGhpcy5hdHRyaWJ1dGVzKSB7XG4gICAgICBjb25zdCBhdHRyaWJ1dGUgPSB0aGlzLmF0dHJpYnV0ZXNbYXR0cmlidXRlTmFtZV07XG4gICAgICBsZXQge2FjY2Vzc29yfSA9IGF0dHJpYnV0ZTtcblxuICAgICAgLy8gQmFja2FyZHMgY29tcGF0aWJpbGl0eTogYWxsb3cgYXR0cmlidXRlIG5hbWUgdG8gYmUgdXNlZCBhcyB1cGRhdGUgdHJpZ2dlciBrZXlcbiAgICAgIHRyaWdnZXJzW2F0dHJpYnV0ZU5hbWVdID0gW2F0dHJpYnV0ZU5hbWVdO1xuXG4gICAgICAvLyB1c2UgYWNjZXNzb3IgbmFtZSBhcyB1cGRhdGUgdHJpZ2dlciBrZXlcbiAgICAgIGlmICh0eXBlb2YgYWNjZXNzb3IgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGFjY2Vzc29yID0gW2FjY2Vzc29yXTtcbiAgICAgIH1cbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGFjY2Vzc29yKSkge1xuICAgICAgICBhY2Nlc3Nvci5mb3JFYWNoKGFjY2Vzc29yTmFtZSA9PiB7XG4gICAgICAgICAgaWYgKCF0cmlnZ2Vyc1thY2Nlc3Nvck5hbWVdKSB7XG4gICAgICAgICAgICB0cmlnZ2Vyc1thY2Nlc3Nvck5hbWVdID0gW107XG4gICAgICAgICAgfVxuICAgICAgICAgIHRyaWdnZXJzW2FjY2Vzc29yTmFtZV0ucHVzaChhdHRyaWJ1dGVOYW1lKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy51cGRhdGVUcmlnZ2VycyA9IHRyaWdnZXJzO1xuICB9XG5cbiAgX3ZhbGlkYXRlQXR0cmlidXRlRGVmaW5pdGlvbihhdHRyaWJ1dGVOYW1lLCBhdHRyaWJ1dGUpIHtcbiAgICBhc3NlcnQoXG4gICAgICBhdHRyaWJ1dGUuc2l6ZSA+PSAxICYmIGF0dHJpYnV0ZS5zaXplIDw9IDQsXG4gICAgICBgQXR0cmlidXRlIGRlZmluaXRpb24gZm9yICR7YXR0cmlidXRlTmFtZX0gaW52YWxpZCBzaXplYFxuICAgICk7XG5cbiAgICAvLyBDaGVjayB0aGF0IGVpdGhlciAnYWNjZXNzb3InIG9yICd1cGRhdGUnIGlzIGEgdmFsaWQgZnVuY3Rpb25cbiAgICBjb25zdCBoYXNVcGRhdGVyID1cbiAgICAgIGF0dHJpYnV0ZS5ub0FsbG9jIHx8XG4gICAgICB0eXBlb2YgYXR0cmlidXRlLnVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJyB8fFxuICAgICAgdHlwZW9mIGF0dHJpYnV0ZS5hY2Nlc3NvciA9PT0gJ3N0cmluZyc7XG4gICAgaWYgKCFoYXNVcGRhdGVyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEF0dHJpYnV0ZSAke2F0dHJpYnV0ZU5hbWV9IG1pc3NpbmcgdXBkYXRlIG9yIGFjY2Vzc29yYCk7XG4gICAgfVxuICB9XG5cbiAgLy8gQ2hlY2tzIHRoYXQgYW55IGF0dHJpYnV0ZSBidWZmZXJzIGluIHByb3BzIGFyZSB2YWxpZFxuICAvLyBOb3RlOiBUaGlzIGlzIGp1c3QgdG8gaGVscCBhcHAgY2F0Y2ggbWlzdGFrZXNcbiAgX2NoZWNrRXh0ZXJuYWxCdWZmZXJzKHtidWZmZXJzID0ge30sIGlnbm9yZVVua25vd25BdHRyaWJ1dGVzID0gZmFsc2V9ID0ge30pIHtcbiAgICBjb25zdCB7YXR0cmlidXRlc30gPSB0aGlzO1xuICAgIGZvciAoY29uc3QgYXR0cmlidXRlTmFtZSBpbiBidWZmZXJzKSB7XG4gICAgICBjb25zdCBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzW2F0dHJpYnV0ZU5hbWVdO1xuICAgICAgaWYgKCFhdHRyaWJ1dGUgJiYgIWlnbm9yZVVua25vd25BdHRyaWJ1dGVzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBhdHRyaWJ1dGUgcHJvcCAke2F0dHJpYnV0ZU5hbWV9YCk7XG4gICAgICB9XG4gICAgICAvLyBjb25zdCBidWZmZXIgPSBidWZmZXJzW2F0dHJpYnV0ZU5hbWVdO1xuICAgICAgLy8gVE9ETyAtIGNoZWNrIGJ1ZmZlciB0eXBlXG4gICAgfVxuICB9XG5cbiAgLy8gU2V0IHRoZSBidWZmZXJzIGZvciB0aGUgc3VwcGxpZWQgYXR0cmlidXRlc1xuICAvLyBVcGRhdGUgYXR0cmlidXRlIGJ1ZmZlcnMgZnJvbSBhbnkgYXR0cmlidXRlcyBpbiBwcm9wc1xuICAvLyBEZXRhY2ggYW55IHByZXZpb3VzbHkgc2V0IGJ1ZmZlcnMsIG1hcmtpbmcgYWxsXG4gIC8vIEF0dHJpYnV0ZXMgZm9yIGF1dG8gYWxsb2NhdGlvblxuICAvKiBlc2xpbnQtZGlzYWJsZSBtYXgtc3RhdGVtZW50cyAqL1xuICBfc2V0RXh0ZXJuYWxCdWZmZXJzKGJ1ZmZlck1hcCkge1xuICAgIGNvbnN0IHthdHRyaWJ1dGVzLCBudW1JbnN0YW5jZXN9ID0gdGhpcztcblxuICAgIC8vIENvcHkgdGhlIHJlZnMgb2YgYW55IHN1cHBsaWVkIGJ1ZmZlcnMgaW4gdGhlIHByb3BzXG4gICAgZm9yIChjb25zdCBhdHRyaWJ1dGVOYW1lIGluIGF0dHJpYnV0ZXMpIHtcbiAgICAgIGNvbnN0IGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXNbYXR0cmlidXRlTmFtZV07XG4gICAgICBjb25zdCBidWZmZXIgPSBidWZmZXJNYXBbYXR0cmlidXRlTmFtZV07XG4gICAgICBhdHRyaWJ1dGUuaXNFeHRlcm5hbEJ1ZmZlciA9IGZhbHNlO1xuICAgICAgaWYgKGJ1ZmZlcikge1xuICAgICAgICBjb25zdCBBcnJheVR5cGUgPSBnbEFycmF5RnJvbVR5cGUoYXR0cmlidXRlLnR5cGUgfHwgR0wuRkxPQVQpO1xuICAgICAgICBpZiAoIShidWZmZXIgaW5zdGFuY2VvZiBBcnJheVR5cGUpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBdHRyaWJ1dGUgJHthdHRyaWJ1dGVOYW1lfSBtdXN0IGJlIG9mIHR5cGUgJHtBcnJheVR5cGUubmFtZX1gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXR0cmlidXRlLmF1dG8gJiYgYnVmZmVyLmxlbmd0aCA8PSBudW1JbnN0YW5jZXMgKiBhdHRyaWJ1dGUuc2l6ZSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQXR0cmlidXRlIHByb3AgYXJyYXkgbXVzdCBtYXRjaCBsZW5ndGggYW5kIHNpemUnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGF0dHJpYnV0ZS5pc0V4dGVybmFsQnVmZmVyID0gdHJ1ZTtcbiAgICAgICAgYXR0cmlidXRlLm5lZWRzVXBkYXRlID0gZmFsc2U7XG4gICAgICAgIGlmIChhdHRyaWJ1dGUudmFsdWUgIT09IGJ1ZmZlcikge1xuICAgICAgICAgIGF0dHJpYnV0ZS52YWx1ZSA9IGJ1ZmZlcjtcbiAgICAgICAgICBhdHRyaWJ1dGUuY2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgdGhpcy5uZWVkc1JlZHJhdyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyogZXNsaW50LWVuYWJsZSBtYXgtc3RhdGVtZW50cyAqL1xuXG4gIC8qIENoZWNrcyB0aGF0IHR5cGVkIGFycmF5cyBmb3IgYXR0cmlidXRlcyBhcmUgYmlnIGVub3VnaFxuICAgKiBzZXRzIGFsbG9jIGZsYWcgaWYgbm90XG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IHdoZXRoZXIgYW55IHVwZGF0ZXMgYXJlIG5lZWRlZFxuICAgKi9cbiAgX2FuYWx5emVCdWZmZXJzKHtudW1JbnN0YW5jZXN9KSB7XG4gICAgY29uc3Qge2F0dHJpYnV0ZXN9ID0gdGhpcztcbiAgICBhc3NlcnQobnVtSW5zdGFuY2VzICE9PSB1bmRlZmluZWQsICdudW1JbnN0YW5jZXMgbm90IGRlZmluZWQnKTtcblxuICAgIC8vIFRyYWNrIHdoZXRoZXIgYW55IGFsbG9jYXRpb25zIG9yIHVwZGF0ZXMgYXJlIG5lZWRlZFxuICAgIGxldCBuZWVkc1VwZGF0ZSA9IGZhbHNlO1xuXG4gICAgZm9yIChjb25zdCBhdHRyaWJ1dGVOYW1lIGluIGF0dHJpYnV0ZXMpIHtcbiAgICAgIGNvbnN0IGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXNbYXR0cmlidXRlTmFtZV07XG4gICAgICBpZiAoIWF0dHJpYnV0ZS5pc0V4dGVybmFsQnVmZmVyKSB7XG4gICAgICAgIC8vIERvIHdlIG5lZWQgdG8gcmVhbGxvY2F0ZSB0aGUgYXR0cmlidXRlJ3MgdHlwZWQgYXJyYXk/XG4gICAgICAgIGNvbnN0IG5lZWRzQWxsb2MgPVxuICAgICAgICAgIGF0dHJpYnV0ZS52YWx1ZSA9PT0gbnVsbCB8fCBhdHRyaWJ1dGUudmFsdWUubGVuZ3RoIC8gYXR0cmlidXRlLnNpemUgPCBudW1JbnN0YW5jZXM7XG4gICAgICAgIGlmIChuZWVkc0FsbG9jICYmIChhdHRyaWJ1dGUudXBkYXRlIHx8IGF0dHJpYnV0ZS5hY2Nlc3NvcikpIHtcbiAgICAgICAgICBhdHRyaWJ1dGUubmVlZHNBbGxvYyA9IHRydWU7XG4gICAgICAgICAgbmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhdHRyaWJ1dGUubmVlZHNVcGRhdGUpIHtcbiAgICAgICAgICBuZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbmVlZHNVcGRhdGU7XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQ2FsbHMgdXBkYXRlIG9uIGFueSBidWZmZXJzIHRoYXQgbmVlZCB1cGRhdGVcbiAgICogVE9ETz8gLSBJZiBhcHAgc3VwcGxpZWQgYWxsIGF0dHJpYnV0ZXMsIG5vIG5lZWQgdG8gaXRlcmF0ZSBvdmVyIGRhdGFcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzLmRhdGEgLSBkYXRhIChpdGVyYWJsZSBvYmplY3QpXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzLm51bUluc3RhbmNlcyAtIGNvdW50IG9mIGRhdGFcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMuYnVmZmVycyA9IHt9IC0gcHJlLWFsbG9jYXRlZCBidWZmZXJzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzLnByb3BzIC0gcGFzc2VkIHRvIHVwZGF0ZXJzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzLmNvbnRleHQgLSBVc2VkIGFzIFwidGhpc1wiIGNvbnRleHQgZm9yIHVwZGF0ZXJzXG4gICAqL1xuICAvKiBlc2xpbnQtZGlzYWJsZSBtYXgtc3RhdGVtZW50cywgY29tcGxleGl0eSAqL1xuICBfdXBkYXRlQnVmZmVycyh7bnVtSW5zdGFuY2VzLCBkYXRhLCBwcm9wcywgY29udGV4dH0pIHtcbiAgICBjb25zdCB7YXR0cmlidXRlc30gPSB0aGlzO1xuXG4gICAgLy8gQWxsb2NhdGUgYXQgbGVhc3Qgb25lIGVsZW1lbnQgdG8gZW5zdXJlIGEgdmFsaWQgYnVmZmVyXG4gICAgY29uc3QgYWxsb2NDb3VudCA9IE1hdGgubWF4KG51bUluc3RhbmNlcywgMSk7XG5cbiAgICBmb3IgKGNvbnN0IGF0dHJpYnV0ZU5hbWUgaW4gYXR0cmlidXRlcykge1xuICAgICAgY29uc3QgYXR0cmlidXRlID0gYXR0cmlidXRlc1thdHRyaWJ1dGVOYW1lXTtcblxuICAgICAgLy8gQWxsb2NhdGUgYSBuZXcgdHlwZWQgYXJyYXkgaWYgbmVlZGVkXG4gICAgICBpZiAoYXR0cmlidXRlLm5lZWRzQWxsb2MpIHtcbiAgICAgICAgY29uc3QgQXJyYXlUeXBlID0gZ2xBcnJheUZyb21UeXBlKGF0dHJpYnV0ZS50eXBlIHx8IEdMLkZMT0FUKTtcbiAgICAgICAgYXR0cmlidXRlLnZhbHVlID0gbmV3IEFycmF5VHlwZShhdHRyaWJ1dGUuc2l6ZSAqIGFsbG9jQ291bnQpO1xuICAgICAgICBsb2dGdW5jdGlvbnMub25VcGRhdGUoe1xuICAgICAgICAgIGxldmVsOiBMT0dfREVUQUlMX1BSSU9SSVRZLFxuICAgICAgICAgIG1lc3NhZ2U6IGAke2F0dHJpYnV0ZU5hbWV9IGFsbG9jYXRlZCAke2FsbG9jQ291bnR9YCxcbiAgICAgICAgICBpZDogdGhpcy5pZFxuICAgICAgICB9KTtcbiAgICAgICAgYXR0cmlidXRlLm5lZWRzQWxsb2MgPSBmYWxzZTtcbiAgICAgICAgYXR0cmlidXRlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IGF0dHJpYnV0ZU5hbWUgaW4gYXR0cmlidXRlcykge1xuICAgICAgY29uc3QgYXR0cmlidXRlID0gYXR0cmlidXRlc1thdHRyaWJ1dGVOYW1lXTtcbiAgICAgIC8vIENhbGwgdXBkYXRlciBmdW5jdGlvbiBpZiBuZWVkZWRcbiAgICAgIGlmIChhdHRyaWJ1dGUubmVlZHNVcGRhdGUpIHtcbiAgICAgICAgdGhpcy5fdXBkYXRlQnVmZmVyKHthdHRyaWJ1dGUsIGF0dHJpYnV0ZU5hbWUsIG51bUluc3RhbmNlcywgZGF0YSwgcHJvcHMsIGNvbnRleHR9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmFsbG9jZWRJbnN0YW5jZXMgPSBhbGxvY0NvdW50O1xuICB9XG5cbiAgX3VwZGF0ZUJ1ZmZlcih7YXR0cmlidXRlLCBhdHRyaWJ1dGVOYW1lLCBudW1JbnN0YW5jZXMsIGRhdGEsIHByb3BzLCBjb250ZXh0fSkge1xuICAgIGNvbnN0IHt1cGRhdGUsIGFjY2Vzc29yfSA9IGF0dHJpYnV0ZTtcblxuICAgIGNvbnN0IHRpbWVTdGFydCA9IG5ldyBEYXRlKCk7XG4gICAgaWYgKHVwZGF0ZSkge1xuICAgICAgLy8gQ3VzdG9tIHVwZGF0ZXIgLSB0eXBpY2FsbHkgZm9yIG5vbi1pbnN0YW5jZWQgbGF5ZXJzXG4gICAgICB1cGRhdGUuY2FsbChjb250ZXh0LCBhdHRyaWJ1dGUsIHtkYXRhLCBwcm9wcywgbnVtSW5zdGFuY2VzfSk7XG4gICAgICB0aGlzLl9jaGVja0F0dHJpYnV0ZUFycmF5KGF0dHJpYnV0ZSwgYXR0cmlidXRlTmFtZSk7XG4gICAgfSBlbHNlIGlmIChhY2Nlc3Nvcikge1xuICAgICAgLy8gU3RhbmRhcmQgdXBkYXRlclxuICAgICAgdGhpcy5fdXBkYXRlQnVmZmVyVmlhU3RhbmRhcmRBY2Nlc3Nvcih7YXR0cmlidXRlLCBkYXRhLCBwcm9wc30pO1xuICAgICAgdGhpcy5fY2hlY2tBdHRyaWJ1dGVBcnJheShhdHRyaWJ1dGUsIGF0dHJpYnV0ZU5hbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsb2dGdW5jdGlvbnMub25VcGRhdGUoe1xuICAgICAgICBsZXZlbDogTE9HX0RFVEFJTF9QUklPUklUWSxcbiAgICAgICAgbWVzc2FnZTogYCR7YXR0cmlidXRlTmFtZX0gbWlzc2luZyB1cGRhdGUgZnVuY3Rpb25gLFxuICAgICAgICBpZDogdGhpcy5pZFxuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IHRpbWVNcyA9IE1hdGgucm91bmQobmV3IERhdGUoKSAtIHRpbWVTdGFydCk7XG4gICAgY29uc3QgdGltZSA9IGAke3RpbWVNc31tc2A7XG4gICAgbG9nRnVuY3Rpb25zLm9uVXBkYXRlKHtcbiAgICAgIGxldmVsOiBMT0dfREVUQUlMX1BSSU9SSVRZLFxuICAgICAgbWVzc2FnZTogYCR7YXR0cmlidXRlTmFtZX0gdXBkYXRlZCAke251bUluc3RhbmNlc30gJHt0aW1lfWAsXG4gICAgICBpZDogdGhpcy5pZFxuICAgIH0pO1xuXG4gICAgYXR0cmlidXRlLm5lZWRzVXBkYXRlID0gZmFsc2U7XG4gICAgYXR0cmlidXRlLmNoYW5nZWQgPSB0cnVlO1xuICAgIHRoaXMubmVlZHNSZWRyYXcgPSB0cnVlO1xuICB9XG4gIC8qIGVzbGludC1lbmFibGUgbWF4LXN0YXRlbWVudHMgKi9cblxuICBfdXBkYXRlQnVmZmVyVmlhU3RhbmRhcmRBY2Nlc3Nvcih7YXR0cmlidXRlLCBkYXRhLCBwcm9wc30pIHtcbiAgICBjb25zdCB7YWNjZXNzb3IsIHZhbHVlLCBzaXplfSA9IGF0dHJpYnV0ZTtcbiAgICBjb25zdCBhY2Nlc3NvckZ1bmMgPSBwcm9wc1thY2Nlc3Nvcl07XG5cbiAgICBhc3NlcnQodHlwZW9mIGFjY2Vzc29yRnVuYyA9PT0gJ2Z1bmN0aW9uJywgYGFjY2Vzc29yIFwiJHthY2Nlc3Nvcn1cIiBpcyBub3QgYSBmdW5jdGlvbmApO1xuXG4gICAgbGV0IHtkZWZhdWx0VmFsdWUgPSBbMCwgMCwgMCwgMF19ID0gYXR0cmlidXRlO1xuICAgIGRlZmF1bHRWYWx1ZSA9IEFycmF5LmlzQXJyYXkoZGVmYXVsdFZhbHVlKSA/IGRlZmF1bHRWYWx1ZSA6IFtkZWZhdWx0VmFsdWVdO1xuICAgIGxldCBpID0gMDtcbiAgICBmb3IgKGNvbnN0IG9iamVjdCBvZiBkYXRhKSB7XG4gICAgICBsZXQgb2JqZWN0VmFsdWUgPSBhY2Nlc3NvckZ1bmMob2JqZWN0KTtcbiAgICAgIG9iamVjdFZhbHVlID0gQXJyYXkuaXNBcnJheShvYmplY3RWYWx1ZSkgPyBvYmplY3RWYWx1ZSA6IFtvYmplY3RWYWx1ZV07XG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1mYWxsdGhyb3VnaCwgZGVmYXVsdC1jYXNlICovXG4gICAgICBzd2l0Y2ggKHNpemUpIHtcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIHZhbHVlW2kgKyAzXSA9IE51bWJlci5pc0Zpbml0ZShvYmplY3RWYWx1ZVszXSkgPyBvYmplY3RWYWx1ZVszXSA6IGRlZmF1bHRWYWx1ZVszXTtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHZhbHVlW2kgKyAyXSA9IE51bWJlci5pc0Zpbml0ZShvYmplY3RWYWx1ZVsyXSkgPyBvYmplY3RWYWx1ZVsyXSA6IGRlZmF1bHRWYWx1ZVsyXTtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHZhbHVlW2kgKyAxXSA9IE51bWJlci5pc0Zpbml0ZShvYmplY3RWYWx1ZVsxXSkgPyBvYmplY3RWYWx1ZVsxXSA6IGRlZmF1bHRWYWx1ZVsxXTtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIHZhbHVlW2kgKyAwXSA9IE51bWJlci5pc0Zpbml0ZShvYmplY3RWYWx1ZVswXSkgPyBvYmplY3RWYWx1ZVswXSA6IGRlZmF1bHRWYWx1ZVswXTtcbiAgICAgIH1cbiAgICAgIGkgKz0gc2l6ZTtcbiAgICB9XG4gIH1cblxuICBfY2hlY2tBdHRyaWJ1dGVBcnJheShhdHRyaWJ1dGUsIGF0dHJpYnV0ZU5hbWUpIHtcbiAgICBjb25zdCB7dmFsdWV9ID0gYXR0cmlidXRlO1xuICAgIGlmICh2YWx1ZSAmJiB2YWx1ZS5sZW5ndGggPj0gNCkge1xuICAgICAgY29uc3QgdmFsaWQgPVxuICAgICAgICBOdW1iZXIuaXNGaW5pdGUodmFsdWVbMF0pICYmXG4gICAgICAgIE51bWJlci5pc0Zpbml0ZSh2YWx1ZVsxXSkgJiZcbiAgICAgICAgTnVtYmVyLmlzRmluaXRlKHZhbHVlWzJdKSAmJlxuICAgICAgICBOdW1iZXIuaXNGaW5pdGUodmFsdWVbM10pO1xuICAgICAgaWYgKCF2YWxpZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYElsbGVnYWwgYXR0cmlidXRlIGdlbmVyYXRlZCBmb3IgJHthdHRyaWJ1dGVOYW1lfWApO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuIl19