'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

/* global window */


var _constants = require('./constants');

var _attributeManager = require('./attribute-manager');

var _attributeManager2 = _interopRequireDefault(_attributeManager);

var _stats = require('./stats');

var _stats2 = _interopRequireDefault(_stats);

var _props2 = require('./props');

var _count = require('../utils/count');

var _log = require('../utils/log');

var _log2 = _interopRequireDefault(_log);

var _seerIntegration = require('./seer-integration');

var _luma = require('luma.gl');

var _assert = require('assert');

var _assert2 = _interopRequireDefault(_assert);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var LOG_PRIORITY_UPDATE = 1;

var EMPTY_ARRAY = [];
var EMPTY_PROPS = {};
Object.freeze(EMPTY_PROPS);
var noop = function noop() {};

var defaultProps = {
  // data: Special handling for null, see below
  dataComparator: null,
  updateTriggers: {}, // Update triggers: a core change detection mechanism in deck.gl
  numInstances: undefined,

  visible: true,
  pickable: false,
  opacity: 0.8,

  onHover: noop,
  onClick: noop,

  coordinateSystem: _constants.COORDINATE_SYSTEM.LNGLAT,
  coordinateOrigin: [0, 0, 0],

  parameters: {},
  uniforms: {},
  framebuffer: null,

  animation: null, // Passed prop animation functions to evaluate props

  // Offset depth based on layer index to avoid z-fighting.
  // Negative values pull layer towards the camera
  // https://www.opengl.org/archives/resources/faq/technical/polygonoffset.htm
  getPolygonOffset: function getPolygonOffset(_ref) {
    var layerIndex = _ref.layerIndex;
    return [0, -layerIndex * 100];
  },

  // Selection/Highlighting
  highlightedObjectIndex: null,
  autoHighlight: false,
  highlightColor: [0, 0, 128, 128]
};

var counter = 0;

var Layer = function () {
  function Layer(props) {
    _classCallCheck(this, Layer);

    // Call a helper function to merge the incoming props with defaults and freeze them.
    this.props = this._normalizeProps(props);

    // Define all members before layer is sealed
    this.id = this.props.id; // The layer's id, used for matching with layers from last render cycle
    this.oldProps = EMPTY_PROPS; // Props from last render used for change detection
    this.count = counter++; // Keep track of how many layer instances you are generating
    this.lifecycle = _constants.LIFECYCLE.NO_STATE; // Helps track and debug the life cycle of the layers
    this.state = null; // Will be set to the shared layer state object during layer matching
    this.context = null; // Will reference layer manager's context, contains state shared by layers
    this.parentLayer = null; // reference to the composite layer parent that rendered this layer

    // CompositeLayer members, need to be defined here because of the `Object.seal`
    this.internalState = null;

    // Seal the layer
    Object.seal(this);
  }

  _createClass(Layer, [{
    key: 'toString',
    value: function toString() {
      var className = this.constructor.layerName || this.constructor.name;
      return className + '({id: \'' + this.props.id + '\'})';
    }
  }, {
    key: 'needsUpdate',
    value: function needsUpdate() {
      // Call subclass lifecycle method
      return this.shouldUpdateState(this._getUpdateParams());
      // End lifecycle method
    }

    // Checks state of attributes and model

  }, {
    key: 'getNeedsRedraw',
    value: function getNeedsRedraw() {
      var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref2$clearRedrawFlag = _ref2.clearRedrawFlags,
          clearRedrawFlags = _ref2$clearRedrawFlag === undefined ? false : _ref2$clearRedrawFlag;

      return this._getNeedsRedraw(clearRedrawFlags);
    }

    // //////////////////////////////////////////////////
    // LIFECYCLE METHODS, overridden by the layer subclasses

    // Called once to set up the initial state
    // App can create WebGL resources

  }, {
    key: 'initializeState',
    value: function initializeState() {
      throw new Error('Layer ' + this + ' has not defined initializeState');
    }

    // Let's layer control if updateState should be called

  }, {
    key: 'shouldUpdateState',
    value: function shouldUpdateState(_ref3) {
      var oldProps = _ref3.oldProps,
          props = _ref3.props,
          oldContext = _ref3.oldContext,
          context = _ref3.context,
          changeFlags = _ref3.changeFlags;

      return changeFlags.propsOrDataChanged;
    }

    // Default implementation, all attributes will be invalidated and updated
    // when data changes

  }, {
    key: 'updateState',
    value: function updateState(_ref4) {
      var oldProps = _ref4.oldProps,
          props = _ref4.props,
          oldContext = _ref4.oldContext,
          context = _ref4.context,
          changeFlags = _ref4.changeFlags;
      var attributeManager = this.state.attributeManager;

      if (changeFlags.dataChanged && attributeManager) {
        attributeManager.invalidateAll();
      }
    }

    // Called once when layer is no longer matched and state will be discarded
    // App can destroy WebGL resources here

  }, {
    key: 'finalizeState',
    value: function finalizeState() {}

    // If state has a model, draw it with supplied uniforms

  }, {
    key: 'draw',
    value: function draw(opts) {
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = this.getModels()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var model = _step.value;

          model.draw(opts);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }

    // called to populate the info object that is passed to the event handler
    // @return null to cancel event

  }, {
    key: 'getPickingInfo',
    value: function getPickingInfo(_ref5) {
      var info = _ref5.info,
          mode = _ref5.mode;
      var index = info.index;


      if (index >= 0) {
        // If props.data is an indexable array, get the object
        if (Array.isArray(this.props.data)) {
          info.object = this.props.data[index];
        }
      }

      return info;
    }

    // END LIFECYCLE METHODS
    // //////////////////////////////////////////////////

    // Returns true if the layer is pickable and visible.

  }, {
    key: 'isPickable',
    value: function isPickable() {
      return this.props.pickable && this.props.visible;
    }

    // Default implementation of attribute invalidation, can be redefined

  }, {
    key: 'invalidateAttribute',
    value: function invalidateAttribute() {
      var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'all';
      var diffReason = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
      var attributeManager = this.state.attributeManager;

      if (!attributeManager) {
        return;
      }

      if (name === 'all') {
        _log2.default.log(LOG_PRIORITY_UPDATE, 'updateTriggers invalidating all attributes: ' + diffReason);
        attributeManager.invalidateAll();
      } else {
        _log2.default.log(LOG_PRIORITY_UPDATE, 'updateTriggers invalidating attribute ' + name + ': ' + diffReason);
        attributeManager.invalidate(name);
      }
    }

    // Calls attribute manager to update any WebGL attributes, can be redefined

  }, {
    key: 'updateAttributes',
    value: function updateAttributes(props) {
      var attributeManager = this.state.attributeManager;

      if (!attributeManager) {
        return;
      }

      // Figure out data length
      var numInstances = this.getNumInstances(props);

      attributeManager.update({
        data: props.data,
        numInstances: numInstances,
        props: props,
        buffers: props,
        context: this,
        // Don't worry about non-attribute props
        ignoreUnknownAttributes: true
      });

      // TODO - Use getModels?
      var model = this.state.model;

      if (model) {
        var changedAttributes = attributeManager.getChangedAttributes({ clearChangedFlags: true });
        model.setAttributes(changedAttributes);
      }
    }

    // Public API

    // Updates selected state members and marks the object for redraw

  }, {
    key: 'setState',
    value: function setState(updateObject) {
      Object.assign(this.state, updateObject);
      this.state.needsRedraw = true;
    }

    // Sets the redraw flag for this layer, will trigger a redraw next animation frame

  }, {
    key: 'setNeedsRedraw',
    value: function setNeedsRedraw() {
      var redraw = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

      if (this.state) {
        this.state.needsRedraw = redraw;
      }
    }

    // Return an array of models used by this layer, can be overriden by layer subclass

  }, {
    key: 'getModels',
    value: function getModels() {
      return this.state.models || (this.state.model ? [this.state.model] : []);
    }

    // PROJECTION METHODS

    /**
     * Projects a point with current map state (lat, lon, zoom, pitch, bearing)
     *
     * Note: Position conversion is done in shader, so in many cases there is no need
     * for this function
     * @param {Array|TypedArray} lngLat - long and lat values
     * @return {Array|TypedArray} - x, y coordinates
     */

  }, {
    key: 'project',
    value: function project(lngLat) {
      var viewport = this.context.viewport;

      (0, _assert2.default)(Array.isArray(lngLat), 'Layer.project needs [lng,lat]');
      return viewport.project(lngLat);
    }
  }, {
    key: 'unproject',
    value: function unproject(xy) {
      var viewport = this.context.viewport;

      (0, _assert2.default)(Array.isArray(xy), 'Layer.unproject needs [x,y]');
      return viewport.unproject(xy);
    }
  }, {
    key: 'projectFlat',
    value: function projectFlat(lngLat) {
      var viewport = this.context.viewport;

      (0, _assert2.default)(Array.isArray(lngLat), 'Layer.project needs [lng,lat]');
      return viewport.projectFlat(lngLat);
    }
  }, {
    key: 'unprojectFlat',
    value: function unprojectFlat(xy) {
      var viewport = this.context.viewport;

      (0, _assert2.default)(Array.isArray(xy), 'Layer.unproject needs [x,y]');
      return viewport.unprojectFlat(xy);
    }

    // TODO - needs to refer to context

  }, {
    key: 'screenToDevicePixels',
    value: function screenToDevicePixels(screenPixels) {
      _log2.default.deprecated('screenToDevicePixels', 'DeckGL prop useDevicePixels for conversion');
      var devicePixelRatio = typeof window !== 'undefined' ? window.devicePixelRatio : 1;
      return screenPixels * devicePixelRatio;
    }

    /**
     * Returns the picking color that doesn't match any subfeature
     * Use if some graphics do not belong to any pickable subfeature
     * @return {Array} - a black color
     */

  }, {
    key: 'nullPickingColor',
    value: function nullPickingColor() {
      return [0, 0, 0];
    }

    /**
     * Returns the picking color that doesn't match any subfeature
     * Use if some graphics do not belong to any pickable subfeature
     * @param {int} i - index to be decoded
     * @return {Array} - the decoded color
     */

  }, {
    key: 'encodePickingColor',
    value: function encodePickingColor(i) {
      (0, _assert2.default)((i + 1 >> 24 & 255) === 0, 'index out of picking color range');
      return [i + 1 & 255, i + 1 >> 8 & 255, i + 1 >> 8 >> 8 & 255];
    }

    /**
     * Returns the picking color that doesn't match any subfeature
     * Use if some graphics do not belong to any pickable subfeature
     * @param {Uint8Array} color - color array to be decoded
     * @return {Array} - the decoded picking color
     */

  }, {
    key: 'decodePickingColor',
    value: function decodePickingColor(color) {
      (0, _assert2.default)(color instanceof Uint8Array);

      var _color = _slicedToArray(color, 3),
          i1 = _color[0],
          i2 = _color[1],
          i3 = _color[2];
      // 1 was added to seperate from no selection


      var index = i1 + i2 * 256 + i3 * 65536 - 1;
      return index;
    }
  }, {
    key: 'calculateInstancePickingColors',
    value: function calculateInstancePickingColors(attribute, _ref6) {
      var numInstances = _ref6.numInstances;
      var value = attribute.value,
          size = attribute.size;
      // add 1 to index to seperate from no selection

      for (var i = 0; i < numInstances; i++) {
        var pickingColor = this.encodePickingColor(i);
        value[i * size + 0] = pickingColor[0];
        value[i * size + 1] = pickingColor[1];
        value[i * size + 2] = pickingColor[2];
      }
    }

    // DATA ACCESS API
    // Data can use iterators and may not be random access

    // Use iteration (the only required capability on data) to get first element

  }, {
    key: 'getFirstObject',
    value: function getFirstObject() {
      var data = this.props.data;
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = data[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var object = _step2.value;

          return object;
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      return null;
    }

    // INTERNAL METHODS

    // Deduces numer of instances. Intention is to support:
    // - Explicit setting of numInstances
    // - Auto-deduction for ES6 containers that define a size member
    // - Auto-deduction for Classic Arrays via the built-in length attribute
    // - Auto-deduction via arrays

  }, {
    key: 'getNumInstances',
    value: function getNumInstances(props) {
      props = props || this.props;

      // First check if the layer has set its own value
      if (this.state && this.state.numInstances !== undefined) {
        return this.state.numInstances;
      }

      // Check if app has provided an explicit value
      if (props.numInstances !== undefined) {
        return props.numInstances;
      }

      // Use container library to get a count for any ES6 container or object
      var _props = props,
          data = _props.data;

      return (0, _count.count)(data);
    }

    // clone this layer with modified props

  }, {
    key: 'clone',
    value: function clone(newProps) {
      return new this.constructor(Object.assign({}, this.props, newProps));
    }

    // LAYER MANAGER API
    // Should only be called by the deck.gl LayerManager class

    // Called by layer manager when a new layer is found
    /* eslint-disable max-statements */

  }, {
    key: '_initialize',
    value: function _initialize() {
      (0, _assert2.default)(arguments.length === 0);
      (0, _assert2.default)(this.context.gl);
      (0, _assert2.default)(!this.state);

      var attributeManager = new _attributeManager2.default({ id: this.props.id });
      // All instanced layers get instancePickingColors attribute by default
      // Their shaders can use it to render a picking scene
      // TODO - this slightly slows down non instanced layers
      attributeManager.addInstanced({
        instancePickingColors: {
          type: _luma.GL.UNSIGNED_BYTE,
          size: 3,
          update: this.calculateInstancePickingColors
        }
      });

      this.internalState = {
        subLayers: null, // reference to sublayers rendered in a previous cycle
        stats: new _stats2.default({ id: 'draw' })
        // animatedProps: null, // Computing animated props requires layer manager state
        // TODO - move these fields here (risks breaking layers)
        // attributeManager,
        // needsRedraw: true,
      };

      this.state = {
        attributeManager: attributeManager,
        model: null,
        needsRedraw: true
      };

      // Call subclass lifecycle methods
      this.initializeState(this.context);
      // End subclass lifecycle methods

      // initializeState callback tends to clear state
      this.setChangeFlags({ dataChanged: true, propsChanged: true, viewportChanged: true });

      this._updateState(this._getUpdateParams());

      if (this.isComposite) {
        this._renderLayers(true);
      }

      var model = this.state.model;

      if (model) {
        model.id = this.props.id;
        model.program.id = this.props.id + '-program';
        model.geometry.id = this.props.id + '-geometry';
        model.setAttributes(attributeManager.getAttributes());
      }

      // Last but not least, update any sublayers
      if (this.isComposite) {
        this._renderLayers();
      }

      this.clearChangeFlags();
    }

    // Called by layer manager
    // if this layer is new (not matched with an existing layer) oldProps will be empty object

  }, {
    key: '_update',
    value: function _update() {
      (0, _assert2.default)(arguments.length === 0);

      // Call subclass lifecycle method
      var stateNeedsUpdate = this.needsUpdate();
      // End lifecycle method

      var updateParams = {
        props: this.props,
        oldProps: this.oldProps,
        context: this.context,
        oldContext: this.oldContext,
        changeFlags: this.internalState.changeFlags
      };

      if (stateNeedsUpdate) {
        this._updateState(updateParams);
      }

      // Render or update previously rendered sublayers
      if (this.isComposite) {
        this._renderLayers(stateNeedsUpdate);
      }

      this.clearChangeFlags();
    }
    /* eslint-enable max-statements */

  }, {
    key: '_updateState',
    value: function _updateState(updateParams) {
      // Call subclass lifecycle methods
      this.updateState(updateParams);
      // End subclass lifecycle methods

      // Add any subclass attributes
      this.updateAttributes(this.props);
      this._updateBaseUniforms();
      this._updateModuleSettings();

      // Note: Automatic instance count update only works for single layers
      if (this.state.model) {
        this.state.model.setInstanceCount(this.getNumInstances());
      }
    }

    // Called by manager when layer is about to be disposed
    // Note: not guaranteed to be called on application shutdown

  }, {
    key: '_finalize',
    value: function _finalize() {
      (0, _assert2.default)(arguments.length === 0);
      // Call subclass lifecycle method
      this.finalizeState(this.context);
      // End lifecycle method
      (0, _seerIntegration.removeLayerInSeer)(this.id);
    }

    // Calculates uniforms

  }, {
    key: 'drawLayer',
    value: function drawLayer(_ref7) {
      var _this = this;

      var _ref7$moduleParameter = _ref7.moduleParameters,
          moduleParameters = _ref7$moduleParameter === undefined ? null : _ref7$moduleParameter,
          _ref7$uniforms = _ref7.uniforms,
          uniforms = _ref7$uniforms === undefined ? {} : _ref7$uniforms,
          _ref7$parameters = _ref7.parameters,
          parameters = _ref7$parameters === undefined ? {} : _ref7$parameters;

      // TODO/ib - hack move to luma Model.draw
      if (moduleParameters) {
        var _iteratorNormalCompletion3 = true;
        var _didIteratorError3 = false;
        var _iteratorError3 = undefined;

        try {
          for (var _iterator3 = this.getModels()[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
            var model = _step3.value;

            model.updateModuleSettings(moduleParameters);
          }
        } catch (err) {
          _didIteratorError3 = true;
          _iteratorError3 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion3 && _iterator3.return) {
              _iterator3.return();
            }
          } finally {
            if (_didIteratorError3) {
              throw _iteratorError3;
            }
          }
        }
      }

      // Apply polygon offset to avoid z-fighting
      // TODO - move to draw-layers
      var getPolygonOffset = this.props.getPolygonOffset;

      var offsets = getPolygonOffset && getPolygonOffset(uniforms) || [0, 0];
      parameters.polygonOffset = offsets;

      // Call subclass lifecycle method
      (0, _luma.withParameters)(this.context.gl, parameters, function () {
        _this.draw({ moduleParameters: moduleParameters, uniforms: uniforms, parameters: parameters, context: _this.context });
      });
      // End lifecycle method
    }

    // {uniforms = {}, ...opts}

  }, {
    key: 'pickLayer',
    value: function pickLayer(opts) {
      // Call subclass lifecycle method
      return this.getPickingInfo(opts);
      // End lifecycle method
    }

    // Helper methods

  }, {
    key: 'getChangeFlags',
    value: function getChangeFlags() {
      return this.internalState.changeFlags;
    }

    // Dirty some change flags, will be handled by updateLayer
    /* eslint-disable complexity */

  }, {
    key: 'setChangeFlags',
    value: function setChangeFlags(flags) {
      var _this2 = this;

      this.internalState.changeFlags = this.internalState.changeFlags || {};
      var changeFlags = this.internalState.changeFlags;

      // Update primary flags
      if (flags.dataChanged && !changeFlags.dataChanged) {
        changeFlags.dataChanged = flags.dataChanged;
        _log2.default.log(LOG_PRIORITY_UPDATE + 1, function () {
          return 'dataChanged: ' + flags.dataChanged + ' in ' + _this2.id;
        });
      }
      if (flags.updateTriggersChanged && !changeFlags.updateTriggersChanged) {
        changeFlags.updateTriggersChanged = changeFlags.updateTriggersChanged && flags.updateTriggersChanged ? Object.assign({}, flags.updateTriggersChanged, changeFlags.updateTriggersChanged) : flags.updateTriggersChanged || changeFlags.updateTriggersChanged;
        _log2.default.log(LOG_PRIORITY_UPDATE + 1, function () {
          return 'updateTriggersChanged: ' + (Object.keys(flags.updateTriggersChanged).join(', ') + ' in ' + _this2.id);
        });
      }
      if (flags.propsChanged && !changeFlags.propsChanged) {
        changeFlags.propsChanged = flags.propsChanged;
        _log2.default.log(LOG_PRIORITY_UPDATE + 1, function () {
          return 'propsChanged: ' + flags.propsChanged + ' in ' + _this2.id;
        });
      }
      if (flags.viewportChanged && !changeFlags.viewportChanged) {
        changeFlags.viewportChanged = flags.viewportChanged;
        _log2.default.log(LOG_PRIORITY_UPDATE + 2, function () {
          return 'viewportChanged: ' + flags.viewportChanged + ' in ' + _this2.id;
        });
      }

      // Update composite flags
      var propsOrDataChanged = flags.dataChanged || flags.updateTriggersChanged || flags.propsChanged;
      changeFlags.propsOrDataChanged = changeFlags.propsOrDataChanged || propsOrDataChanged;
      changeFlags.somethingChanged = changeFlags.somethingChanged || propsOrDataChanged || flags.viewportChanged;
    }
    /* eslint-enable complexity */

    // Clear all changeFlags, typically after an update

  }, {
    key: 'clearChangeFlags',
    value: function clearChangeFlags() {
      this.internalState.changeFlags = {
        // Primary changeFlags, can be strings stating reason for change
        dataChanged: false,
        propsChanged: false,
        updateTriggersChanged: false,
        viewportChanged: false,

        // Derived changeFlags
        propsOrDataChanged: false,
        somethingChanged: false
      };
    }
  }, {
    key: 'printChangeFlags',
    value: function printChangeFlags() {
      var flags = this.internalState.changeFlags;
      return '' + (flags.dataChanged ? 'data ' : '') + (flags.propsChanged ? 'props ' : '') + (flags.updateTriggersChanged ? 'triggers ' : '') + (flags.viewportChanged ? 'viewport' : '');
    }

    // Compares the layers props with old props from a matched older layer
    // and extracts change flags that describe what has change so that state
    // can be update correctly with minimal effort
    // TODO - arguments for testing only

  }, {
    key: 'diffProps',
    value: function diffProps() {
      var newProps = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;
      var oldProps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.oldProps;

      var changeFlags = (0, _props2.diffProps)(newProps, oldProps);

      // iterate over changedTriggers
      if (changeFlags.updateTriggersChanged) {
        for (var key in changeFlags.updateTriggersChanged) {
          if (changeFlags.updateTriggersChanged[key]) {
            this._activeUpdateTrigger(key);
          }
        }
      }

      return this.setChangeFlags(changeFlags);
    }

    // PRIVATE METHODS

  }, {
    key: '_getUpdateParams',
    value: function _getUpdateParams() {
      return {
        props: this.props,
        oldProps: this.oldProps,
        context: this.context,
        oldContext: this.oldContext || {},
        changeFlags: this.internalState.changeFlags
      };
    }

    // Checks state of attributes and model

  }, {
    key: '_getNeedsRedraw',
    value: function _getNeedsRedraw(clearRedrawFlags) {
      // this method may be called by the render loop as soon a the layer
      // has been created, so guard against uninitialized state
      if (!this.state) {
        return false;
      }

      var redraw = false;
      redraw = redraw || this.state.needsRedraw && this.id;
      this.state.needsRedraw = this.state.needsRedraw && !clearRedrawFlags;

      // TODO - is attribute manager needed? - Model should be enough.
      var attributeManager = this.state.attributeManager;

      var attributeManagerNeedsRedraw = attributeManager && attributeManager.getNeedsRedraw({ clearRedrawFlags: clearRedrawFlags });
      redraw = redraw || attributeManagerNeedsRedraw;

      var _iteratorNormalCompletion4 = true;
      var _didIteratorError4 = false;
      var _iteratorError4 = undefined;

      try {
        for (var _iterator4 = this.getModels()[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
          var model = _step4.value;

          var modelNeedsRedraw = model.getNeedsRedraw({ clearRedrawFlags: clearRedrawFlags });
          if (modelNeedsRedraw && typeof modelNeedsRedraw !== 'string') {
            modelNeedsRedraw = 'model ' + model.id;
          }
          redraw = redraw || modelNeedsRedraw;
        }
      } catch (err) {
        _didIteratorError4 = true;
        _iteratorError4 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion4 && _iterator4.return) {
            _iterator4.return();
          }
        } finally {
          if (_didIteratorError4) {
            throw _iteratorError4;
          }
        }
      }

      return redraw;
    }

    // Helper for constructor, merges props with default props and freezes them

  }, {
    key: '_normalizeProps',
    value: function _normalizeProps(props) {
      // If sublayer has static defaultProps member, getDefaultProps will return it
      var mergedDefaultProps = (0, _props2.getDefaultProps)(this);
      // Merge supplied props with pre-merged default props
      props = Object.assign({}, mergedDefaultProps, props);
      // Accept null as data - otherwise apps and layers need to add ugly checks
      // Use constant fallback so that data change is not triggered
      props.data = props.data || EMPTY_ARRAY;
      // Apply any overrides from the seer debug extension if it is active
      (0, _seerIntegration.applyPropOverrides)(props);
      // Props are immutable
      Object.freeze(props);
      return props;
    }

    // Called by layer manager to transfer state from an old layer

  }, {
    key: '_transferState',
    value: function _transferState(oldLayer) {
      var state = oldLayer.state,
          internalState = oldLayer.internalState,
          props = oldLayer.props;

      (0, _assert2.default)(state && internalState);

      // Move state
      state.layer = this;
      this.state = state;
      this.internalState = internalState;
      // Note: We keep the state ref on old layers to support async actions
      // oldLayer.state = null;

      // Keep a temporary ref to the old props, for prop comparison
      this.oldProps = props;

      // Update model layer reference
      var _iteratorNormalCompletion5 = true;
      var _didIteratorError5 = false;
      var _iteratorError5 = undefined;

      try {
        for (var _iterator5 = this.getModels()[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
          var model = _step5.value;

          model.userData.layer = this;
        }
      } catch (err) {
        _didIteratorError5 = true;
        _iteratorError5 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion5 && _iterator5.return) {
            _iterator5.return();
          }
        } finally {
          if (_didIteratorError5) {
            throw _iteratorError5;
          }
        }
      }

      this.diffProps();
    }

    // Operate on each changed triggers, will be called when an updateTrigger changes

  }, {
    key: '_activeUpdateTrigger',
    value: function _activeUpdateTrigger(propName) {
      this.invalidateAttribute(propName);
    }

    //  Helper to check that required props are supplied

  }, {
    key: '_checkRequiredProp',
    value: function _checkRequiredProp(propertyName, condition) {
      var value = this.props[propertyName];
      if (value === undefined) {
        throw new Error('Property ' + propertyName + ' undefined in layer ' + this);
      }
      if (condition && !condition(value)) {
        throw new Error('Bad property ' + propertyName + ' in layer ' + this);
      }
    }
  }, {
    key: '_updateBaseUniforms',
    value: function _updateBaseUniforms() {
      var uniforms = {
        // apply gamma to opacity to make it visually "linear"
        opacity: Math.pow(this.props.opacity, 1 / 2.2),
        ONE: 1.0
      };
      var _iteratorNormalCompletion6 = true;
      var _didIteratorError6 = false;
      var _iteratorError6 = undefined;

      try {
        for (var _iterator6 = this.getModels()[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
          var model = _step6.value;

          model.setUniforms(uniforms);
        }

        // TODO - set needsRedraw on the model(s)?
      } catch (err) {
        _didIteratorError6 = true;
        _iteratorError6 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion6 && _iterator6.return) {
            _iterator6.return();
          }
        } finally {
          if (_didIteratorError6) {
            throw _iteratorError6;
          }
        }
      }

      this.state.needsRedraw = true;
    }
  }, {
    key: '_updateModuleSettings',
    value: function _updateModuleSettings() {
      var settings = {
        pickingHighlightColor: this.props.highlightColor
      };
      var _iteratorNormalCompletion7 = true;
      var _didIteratorError7 = false;
      var _iteratorError7 = undefined;

      try {
        for (var _iterator7 = this.getModels()[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
          var model = _step7.value;

          model.updateModuleSettings(settings);
        }
      } catch (err) {
        _didIteratorError7 = true;
        _iteratorError7 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion7 && _iterator7.return) {
            _iterator7.return();
          }
        } finally {
          if (_didIteratorError7) {
            throw _iteratorError7;
          }
        }
      }
    }

    // DEPRECATED METHODS

    // Updates selected state members and marks the object for redraw

  }, {
    key: 'setUniforms',
    value: function setUniforms(uniformMap) {
      var _iteratorNormalCompletion8 = true;
      var _didIteratorError8 = false;
      var _iteratorError8 = undefined;

      try {
        for (var _iterator8 = this.getModels()[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
          var model = _step8.value;

          model.setUniforms(uniformMap);
        }

        // TODO - set needsRedraw on the model(s)?
      } catch (err) {
        _didIteratorError8 = true;
        _iteratorError8 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion8 && _iterator8.return) {
            _iterator8.return();
          }
        } finally {
          if (_didIteratorError8) {
            throw _iteratorError8;
          }
        }
      }

      this.state.needsRedraw = true;
      _log2.default.deprecated('layer.setUniforms', 'model.setUniforms');
    }
  }, {
    key: 'stats',
    get: function get() {
      return this.internalState.stats;
    }
  }]);

  return Layer;
}();

exports.default = Layer;


Layer.layerName = 'Layer';
Layer.propTypes = defaultProps;
Layer.defaultProps = defaultProps;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9jb3JlL2xpYi9sYXllci5qcyJdLCJuYW1lcyI6WyJMT0dfUFJJT1JJVFlfVVBEQVRFIiwiRU1QVFlfQVJSQVkiLCJFTVBUWV9QUk9QUyIsIk9iamVjdCIsImZyZWV6ZSIsIm5vb3AiLCJkZWZhdWx0UHJvcHMiLCJkYXRhQ29tcGFyYXRvciIsInVwZGF0ZVRyaWdnZXJzIiwibnVtSW5zdGFuY2VzIiwidW5kZWZpbmVkIiwidmlzaWJsZSIsInBpY2thYmxlIiwib3BhY2l0eSIsIm9uSG92ZXIiLCJvbkNsaWNrIiwiY29vcmRpbmF0ZVN5c3RlbSIsIkxOR0xBVCIsImNvb3JkaW5hdGVPcmlnaW4iLCJwYXJhbWV0ZXJzIiwidW5pZm9ybXMiLCJmcmFtZWJ1ZmZlciIsImFuaW1hdGlvbiIsImdldFBvbHlnb25PZmZzZXQiLCJsYXllckluZGV4IiwiaGlnaGxpZ2h0ZWRPYmplY3RJbmRleCIsImF1dG9IaWdobGlnaHQiLCJoaWdobGlnaHRDb2xvciIsImNvdW50ZXIiLCJMYXllciIsInByb3BzIiwiX25vcm1hbGl6ZVByb3BzIiwiaWQiLCJvbGRQcm9wcyIsImNvdW50IiwibGlmZWN5Y2xlIiwiTk9fU1RBVEUiLCJzdGF0ZSIsImNvbnRleHQiLCJwYXJlbnRMYXllciIsImludGVybmFsU3RhdGUiLCJzZWFsIiwiY2xhc3NOYW1lIiwiY29uc3RydWN0b3IiLCJsYXllck5hbWUiLCJuYW1lIiwic2hvdWxkVXBkYXRlU3RhdGUiLCJfZ2V0VXBkYXRlUGFyYW1zIiwiY2xlYXJSZWRyYXdGbGFncyIsIl9nZXROZWVkc1JlZHJhdyIsIkVycm9yIiwib2xkQ29udGV4dCIsImNoYW5nZUZsYWdzIiwicHJvcHNPckRhdGFDaGFuZ2VkIiwiYXR0cmlidXRlTWFuYWdlciIsImRhdGFDaGFuZ2VkIiwiaW52YWxpZGF0ZUFsbCIsIm9wdHMiLCJnZXRNb2RlbHMiLCJtb2RlbCIsImRyYXciLCJpbmZvIiwibW9kZSIsImluZGV4IiwiQXJyYXkiLCJpc0FycmF5IiwiZGF0YSIsIm9iamVjdCIsImRpZmZSZWFzb24iLCJsb2ciLCJpbnZhbGlkYXRlIiwiZ2V0TnVtSW5zdGFuY2VzIiwidXBkYXRlIiwiYnVmZmVycyIsImlnbm9yZVVua25vd25BdHRyaWJ1dGVzIiwiY2hhbmdlZEF0dHJpYnV0ZXMiLCJnZXRDaGFuZ2VkQXR0cmlidXRlcyIsImNsZWFyQ2hhbmdlZEZsYWdzIiwic2V0QXR0cmlidXRlcyIsInVwZGF0ZU9iamVjdCIsImFzc2lnbiIsIm5lZWRzUmVkcmF3IiwicmVkcmF3IiwibW9kZWxzIiwibG5nTGF0Iiwidmlld3BvcnQiLCJwcm9qZWN0IiwieHkiLCJ1bnByb2plY3QiLCJwcm9qZWN0RmxhdCIsInVucHJvamVjdEZsYXQiLCJzY3JlZW5QaXhlbHMiLCJkZXByZWNhdGVkIiwiZGV2aWNlUGl4ZWxSYXRpbyIsIndpbmRvdyIsImkiLCJjb2xvciIsIlVpbnQ4QXJyYXkiLCJpMSIsImkyIiwiaTMiLCJhdHRyaWJ1dGUiLCJ2YWx1ZSIsInNpemUiLCJwaWNraW5nQ29sb3IiLCJlbmNvZGVQaWNraW5nQ29sb3IiLCJuZXdQcm9wcyIsImFyZ3VtZW50cyIsImxlbmd0aCIsImdsIiwiYWRkSW5zdGFuY2VkIiwiaW5zdGFuY2VQaWNraW5nQ29sb3JzIiwidHlwZSIsIlVOU0lHTkVEX0JZVEUiLCJjYWxjdWxhdGVJbnN0YW5jZVBpY2tpbmdDb2xvcnMiLCJzdWJMYXllcnMiLCJzdGF0cyIsImluaXRpYWxpemVTdGF0ZSIsInNldENoYW5nZUZsYWdzIiwicHJvcHNDaGFuZ2VkIiwidmlld3BvcnRDaGFuZ2VkIiwiX3VwZGF0ZVN0YXRlIiwiaXNDb21wb3NpdGUiLCJfcmVuZGVyTGF5ZXJzIiwicHJvZ3JhbSIsImdlb21ldHJ5IiwiZ2V0QXR0cmlidXRlcyIsImNsZWFyQ2hhbmdlRmxhZ3MiLCJzdGF0ZU5lZWRzVXBkYXRlIiwibmVlZHNVcGRhdGUiLCJ1cGRhdGVQYXJhbXMiLCJ1cGRhdGVTdGF0ZSIsInVwZGF0ZUF0dHJpYnV0ZXMiLCJfdXBkYXRlQmFzZVVuaWZvcm1zIiwiX3VwZGF0ZU1vZHVsZVNldHRpbmdzIiwic2V0SW5zdGFuY2VDb3VudCIsImZpbmFsaXplU3RhdGUiLCJtb2R1bGVQYXJhbWV0ZXJzIiwidXBkYXRlTW9kdWxlU2V0dGluZ3MiLCJvZmZzZXRzIiwicG9seWdvbk9mZnNldCIsImdldFBpY2tpbmdJbmZvIiwiZmxhZ3MiLCJ1cGRhdGVUcmlnZ2Vyc0NoYW5nZWQiLCJrZXlzIiwiam9pbiIsInNvbWV0aGluZ0NoYW5nZWQiLCJrZXkiLCJfYWN0aXZlVXBkYXRlVHJpZ2dlciIsImF0dHJpYnV0ZU1hbmFnZXJOZWVkc1JlZHJhdyIsImdldE5lZWRzUmVkcmF3IiwibW9kZWxOZWVkc1JlZHJhdyIsIm1lcmdlZERlZmF1bHRQcm9wcyIsIm9sZExheWVyIiwibGF5ZXIiLCJ1c2VyRGF0YSIsImRpZmZQcm9wcyIsInByb3BOYW1lIiwiaW52YWxpZGF0ZUF0dHJpYnV0ZSIsInByb3BlcnR5TmFtZSIsImNvbmRpdGlvbiIsIk1hdGgiLCJwb3ciLCJPTkUiLCJzZXRVbmlmb3JtcyIsInNldHRpbmdzIiwicGlja2luZ0hpZ2hsaWdodENvbG9yIiwidW5pZm9ybU1hcCIsInByb3BUeXBlcyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7cWpCQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFDQTs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7O0FBQ0E7O0FBQ0E7Ozs7QUFDQTs7QUFDQTs7QUFDQTs7Ozs7Ozs7QUFFQSxJQUFNQSxzQkFBc0IsQ0FBNUI7O0FBRUEsSUFBTUMsY0FBYyxFQUFwQjtBQUNBLElBQU1DLGNBQWMsRUFBcEI7QUFDQUMsT0FBT0MsTUFBUCxDQUFjRixXQUFkO0FBQ0EsSUFBTUcsT0FBTyxTQUFQQSxJQUFPLEdBQU0sQ0FBRSxDQUFyQjs7QUFFQSxJQUFNQyxlQUFlO0FBQ25CO0FBQ0FDLGtCQUFnQixJQUZH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O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFNdEIsV0FBS2xJLEtBQUwsQ0FBVzRDLFdBQVgsR0FBeUIsSUFBekI7QUFDQSxvQkFBSVcsVUFBSixDQUFlLG1CQUFmLEVBQW9DLG1CQUFwQztBQUNEOzs7d0JBOW5CVztBQUNWLGFBQU8sS0FBS3BELGFBQUwsQ0FBbUI0RSxLQUExQjtBQUNEOzs7Ozs7a0JBNUJrQnZGLEs7OztBQTJwQnJCQSxNQUFNZSxTQUFOLEdBQWtCLE9BQWxCO0FBQ0FmLE1BQU0ySSxTQUFOLEdBQWtCbEssWUFBbEI7QUFDQXVCLE1BQU12QixZQUFOLEdBQXFCQSxZQUFyQiIsImZpbGUiOiJsYXllci5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgMjAxNSAtIDIwMTcgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuLy8gVEhFIFNPRlRXQVJFLlxuXG4vKiBnbG9iYWwgd2luZG93ICovXG5pbXBvcnQge0NPT1JESU5BVEVfU1lTVEVNLCBMSUZFQ1lDTEV9IGZyb20gJy4vY29uc3RhbnRzJztcbmltcG9ydCBBdHRyaWJ1dGVNYW5hZ2VyIGZyb20gJy4vYXR0cmlidXRlLW1hbmFnZXInO1xuaW1wb3J0IFN0YXRzIGZyb20gJy4vc3RhdHMnO1xuaW1wb3J0IHtnZXREZWZhdWx0UHJvcHMsIGRpZmZQcm9wc30gZnJvbSAnLi9wcm9wcyc7XG5pbXBvcnQge2NvdW50fSBmcm9tICcuLi91dGlscy9jb3VudCc7XG5pbXBvcnQgbG9nIGZyb20gJy4uL3V0aWxzL2xvZyc7XG5pbXBvcnQge2FwcGx5UHJvcE92ZXJyaWRlcywgcmVtb3ZlTGF5ZXJJblNlZXJ9IGZyb20gJy4vc2Vlci1pbnRlZ3JhdGlvbic7XG5pbXBvcnQge0dMLCB3aXRoUGFyYW1ldGVyc30gZnJvbSAnbHVtYS5nbCc7XG5pbXBvcnQgYXNzZXJ0IGZyb20gJ2Fzc2VydCc7XG5cbmNvbnN0IExPR19QUklPUklUWV9VUERBVEUgPSAxO1xuXG5jb25zdCBFTVBUWV9BUlJBWSA9IFtdO1xuY29uc3QgRU1QVFlfUFJPUFMgPSB7fTtcbk9iamVjdC5mcmVlemUoRU1QVFlfUFJPUFMpO1xuY29uc3Qgbm9vcCA9ICgpID0+IHt9O1xuXG5jb25zdCBkZWZhdWx0UHJvcHMgPSB7XG4gIC8vIGRhdGE6IFNwZWNpYWwgaGFuZGxpbmcgZm9yIG51bGwsIHNlZSBiZWxvd1xuICBkYXRhQ29tcGFyYXRvcjogbnVsbCxcbiAgdXBkYXRlVHJpZ2dlcnM6IHt9LCAvLyBVcGRhdGUgdHJpZ2dlcnM6IGEgY29yZSBjaGFuZ2UgZGV0ZWN0aW9uIG1lY2hhbmlzbSBpbiBkZWNrLmdsXG4gIG51bUluc3RhbmNlczogdW5kZWZpbmVkLFxuXG4gIHZpc2libGU6IHRydWUsXG4gIHBpY2thYmxlOiBmYWxzZSxcbiAgb3BhY2l0eTogMC44LFxuXG4gIG9uSG92ZXI6IG5vb3AsXG4gIG9uQ2xpY2s6IG5vb3AsXG5cbiAgY29vcmRpbmF0ZVN5c3RlbTogQ09PUkRJTkFURV9TWVNURU0uTE5HTEFULFxuICBjb29yZGluYXRlT3JpZ2luOiBbMCwgMCwgMF0sXG5cbiAgcGFyYW1ldGVyczoge30sXG4gIHVuaWZvcm1zOiB7fSxcbiAgZnJhbWVidWZmZXI6IG51bGwsXG5cbiAgYW5pbWF0aW9uOiBudWxsLCAvLyBQYXNzZWQgcHJvcCBhbmltYXRpb24gZnVuY3Rpb25zIHRvIGV2YWx1YXRlIHByb3BzXG5cbiAgLy8gT2Zmc2V0IGRlcHRoIGJhc2VkIG9uIGxheWVyIGluZGV4IHRvIGF2b2lkIHotZmlnaHRpbmcuXG4gIC8vIE5lZ2F0aXZlIHZhbHVlcyBwdWxsIGxheWVyIHRvd2FyZHMgdGhlIGNhbWVyYVxuICAvLyBodHRwczovL3d3dy5vcGVuZ2wub3JnL2FyY2hpdmVzL3Jlc291cmNlcy9mYXEvdGVjaG5pY2FsL3BvbHlnb25vZmZzZXQuaHRtXG4gIGdldFBvbHlnb25PZmZzZXQ6ICh7bGF5ZXJJbmRleH0pID0+IFswLCAtbGF5ZXJJbmRleCAqIDEwMF0sXG5cbiAgLy8gU2VsZWN0aW9uL0hpZ2hsaWdodGluZ1xuICBoaWdobGlnaHRlZE9iamVjdEluZGV4OiBudWxsLFxuICBhdXRvSGlnaGxpZ2h0OiBmYWxzZSxcbiAgaGlnaGxpZ2h0Q29sb3I6IFswLCAwLCAxMjgsIDEyOF1cbn07XG5cbmxldCBjb3VudGVyID0gMDtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTGF5ZXIge1xuICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgIC8vIENhbGwgYSBoZWxwZXIgZnVuY3Rpb24gdG8gbWVyZ2UgdGhlIGluY29taW5nIHByb3BzIHdpdGggZGVmYXVsdHMgYW5kIGZyZWV6ZSB0aGVtLlxuICAgIHRoaXMucHJvcHMgPSB0aGlzLl9ub3JtYWxpemVQcm9wcyhwcm9wcyk7XG5cbiAgICAvLyBEZWZpbmUgYWxsIG1lbWJlcnMgYmVmb3JlIGxheWVyIGlzIHNlYWxlZFxuICAgIHRoaXMuaWQgPSB0aGlzLnByb3BzLmlkOyAvLyBUaGUgbGF5ZXIncyBpZCwgdXNlZCBmb3IgbWF0Y2hpbmcgd2l0aCBsYXllcnMgZnJvbSBsYXN0IHJlbmRlciBjeWNsZVxuICAgIHRoaXMub2xkUHJvcHMgPSBFTVBUWV9QUk9QUzsgLy8gUHJvcHMgZnJvbSBsYXN0IHJlbmRlciB1c2VkIGZvciBjaGFuZ2UgZGV0ZWN0aW9uXG4gICAgdGhpcy5jb3VudCA9IGNvdW50ZXIrKzsgLy8gS2VlcCB0cmFjayBvZiBob3cgbWFueSBsYXllciBpbnN0YW5jZXMgeW91IGFyZSBnZW5lcmF0aW5nXG4gICAgdGhpcy5saWZlY3ljbGUgPSBMSUZFQ1lDTEUuTk9fU1RBVEU7IC8vIEhlbHBzIHRyYWNrIGFuZCBkZWJ1ZyB0aGUgbGlmZSBjeWNsZSBvZiB0aGUgbGF5ZXJzXG4gICAgdGhpcy5zdGF0ZSA9IG51bGw7IC8vIFdpbGwgYmUgc2V0IHRvIHRoZSBzaGFyZWQgbGF5ZXIgc3RhdGUgb2JqZWN0IGR1cmluZyBsYXllciBtYXRjaGluZ1xuICAgIHRoaXMuY29udGV4dCA9IG51bGw7IC8vIFdpbGwgcmVmZXJlbmNlIGxheWVyIG1hbmFnZXIncyBjb250ZXh0LCBjb250YWlucyBzdGF0ZSBzaGFyZWQgYnkgbGF5ZXJzXG4gICAgdGhpcy5wYXJlbnRMYXllciA9IG51bGw7IC8vIHJlZmVyZW5jZSB0byB0aGUgY29tcG9zaXRlIGxheWVyIHBhcmVudCB0aGF0IHJlbmRlcmVkIHRoaXMgbGF5ZXJcblxuICAgIC8vIENvbXBvc2l0ZUxheWVyIG1lbWJlcnMsIG5lZWQgdG8gYmUgZGVmaW5lZCBoZXJlIGJlY2F1c2Ugb2YgdGhlIGBPYmplY3Quc2VhbGBcbiAgICB0aGlzLmludGVybmFsU3RhdGUgPSBudWxsO1xuXG4gICAgLy8gU2VhbCB0aGUgbGF5ZXJcbiAgICBPYmplY3Quc2VhbCh0aGlzKTtcbiAgfVxuXG4gIHRvU3RyaW5nKCkge1xuICAgIGNvbnN0IGNsYXNzTmFtZSA9IHRoaXMuY29uc3RydWN0b3IubGF5ZXJOYW1lIHx8IHRoaXMuY29uc3RydWN0b3IubmFtZTtcbiAgICByZXR1cm4gYCR7Y2xhc3NOYW1lfSh7aWQ6ICcke3RoaXMucHJvcHMuaWR9J30pYDtcbiAgfVxuXG4gIGdldCBzdGF0cygpIHtcbiAgICByZXR1cm4gdGhpcy5pbnRlcm5hbFN0YXRlLnN0YXRzO1xuICB9XG5cbiAgbmVlZHNVcGRhdGUoKSB7XG4gICAgLy8gQ2FsbCBzdWJjbGFzcyBsaWZlY3ljbGUgbWV0aG9kXG4gICAgcmV0dXJuIHRoaXMuc2hvdWxkVXBkYXRlU3RhdGUodGhpcy5fZ2V0VXBkYXRlUGFyYW1zKCkpO1xuICAgIC8vIEVuZCBsaWZlY3ljbGUgbWV0aG9kXG4gIH1cblxuICAvLyBDaGVja3Mgc3RhdGUgb2YgYXR0cmlidXRlcyBhbmQgbW9kZWxcbiAgZ2V0TmVlZHNSZWRyYXcoe2NsZWFyUmVkcmF3RmxhZ3MgPSBmYWxzZX0gPSB7fSkge1xuICAgIHJldHVybiB0aGlzLl9nZXROZWVkc1JlZHJhdyhjbGVhclJlZHJhd0ZsYWdzKTtcbiAgfVxuXG4gIC8vIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gIC8vIExJRkVDWUNMRSBNRVRIT0RTLCBvdmVycmlkZGVuIGJ5IHRoZSBsYXllciBzdWJjbGFzc2VzXG5cbiAgLy8gQ2FsbGVkIG9uY2UgdG8gc2V0IHVwIHRoZSBpbml0aWFsIHN0YXRlXG4gIC8vIEFwcCBjYW4gY3JlYXRlIFdlYkdMIHJlc291cmNlc1xuICBpbml0aWFsaXplU3RhdGUoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBMYXllciAke3RoaXN9IGhhcyBub3QgZGVmaW5lZCBpbml0aWFsaXplU3RhdGVgKTtcbiAgfVxuXG4gIC8vIExldCdzIGxheWVyIGNvbnRyb2wgaWYgdXBkYXRlU3RhdGUgc2hvdWxkIGJlIGNhbGxlZFxuICBzaG91bGRVcGRhdGVTdGF0ZSh7b2xkUHJvcHMsIHByb3BzLCBvbGRDb250ZXh0LCBjb250ZXh0LCBjaGFuZ2VGbGFnc30pIHtcbiAgICByZXR1cm4gY2hhbmdlRmxhZ3MucHJvcHNPckRhdGFDaGFuZ2VkO1xuICB9XG5cbiAgLy8gRGVmYXVsdCBpbXBsZW1lbnRhdGlvbiwgYWxsIGF0dHJpYnV0ZXMgd2lsbCBiZSBpbnZhbGlkYXRlZCBhbmQgdXBkYXRlZFxuICAvLyB3aGVuIGRhdGEgY2hhbmdlc1xuICB1cGRhdGVTdGF0ZSh7b2xkUHJvcHMsIHByb3BzLCBvbGRDb250ZXh0LCBjb250ZXh0LCBjaGFuZ2VGbGFnc30pIHtcbiAgICBjb25zdCB7YXR0cmlidXRlTWFuYWdlcn0gPSB0aGlzLnN0YXRlO1xuICAgIGlmIChjaGFuZ2VGbGFncy5kYXRhQ2hhbmdlZCAmJiBhdHRyaWJ1dGVNYW5hZ2VyKSB7XG4gICAgICBhdHRyaWJ1dGVNYW5hZ2VyLmludmFsaWRhdGVBbGwoKTtcbiAgICB9XG4gIH1cblxuICAvLyBDYWxsZWQgb25jZSB3aGVuIGxheWVyIGlzIG5vIGxvbmdlciBtYXRjaGVkIGFuZCBzdGF0ZSB3aWxsIGJlIGRpc2NhcmRlZFxuICAvLyBBcHAgY2FuIGRlc3Ryb3kgV2ViR0wgcmVzb3VyY2VzIGhlcmVcbiAgZmluYWxpemVTdGF0ZSgpIHt9XG5cbiAgLy8gSWYgc3RhdGUgaGFzIGEgbW9kZWwsIGRyYXcgaXQgd2l0aCBzdXBwbGllZCB1bmlmb3Jtc1xuICBkcmF3KG9wdHMpIHtcbiAgICBmb3IgKGNvbnN0IG1vZGVsIG9mIHRoaXMuZ2V0TW9kZWxzKCkpIHtcbiAgICAgIG1vZGVsLmRyYXcob3B0cyk7XG4gICAgfVxuICB9XG5cbiAgLy8gY2FsbGVkIHRvIHBvcHVsYXRlIHRoZSBpbmZvIG9iamVjdCB0aGF0IGlzIHBhc3NlZCB0byB0aGUgZXZlbnQgaGFuZGxlclxuICAvLyBAcmV0dXJuIG51bGwgdG8gY2FuY2VsIGV2ZW50XG4gIGdldFBpY2tpbmdJbmZvKHtpbmZvLCBtb2RlfSkge1xuICAgIGNvbnN0IHtpbmRleH0gPSBpbmZvO1xuXG4gICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgIC8vIElmIHByb3BzLmRhdGEgaXMgYW4gaW5kZXhhYmxlIGFycmF5LCBnZXQgdGhlIG9iamVjdFxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodGhpcy5wcm9wcy5kYXRhKSkge1xuICAgICAgICBpbmZvLm9iamVjdCA9IHRoaXMucHJvcHMuZGF0YVtpbmRleF07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGluZm87XG4gIH1cblxuICAvLyBFTkQgTElGRUNZQ0xFIE1FVEhPRFNcbiAgLy8gLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuICAvLyBSZXR1cm5zIHRydWUgaWYgdGhlIGxheWVyIGlzIHBpY2thYmxlIGFuZCB2aXNpYmxlLlxuICBpc1BpY2thYmxlKCkge1xuICAgIHJldHVybiB0aGlzLnByb3BzLnBpY2thYmxlICYmIHRoaXMucHJvcHMudmlzaWJsZTtcbiAgfVxuXG4gIC8vIERlZmF1bHQgaW1wbGVtZW50YXRpb24gb2YgYXR0cmlidXRlIGludmFsaWRhdGlvbiwgY2FuIGJlIHJlZGVmaW5lZFxuICBpbnZhbGlkYXRlQXR0cmlidXRlKG5hbWUgPSAnYWxsJywgZGlmZlJlYXNvbiA9ICcnKSB7XG4gICAgY29uc3Qge2F0dHJpYnV0ZU1hbmFnZXJ9ID0gdGhpcy5zdGF0ZTtcbiAgICBpZiAoIWF0dHJpYnV0ZU1hbmFnZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAobmFtZSA9PT0gJ2FsbCcpIHtcbiAgICAgIGxvZy5sb2coTE9HX1BSSU9SSVRZX1VQREFURSwgYHVwZGF0ZVRyaWdnZXJzIGludmFsaWRhdGluZyBhbGwgYXR0cmlidXRlczogJHtkaWZmUmVhc29ufWApO1xuICAgICAgYXR0cmlidXRlTWFuYWdlci5pbnZhbGlkYXRlQWxsKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvZy5sb2coTE9HX1BSSU9SSVRZX1VQREFURSwgYHVwZGF0ZVRyaWdnZXJzIGludmFsaWRhdGluZyBhdHRyaWJ1dGUgJHtuYW1lfTogJHtkaWZmUmVhc29ufWApO1xuICAgICAgYXR0cmlidXRlTWFuYWdlci5pbnZhbGlkYXRlKG5hbWUpO1xuICAgIH1cbiAgfVxuXG4gIC8vIENhbGxzIGF0dHJpYnV0ZSBtYW5hZ2VyIHRvIHVwZGF0ZSBhbnkgV2ViR0wgYXR0cmlidXRlcywgY2FuIGJlIHJlZGVmaW5lZFxuICB1cGRhdGVBdHRyaWJ1dGVzKHByb3BzKSB7XG4gICAgY29uc3Qge2F0dHJpYnV0ZU1hbmFnZXJ9ID0gdGhpcy5zdGF0ZTtcbiAgICBpZiAoIWF0dHJpYnV0ZU1hbmFnZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBGaWd1cmUgb3V0IGRhdGEgbGVuZ3RoXG4gICAgY29uc3QgbnVtSW5zdGFuY2VzID0gdGhpcy5nZXROdW1JbnN0YW5jZXMocHJvcHMpO1xuXG4gICAgYXR0cmlidXRlTWFuYWdlci51cGRhdGUoe1xuICAgICAgZGF0YTogcHJvcHMuZGF0YSxcbiAgICAgIG51bUluc3RhbmNlcyxcbiAgICAgIHByb3BzLFxuICAgICAgYnVmZmVyczogcHJvcHMsXG4gICAgICBjb250ZXh0OiB0aGlzLFxuICAgICAgLy8gRG9uJ3Qgd29ycnkgYWJvdXQgbm9uLWF0dHJpYnV0ZSBwcm9wc1xuICAgICAgaWdub3JlVW5rbm93bkF0dHJpYnV0ZXM6IHRydWVcbiAgICB9KTtcblxuICAgIC8vIFRPRE8gLSBVc2UgZ2V0TW9kZWxzP1xuICAgIGNvbnN0IHttb2RlbH0gPSB0aGlzLnN0YXRlO1xuICAgIGlmIChtb2RlbCkge1xuICAgICAgY29uc3QgY2hhbmdlZEF0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVNYW5hZ2VyLmdldENoYW5nZWRBdHRyaWJ1dGVzKHtjbGVhckNoYW5nZWRGbGFnczogdHJ1ZX0pO1xuICAgICAgbW9kZWwuc2V0QXR0cmlidXRlcyhjaGFuZ2VkQXR0cmlidXRlcyk7XG4gICAgfVxuICB9XG5cbiAgLy8gUHVibGljIEFQSVxuXG4gIC8vIFVwZGF0ZXMgc2VsZWN0ZWQgc3RhdGUgbWVtYmVycyBhbmQgbWFya3MgdGhlIG9iamVjdCBmb3IgcmVkcmF3XG4gIHNldFN0YXRlKHVwZGF0ZU9iamVjdCkge1xuICAgIE9iamVjdC5hc3NpZ24odGhpcy5zdGF0ZSwgdXBkYXRlT2JqZWN0KTtcbiAgICB0aGlzLnN0YXRlLm5lZWRzUmVkcmF3ID0gdHJ1ZTtcbiAgfVxuXG4gIC8vIFNldHMgdGhlIHJlZHJhdyBmbGFnIGZvciB0aGlzIGxheWVyLCB3aWxsIHRyaWdnZXIgYSByZWRyYXcgbmV4dCBhbmltYXRpb24gZnJhbWVcbiAgc2V0TmVlZHNSZWRyYXcocmVkcmF3ID0gdHJ1ZSkge1xuICAgIGlmICh0aGlzLnN0YXRlKSB7XG4gICAgICB0aGlzLnN0YXRlLm5lZWRzUmVkcmF3ID0gcmVkcmF3O1xuICAgIH1cbiAgfVxuXG4gIC8vIFJldHVybiBhbiBhcnJheSBvZiBtb2RlbHMgdXNlZCBieSB0aGlzIGxheWVyLCBjYW4gYmUgb3ZlcnJpZGVuIGJ5IGxheWVyIHN1YmNsYXNzXG4gIGdldE1vZGVscygpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZS5tb2RlbHMgfHwgKHRoaXMuc3RhdGUubW9kZWwgPyBbdGhpcy5zdGF0ZS5tb2RlbF0gOiBbXSk7XG4gIH1cblxuICAvLyBQUk9KRUNUSU9OIE1FVEhPRFNcblxuICAvKipcbiAgICogUHJvamVjdHMgYSBwb2ludCB3aXRoIGN1cnJlbnQgbWFwIHN0YXRlIChsYXQsIGxvbiwgem9vbSwgcGl0Y2gsIGJlYXJpbmcpXG4gICAqXG4gICAqIE5vdGU6IFBvc2l0aW9uIGNvbnZlcnNpb24gaXMgZG9uZSBpbiBzaGFkZXIsIHNvIGluIG1hbnkgY2FzZXMgdGhlcmUgaXMgbm8gbmVlZFxuICAgKiBmb3IgdGhpcyBmdW5jdGlvblxuICAgKiBAcGFyYW0ge0FycmF5fFR5cGVkQXJyYXl9IGxuZ0xhdCAtIGxvbmcgYW5kIGxhdCB2YWx1ZXNcbiAgICogQHJldHVybiB7QXJyYXl8VHlwZWRBcnJheX0gLSB4LCB5IGNvb3JkaW5hdGVzXG4gICAqL1xuICBwcm9qZWN0KGxuZ0xhdCkge1xuICAgIGNvbnN0IHt2aWV3cG9ydH0gPSB0aGlzLmNvbnRleHQ7XG4gICAgYXNzZXJ0KEFycmF5LmlzQXJyYXkobG5nTGF0KSwgJ0xheWVyLnByb2plY3QgbmVlZHMgW2xuZyxsYXRdJyk7XG4gICAgcmV0dXJuIHZpZXdwb3J0LnByb2plY3QobG5nTGF0KTtcbiAgfVxuXG4gIHVucHJvamVjdCh4eSkge1xuICAgIGNvbnN0IHt2aWV3cG9ydH0gPSB0aGlzLmNvbnRleHQ7XG4gICAgYXNzZXJ0KEFycmF5LmlzQXJyYXkoeHkpLCAnTGF5ZXIudW5wcm9qZWN0IG5lZWRzIFt4LHldJyk7XG4gICAgcmV0dXJuIHZpZXdwb3J0LnVucHJvamVjdCh4eSk7XG4gIH1cblxuICBwcm9qZWN0RmxhdChsbmdMYXQpIHtcbiAgICBjb25zdCB7dmlld3BvcnR9ID0gdGhpcy5jb250ZXh0O1xuICAgIGFzc2VydChBcnJheS5pc0FycmF5KGxuZ0xhdCksICdMYXllci5wcm9qZWN0IG5lZWRzIFtsbmcsbGF0XScpO1xuICAgIHJldHVybiB2aWV3cG9ydC5wcm9qZWN0RmxhdChsbmdMYXQpO1xuICB9XG5cbiAgdW5wcm9qZWN0RmxhdCh4eSkge1xuICAgIGNvbnN0IHt2aWV3cG9ydH0gPSB0aGlzLmNvbnRleHQ7XG4gICAgYXNzZXJ0KEFycmF5LmlzQXJyYXkoeHkpLCAnTGF5ZXIudW5wcm9qZWN0IG5lZWRzIFt4LHldJyk7XG4gICAgcmV0dXJuIHZpZXdwb3J0LnVucHJvamVjdEZsYXQoeHkpO1xuICB9XG5cbiAgLy8gVE9ETyAtIG5lZWRzIHRvIHJlZmVyIHRvIGNvbnRleHRcbiAgc2NyZWVuVG9EZXZpY2VQaXhlbHMoc2NyZWVuUGl4ZWxzKSB7XG4gICAgbG9nLmRlcHJlY2F0ZWQoJ3NjcmVlblRvRGV2aWNlUGl4ZWxzJywgJ0RlY2tHTCBwcm9wIHVzZURldmljZVBpeGVscyBmb3IgY29udmVyc2lvbicpO1xuICAgIGNvbnN0IGRldmljZVBpeGVsUmF0aW8gPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIDogMTtcbiAgICByZXR1cm4gc2NyZWVuUGl4ZWxzICogZGV2aWNlUGl4ZWxSYXRpbztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBwaWNraW5nIGNvbG9yIHRoYXQgZG9lc24ndCBtYXRjaCBhbnkgc3ViZmVhdHVyZVxuICAgKiBVc2UgaWYgc29tZSBncmFwaGljcyBkbyBub3QgYmVsb25nIHRvIGFueSBwaWNrYWJsZSBzdWJmZWF0dXJlXG4gICAqIEByZXR1cm4ge0FycmF5fSAtIGEgYmxhY2sgY29sb3JcbiAgICovXG4gIG51bGxQaWNraW5nQ29sb3IoKSB7XG4gICAgcmV0dXJuIFswLCAwLCAwXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBwaWNraW5nIGNvbG9yIHRoYXQgZG9lc24ndCBtYXRjaCBhbnkgc3ViZmVhdHVyZVxuICAgKiBVc2UgaWYgc29tZSBncmFwaGljcyBkbyBub3QgYmVsb25nIHRvIGFueSBwaWNrYWJsZSBzdWJmZWF0dXJlXG4gICAqIEBwYXJhbSB7aW50fSBpIC0gaW5kZXggdG8gYmUgZGVjb2RlZFxuICAgKiBAcmV0dXJuIHtBcnJheX0gLSB0aGUgZGVjb2RlZCBjb2xvclxuICAgKi9cbiAgZW5jb2RlUGlja2luZ0NvbG9yKGkpIHtcbiAgICBhc3NlcnQoKCgoaSArIDEpID4+IDI0KSAmIDI1NSkgPT09IDAsICdpbmRleCBvdXQgb2YgcGlja2luZyBjb2xvciByYW5nZScpO1xuICAgIHJldHVybiBbKGkgKyAxKSAmIDI1NSwgKChpICsgMSkgPj4gOCkgJiAyNTUsICgoKGkgKyAxKSA+PiA4KSA+PiA4KSAmIDI1NV07XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgcGlja2luZyBjb2xvciB0aGF0IGRvZXNuJ3QgbWF0Y2ggYW55IHN1YmZlYXR1cmVcbiAgICogVXNlIGlmIHNvbWUgZ3JhcGhpY3MgZG8gbm90IGJlbG9uZyB0byBhbnkgcGlja2FibGUgc3ViZmVhdHVyZVxuICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGNvbG9yIC0gY29sb3IgYXJyYXkgdG8gYmUgZGVjb2RlZFxuICAgKiBAcmV0dXJuIHtBcnJheX0gLSB0aGUgZGVjb2RlZCBwaWNraW5nIGNvbG9yXG4gICAqL1xuICBkZWNvZGVQaWNraW5nQ29sb3IoY29sb3IpIHtcbiAgICBhc3NlcnQoY29sb3IgaW5zdGFuY2VvZiBVaW50OEFycmF5KTtcbiAgICBjb25zdCBbaTEsIGkyLCBpM10gPSBjb2xvcjtcbiAgICAvLyAxIHdhcyBhZGRlZCB0byBzZXBlcmF0ZSBmcm9tIG5vIHNlbGVjdGlvblxuICAgIGNvbnN0IGluZGV4ID0gaTEgKyBpMiAqIDI1NiArIGkzICogNjU1MzYgLSAxO1xuICAgIHJldHVybiBpbmRleDtcbiAgfVxuXG4gIGNhbGN1bGF0ZUluc3RhbmNlUGlja2luZ0NvbG9ycyhhdHRyaWJ1dGUsIHtudW1JbnN0YW5jZXN9KSB7XG4gICAgY29uc3Qge3ZhbHVlLCBzaXplfSA9IGF0dHJpYnV0ZTtcbiAgICAvLyBhZGQgMSB0byBpbmRleCB0byBzZXBlcmF0ZSBmcm9tIG5vIHNlbGVjdGlvblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtSW5zdGFuY2VzOyBpKyspIHtcbiAgICAgIGNvbnN0IHBpY2tpbmdDb2xvciA9IHRoaXMuZW5jb2RlUGlja2luZ0NvbG9yKGkpO1xuICAgICAgdmFsdWVbaSAqIHNpemUgKyAwXSA9IHBpY2tpbmdDb2xvclswXTtcbiAgICAgIHZhbHVlW2kgKiBzaXplICsgMV0gPSBwaWNraW5nQ29sb3JbMV07XG4gICAgICB2YWx1ZVtpICogc2l6ZSArIDJdID0gcGlja2luZ0NvbG9yWzJdO1xuICAgIH1cbiAgfVxuXG4gIC8vIERBVEEgQUNDRVNTIEFQSVxuICAvLyBEYXRhIGNhbiB1c2UgaXRlcmF0b3JzIGFuZCBtYXkgbm90IGJlIHJhbmRvbSBhY2Nlc3NcblxuICAvLyBVc2UgaXRlcmF0aW9uICh0aGUgb25seSByZXF1aXJlZCBjYXBhYmlsaXR5IG9uIGRhdGEpIHRvIGdldCBmaXJzdCBlbGVtZW50XG4gIGdldEZpcnN0T2JqZWN0KCkge1xuICAgIGNvbnN0IHtkYXRhfSA9IHRoaXMucHJvcHM7XG4gICAgZm9yIChjb25zdCBvYmplY3Qgb2YgZGF0YSkge1xuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBJTlRFUk5BTCBNRVRIT0RTXG5cbiAgLy8gRGVkdWNlcyBudW1lciBvZiBpbnN0YW5jZXMuIEludGVudGlvbiBpcyB0byBzdXBwb3J0OlxuICAvLyAtIEV4cGxpY2l0IHNldHRpbmcgb2YgbnVtSW5zdGFuY2VzXG4gIC8vIC0gQXV0by1kZWR1Y3Rpb24gZm9yIEVTNiBjb250YWluZXJzIHRoYXQgZGVmaW5lIGEgc2l6ZSBtZW1iZXJcbiAgLy8gLSBBdXRvLWRlZHVjdGlvbiBmb3IgQ2xhc3NpYyBBcnJheXMgdmlhIHRoZSBidWlsdC1pbiBsZW5ndGggYXR0cmlidXRlXG4gIC8vIC0gQXV0by1kZWR1Y3Rpb24gdmlhIGFycmF5c1xuICBnZXROdW1JbnN0YW5jZXMocHJvcHMpIHtcbiAgICBwcm9wcyA9IHByb3BzIHx8IHRoaXMucHJvcHM7XG5cbiAgICAvLyBGaXJzdCBjaGVjayBpZiB0aGUgbGF5ZXIgaGFzIHNldCBpdHMgb3duIHZhbHVlXG4gICAgaWYgKHRoaXMuc3RhdGUgJiYgdGhpcy5zdGF0ZS5udW1JbnN0YW5jZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHRoaXMuc3RhdGUubnVtSW5zdGFuY2VzO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGlmIGFwcCBoYXMgcHJvdmlkZWQgYW4gZXhwbGljaXQgdmFsdWVcbiAgICBpZiAocHJvcHMubnVtSW5zdGFuY2VzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBwcm9wcy5udW1JbnN0YW5jZXM7XG4gICAgfVxuXG4gICAgLy8gVXNlIGNvbnRhaW5lciBsaWJyYXJ5IHRvIGdldCBhIGNvdW50IGZvciBhbnkgRVM2IGNvbnRhaW5lciBvciBvYmplY3RcbiAgICBjb25zdCB7ZGF0YX0gPSBwcm9wcztcbiAgICByZXR1cm4gY291bnQoZGF0YSk7XG4gIH1cblxuICAvLyBjbG9uZSB0aGlzIGxheWVyIHdpdGggbW9kaWZpZWQgcHJvcHNcbiAgY2xvbmUobmV3UHJvcHMpIHtcbiAgICByZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5wcm9wcywgbmV3UHJvcHMpKTtcbiAgfVxuXG4gIC8vIExBWUVSIE1BTkFHRVIgQVBJXG4gIC8vIFNob3VsZCBvbmx5IGJlIGNhbGxlZCBieSB0aGUgZGVjay5nbCBMYXllck1hbmFnZXIgY2xhc3NcblxuICAvLyBDYWxsZWQgYnkgbGF5ZXIgbWFuYWdlciB3aGVuIGEgbmV3IGxheWVyIGlzIGZvdW5kXG4gIC8qIGVzbGludC1kaXNhYmxlIG1heC1zdGF0ZW1lbnRzICovXG4gIF9pbml0aWFsaXplKCkge1xuICAgIGFzc2VydChhcmd1bWVudHMubGVuZ3RoID09PSAwKTtcbiAgICBhc3NlcnQodGhpcy5jb250ZXh0LmdsKTtcbiAgICBhc3NlcnQoIXRoaXMuc3RhdGUpO1xuXG4gICAgY29uc3QgYXR0cmlidXRlTWFuYWdlciA9IG5ldyBBdHRyaWJ1dGVNYW5hZ2VyKHtpZDogdGhpcy5wcm9wcy5pZH0pO1xuICAgIC8vIEFsbCBpbnN0YW5jZWQgbGF5ZXJzIGdldCBpbnN0YW5jZVBpY2tpbmdDb2xvcnMgYXR0cmlidXRlIGJ5IGRlZmF1bHRcbiAgICAvLyBUaGVpciBzaGFkZXJzIGNhbiB1c2UgaXQgdG8gcmVuZGVyIGEgcGlja2luZyBzY2VuZVxuICAgIC8vIFRPRE8gLSB0aGlzIHNsaWdodGx5IHNsb3dzIGRvd24gbm9uIGluc3RhbmNlZCBsYXllcnNcbiAgICBhdHRyaWJ1dGVNYW5hZ2VyLmFkZEluc3RhbmNlZCh7XG4gICAgICBpbnN0YW5jZVBpY2tpbmdDb2xvcnM6IHtcbiAgICAgICAgdHlwZTogR0wuVU5TSUdORURfQllURSxcbiAgICAgICAgc2l6ZTogMyxcbiAgICAgICAgdXBkYXRlOiB0aGlzLmNhbGN1bGF0ZUluc3RhbmNlUGlja2luZ0NvbG9yc1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdGhpcy5pbnRlcm5hbFN0YXRlID0ge1xuICAgICAgc3ViTGF5ZXJzOiBudWxsLCAvLyByZWZlcmVuY2UgdG8gc3VibGF5ZXJzIHJlbmRlcmVkIGluIGEgcHJldmlvdXMgY3ljbGVcbiAgICAgIHN0YXRzOiBuZXcgU3RhdHMoe2lkOiAnZHJhdyd9KVxuICAgICAgLy8gYW5pbWF0ZWRQcm9wczogbnVsbCwgLy8gQ29tcHV0aW5nIGFuaW1hdGVkIHByb3BzIHJlcXVpcmVzIGxheWVyIG1hbmFnZXIgc3RhdGVcbiAgICAgIC8vIFRPRE8gLSBtb3ZlIHRoZXNlIGZpZWxkcyBoZXJlIChyaXNrcyBicmVha2luZyBsYXllcnMpXG4gICAgICAvLyBhdHRyaWJ1dGVNYW5hZ2VyLFxuICAgICAgLy8gbmVlZHNSZWRyYXc6IHRydWUsXG4gICAgfTtcblxuICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICBhdHRyaWJ1dGVNYW5hZ2VyLFxuICAgICAgbW9kZWw6IG51bGwsXG4gICAgICBuZWVkc1JlZHJhdzogdHJ1ZVxuICAgIH07XG5cbiAgICAvLyBDYWxsIHN1YmNsYXNzIGxpZmVjeWNsZSBtZXRob2RzXG4gICAgdGhpcy5pbml0aWFsaXplU3RhdGUodGhpcy5jb250ZXh0KTtcbiAgICAvLyBFbmQgc3ViY2xhc3MgbGlmZWN5Y2xlIG1ldGhvZHNcblxuICAgIC8vIGluaXRpYWxpemVTdGF0ZSBjYWxsYmFjayB0ZW5kcyB0byBjbGVhciBzdGF0ZVxuICAgIHRoaXMuc2V0Q2hhbmdlRmxhZ3Moe2RhdGFDaGFuZ2VkOiB0cnVlLCBwcm9wc0NoYW5nZWQ6IHRydWUsIHZpZXdwb3J0Q2hhbmdlZDogdHJ1ZX0pO1xuXG4gICAgdGhpcy5fdXBkYXRlU3RhdGUodGhpcy5fZ2V0VXBkYXRlUGFyYW1zKCkpO1xuXG4gICAgaWYgKHRoaXMuaXNDb21wb3NpdGUpIHtcbiAgICAgIHRoaXMuX3JlbmRlckxheWVycyh0cnVlKTtcbiAgICB9XG5cbiAgICBjb25zdCB7bW9kZWx9ID0gdGhpcy5zdGF0ZTtcbiAgICBpZiAobW9kZWwpIHtcbiAgICAgIG1vZGVsLmlkID0gdGhpcy5wcm9wcy5pZDtcbiAgICAgIG1vZGVsLnByb2dyYW0uaWQgPSBgJHt0aGlzLnByb3BzLmlkfS1wcm9ncmFtYDtcbiAgICAgIG1vZGVsLmdlb21ldHJ5LmlkID0gYCR7dGhpcy5wcm9wcy5pZH0tZ2VvbWV0cnlgO1xuICAgICAgbW9kZWwuc2V0QXR0cmlidXRlcyhhdHRyaWJ1dGVNYW5hZ2VyLmdldEF0dHJpYnV0ZXMoKSk7XG4gICAgfVxuXG4gICAgLy8gTGFzdCBidXQgbm90IGxlYXN0LCB1cGRhdGUgYW55IHN1YmxheWVyc1xuICAgIGlmICh0aGlzLmlzQ29tcG9zaXRlKSB7XG4gICAgICB0aGlzLl9yZW5kZXJMYXllcnMoKTtcbiAgICB9XG5cbiAgICB0aGlzLmNsZWFyQ2hhbmdlRmxhZ3MoKTtcbiAgfVxuXG4gIC8vIENhbGxlZCBieSBsYXllciBtYW5hZ2VyXG4gIC8vIGlmIHRoaXMgbGF5ZXIgaXMgbmV3IChub3QgbWF0Y2hlZCB3aXRoIGFuIGV4aXN0aW5nIGxheWVyKSBvbGRQcm9wcyB3aWxsIGJlIGVtcHR5IG9iamVjdFxuICBfdXBkYXRlKCkge1xuICAgIGFzc2VydChhcmd1bWVudHMubGVuZ3RoID09PSAwKTtcblxuICAgIC8vIENhbGwgc3ViY2xhc3MgbGlmZWN5Y2xlIG1ldGhvZFxuICAgIGNvbnN0IHN0YXRlTmVlZHNVcGRhdGUgPSB0aGlzLm5lZWRzVXBkYXRlKCk7XG4gICAgLy8gRW5kIGxpZmVjeWNsZSBtZXRob2RcblxuICAgIGNvbnN0IHVwZGF0ZVBhcmFtcyA9IHtcbiAgICAgIHByb3BzOiB0aGlzLnByb3BzLFxuICAgICAgb2xkUHJvcHM6IHRoaXMub2xkUHJvcHMsXG4gICAgICBjb250ZXh0OiB0aGlzLmNvbnRleHQsXG4gICAgICBvbGRDb250ZXh0OiB0aGlzLm9sZENvbnRleHQsXG4gICAgICBjaGFuZ2VGbGFnczogdGhpcy5pbnRlcm5hbFN0YXRlLmNoYW5nZUZsYWdzXG4gICAgfTtcblxuICAgIGlmIChzdGF0ZU5lZWRzVXBkYXRlKSB7XG4gICAgICB0aGlzLl91cGRhdGVTdGF0ZSh1cGRhdGVQYXJhbXMpO1xuICAgIH1cblxuICAgIC8vIFJlbmRlciBvciB1cGRhdGUgcHJldmlvdXNseSByZW5kZXJlZCBzdWJsYXllcnNcbiAgICBpZiAodGhpcy5pc0NvbXBvc2l0ZSkge1xuICAgICAgdGhpcy5fcmVuZGVyTGF5ZXJzKHN0YXRlTmVlZHNVcGRhdGUpO1xuICAgIH1cblxuICAgIHRoaXMuY2xlYXJDaGFuZ2VGbGFncygpO1xuICB9XG4gIC8qIGVzbGludC1lbmFibGUgbWF4LXN0YXRlbWVudHMgKi9cblxuICBfdXBkYXRlU3RhdGUodXBkYXRlUGFyYW1zKSB7XG4gICAgLy8gQ2FsbCBzdWJjbGFzcyBsaWZlY3ljbGUgbWV0aG9kc1xuICAgIHRoaXMudXBkYXRlU3RhdGUodXBkYXRlUGFyYW1zKTtcbiAgICAvLyBFbmQgc3ViY2xhc3MgbGlmZWN5Y2xlIG1ldGhvZHNcblxuICAgIC8vIEFkZCBhbnkgc3ViY2xhc3MgYXR0cmlidXRlc1xuICAgIHRoaXMudXBkYXRlQXR0cmlidXRlcyh0aGlzLnByb3BzKTtcbiAgICB0aGlzLl91cGRhdGVCYXNlVW5pZm9ybXMoKTtcbiAgICB0aGlzLl91cGRhdGVNb2R1bGVTZXR0aW5ncygpO1xuXG4gICAgLy8gTm90ZTogQXV0b21hdGljIGluc3RhbmNlIGNvdW50IHVwZGF0ZSBvbmx5IHdvcmtzIGZvciBzaW5nbGUgbGF5ZXJzXG4gICAgaWYgKHRoaXMuc3RhdGUubW9kZWwpIHtcbiAgICAgIHRoaXMuc3RhdGUubW9kZWwuc2V0SW5zdGFuY2VDb3VudCh0aGlzLmdldE51bUluc3RhbmNlcygpKTtcbiAgICB9XG4gIH1cblxuICAvLyBDYWxsZWQgYnkgbWFuYWdlciB3aGVuIGxheWVyIGlzIGFib3V0IHRvIGJlIGRpc3Bvc2VkXG4gIC8vIE5vdGU6IG5vdCBndWFyYW50ZWVkIHRvIGJlIGNhbGxlZCBvbiBhcHBsaWNhdGlvbiBzaHV0ZG93blxuICBfZmluYWxpemUoKSB7XG4gICAgYXNzZXJ0KGFyZ3VtZW50cy5sZW5ndGggPT09IDApO1xuICAgIC8vIENhbGwgc3ViY2xhc3MgbGlmZWN5Y2xlIG1ldGhvZFxuICAgIHRoaXMuZmluYWxpemVTdGF0ZSh0aGlzLmNvbnRleHQpO1xuICAgIC8vIEVuZCBsaWZlY3ljbGUgbWV0aG9kXG4gICAgcmVtb3ZlTGF5ZXJJblNlZXIodGhpcy5pZCk7XG4gIH1cblxuICAvLyBDYWxjdWxhdGVzIHVuaWZvcm1zXG4gIGRyYXdMYXllcih7bW9kdWxlUGFyYW1ldGVycyA9IG51bGwsIHVuaWZvcm1zID0ge30sIHBhcmFtZXRlcnMgPSB7fX0pIHtcbiAgICAvLyBUT0RPL2liIC0gaGFjayBtb3ZlIHRvIGx1bWEgTW9kZWwuZHJhd1xuICAgIGlmIChtb2R1bGVQYXJhbWV0ZXJzKSB7XG4gICAgICBmb3IgKGNvbnN0IG1vZGVsIG9mIHRoaXMuZ2V0TW9kZWxzKCkpIHtcbiAgICAgICAgbW9kZWwudXBkYXRlTW9kdWxlU2V0dGluZ3MobW9kdWxlUGFyYW1ldGVycyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQXBwbHkgcG9seWdvbiBvZmZzZXQgdG8gYXZvaWQgei1maWdodGluZ1xuICAgIC8vIFRPRE8gLSBtb3ZlIHRvIGRyYXctbGF5ZXJzXG4gICAgY29uc3Qge2dldFBvbHlnb25PZmZzZXR9ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCBvZmZzZXRzID0gKGdldFBvbHlnb25PZmZzZXQgJiYgZ2V0UG9seWdvbk9mZnNldCh1bmlmb3JtcykpIHx8IFswLCAwXTtcbiAgICBwYXJhbWV0ZXJzLnBvbHlnb25PZmZzZXQgPSBvZmZzZXRzO1xuXG4gICAgLy8gQ2FsbCBzdWJjbGFzcyBsaWZlY3ljbGUgbWV0aG9kXG4gICAgd2l0aFBhcmFtZXRlcnModGhpcy5jb250ZXh0LmdsLCBwYXJhbWV0ZXJzLCAoKSA9PiB7XG4gICAgICB0aGlzLmRyYXcoe21vZHVsZVBhcmFtZXRlcnMsIHVuaWZvcm1zLCBwYXJhbWV0ZXJzLCBjb250ZXh0OiB0aGlzLmNvbnRleHR9KTtcbiAgICB9KTtcbiAgICAvLyBFbmQgbGlmZWN5Y2xlIG1ldGhvZFxuICB9XG5cbiAgLy8ge3VuaWZvcm1zID0ge30sIC4uLm9wdHN9XG4gIHBpY2tMYXllcihvcHRzKSB7XG4gICAgLy8gQ2FsbCBzdWJjbGFzcyBsaWZlY3ljbGUgbWV0aG9kXG4gICAgcmV0dXJuIHRoaXMuZ2V0UGlja2luZ0luZm8ob3B0cyk7XG4gICAgLy8gRW5kIGxpZmVjeWNsZSBtZXRob2RcbiAgfVxuXG4gIC8vIEhlbHBlciBtZXRob2RzXG4gIGdldENoYW5nZUZsYWdzKCkge1xuICAgIHJldHVybiB0aGlzLmludGVybmFsU3RhdGUuY2hhbmdlRmxhZ3M7XG4gIH1cblxuICAvLyBEaXJ0eSBzb21lIGNoYW5nZSBmbGFncywgd2lsbCBiZSBoYW5kbGVkIGJ5IHVwZGF0ZUxheWVyXG4gIC8qIGVzbGludC1kaXNhYmxlIGNvbXBsZXhpdHkgKi9cbiAgc2V0Q2hhbmdlRmxhZ3MoZmxhZ3MpIHtcbiAgICB0aGlzLmludGVybmFsU3RhdGUuY2hhbmdlRmxhZ3MgPSB0aGlzLmludGVybmFsU3RhdGUuY2hhbmdlRmxhZ3MgfHwge307XG4gICAgY29uc3QgY2hhbmdlRmxhZ3MgPSB0aGlzLmludGVybmFsU3RhdGUuY2hhbmdlRmxhZ3M7XG5cbiAgICAvLyBVcGRhdGUgcHJpbWFyeSBmbGFnc1xuICAgIGlmIChmbGFncy5kYXRhQ2hhbmdlZCAmJiAhY2hhbmdlRmxhZ3MuZGF0YUNoYW5nZWQpIHtcbiAgICAgIGNoYW5nZUZsYWdzLmRhdGFDaGFuZ2VkID0gZmxhZ3MuZGF0YUNoYW5nZWQ7XG4gICAgICBsb2cubG9nKExPR19QUklPUklUWV9VUERBVEUgKyAxLCAoKSA9PiBgZGF0YUNoYW5nZWQ6ICR7ZmxhZ3MuZGF0YUNoYW5nZWR9IGluICR7dGhpcy5pZH1gKTtcbiAgICB9XG4gICAgaWYgKGZsYWdzLnVwZGF0ZVRyaWdnZXJzQ2hhbmdlZCAmJiAhY2hhbmdlRmxhZ3MudXBkYXRlVHJpZ2dlcnNDaGFuZ2VkKSB7XG4gICAgICBjaGFuZ2VGbGFncy51cGRhdGVUcmlnZ2Vyc0NoYW5nZWQgPVxuICAgICAgICBjaGFuZ2VGbGFncy51cGRhdGVUcmlnZ2Vyc0NoYW5nZWQgJiYgZmxhZ3MudXBkYXRlVHJpZ2dlcnNDaGFuZ2VkXG4gICAgICAgICAgPyBPYmplY3QuYXNzaWduKHt9LCBmbGFncy51cGRhdGVUcmlnZ2Vyc0NoYW5nZWQsIGNoYW5nZUZsYWdzLnVwZGF0ZVRyaWdnZXJzQ2hhbmdlZClcbiAgICAgICAgICA6IGZsYWdzLnVwZGF0ZVRyaWdnZXJzQ2hhbmdlZCB8fCBjaGFuZ2VGbGFncy51cGRhdGVUcmlnZ2Vyc0NoYW5nZWQ7XG4gICAgICBsb2cubG9nKFxuICAgICAgICBMT0dfUFJJT1JJVFlfVVBEQVRFICsgMSxcbiAgICAgICAgKCkgPT5cbiAgICAgICAgICAndXBkYXRlVHJpZ2dlcnNDaGFuZ2VkOiAnICtcbiAgICAgICAgICBgJHtPYmplY3Qua2V5cyhmbGFncy51cGRhdGVUcmlnZ2Vyc0NoYW5nZWQpLmpvaW4oJywgJyl9IGluICR7dGhpcy5pZH1gXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoZmxhZ3MucHJvcHNDaGFuZ2VkICYmICFjaGFuZ2VGbGFncy5wcm9wc0NoYW5nZWQpIHtcbiAgICAgIGNoYW5nZUZsYWdzLnByb3BzQ2hhbmdlZCA9IGZsYWdzLnByb3BzQ2hhbmdlZDtcbiAgICAgIGxvZy5sb2coTE9HX1BSSU9SSVRZX1VQREFURSArIDEsICgpID0+IGBwcm9wc0NoYW5nZWQ6ICR7ZmxhZ3MucHJvcHNDaGFuZ2VkfSBpbiAke3RoaXMuaWR9YCk7XG4gICAgfVxuICAgIGlmIChmbGFncy52aWV3cG9ydENoYW5nZWQgJiYgIWNoYW5nZUZsYWdzLnZpZXdwb3J0Q2hhbmdlZCkge1xuICAgICAgY2hhbmdlRmxhZ3Mudmlld3BvcnRDaGFuZ2VkID0gZmxhZ3Mudmlld3BvcnRDaGFuZ2VkO1xuICAgICAgbG9nLmxvZyhcbiAgICAgICAgTE9HX1BSSU9SSVRZX1VQREFURSArIDIsXG4gICAgICAgICgpID0+IGB2aWV3cG9ydENoYW5nZWQ6ICR7ZmxhZ3Mudmlld3BvcnRDaGFuZ2VkfSBpbiAke3RoaXMuaWR9YFxuICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBVcGRhdGUgY29tcG9zaXRlIGZsYWdzXG4gICAgY29uc3QgcHJvcHNPckRhdGFDaGFuZ2VkID1cbiAgICAgIGZsYWdzLmRhdGFDaGFuZ2VkIHx8IGZsYWdzLnVwZGF0ZVRyaWdnZXJzQ2hhbmdlZCB8fCBmbGFncy5wcm9wc0NoYW5nZWQ7XG4gICAgY2hhbmdlRmxhZ3MucHJvcHNPckRhdGFDaGFuZ2VkID0gY2hhbmdlRmxhZ3MucHJvcHNPckRhdGFDaGFuZ2VkIHx8IHByb3BzT3JEYXRhQ2hhbmdlZDtcbiAgICBjaGFuZ2VGbGFncy5zb21ldGhpbmdDaGFuZ2VkID1cbiAgICAgIGNoYW5nZUZsYWdzLnNvbWV0aGluZ0NoYW5nZWQgfHwgcHJvcHNPckRhdGFDaGFuZ2VkIHx8IGZsYWdzLnZpZXdwb3J0Q2hhbmdlZDtcbiAgfVxuICAvKiBlc2xpbnQtZW5hYmxlIGNvbXBsZXhpdHkgKi9cblxuICAvLyBDbGVhciBhbGwgY2hhbmdlRmxhZ3MsIHR5cGljYWxseSBhZnRlciBhbiB1cGRhdGVcbiAgY2xlYXJDaGFuZ2VGbGFncygpIHtcbiAgICB0aGlzLmludGVybmFsU3RhdGUuY2hhbmdlRmxhZ3MgPSB7XG4gICAgICAvLyBQcmltYXJ5IGNoYW5nZUZsYWdzLCBjYW4gYmUgc3RyaW5ncyBzdGF0aW5nIHJlYXNvbiBmb3IgY2hhbmdlXG4gICAgICBkYXRhQ2hhbmdlZDogZmFsc2UsXG4gICAgICBwcm9wc0NoYW5nZWQ6IGZhbHNlLFxuICAgICAgdXBkYXRlVHJpZ2dlcnNDaGFuZ2VkOiBmYWxzZSxcbiAgICAgIHZpZXdwb3J0Q2hhbmdlZDogZmFsc2UsXG5cbiAgICAgIC8vIERlcml2ZWQgY2hhbmdlRmxhZ3NcbiAgICAgIHByb3BzT3JEYXRhQ2hhbmdlZDogZmFsc2UsXG4gICAgICBzb21ldGhpbmdDaGFuZ2VkOiBmYWxzZVxuICAgIH07XG4gIH1cblxuICBwcmludENoYW5nZUZsYWdzKCkge1xuICAgIGNvbnN0IGZsYWdzID0gdGhpcy5pbnRlcm5hbFN0YXRlLmNoYW5nZUZsYWdzO1xuICAgIHJldHVybiBgXFxcbiR7ZmxhZ3MuZGF0YUNoYW5nZWQgPyAnZGF0YSAnIDogJyd9XFxcbiR7ZmxhZ3MucHJvcHNDaGFuZ2VkID8gJ3Byb3BzICcgOiAnJ31cXFxuJHtmbGFncy51cGRhdGVUcmlnZ2Vyc0NoYW5nZWQgPyAndHJpZ2dlcnMgJyA6ICcnfVxcXG4ke2ZsYWdzLnZpZXdwb3J0Q2hhbmdlZCA/ICd2aWV3cG9ydCcgOiAnJ31cXFxuYDtcbiAgfVxuXG4gIC8vIENvbXBhcmVzIHRoZSBsYXllcnMgcHJvcHMgd2l0aCBvbGQgcHJvcHMgZnJvbSBhIG1hdGNoZWQgb2xkZXIgbGF5ZXJcbiAgLy8gYW5kIGV4dHJhY3RzIGNoYW5nZSBmbGFncyB0aGF0IGRlc2NyaWJlIHdoYXQgaGFzIGNoYW5nZSBzbyB0aGF0IHN0YXRlXG4gIC8vIGNhbiBiZSB1cGRhdGUgY29ycmVjdGx5IHdpdGggbWluaW1hbCBlZmZvcnRcbiAgLy8gVE9ETyAtIGFyZ3VtZW50cyBmb3IgdGVzdGluZyBvbmx5XG4gIGRpZmZQcm9wcyhuZXdQcm9wcyA9IHRoaXMucHJvcHMsIG9sZFByb3BzID0gdGhpcy5vbGRQcm9wcykge1xuICAgIGNvbnN0IGNoYW5nZUZsYWdzID0gZGlmZlByb3BzKG5ld1Byb3BzLCBvbGRQcm9wcyk7XG5cbiAgICAvLyBpdGVyYXRlIG92ZXIgY2hhbmdlZFRyaWdnZXJzXG4gICAgaWYgKGNoYW5nZUZsYWdzLnVwZGF0ZVRyaWdnZXJzQ2hhbmdlZCkge1xuICAgICAgZm9yIChjb25zdCBrZXkgaW4gY2hhbmdlRmxhZ3MudXBkYXRlVHJpZ2dlcnNDaGFuZ2VkKSB7XG4gICAgICAgIGlmIChjaGFuZ2VGbGFncy51cGRhdGVUcmlnZ2Vyc0NoYW5nZWRba2V5XSkge1xuICAgICAgICAgIHRoaXMuX2FjdGl2ZVVwZGF0ZVRyaWdnZXIoa2V5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnNldENoYW5nZUZsYWdzKGNoYW5nZUZsYWdzKTtcbiAgfVxuXG4gIC8vIFBSSVZBVEUgTUVUSE9EU1xuXG4gIF9nZXRVcGRhdGVQYXJhbXMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHByb3BzOiB0aGlzLnByb3BzLFxuICAgICAgb2xkUHJvcHM6IHRoaXMub2xkUHJvcHMsXG4gICAgICBjb250ZXh0OiB0aGlzLmNvbnRleHQsXG4gICAgICBvbGRDb250ZXh0OiB0aGlzLm9sZENvbnRleHQgfHwge30sXG4gICAgICBjaGFuZ2VGbGFnczogdGhpcy5pbnRlcm5hbFN0YXRlLmNoYW5nZUZsYWdzXG4gICAgfTtcbiAgfVxuXG4gIC8vIENoZWNrcyBzdGF0ZSBvZiBhdHRyaWJ1dGVzIGFuZCBtb2RlbFxuICBfZ2V0TmVlZHNSZWRyYXcoY2xlYXJSZWRyYXdGbGFncykge1xuICAgIC8vIHRoaXMgbWV0aG9kIG1heSBiZSBjYWxsZWQgYnkgdGhlIHJlbmRlciBsb29wIGFzIHNvb24gYSB0aGUgbGF5ZXJcbiAgICAvLyBoYXMgYmVlbiBjcmVhdGVkLCBzbyBndWFyZCBhZ2FpbnN0IHVuaW5pdGlhbGl6ZWQgc3RhdGVcbiAgICBpZiAoIXRoaXMuc3RhdGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBsZXQgcmVkcmF3ID0gZmFsc2U7XG4gICAgcmVkcmF3ID0gcmVkcmF3IHx8ICh0aGlzLnN0YXRlLm5lZWRzUmVkcmF3ICYmIHRoaXMuaWQpO1xuICAgIHRoaXMuc3RhdGUubmVlZHNSZWRyYXcgPSB0aGlzLnN0YXRlLm5lZWRzUmVkcmF3ICYmICFjbGVhclJlZHJhd0ZsYWdzO1xuXG4gICAgLy8gVE9ETyAtIGlzIGF0dHJpYnV0ZSBtYW5hZ2VyIG5lZWRlZD8gLSBNb2RlbCBzaG91bGQgYmUgZW5vdWdoLlxuICAgIGNvbnN0IHthdHRyaWJ1dGVNYW5hZ2VyfSA9IHRoaXMuc3RhdGU7XG4gICAgY29uc3QgYXR0cmlidXRlTWFuYWdlck5lZWRzUmVkcmF3ID1cbiAgICAgIGF0dHJpYnV0ZU1hbmFnZXIgJiYgYXR0cmlidXRlTWFuYWdlci5nZXROZWVkc1JlZHJhdyh7Y2xlYXJSZWRyYXdGbGFnc30pO1xuICAgIHJlZHJhdyA9IHJlZHJhdyB8fCBhdHRyaWJ1dGVNYW5hZ2VyTmVlZHNSZWRyYXc7XG5cbiAgICBmb3IgKGNvbnN0IG1vZGVsIG9mIHRoaXMuZ2V0TW9kZWxzKCkpIHtcbiAgICAgIGxldCBtb2RlbE5lZWRzUmVkcmF3ID0gbW9kZWwuZ2V0TmVlZHNSZWRyYXcoe2NsZWFyUmVkcmF3RmxhZ3N9KTtcbiAgICAgIGlmIChtb2RlbE5lZWRzUmVkcmF3ICYmIHR5cGVvZiBtb2RlbE5lZWRzUmVkcmF3ICE9PSAnc3RyaW5nJykge1xuICAgICAgICBtb2RlbE5lZWRzUmVkcmF3ID0gYG1vZGVsICR7bW9kZWwuaWR9YDtcbiAgICAgIH1cbiAgICAgIHJlZHJhdyA9IHJlZHJhdyB8fCBtb2RlbE5lZWRzUmVkcmF3O1xuICAgIH1cblxuICAgIHJldHVybiByZWRyYXc7XG4gIH1cblxuICAvLyBIZWxwZXIgZm9yIGNvbnN0cnVjdG9yLCBtZXJnZXMgcHJvcHMgd2l0aCBkZWZhdWx0IHByb3BzIGFuZCBmcmVlemVzIHRoZW1cbiAgX25vcm1hbGl6ZVByb3BzKHByb3BzKSB7XG4gICAgLy8gSWYgc3VibGF5ZXIgaGFzIHN0YXRpYyBkZWZhdWx0UHJvcHMgbWVtYmVyLCBnZXREZWZhdWx0UHJvcHMgd2lsbCByZXR1cm4gaXRcbiAgICBjb25zdCBtZXJnZWREZWZhdWx0UHJvcHMgPSBnZXREZWZhdWx0UHJvcHModGhpcyk7XG4gICAgLy8gTWVyZ2Ugc3VwcGxpZWQgcHJvcHMgd2l0aCBwcmUtbWVyZ2VkIGRlZmF1bHQgcHJvcHNcbiAgICBwcm9wcyA9IE9iamVjdC5hc3NpZ24oe30sIG1lcmdlZERlZmF1bHRQcm9wcywgcHJvcHMpO1xuICAgIC8vIEFjY2VwdCBudWxsIGFzIGRhdGEgLSBvdGhlcndpc2UgYXBwcyBhbmQgbGF5ZXJzIG5lZWQgdG8gYWRkIHVnbHkgY2hlY2tzXG4gICAgLy8gVXNlIGNvbnN0YW50IGZhbGxiYWNrIHNvIHRoYXQgZGF0YSBjaGFuZ2UgaXMgbm90IHRyaWdnZXJlZFxuICAgIHByb3BzLmRhdGEgPSBwcm9wcy5kYXRhIHx8IEVNUFRZX0FSUkFZO1xuICAgIC8vIEFwcGx5IGFueSBvdmVycmlkZXMgZnJvbSB0aGUgc2VlciBkZWJ1ZyBleHRlbnNpb24gaWYgaXQgaXMgYWN0aXZlXG4gICAgYXBwbHlQcm9wT3ZlcnJpZGVzKHByb3BzKTtcbiAgICAvLyBQcm9wcyBhcmUgaW1tdXRhYmxlXG4gICAgT2JqZWN0LmZyZWV6ZShwcm9wcyk7XG4gICAgcmV0dXJuIHByb3BzO1xuICB9XG5cbiAgLy8gQ2FsbGVkIGJ5IGxheWVyIG1hbmFnZXIgdG8gdHJhbnNmZXIgc3RhdGUgZnJvbSBhbiBvbGQgbGF5ZXJcbiAgX3RyYW5zZmVyU3RhdGUob2xkTGF5ZXIpIHtcbiAgICBjb25zdCB7c3RhdGUsIGludGVybmFsU3RhdGUsIHByb3BzfSA9IG9sZExheWVyO1xuICAgIGFzc2VydChzdGF0ZSAmJiBpbnRlcm5hbFN0YXRlKTtcblxuICAgIC8vIE1vdmUgc3RhdGVcbiAgICBzdGF0ZS5sYXllciA9IHRoaXM7XG4gICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICAgIHRoaXMuaW50ZXJuYWxTdGF0ZSA9IGludGVybmFsU3RhdGU7XG4gICAgLy8gTm90ZTogV2Uga2VlcCB0aGUgc3RhdGUgcmVmIG9uIG9sZCBsYXllcnMgdG8gc3VwcG9ydCBhc3luYyBhY3Rpb25zXG4gICAgLy8gb2xkTGF5ZXIuc3RhdGUgPSBudWxsO1xuXG4gICAgLy8gS2VlcCBhIHRlbXBvcmFyeSByZWYgdG8gdGhlIG9sZCBwcm9wcywgZm9yIHByb3AgY29tcGFyaXNvblxuICAgIHRoaXMub2xkUHJvcHMgPSBwcm9wcztcblxuICAgIC8vIFVwZGF0ZSBtb2RlbCBsYXllciByZWZlcmVuY2VcbiAgICBmb3IgKGNvbnN0IG1vZGVsIG9mIHRoaXMuZ2V0TW9kZWxzKCkpIHtcbiAgICAgIG1vZGVsLnVzZXJEYXRhLmxheWVyID0gdGhpcztcbiAgICB9XG5cbiAgICB0aGlzLmRpZmZQcm9wcygpO1xuICB9XG5cbiAgLy8gT3BlcmF0ZSBvbiBlYWNoIGNoYW5nZWQgdHJpZ2dlcnMsIHdpbGwgYmUgY2FsbGVkIHdoZW4gYW4gdXBkYXRlVHJpZ2dlciBjaGFuZ2VzXG4gIF9hY3RpdmVVcGRhdGVUcmlnZ2VyKHByb3BOYW1lKSB7XG4gICAgdGhpcy5pbnZhbGlkYXRlQXR0cmlidXRlKHByb3BOYW1lKTtcbiAgfVxuXG4gIC8vICBIZWxwZXIgdG8gY2hlY2sgdGhhdCByZXF1aXJlZCBwcm9wcyBhcmUgc3VwcGxpZWRcbiAgX2NoZWNrUmVxdWlyZWRQcm9wKHByb3BlcnR5TmFtZSwgY29uZGl0aW9uKSB7XG4gICAgY29uc3QgdmFsdWUgPSB0aGlzLnByb3BzW3Byb3BlcnR5TmFtZV07XG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgUHJvcGVydHkgJHtwcm9wZXJ0eU5hbWV9IHVuZGVmaW5lZCBpbiBsYXllciAke3RoaXN9YCk7XG4gICAgfVxuICAgIGlmIChjb25kaXRpb24gJiYgIWNvbmRpdGlvbih2YWx1ZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQmFkIHByb3BlcnR5ICR7cHJvcGVydHlOYW1lfSBpbiBsYXllciAke3RoaXN9YCk7XG4gICAgfVxuICB9XG5cbiAgX3VwZGF0ZUJhc2VVbmlmb3JtcygpIHtcbiAgICBjb25zdCB1bmlmb3JtcyA9IHtcbiAgICAgIC8vIGFwcGx5IGdhbW1hIHRvIG9wYWNpdHkgdG8gbWFrZSBpdCB2aXN1YWxseSBcImxpbmVhclwiXG4gICAgICBvcGFjaXR5OiBNYXRoLnBvdyh0aGlzLnByb3BzLm9wYWNpdHksIDEgLyAyLjIpLFxuICAgICAgT05FOiAxLjBcbiAgICB9O1xuICAgIGZvciAoY29uc3QgbW9kZWwgb2YgdGhpcy5nZXRNb2RlbHMoKSkge1xuICAgICAgbW9kZWwuc2V0VW5pZm9ybXModW5pZm9ybXMpO1xuICAgIH1cblxuICAgIC8vIFRPRE8gLSBzZXQgbmVlZHNSZWRyYXcgb24gdGhlIG1vZGVsKHMpP1xuICAgIHRoaXMuc3RhdGUubmVlZHNSZWRyYXcgPSB0cnVlO1xuICB9XG5cbiAgX3VwZGF0ZU1vZHVsZVNldHRpbmdzKCkge1xuICAgIGNvbnN0IHNldHRpbmdzID0ge1xuICAgICAgcGlja2luZ0hpZ2hsaWdodENvbG9yOiB0aGlzLnByb3BzLmhpZ2hsaWdodENvbG9yXG4gICAgfTtcbiAgICBmb3IgKGNvbnN0IG1vZGVsIG9mIHRoaXMuZ2V0TW9kZWxzKCkpIHtcbiAgICAgIG1vZGVsLnVwZGF0ZU1vZHVsZVNldHRpbmdzKHNldHRpbmdzKTtcbiAgICB9XG4gIH1cblxuICAvLyBERVBSRUNBVEVEIE1FVEhPRFNcblxuICAvLyBVcGRhdGVzIHNlbGVjdGVkIHN0YXRlIG1lbWJlcnMgYW5kIG1hcmtzIHRoZSBvYmplY3QgZm9yIHJlZHJhd1xuICBzZXRVbmlmb3Jtcyh1bmlmb3JtTWFwKSB7XG4gICAgZm9yIChjb25zdCBtb2RlbCBvZiB0aGlzLmdldE1vZGVscygpKSB7XG4gICAgICBtb2RlbC5zZXRVbmlmb3Jtcyh1bmlmb3JtTWFwKTtcbiAgICB9XG5cbiAgICAvLyBUT0RPIC0gc2V0IG5lZWRzUmVkcmF3IG9uIHRoZSBtb2RlbChzKT9cbiAgICB0aGlzLnN0YXRlLm5lZWRzUmVkcmF3ID0gdHJ1ZTtcbiAgICBsb2cuZGVwcmVjYXRlZCgnbGF5ZXIuc2V0VW5pZm9ybXMnLCAnbW9kZWwuc2V0VW5pZm9ybXMnKTtcbiAgfVxufVxuXG5MYXllci5sYXllck5hbWUgPSAnTGF5ZXInO1xuTGF5ZXIucHJvcFR5cGVzID0gZGVmYXVsdFByb3BzO1xuTGF5ZXIuZGVmYXVsdFByb3BzID0gZGVmYXVsdFByb3BzO1xuIl19