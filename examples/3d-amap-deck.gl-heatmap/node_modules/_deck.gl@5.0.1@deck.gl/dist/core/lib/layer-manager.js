'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

// TODO - remove, just for dummy initialization


var _assert = require('assert');

var _assert2 = _interopRequireDefault(_assert);

var _luma = require('luma.gl');

var _seer = require('seer');

var _seer2 = _interopRequireDefault(_seer);

var _layer = require('./layer');

var _layer2 = _interopRequireDefault(_layer);

var _drawLayers2 = require('./draw-layers');

var _pickLayers = require('./pick-layers');

var _constants = require('./constants');

var _viewport = require('../viewports/viewport');

var _viewport2 = _interopRequireDefault(_viewport);

var _webMercatorViewport = require('../viewports/web-mercator-viewport');

var _webMercatorViewport2 = _interopRequireDefault(_webMercatorViewport);

var _log = require('../utils/log');

var _log2 = _interopRequireDefault(_log);

var _flatten = require('../utils/flatten');

var _seerIntegration = require('./seer-integration');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var LOG_PRIORITY_LIFECYCLE = 2;
var LOG_PRIORITY_LIFECYCLE_MINOR = 4;

var initialContext = {
  uniforms: {},
  viewports: [],
  viewport: null,
  layerFilter: null,
  viewportChanged: true,
  pickingFBO: null,
  useDevicePixels: true,
  lastPickedInfo: {
    index: -1,
    layerId: null
  }
};

var layerName = function layerName(layer) {
  return layer instanceof _layer2.default ? '' + layer : !layer ? 'null' : 'invalid';
};

var LayerManager = function () {
  // eslint-disable-next-line
  function LayerManager(gl) {
    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        eventManager = _ref.eventManager;

    _classCallCheck(this, LayerManager);

    // Currently deck.gl expects the DeckGL.layers array to be different
    // whenever React rerenders. If the same layers array is used, the
    // LayerManager's diffing algorithm will generate a fatal error and
    // break the rendering.

    // `this.lastRenderedLayers` stores the UNFILTERED layers sent
    // down to LayerManager, so that `layers` reference can be compared.
    // If it's the same across two React render calls, the diffing logic
    // will be skipped.
    this.lastRenderedLayers = [];
    this.prevLayers = [];
    this.layers = [];

    this.oldContext = {};
    this.context = Object.assign({}, initialContext, {
      gl: gl,
      // Enabling luma.gl Program caching using private API (_cachePrograms)
      shaderCache: new _luma.ShaderCache({ gl: gl, _cachePrograms: true })
    });

    // List of view descriptors, gets re-evaluated when width/height changes
    this.width = 100;
    this.height = 100;
    this.viewDescriptors = [];
    this.viewDescriptorsChanged = true;
    this.viewports = []; // Generated viewports
    this._needsRedraw = 'Initial render';

    // Event handling
    this._pickingRadius = 0;

    this._eventManager = null;
    this._onLayerClick = null;
    this._onLayerHover = null;
    this._onClick = this._onClick.bind(this);
    this._onPointerMove = this._onPointerMove.bind(this);
    this._onPointerLeave = this._onPointerLeave.bind(this);
    this._pickAndCallback = this._pickAndCallback.bind(this);

    // Seer integration
    this._initSeer = this._initSeer.bind(this);
    this._editSeer = this._editSeer.bind(this);
    (0, _seerIntegration.seerInitListener)(this._initSeer);
    (0, _seerIntegration.layerEditListener)(this._editSeer);

    Object.seal(this);

    if (eventManager) {
      this._initEventHandling(eventManager);
    }

    // Init with dummy viewport
    this.setViewports([new _webMercatorViewport2.default({ width: 1, height: 1, latitude: 0, longitude: 0, zoom: 1 })]);
  }

  /**
   * Method to call when the layer manager is not needed anymore.
   *
   * Currently used in the <DeckGL> componentWillUnmount lifecycle to unbind Seer listeners.
   */


  _createClass(LayerManager, [{
    key: 'finalize',
    value: function finalize() {
      _seer2.default.removeListener(this._initSeer);
      _seer2.default.removeListener(this._editSeer);
    }
  }, {
    key: 'needsRedraw',
    value: function needsRedraw() {
      var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref2$clearRedrawFlag = _ref2.clearRedrawFlags,
          clearRedrawFlags = _ref2$clearRedrawFlag === undefined ? true : _ref2$clearRedrawFlag;

      return this._checkIfNeedsRedraw(clearRedrawFlags);
    }

    // Normally not called by app

  }, {
    key: 'setNeedsRedraw',
    value: function setNeedsRedraw(reason) {
      this._needsRedraw = this._needsRedraw || reason;
    }

    // Gets an (optionally) filtered list of layers

  }, {
    key: 'getLayers',
    value: function getLayers() {
      var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref3$layerIds = _ref3.layerIds,
          layerIds = _ref3$layerIds === undefined ? null : _ref3$layerIds;

      // Filtering by layerId compares beginning of strings, so that sublayers will be included
      // Dependes on the convention of adding suffixes to the parent's layer name
      return layerIds ? this.layers.filter(function (layer) {
        return layerIds.find(function (layerId) {
          return layer.id.indexOf(layerId) === 0;
        });
      }) : this.layers;
    }

    // Get a set of viewports for a given width and height
    // TODO - Intention is for deck.gl to autodeduce width and height and drop the need for props

  }, {
    key: 'getViewports',
    value: function getViewports() {
      var _ref4 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          width = _ref4.width,
          height = _ref4.height;

      if (width !== this.width || height !== this.height || this.viewDescriptorsChanged) {
        this._rebuildViewportsFromViews({ viewDescriptors: this.viewDescriptors, width: width, height: height });
        this.width = width;
        this.height = height;
      }
      return this.viewports;
    }

    /**
     * Set parameters needed for layer rendering and picking.
     * Parameters are to be passed as a single object, with the following values:
     * @param {Boolean} useDevicePixels
     */

  }, {
    key: 'setParameters',
    value: function setParameters(parameters) {
      if ('eventManager' in parameters) {
        this._initEventHandling(parameters.eventManager);
      }

      if ('pickingRadius' in parameters || 'onLayerClick' in parameters || 'onLayerHover' in parameters) {
        this._setEventHandlingParameters(parameters);
      }

      // TODO - For now we set layers before viewports to preservenchangeFlags
      if ('layers' in parameters) {
        this.setLayers(parameters.layers);
      }

      if ('viewports' in parameters) {
        this.setViewports(parameters.viewports);
      }

      if ('layerFilter' in parameters) {
        this.context.layerFilter = parameters.layerFilter;
        if (this.context.layerFilter !== parameters.layerFilter) {
          this.setNeedsRedraw('layerFilter changed');
        }
      }

      if ('drawPickingColors' in parameters) {
        if (this.context.drawPickingColors !== parameters.drawPickingColors) {
          this.setNeedsRedraw('drawPickingColors changed');
        }
      }

      Object.assign(this.context, parameters);
    }

    // Update the view descriptor list and set change flag if needed

  }, {
    key: 'setViewports',
    value: function setViewports(viewports) {
      // Ensure viewports are wrapped in descriptors
      var viewDescriptors = (0, _flatten.flatten)(viewports, { filter: Boolean }).map(function (viewport) {
        return viewport instanceof _viewport2.default ? { viewport: viewport } : viewport;
      });

      this.viewDescriptorsChanged = this.viewDescriptorsChanged || this._diffViews(viewDescriptors, this.viewDescriptors);

      // Try to not actually rebuild the viewports until `getViewports` is called
      if (this.viewDescriptorsChanged) {
        this.viewDescriptors = viewDescriptors;
        this._rebuildViewportsFromViews({ viewDescriptors: this.viewDescriptors });
        this.viewDescriptorsChanged = false;
      }
    }

    // Supply a new layer list, initiating sublayer generation and layer matching

  }, {
    key: 'setLayers',
    value: function setLayers(newLayers) {
      (0, _assert2.default)(this.context.viewport, 'LayerManager.updateLayers: viewport not set');

      // TODO - something is generating state updates that cause rerender of the same
      if (newLayers === this.lastRenderedLayers) {
        _log2.default.log(3, 'Ignoring layer update due to layer array not changed');
        return this;
      }
      this.lastRenderedLayers = newLayers;

      newLayers = (0, _flatten.flatten)(newLayers, { filter: Boolean });

      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = newLayers[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var layer = _step.value;

          layer.context = this.context;
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      this.prevLayers = this.layers;

      var _updateLayers2 = this._updateLayers({
        oldLayers: this.prevLayers,
        newLayers: newLayers
      }),
          error = _updateLayers2.error,
          generatedLayers = _updateLayers2.generatedLayers;

      this.layers = generatedLayers;
      // Throw first error found, if any
      if (error) {
        throw error;
      }
      return this;
    }
  }, {
    key: 'drawLayers',
    value: function drawLayers() {
      var _ref5 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref5$pass = _ref5.pass,
          pass = _ref5$pass === undefined ? 'render to screen' : _ref5$pass,
          _ref5$redrawReason = _ref5.redrawReason,
          redrawReason = _ref5$redrawReason === undefined ? 'unknown reason' : _ref5$redrawReason;

      var _context = this.context,
          gl = _context.gl,
          useDevicePixels = _context.useDevicePixels,
          drawPickingColors = _context.drawPickingColors;

      // render this viewport

      (0, _drawLayers2.drawLayers)(gl, {
        layers: this.layers,
        viewports: this.getViewports(),
        onViewportActive: this._activateViewport.bind(this),
        useDevicePixels: useDevicePixels,
        drawPickingColors: drawPickingColors,
        pass: pass,
        layerFilter: this.context.layerFilter,
        redrawReason: redrawReason
      });
    }

    // Pick the closest info at given coordinate

  }, {
    key: 'pickObject',
    value: function pickObject(_ref6) {
      var x = _ref6.x,
          y = _ref6.y,
          mode = _ref6.mode,
          _ref6$radius = _ref6.radius,
          radius = _ref6$radius === undefined ? 0 : _ref6$radius,
          layerIds = _ref6.layerIds,
          layerFilter = _ref6.layerFilter;
      var _context2 = this.context,
          gl = _context2.gl,
          useDevicePixels = _context2.useDevicePixels;


      var layers = this.getLayers({ layerIds: layerIds });

      return (0, _pickLayers.pickObject)(gl, {
        // User params
        x: x,
        y: y,
        radius: radius,
        layers: layers,
        mode: mode,
        layerFilter: layerFilter,
        // Injected params
        viewports: this.getViewports(),
        onViewportActive: this._activateViewport.bind(this),
        pickingFBO: this._getPickingBuffer(),
        lastPickedInfo: this.context.lastPickedInfo,
        useDevicePixels: useDevicePixels
      });
    }

    // Get all unique infos within a bounding box

  }, {
    key: 'pickObjects',
    value: function pickObjects(_ref7) {
      var x = _ref7.x,
          y = _ref7.y,
          width = _ref7.width,
          height = _ref7.height,
          layerIds = _ref7.layerIds,
          layerFilter = _ref7.layerFilter;
      var _context3 = this.context,
          gl = _context3.gl,
          useDevicePixels = _context3.useDevicePixels;


      var layers = this.getLayers({ layerIds: layerIds });

      return (0, _pickLayers.pickVisibleObjects)(gl, {
        x: x,
        y: y,
        width: width,
        height: height,
        layers: layers,
        layerFilter: layerFilter,
        mode: 'pickObjects',
        // TODO - how does this interact with multiple viewports?
        viewport: this.context.viewport,
        viewports: this.getViewports(),
        onViewportActive: this._activateViewport.bind(this),
        pickingFBO: this._getPickingBuffer(),
        useDevicePixels: useDevicePixels
      });
    }

    //
    // DEPRECATED METHODS in V5
    //

  }, {
    key: 'updateLayers',
    value: function updateLayers(_ref8) {
      var newLayers = _ref8.newLayers;

      _log2.default.deprecated('updateLayers', 'setLayers');
      this.setLayers(newLayers);
    }
  }, {
    key: 'setViewport',
    value: function setViewport(viewport) {
      _log2.default.deprecated('setViewport', 'setViewports');
      this.setViewports([viewport]);
      return this;
    }

    //
    // PRIVATE METHODS
    //

  }, {
    key: '_checkIfNeedsRedraw',
    value: function _checkIfNeedsRedraw(clearRedrawFlags) {
      var redraw = this._needsRedraw;
      if (clearRedrawFlags) {
        this._needsRedraw = false;
      }

      // This layers list doesn't include sublayers, relying on composite layers
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = this.layers[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var layer = _step2.value;

          // Call every layer to clear their flags
          var layerNeedsRedraw = layer.getNeedsRedraw({ clearRedrawFlags: clearRedrawFlags });
          redraw = redraw || layerNeedsRedraw;
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      return redraw;
    }

    // Rebuilds viewports from descriptors towards a certain window size

  }, {
    key: '_rebuildViewportsFromViews',
    value: function _rebuildViewportsFromViews(_ref9) {
      var _this = this;

      var viewDescriptors = _ref9.viewDescriptors,
          width = _ref9.width,
          height = _ref9.height;

      var newViewports = viewDescriptors.map(function (viewDescriptor) {
        return (
          // If a `Viewport` instance was supplied, use it, otherwise build it
          viewDescriptor.viewport instanceof _viewport2.default ? viewDescriptor.viewport : _this._makeViewportFromViewDescriptor({ viewDescriptor: viewDescriptor, width: width, height: height })
        );
      });

      this.setNeedsRedraw('Viewport(s) changed');

      // Ensure one viewport is activated, layers may expect it
      // TODO - handle empty viewport list (using dummy viewport), or assert
      // const oldViewports = this.context.viewports;
      // if (viewportsChanged) {

      var viewport = newViewports[0];
      (0, _assert2.default)(viewport instanceof _viewport2.default, 'Invalid viewport');

      this.context.viewports = newViewports;
      this._activateViewport(viewport);
      // }

      // We've just rebuilt the viewports to match the descriptors, so clear the flag
      this.viewports = newViewports;
      this.viewDescriptorsChanged = false;
    }

    // Build a `Viewport` from a view descriptor
    // TODO - add support for autosizing viewports using width and height

  }, {
    key: '_makeViewportFromViewDescriptor',
    value: function _makeViewportFromViewDescriptor(_ref10) {
      var viewDescriptor = _ref10.viewDescriptor,
          width = _ref10.width,
          height = _ref10.height;

      // Get the type of the viewport
      // TODO - default to WebMercator?
      var ViewportType = viewDescriptor.type,
          viewState = viewDescriptor.viewState;

      // Resolve relative viewport dimensions
      // TODO - we need to have width and height available

      var viewportDimensions = this._getViewDimensions({ viewDescriptor: viewDescriptor });

      // Create the viewport, giving preference to view state in `viewState`
      return new ViewportType(Object.assign({}, viewDescriptor, viewportDimensions, viewState // Object.assign handles undefined
      ));
    }

    // Check if viewport array has changed, returns true if any change
    // Note that descriptors can be the same

  }, {
    key: '_diffViews',
    value: function _diffViews(newViews, oldViews) {
      var _this2 = this;

      if (newViews.length !== oldViews.length) {
        return true;
      }

      return newViews.some(function (_, i) {
        return _this2._diffView(newViews[i], oldViews[i]);
      });
    }
  }, {
    key: '_diffView',
    value: function _diffView(newView, oldView) {
      // `View` hiearchy supports an `equals` method
      if (newView.viewport) {
        return !oldView.viewport || !newView.viewport.equals(oldView.viewport);
      }
      // TODO - implement deep equal on view descriptors
      return newView !== oldView;
    }

    // Support for relative viewport dimensions (e.g {y: '50%', height: '50%'})

  }, {
    key: '_getViewDimensions',
    value: function _getViewDimensions(_ref11) {
      var viewDescriptor = _ref11.viewDescriptor,
          width = _ref11.width,
          height = _ref11.height;

      var parsePercent = function parsePercent(value, max) {
        return value;
      };
      // TODO - enable to support percent size specifiers
      // const parsePercent = (value, max) => value ?
      //   Math.round(parseFloat(value) / 100 * max) :
      //   (value === null ? max : value);

      return {
        x: parsePercent(viewDescriptor.x, width),
        y: parsePercent(viewDescriptor.y, height),
        width: parsePercent(viewDescriptor.width, width),
        height: parsePercent(viewDescriptor.height, height)
      };
    }

    /**
     * @param {Object} eventManager   A source of DOM input events
     */

  }, {
    key: '_initEventHandling',
    value: function _initEventHandling(eventManager) {
      this._eventManager = eventManager;

      // TODO: add/remove handlers on demand at runtime, not all at once on init.
      // Consider both top-level handlers like onLayerClick/Hover
      // and per-layer handlers attached to individual layers.
      // https://github.com/uber/deck.gl/issues/634
      this._eventManager.on({
        click: this._onClick,
        pointermove: this._onPointerMove,
        pointerleave: this._onPointerLeave
      });
    }

    // Set parameters for input event handling.

  }, {
    key: '_setEventHandlingParameters',
    value: function _setEventHandlingParameters(_ref12) {
      var pickingRadius = _ref12.pickingRadius,
          onLayerClick = _ref12.onLayerClick,
          onLayerHover = _ref12.onLayerHover;

      if (!isNaN(pickingRadius)) {
        this._pickingRadius = pickingRadius;
      }
      if (typeof onLayerClick !== 'undefined') {
        this._onLayerClick = onLayerClick;
      }
      if (typeof onLayerHover !== 'undefined') {
        this._onLayerHover = onLayerHover;
      }
      this._validateEventHandling();
    }

    // Make a viewport "current" in layer context, primed for draw

  }, {
    key: '_activateViewport',
    value: function _activateViewport(viewport) {
      // TODO - viewport change detection breaks METER_OFFSETS mode
      // const oldViewport = this.context.viewport;
      // const viewportChanged = !oldViewport || !viewport.equals(oldViewport);
      var viewportChanged = true;

      if (viewportChanged) {
        Object.assign(this.oldContext, this.context);
        this.context.viewport = viewport;
        this.context.viewportChanged = true;
        this.context.uniforms = {};
        (0, _log2.default)(4, viewport);

        // Update layers states
        // Let screen space layers update their state based on viewport
        // TODO - reimplement viewport change detection (single viewport optimization)
        // TODO - don't set viewportChanged during setViewports?
        if (this.context.viewportChanged) {
          var _iteratorNormalCompletion3 = true;
          var _didIteratorError3 = false;
          var _iteratorError3 = undefined;

          try {
            for (var _iterator3 = this.layers[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
              var layer = _step3.value;

              layer.setChangeFlags({ viewportChanged: 'Viewport changed' });
              this._updateLayer(layer);
            }
          } catch (err) {
            _didIteratorError3 = true;
            _iteratorError3 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion3 && _iterator3.return) {
                _iterator3.return();
              }
            } finally {
              if (_didIteratorError3) {
                throw _iteratorError3;
              }
            }
          }
        }
      }

      (0, _assert2.default)(this.context.viewport, 'LayerManager: viewport not set');

      return this;
    }
  }, {
    key: '_getPickingBuffer',
    value: function _getPickingBuffer() {
      var gl = this.context.gl;
      // Create a frame buffer if not already available

      this.context.pickingFBO = this.context.pickingFBO || new _luma.Framebuffer(gl);
      // Resize it to current canvas size (this is a noop if size hasn't changed)
      this.context.pickingFBO.resize({ width: gl.canvas.width, height: gl.canvas.height });
      return this.context.pickingFBO;
    }

    // Match all layers, checking for caught errors
    // To avoid having an exception in one layer disrupt other layers
    // TODO - mark layers with exceptions as bad and remove from rendering cycle?

  }, {
    key: '_updateLayers',
    value: function _updateLayers(_ref13) {
      var oldLayers = _ref13.oldLayers,
          newLayers = _ref13.newLayers;

      // Create old layer map
      var oldLayerMap = {};
      var _iteratorNormalCompletion4 = true;
      var _didIteratorError4 = false;
      var _iteratorError4 = undefined;

      try {
        for (var _iterator4 = oldLayers[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
          var oldLayer = _step4.value;

          if (oldLayerMap[oldLayer.id]) {
            _log2.default.warn('Multiple old layers with same id ' + layerName(oldLayer));
          } else {
            oldLayerMap[oldLayer.id] = oldLayer;
          }
        }

        // Allocate array for generated layers
      } catch (err) {
        _didIteratorError4 = true;
        _iteratorError4 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion4 && _iterator4.return) {
            _iterator4.return();
          }
        } finally {
          if (_didIteratorError4) {
            throw _iteratorError4;
          }
        }
      }

      var generatedLayers = [];

      // Match sublayers
      var error = this._updateSublayersRecursively({
        newLayers: newLayers,
        oldLayerMap: oldLayerMap,
        generatedLayers: generatedLayers
      });

      // Finalize unmatched layers
      var error2 = this._finalizeOldLayers(oldLayerMap);

      var firstError = error || error2;
      return { error: firstError, generatedLayers: generatedLayers };
    }

    // Note: adds generated layers to `generatedLayers` array parameter

  }, {
    key: '_updateSublayersRecursively',
    value: function _updateSublayersRecursively(_ref14) {
      var newLayers = _ref14.newLayers,
          oldLayerMap = _ref14.oldLayerMap,
          generatedLayers = _ref14.generatedLayers;

      var error = null;

      var _iteratorNormalCompletion5 = true;
      var _didIteratorError5 = false;
      var _iteratorError5 = undefined;

      try {
        for (var _iterator5 = newLayers[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
          var newLayer = _step5.value;

          newLayer.context = this.context;

          // Given a new coming layer, find its matching old layer (if any)
          var oldLayer = oldLayerMap[newLayer.id];
          if (oldLayer === null) {
            // null, rather than undefined, means this id was originally there
            _log2.default.warn('Multiple new layers with same id ' + layerName(newLayer));
          }
          // Remove the old layer from candidates, as it has been matched with this layer
          oldLayerMap[newLayer.id] = null;

          var sublayers = null;

          // We must not generate exceptions until after layer matching is complete
          try {
            if (!oldLayer) {
              this._initializeLayer(newLayer);
              (0, _seerIntegration.initLayerInSeer)(newLayer); // Initializes layer in seer chrome extension (if connected)
            } else {
              this._transferLayerState(oldLayer, newLayer);
              this._updateLayer(newLayer);
              (0, _seerIntegration.updateLayerInSeer)(newLayer); // Updates layer in seer chrome extension (if connected)
            }
            generatedLayers.push(newLayer);

            // Call layer lifecycle method: render sublayers
            sublayers = newLayer.isComposite && newLayer.getSubLayers();
            // End layer lifecycle method: render sublayers
          } catch (err) {
            _log2.default.warn('error during matching of ' + layerName(newLayer), err);
            error = error || err; // Record first exception
          }

          if (sublayers) {
            this._updateSublayersRecursively({
              newLayers: sublayers,
              oldLayerMap: oldLayerMap,
              generatedLayers: generatedLayers
            });
          }
        }
      } catch (err) {
        _didIteratorError5 = true;
        _iteratorError5 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion5 && _iterator5.return) {
            _iterator5.return();
          }
        } finally {
          if (_didIteratorError5) {
            throw _iteratorError5;
          }
        }
      }

      return error;
    }

    // Finalize any old layers that were not matched

  }, {
    key: '_finalizeOldLayers',
    value: function _finalizeOldLayers(oldLayerMap) {
      var error = null;
      for (var layerId in oldLayerMap) {
        var layer = oldLayerMap[layerId];
        if (layer) {
          error = error || this._finalizeLayer(layer);
        }
      }
      return error;
    }

    // Initializes a single layer, calling layer methods

  }, {
    key: '_initializeLayer',
    value: function _initializeLayer(layer) {
      (0, _assert2.default)(!layer.state);
      (0, _log2.default)(LOG_PRIORITY_LIFECYCLE, 'initializing ' + layerName(layer));

      var error = null;
      try {
        layer._initialize();
        layer.lifecycle = _constants.LIFECYCLE.INITIALIZED;
      } catch (err) {
        _log2.default.warn('error while initializing ' + layerName(layer) + '\n', err);
        error = error || err;
        // TODO - what should the lifecycle state be here? LIFECYCLE.INITIALIZATION_FAILED?
      }

      (0, _assert2.default)(layer.state);

      // Set back pointer (used in picking)
      layer.state.layer = layer;

      // Save layer on model for picking purposes
      // store on model.userData rather than directly on model
      var _iteratorNormalCompletion6 = true;
      var _didIteratorError6 = false;
      var _iteratorError6 = undefined;

      try {
        for (var _iterator6 = layer.getModels()[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
          var model = _step6.value;

          model.userData.layer = layer;
        }
      } catch (err) {
        _didIteratorError6 = true;
        _iteratorError6 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion6 && _iterator6.return) {
            _iterator6.return();
          }
        } finally {
          if (_didIteratorError6) {
            throw _iteratorError6;
          }
        }
      }

      return error;
    }
  }, {
    key: '_transferLayerState',
    value: function _transferLayerState(oldLayer, newLayer) {
      if (newLayer !== oldLayer) {
        (0, _log2.default)(LOG_PRIORITY_LIFECYCLE_MINOR, 'matched ' + layerName(newLayer), oldLayer, '->', newLayer);
        newLayer.lifecycle = _constants.LIFECYCLE.MATCHED;
        oldLayer.lifecycle = _constants.LIFECYCLE.AWAITING_GC;
        newLayer._transferState(oldLayer);
      } else {
        _log2.default.log(LOG_PRIORITY_LIFECYCLE_MINOR, 'Matching layer is unchanged ' + newLayer.id);
        newLayer.lifecycle = _constants.LIFECYCLE.MATCHED;
        newLayer.oldProps = newLayer.props;
      }
    }

    // Updates a single layer, cleaning all flags

  }, {
    key: '_updateLayer',
    value: function _updateLayer(layer) {
      _log2.default.log(LOG_PRIORITY_LIFECYCLE_MINOR, 'updating ' + layer + ' because: ' + layer.printChangeFlags());
      var error = null;
      try {
        layer._update();
      } catch (err) {
        _log2.default.warn('error during update of ' + layerName(layer), err);
        // Save first error
        error = err;
      }
      return error;
    }

    // Finalizes a single layer

  }, {
    key: '_finalizeLayer',
    value: function _finalizeLayer(layer) {
      (0, _assert2.default)(layer.state);
      (0, _assert2.default)(layer.lifecycle !== _constants.LIFECYCLE.AWAITING_FINALIZATION);
      layer.lifecycle = _constants.LIFECYCLE.AWAITING_FINALIZATION;
      var error = null;
      this.setNeedsRedraw('finalized ' + layerName(layer));
      try {
        layer._finalize();
      } catch (err) {
        _log2.default.warn('error during finalization of ' + layerName(layer), err);
        error = err;
      }
      layer.lifecycle = _constants.LIFECYCLE.FINALIZED;
      (0, _log2.default)(LOG_PRIORITY_LIFECYCLE, 'finalizing ' + layerName(layer));
      return error;
    }

    /**
     * Warn if a deck-level mouse event has been specified,
     * but no layers are `pickable`.
     */

  }, {
    key: '_validateEventHandling',
    value: function _validateEventHandling() {
      if (this.onLayerClick || this.onLayerHover) {
        if (this.layers.length && !this.layers.some(function (layer) {
          return layer.props.pickable;
        })) {
          _log2.default.warn('You have supplied a top-level input event handler (e.g. `onLayerClick`), ' + 'but none of your layers have set the `pickable` flag.');
        }
      }
    }

    /**
     * Route click events to layers.
     * `pickLayer` will call the `onClick` prop of any picked layer,
     * and `onLayerClick` is called directly from here
     * with any picking info generated by `pickLayer`.
     * @param {Object} event  An object encapsulating an input event,
     *                        with the following shape:
     *                        {Object: {x, y}} offsetCenter: center of the event
     *                        {Object} srcEvent:             native JS Event object
     */

  }, {
    key: '_onClick',
    value: function _onClick(event) {
      if (!event.offsetCenter) {
        // Do not trigger onHover callbacks when click position is invalid.
        return;
      }
      this._pickAndCallback({
        callback: this._onLayerClick,
        event: event,
        mode: 'click'
      });
    }

    /**
     * Route click events to layers.
     * `pickLayer` will call the `onHover` prop of any picked layer,
     * and `onLayerHover` is called directly from here
     * with any picking info generated by `pickLayer`.
     * @param {Object} event  An object encapsulating an input event,
     *                        with the following shape:
     *                        {Object: {x, y}} offsetCenter: center of the event
     *                        {Object} srcEvent:             native JS Event object
     */

  }, {
    key: '_onPointerMove',
    value: function _onPointerMove(event) {
      if (event.isDown) {
        // Do not trigger onHover callbacks if mouse button is down.
        return;
      }
      this._pickAndCallback({
        callback: this._onLayerHover,
        event: event,
        mode: 'hover'
      });
    }
  }, {
    key: '_onPointerLeave',
    value: function _onPointerLeave(event) {
      this.pickObject({
        x: -1,
        y: -1,
        radius: this._pickingRadius,
        mode: 'hover'
      });
    }
  }, {
    key: '_pickAndCallback',
    value: function _pickAndCallback(options) {
      var pos = options.event.offsetCenter;
      var radius = this._pickingRadius;
      var selectedInfos = this.pickObject({ x: pos.x, y: pos.y, radius: radius, mode: options.mode });
      if (options.callback) {
        var firstInfo = selectedInfos.find(function (info) {
          return info.index >= 0;
        }) || null;
        // As per documentation, send null value when no valid object is picked.
        options.callback(firstInfo, selectedInfos, options.event.srcEvent);
      }
    }

    // SEER INTEGRATION

    /**
     * Called upon Seer initialization, manually sends layers data.
     */

  }, {
    key: '_initSeer',
    value: function _initSeer() {
      this.layers.forEach(function (layer) {
        (0, _seerIntegration.initLayerInSeer)(layer);
        (0, _seerIntegration.updateLayerInSeer)(layer);
      });
    }

    /**
     * On Seer property edition, set override and update layers.
     */

  }, {
    key: '_editSeer',
    value: function _editSeer(payload) {
      if (payload.type !== 'edit' || payload.valuePath[0] !== 'props') {
        return;
      }

      (0, _seerIntegration.setPropOverrides)(payload.itemKey, payload.valuePath.slice(1), payload.value);
      var newLayers = this.layers.map(function (layer) {
        return new layer.constructor(layer.props);
      });
      this.updateLayers({ newLayers: newLayers });
    }
  }]);

  return LayerManager;
}();

exports.default = LayerManager;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9jb3JlL2xpYi9sYXllci1tYW5hZ2VyLmpzIl0sIm5hbWVzIjpbIkxPR19QUklPUklUWV9MSUZFQ1lDTEUiLCJMT0dfUFJJT1JJVFlfTElGRUNZQ0xFX01JTk9SIiwiaW5pdGlhbENvbnRleHQiLCJ1bmlmb3JtcyIsInZpZXdwb3J0cyIsInZpZXdwb3J0IiwibGF5ZXJGaWx0ZXIiLCJ2aWV3cG9ydENoYW5nZWQiLCJwaWNraW5nRkJPIiwidXNlRGV2aWNlUGl4ZWxzIiwibGFzdFBpY2tlZEluZm8iLCJpbmRleCIsImxheWVySWQiLCJsYXllck5hbWUiLCJsYXllciIsIkxheWVyTWFuYWdlciIsImdsIiwiZXZlbnRNYW5hZ2VyIiwibGFzdFJlbmRlcmVkTGF5ZXJzIiwicHJldkxheWVycyIsImxheWVycyIsIm9sZENvbnRleHQiLCJjb250ZXh0IiwiT2JqZWN0IiwiYXNzaWduIiwic2hhZGVyQ2FjaGUiLCJfY2FjaGVQcm9ncmFtcyIsIndpZHRoIiwiaGVpZ2h0Iiwidmlld0Rlc2NyaXB0b3JzIiwidmlld0Rlc2NyaXB0b3JzQ2hhbmdlZCIsIl9uZWVkc1JlZHJhdyIsIl9waWNraW5nUmFkaXVzIiwiX2V2ZW50TWFuYWdlciIsIl9vbkxheWVyQ2xpY2siLCJfb25MYXllckhvdmVyIiwiX29uQ2xpY2siLCJiaW5kIiwiX29uUG9pbnRlck1vdmUiLCJfb25Qb2ludGVyTGVhdmUiLCJfcGlja0FuZENhbGxiYWNrIiwiX2luaXRTZWVyIiwiX2VkaXRTZWVyIiwic2VhbCIsIl9pbml0RXZlbnRIYW5kbGluZyIsInNldFZpZXdwb3J0cyIsImxhdGl0dWRlIiwibG9uZ2l0dWRlIiwiem9vbSIsInJlbW92ZUxpc3RlbmVyIiwiY2xlYXJSZWRyYXdGbGFncyIsIl9jaGVja0lmTmVlZHNSZWRyYXciLCJyZWFzb24iLCJsYXllcklkcyIsImZpbHRlciIsImZpbmQiLCJpZCIsImluZGV4T2YiLCJfcmVidWlsZFZpZXdwb3J0c0Zyb21WaWV3cyIsInBhcmFtZXRlcnMiLCJfc2V0RXZlbnRIYW5kbGluZ1BhcmFtZXRlcnMiLCJzZXRMYXllcnMiLCJzZXROZWVkc1JlZHJhdyIsImRyYXdQaWNraW5nQ29sb3JzIiwiQm9vbGVhbiIsIm1hcCIsIl9kaWZmVmlld3MiLCJuZXdMYXllcnMiLCJsb2ciLCJfdXBkYXRlTGF5ZXJzIiwib2xkTGF5ZXJzIiwiZXJyb3IiLCJnZW5lcmF0ZWRMYXllcnMiLCJwYXNzIiwicmVkcmF3UmVhc29uIiwiZ2V0Vmlld3BvcnRzIiwib25WaWV3cG9ydEFjdGl2ZSIsIl9hY3RpdmF0ZVZpZXdwb3J0IiwieCIsInkiLCJtb2RlIiwicmFkaXVzIiwiZ2V0TGF5ZXJzIiwiX2dldFBpY2tpbmdCdWZmZXIiLCJkZXByZWNhdGVkIiwicmVkcmF3IiwibGF5ZXJOZWVkc1JlZHJhdyIsImdldE5lZWRzUmVkcmF3IiwibmV3Vmlld3BvcnRzIiwidmlld0Rlc2NyaXB0b3IiLCJfbWFrZVZpZXdwb3J0RnJvbVZpZXdEZXNjcmlwdG9yIiwiVmlld3BvcnRUeXBlIiwidHlwZSIsInZpZXdTdGF0ZSIsInZpZXdwb3J0RGltZW5zaW9ucyIsIl9nZXRWaWV3RGltZW5zaW9ucyIsIm5ld1ZpZXdzIiwib2xkVmlld3MiLCJsZW5ndGgiLCJzb21lIiwiXyIsImkiLCJfZGlmZlZpZXciLCJuZXdWaWV3Iiwib2xkVmlldyIsImVxdWFscyIsInBhcnNlUGVyY2VudCIsInZhbHVlIiwibWF4Iiwib24iLCJjbGljayIsInBvaW50ZXJtb3ZlIiwicG9pbnRlcmxlYXZlIiwicGlja2luZ1JhZGl1cyIsIm9uTGF5ZXJDbGljayIsIm9uTGF5ZXJIb3ZlciIsImlzTmFOIiwiX3ZhbGlkYXRlRXZlbnRIYW5kbGluZyIsInNldENoYW5nZUZsYWdzIiwiX3VwZGF0ZUxheWVyIiwicmVzaXplIiwiY2FudmFzIiwib2xkTGF5ZXJNYXAiLCJvbGRMYXllciIsIndhcm4iLCJfdXBkYXRlU3VibGF5ZXJzUmVjdXJzaXZlbHkiLCJlcnJvcjIiLCJfZmluYWxpemVPbGRMYXllcnMiLCJmaXJzdEVycm9yIiwibmV3TGF5ZXIiLCJzdWJsYXllcnMiLCJfaW5pdGlhbGl6ZUxheWVyIiwiX3RyYW5zZmVyTGF5ZXJTdGF0ZSIsInB1c2giLCJpc0NvbXBvc2l0ZSIsImdldFN1YkxheWVycyIsImVyciIsIl9maW5hbGl6ZUxheWVyIiwic3RhdGUiLCJfaW5pdGlhbGl6ZSIsImxpZmVjeWNsZSIsIklOSVRJQUxJWkVEIiwiZ2V0TW9kZWxzIiwibW9kZWwiLCJ1c2VyRGF0YSIsIk1BVENIRUQiLCJBV0FJVElOR19HQyIsIl90cmFuc2ZlclN0YXRlIiwib2xkUHJvcHMiLCJwcm9wcyIsInByaW50Q2hhbmdlRmxhZ3MiLCJfdXBkYXRlIiwiQVdBSVRJTkdfRklOQUxJWkFUSU9OIiwiX2ZpbmFsaXplIiwiRklOQUxJWkVEIiwicGlja2FibGUiLCJldmVudCIsIm9mZnNldENlbnRlciIsImNhbGxiYWNrIiwiaXNEb3duIiwicGlja09iamVjdCIsIm9wdGlvbnMiLCJwb3MiLCJzZWxlY3RlZEluZm9zIiwiZmlyc3RJbmZvIiwiaW5mbyIsInNyY0V2ZW50IiwiZm9yRWFjaCIsInBheWxvYWQiLCJ2YWx1ZVBhdGgiLCJpdGVtS2V5Iiwic2xpY2UiLCJjb25zdHJ1Y3RvciIsInVwZGF0ZUxheWVycyJdLCJtYXBwaW5ncyI6Ijs7Ozs7O3FqQkFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFVQTs7O0FBUkE7Ozs7QUFDQTs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7Ozs7QUFFQTs7OztBQUNBOzs7O0FBQ0E7O0FBRUE7Ozs7OztBQVFBLElBQU1BLHlCQUF5QixDQUEvQjtBQUNBLElBQU1DLCtCQUErQixDQUFyQzs7QUFFQSxJQUFNQyxpQkFBaUI7QUFDckJDLFlBQVUsRUFEVztBQUVyQkMsYUFBVyxFQUZVO0FBR3JCQyxZQUFVLElBSFc7QUFJckJDLGVB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SixPQUFaLENBQW9CLGlCQUFTO0FBQzNCLDhDQUFnQnpKLEtBQWhCO0FBQ0EsZ0RBQWtCQSxLQUFsQjtBQUNELE9BSEQ7QUFJRDs7QUFFRDs7Ozs7OzhCQUdVMEosTyxFQUFTO0FBQ2pCLFVBQUlBLFFBQVE1RSxJQUFSLEtBQWlCLE1BQWpCLElBQTJCNEUsUUFBUUMsU0FBUixDQUFrQixDQUFsQixNQUF5QixPQUF4RCxFQUFpRTtBQUMvRDtBQUNEOztBQUVELDZDQUFpQkQsUUFBUUUsT0FBekIsRUFBa0NGLFFBQVFDLFNBQVIsQ0FBa0JFLEtBQWxCLENBQXdCLENBQXhCLENBQWxDLEVBQThESCxRQUFRN0QsS0FBdEU7QUFDQSxVQUFNeEMsWUFBWSxLQUFLL0MsTUFBTCxDQUFZNkMsR0FBWixDQUFnQjtBQUFBLGVBQVMsSUFBSW5ELE1BQU04SixXQUFWLENBQXNCOUosTUFBTXVJLEtBQTVCLENBQVQ7QUFBQSxPQUFoQixDQUFsQjtBQUNBLFdBQUt3QixZQUFMLENBQWtCLEVBQUMxRyxvQkFBRCxFQUFsQjtBQUNEOzs7Ozs7a0JBMXNCa0JwRCxZIiwiZmlsZSI6ImxheWVyLW1hbmFnZXIuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIDIwMTUgLSAyMDE3IFViZXIgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbi8vIFRIRSBTT0ZUV0FSRS5cblxuaW1wb3J0IGFzc2VydCBmcm9tICdhc3NlcnQnO1xuaW1wb3J0IHtGcmFtZWJ1ZmZlciwgU2hhZGVyQ2FjaGV9IGZyb20gJ2x1bWEuZ2wnO1xuaW1wb3J0IHNlZXIgZnJvbSAnc2Vlcic7XG5pbXBvcnQgTGF5ZXIgZnJvbSAnLi9sYXllcic7XG5pbXBvcnQge2RyYXdMYXllcnN9IGZyb20gJy4vZHJhdy1sYXllcnMnO1xuaW1wb3J0IHtwaWNrT2JqZWN0LCBwaWNrVmlzaWJsZU9iamVjdHN9IGZyb20gJy4vcGljay1sYXllcnMnO1xuaW1wb3J0IHtMSUZFQ1lDTEV9IGZyb20gJy4vY29uc3RhbnRzJztcbmltcG9ydCBWaWV3cG9ydCBmcm9tICcuLi92aWV3cG9ydHMvdmlld3BvcnQnO1xuLy8gVE9ETyAtIHJlbW92ZSwganVzdCBmb3IgZHVtbXkgaW5pdGlhbGl6YXRpb25cbmltcG9ydCBXZWJNZXJjYXRvclZpZXdwb3J0IGZyb20gJy4uL3ZpZXdwb3J0cy93ZWItbWVyY2F0b3Itdmlld3BvcnQnO1xuaW1wb3J0IGxvZyBmcm9tICcuLi91dGlscy9sb2cnO1xuaW1wb3J0IHtmbGF0dGVufSBmcm9tICcuLi91dGlscy9mbGF0dGVuJztcblxuaW1wb3J0IHtcbiAgc2V0UHJvcE92ZXJyaWRlcyxcbiAgbGF5ZXJFZGl0TGlzdGVuZXIsXG4gIHNlZXJJbml0TGlzdGVuZXIsXG4gIGluaXRMYXllckluU2VlcixcbiAgdXBkYXRlTGF5ZXJJblNlZXJcbn0gZnJvbSAnLi9zZWVyLWludGVncmF0aW9uJztcblxuY29uc3QgTE9HX1BSSU9SSVRZX0xJRkVDWUNMRSA9IDI7XG5jb25zdCBMT0dfUFJJT1JJVFlfTElGRUNZQ0xFX01JTk9SID0gNDtcblxuY29uc3QgaW5pdGlhbENvbnRleHQgPSB7XG4gIHVuaWZvcm1zOiB7fSxcbiAgdmlld3BvcnRzOiBbXSxcbiAgdmlld3BvcnQ6IG51bGwsXG4gIGxheWVyRmlsdGVyOiBudWxsLFxuICB2aWV3cG9ydENoYW5nZWQ6IHRydWUsXG4gIHBpY2tpbmdGQk86IG51bGwsXG4gIHVzZURldmljZVBpeGVsczogdHJ1ZSxcbiAgbGFzdFBpY2tlZEluZm86IHtcbiAgICBpbmRleDogLTEsXG4gICAgbGF5ZXJJZDogbnVsbFxuICB9XG59O1xuXG5jb25zdCBsYXllck5hbWUgPSBsYXllciA9PiAobGF5ZXIgaW5zdGFuY2VvZiBMYXllciA/IGAke2xheWVyfWAgOiAhbGF5ZXIgPyAnbnVsbCcgOiAnaW52YWxpZCcpO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMYXllck1hbmFnZXIge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgY29uc3RydWN0b3IoZ2wsIHtldmVudE1hbmFnZXJ9ID0ge30pIHtcbiAgICAvLyBDdXJyZW50bHkgZGVjay5nbCBleHBlY3RzIHRoZSBEZWNrR0wubGF5ZXJzIGFycmF5IHRvIGJlIGRpZmZlcmVudFxuICAgIC8vIHdoZW5ldmVyIFJlYWN0IHJlcmVuZGVycy4gSWYgdGhlIHNhbWUgbGF5ZXJzIGFycmF5IGlzIHVzZWQsIHRoZVxuICAgIC8vIExheWVyTWFuYWdlcidzIGRpZmZpbmcgYWxnb3JpdGhtIHdpbGwgZ2VuZXJhdGUgYSBmYXRhbCBlcnJvciBhbmRcbiAgICAvLyBicmVhayB0aGUgcmVuZGVyaW5nLlxuXG4gICAgLy8gYHRoaXMubGFzdFJlbmRlcmVkTGF5ZXJzYCBzdG9yZXMgdGhlIFVORklMVEVSRUQgbGF5ZXJzIHNlbnRcbiAgICAvLyBkb3duIHRvIExheWVyTWFuYWdlciwgc28gdGhhdCBgbGF5ZXJzYCByZWZlcmVuY2UgY2FuIGJlIGNvbXBhcmVkLlxuICAgIC8vIElmIGl0J3MgdGhlIHNhbWUgYWNyb3NzIHR3byBSZWFjdCByZW5kZXIgY2FsbHMsIHRoZSBkaWZmaW5nIGxvZ2ljXG4gICAgLy8gd2lsbCBiZSBza2lwcGVkLlxuICAgIHRoaXMubGFzdFJlbmRlcmVkTGF5ZXJzID0gW107XG4gICAgdGhpcy5wcmV2TGF5ZXJzID0gW107XG4gICAgdGhpcy5sYXllcnMgPSBbXTtcblxuICAgIHRoaXMub2xkQ29udGV4dCA9IHt9O1xuICAgIHRoaXMuY29udGV4dCA9IE9iamVjdC5hc3NpZ24oe30sIGluaXRpYWxDb250ZXh0LCB7XG4gICAgICBnbCxcbiAgICAgIC8vIEVuYWJsaW5nIGx1bWEuZ2wgUHJvZ3JhbSBjYWNoaW5nIHVzaW5nIHByaXZhdGUgQVBJIChfY2FjaGVQcm9ncmFtcylcbiAgICAgIHNoYWRlckNhY2hlOiBuZXcgU2hhZGVyQ2FjaGUoe2dsLCBfY2FjaGVQcm9ncmFtczogdHJ1ZX0pXG4gICAgfSk7XG5cbiAgICAvLyBMaXN0IG9mIHZpZXcgZGVzY3JpcHRvcnMsIGdldHMgcmUtZXZhbHVhdGVkIHdoZW4gd2lkdGgvaGVpZ2h0IGNoYW5nZXNcbiAgICB0aGlzLndpZHRoID0gMTAwO1xuICAgIHRoaXMuaGVpZ2h0ID0gMTAwO1xuICAgIHRoaXMudmlld0Rlc2NyaXB0b3JzID0gW107XG4gICAgdGhpcy52aWV3RGVzY3JpcHRvcnNDaGFuZ2VkID0gdHJ1ZTtcbiAgICB0aGlzLnZpZXdwb3J0cyA9IFtdOyAvLyBHZW5lcmF0ZWQgdmlld3BvcnRzXG4gICAgdGhpcy5fbmVlZHNSZWRyYXcgPSAnSW5pdGlhbCByZW5kZXInO1xuXG4gICAgLy8gRXZlbnQgaGFuZGxpbmdcbiAgICB0aGlzLl9waWNraW5nUmFkaXVzID0gMDtcblxuICAgIHRoaXMuX2V2ZW50TWFuYWdlciA9IG51bGw7XG4gICAgdGhpcy5fb25MYXllckNsaWNrID0gbnVsbDtcbiAgICB0aGlzLl9vbkxheWVySG92ZXIgPSBudWxsO1xuICAgIHRoaXMuX29uQ2xpY2sgPSB0aGlzLl9vbkNsaWNrLmJpbmQodGhpcyk7XG4gICAgdGhpcy5fb25Qb2ludGVyTW92ZSA9IHRoaXMuX29uUG9pbnRlck1vdmUuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9vblBvaW50ZXJMZWF2ZSA9IHRoaXMuX29uUG9pbnRlckxlYXZlLmJpbmQodGhpcyk7XG4gICAgdGhpcy5fcGlja0FuZENhbGxiYWNrID0gdGhpcy5fcGlja0FuZENhbGxiYWNrLmJpbmQodGhpcyk7XG5cbiAgICAvLyBTZWVyIGludGVncmF0aW9uXG4gICAgdGhpcy5faW5pdFNlZXIgPSB0aGlzLl9pbml0U2Vlci5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX2VkaXRTZWVyID0gdGhpcy5fZWRpdFNlZXIuYmluZCh0aGlzKTtcbiAgICBzZWVySW5pdExpc3RlbmVyKHRoaXMuX2luaXRTZWVyKTtcbiAgICBsYXllckVkaXRMaXN0ZW5lcih0aGlzLl9lZGl0U2Vlcik7XG5cbiAgICBPYmplY3Quc2VhbCh0aGlzKTtcblxuICAgIGlmIChldmVudE1hbmFnZXIpIHtcbiAgICAgIHRoaXMuX2luaXRFdmVudEhhbmRsaW5nKGV2ZW50TWFuYWdlcik7XG4gICAgfVxuXG4gICAgLy8gSW5pdCB3aXRoIGR1bW15IHZpZXdwb3J0XG4gICAgdGhpcy5zZXRWaWV3cG9ydHMoW1xuICAgICAgbmV3IFdlYk1lcmNhdG9yVmlld3BvcnQoe3dpZHRoOiAxLCBoZWlnaHQ6IDEsIGxhdGl0dWRlOiAwLCBsb25naXR1ZGU6IDAsIHpvb206IDF9KVxuICAgIF0pO1xuICB9XG5cbiAgLyoqXG4gICAqIE1ldGhvZCB0byBjYWxsIHdoZW4gdGhlIGxheWVyIG1hbmFnZXIgaXMgbm90IG5lZWRlZCBhbnltb3JlLlxuICAgKlxuICAgKiBDdXJyZW50bHkgdXNlZCBpbiB0aGUgPERlY2tHTD4gY29tcG9uZW50V2lsbFVubW91bnQgbGlmZWN5Y2xlIHRvIHVuYmluZCBTZWVyIGxpc3RlbmVycy5cbiAgICovXG4gIGZpbmFsaXplKCkge1xuICAgIHNlZXIucmVtb3ZlTGlzdGVuZXIodGhpcy5faW5pdFNlZXIpO1xuICAgIHNlZXIucmVtb3ZlTGlzdGVuZXIodGhpcy5fZWRpdFNlZXIpO1xuICB9XG5cbiAgbmVlZHNSZWRyYXcoe2NsZWFyUmVkcmF3RmxhZ3MgPSB0cnVlfSA9IHt9KSB7XG4gICAgcmV0dXJuIHRoaXMuX2NoZWNrSWZOZWVkc1JlZHJhdyhjbGVhclJlZHJhd0ZsYWdzKTtcbiAgfVxuXG4gIC8vIE5vcm1hbGx5IG5vdCBjYWxsZWQgYnkgYXBwXG4gIHNldE5lZWRzUmVkcmF3KHJlYXNvbikge1xuICAgIHRoaXMuX25lZWRzUmVkcmF3ID0gdGhpcy5fbmVlZHNSZWRyYXcgfHwgcmVhc29uO1xuICB9XG5cbiAgLy8gR2V0cyBhbiAob3B0aW9uYWxseSkgZmlsdGVyZWQgbGlzdCBvZiBsYXllcnNcbiAgZ2V0TGF5ZXJzKHtsYXllcklkcyA9IG51bGx9ID0ge30pIHtcbiAgICAvLyBGaWx0ZXJpbmcgYnkgbGF5ZXJJZCBjb21wYXJlcyBiZWdpbm5pbmcgb2Ygc3RyaW5ncywgc28gdGhhdCBzdWJsYXllcnMgd2lsbCBiZSBpbmNsdWRlZFxuICAgIC8vIERlcGVuZGVzIG9uIHRoZSBjb252ZW50aW9uIG9mIGFkZGluZyBzdWZmaXhlcyB0byB0aGUgcGFyZW50J3MgbGF5ZXIgbmFtZVxuICAgIHJldHVybiBsYXllcklkc1xuICAgICAgPyB0aGlzLmxheWVycy5maWx0ZXIobGF5ZXIgPT4gbGF5ZXJJZHMuZmluZChsYXllcklkID0+IGxheWVyLmlkLmluZGV4T2YobGF5ZXJJZCkgPT09IDApKVxuICAgICAgOiB0aGlzLmxheWVycztcbiAgfVxuXG4gIC8vIEdldCBhIHNldCBvZiB2aWV3cG9ydHMgZm9yIGEgZ2l2ZW4gd2lkdGggYW5kIGhlaWdodFxuICAvLyBUT0RPIC0gSW50ZW50aW9uIGlzIGZvciBkZWNrLmdsIHRvIGF1dG9kZWR1Y2Ugd2lkdGggYW5kIGhlaWdodCBhbmQgZHJvcCB0aGUgbmVlZCBmb3IgcHJvcHNcbiAgZ2V0Vmlld3BvcnRzKHt3aWR0aCwgaGVpZ2h0fSA9IHt9KSB7XG4gICAgaWYgKHdpZHRoICE9PSB0aGlzLndpZHRoIHx8IGhlaWdodCAhPT0gdGhpcy5oZWlnaHQgfHwgdGhpcy52aWV3RGVzY3JpcHRvcnNDaGFuZ2VkKSB7XG4gICAgICB0aGlzLl9yZWJ1aWxkVmlld3BvcnRzRnJvbVZpZXdzKHt2aWV3RGVzY3JpcHRvcnM6IHRoaXMudmlld0Rlc2NyaXB0b3JzLCB3aWR0aCwgaGVpZ2h0fSk7XG4gICAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMudmlld3BvcnRzO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCBwYXJhbWV0ZXJzIG5lZWRlZCBmb3IgbGF5ZXIgcmVuZGVyaW5nIGFuZCBwaWNraW5nLlxuICAgKiBQYXJhbWV0ZXJzIGFyZSB0byBiZSBwYXNzZWQgYXMgYSBzaW5nbGUgb2JqZWN0LCB3aXRoIHRoZSBmb2xsb3dpbmcgdmFsdWVzOlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IHVzZURldmljZVBpeGVsc1xuICAgKi9cbiAgc2V0UGFyYW1ldGVycyhwYXJhbWV0ZXJzKSB7XG4gICAgaWYgKCdldmVudE1hbmFnZXInIGluIHBhcmFtZXRlcnMpIHtcbiAgICAgIHRoaXMuX2luaXRFdmVudEhhbmRsaW5nKHBhcmFtZXRlcnMuZXZlbnRNYW5hZ2VyKTtcbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICAncGlja2luZ1JhZGl1cycgaW4gcGFyYW1ldGVycyB8fFxuICAgICAgJ29uTGF5ZXJDbGljaycgaW4gcGFyYW1ldGVycyB8fFxuICAgICAgJ29uTGF5ZXJIb3ZlcicgaW4gcGFyYW1ldGVyc1xuICAgICkge1xuICAgICAgdGhpcy5fc2V0RXZlbnRIYW5kbGluZ1BhcmFtZXRlcnMocGFyYW1ldGVycyk7XG4gICAgfVxuXG4gICAgLy8gVE9ETyAtIEZvciBub3cgd2Ugc2V0IGxheWVycyBiZWZvcmUgdmlld3BvcnRzIHRvIHByZXNlcnZlbmNoYW5nZUZsYWdzXG4gICAgaWYgKCdsYXllcnMnIGluIHBhcmFtZXRlcnMpIHtcbiAgICAgIHRoaXMuc2V0TGF5ZXJzKHBhcmFtZXRlcnMubGF5ZXJzKTtcbiAgICB9XG5cbiAgICBpZiAoJ3ZpZXdwb3J0cycgaW4gcGFyYW1ldGVycykge1xuICAgICAgdGhpcy5zZXRWaWV3cG9ydHMocGFyYW1ldGVycy52aWV3cG9ydHMpO1xuICAgIH1cblxuICAgIGlmICgnbGF5ZXJGaWx0ZXInIGluIHBhcmFtZXRlcnMpIHtcbiAgICAgIHRoaXMuY29udGV4dC5sYXllckZpbHRlciA9IHBhcmFtZXRlcnMubGF5ZXJGaWx0ZXI7XG4gICAgICBpZiAodGhpcy5jb250ZXh0LmxheWVyRmlsdGVyICE9PSBwYXJhbWV0ZXJzLmxheWVyRmlsdGVyKSB7XG4gICAgICAgIHRoaXMuc2V0TmVlZHNSZWRyYXcoJ2xheWVyRmlsdGVyIGNoYW5nZWQnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoJ2RyYXdQaWNraW5nQ29sb3JzJyBpbiBwYXJhbWV0ZXJzKSB7XG4gICAgICBpZiAodGhpcy5jb250ZXh0LmRyYXdQaWNraW5nQ29sb3JzICE9PSBwYXJhbWV0ZXJzLmRyYXdQaWNraW5nQ29sb3JzKSB7XG4gICAgICAgIHRoaXMuc2V0TmVlZHNSZWRyYXcoJ2RyYXdQaWNraW5nQ29sb3JzIGNoYW5nZWQnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBPYmplY3QuYXNzaWduKHRoaXMuY29udGV4dCwgcGFyYW1ldGVycyk7XG4gIH1cblxuICAvLyBVcGRhdGUgdGhlIHZpZXcgZGVzY3JpcHRvciBsaXN0IGFuZCBzZXQgY2hhbmdlIGZsYWcgaWYgbmVlZGVkXG4gIHNldFZpZXdwb3J0cyh2aWV3cG9ydHMpIHtcbiAgICAvLyBFbnN1cmUgdmlld3BvcnRzIGFyZSB3cmFwcGVkIGluIGRlc2NyaXB0b3JzXG4gICAgY29uc3Qgdmlld0Rlc2NyaXB0b3JzID0gZmxhdHRlbih2aWV3cG9ydHMsIHtmaWx0ZXI6IEJvb2xlYW59KS5tYXAoXG4gICAgICB2aWV3cG9ydCA9PiAodmlld3BvcnQgaW5zdGFuY2VvZiBWaWV3cG9ydCA/IHt2aWV3cG9ydH0gOiB2aWV3cG9ydClcbiAgICApO1xuXG4gICAgdGhpcy52aWV3RGVzY3JpcHRvcnNDaGFuZ2VkID1cbiAgICAgIHRoaXMudmlld0Rlc2NyaXB0b3JzQ2hhbmdlZCB8fCB0aGlzLl9kaWZmVmlld3Modmlld0Rlc2NyaXB0b3JzLCB0aGlzLnZpZXdEZXNjcmlwdG9ycyk7XG5cbiAgICAvLyBUcnkgdG8gbm90IGFjdHVhbGx5IHJlYnVpbGQgdGhlIHZpZXdwb3J0cyB1bnRpbCBgZ2V0Vmlld3BvcnRzYCBpcyBjYWxsZWRcbiAgICBpZiAodGhpcy52aWV3RGVzY3JpcHRvcnNDaGFuZ2VkKSB7XG4gICAgICB0aGlzLnZpZXdEZXNjcmlwdG9ycyA9IHZpZXdEZXNjcmlwdG9ycztcbiAgICAgIHRoaXMuX3JlYnVpbGRWaWV3cG9ydHNGcm9tVmlld3Moe3ZpZXdEZXNjcmlwdG9yczogdGhpcy52aWV3RGVzY3JpcHRvcnN9KTtcbiAgICAgIHRoaXMudmlld0Rlc2NyaXB0b3JzQ2hhbmdlZCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIC8vIFN1cHBseSBhIG5ldyBsYXllciBsaXN0LCBpbml0aWF0aW5nIHN1YmxheWVyIGdlbmVyYXRpb24gYW5kIGxheWVyIG1hdGNoaW5nXG4gIHNldExheWVycyhuZXdMYXllcnMpIHtcbiAgICBhc3NlcnQodGhpcy5jb250ZXh0LnZpZXdwb3J0LCAnTGF5ZXJNYW5hZ2VyLnVwZGF0ZUxheWVyczogdmlld3BvcnQgbm90IHNldCcpO1xuXG4gICAgLy8gVE9ETyAtIHNvbWV0aGluZyBpcyBnZW5lcmF0aW5nIHN0YXRlIHVwZGF0ZXMgdGhhdCBjYXVzZSByZXJlbmRlciBvZiB0aGUgc2FtZVxuICAgIGlmIChuZXdMYXllcnMgPT09IHRoaXMubGFzdFJlbmRlcmVkTGF5ZXJzKSB7XG4gICAgICBsb2cubG9nKDMsICdJZ25vcmluZyBsYXllciB1cGRhdGUgZHVlIHRvIGxheWVyIGFycmF5IG5vdCBjaGFuZ2VkJyk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdGhpcy5sYXN0UmVuZGVyZWRMYXllcnMgPSBuZXdMYXllcnM7XG5cbiAgICBuZXdMYXllcnMgPSBmbGF0dGVuKG5ld0xheWVycywge2ZpbHRlcjogQm9vbGVhbn0pO1xuXG4gICAgZm9yIChjb25zdCBsYXllciBvZiBuZXdMYXllcnMpIHtcbiAgICAgIGxheWVyLmNvbnRleHQgPSB0aGlzLmNvbnRleHQ7XG4gICAgfVxuXG4gICAgdGhpcy5wcmV2TGF5ZXJzID0gdGhpcy5sYXllcnM7XG4gICAgY29uc3Qge2Vycm9yLCBnZW5lcmF0ZWRMYXllcnN9ID0gdGhpcy5fdXBkYXRlTGF5ZXJzKHtcbiAgICAgIG9sZExheWVyczogdGhpcy5wcmV2TGF5ZXJzLFxuICAgICAgbmV3TGF5ZXJzXG4gICAgfSk7XG5cbiAgICB0aGlzLmxheWVycyA9IGdlbmVyYXRlZExheWVycztcbiAgICAvLyBUaHJvdyBmaXJzdCBlcnJvciBmb3VuZCwgaWYgYW55XG4gICAgaWYgKGVycm9yKSB7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBkcmF3TGF5ZXJzKHtwYXNzID0gJ3JlbmRlciB0byBzY3JlZW4nLCByZWRyYXdSZWFzb24gPSAndW5rbm93biByZWFzb24nfSA9IHt9KSB7XG4gICAgY29uc3Qge2dsLCB1c2VEZXZpY2VQaXhlbHMsIGRyYXdQaWNraW5nQ29sb3JzfSA9IHRoaXMuY29udGV4dDtcblxuICAgIC8vIHJlbmRlciB0aGlzIHZpZXdwb3J0XG4gICAgZHJhd0xheWVycyhnbCwge1xuICAgICAgbGF5ZXJzOiB0aGlzLmxheWVycyxcbiAgICAgIHZpZXdwb3J0czogdGhpcy5nZXRWaWV3cG9ydHMoKSxcbiAgICAgIG9uVmlld3BvcnRBY3RpdmU6IHRoaXMuX2FjdGl2YXRlVmlld3BvcnQuYmluZCh0aGlzKSxcbiAgICAgIHVzZURldmljZVBpeGVscyxcbiAgICAgIGRyYXdQaWNraW5nQ29sb3JzLFxuICAgICAgcGFzcyxcbiAgICAgIGxheWVyRmlsdGVyOiB0aGlzLmNvbnRleHQubGF5ZXJGaWx0ZXIsXG4gICAgICByZWRyYXdSZWFzb25cbiAgICB9KTtcbiAgfVxuXG4gIC8vIFBpY2sgdGhlIGNsb3Nlc3QgaW5mbyBhdCBnaXZlbiBjb29yZGluYXRlXG4gIHBpY2tPYmplY3Qoe3gsIHksIG1vZGUsIHJhZGl1cyA9IDAsIGxheWVySWRzLCBsYXllckZpbHRlcn0pIHtcbiAgICBjb25zdCB7Z2wsIHVzZURldmljZVBpeGVsc30gPSB0aGlzLmNvbnRleHQ7XG5cbiAgICBjb25zdCBsYXllcnMgPSB0aGlzLmdldExheWVycyh7bGF5ZXJJZHN9KTtcblxuICAgIHJldHVybiBwaWNrT2JqZWN0KGdsLCB7XG4gICAgICAvLyBVc2VyIHBhcmFtc1xuICAgICAgeCxcbiAgICAgIHksXG4gICAgICByYWRpdXMsXG4gICAgICBsYXllcnMsXG4gICAgICBtb2RlLFxuICAgICAgbGF5ZXJGaWx0ZXIsXG4gICAgICAvLyBJbmplY3RlZCBwYXJhbXNcbiAgICAgIHZpZXdwb3J0czogdGhpcy5nZXRWaWV3cG9ydHMoKSxcbiAgICAgIG9uVmlld3BvcnRBY3RpdmU6IHRoaXMuX2FjdGl2YXRlVmlld3BvcnQuYmluZCh0aGlzKSxcbiAgICAgIHBpY2tpbmdGQk86IHRoaXMuX2dldFBpY2tpbmdCdWZmZXIoKSxcbiAgICAgIGxhc3RQaWNrZWRJbmZvOiB0aGlzLmNvbnRleHQubGFzdFBpY2tlZEluZm8sXG4gICAgICB1c2VEZXZpY2VQaXhlbHNcbiAgICB9KTtcbiAgfVxuXG4gIC8vIEdldCBhbGwgdW5pcXVlIGluZm9zIHdpdGhpbiBhIGJvdW5kaW5nIGJveFxuICBwaWNrT2JqZWN0cyh7eCwgeSwgd2lkdGgsIGhlaWdodCwgbGF5ZXJJZHMsIGxheWVyRmlsdGVyfSkge1xuICAgIGNvbnN0IHtnbCwgdXNlRGV2aWNlUGl4ZWxzfSA9IHRoaXMuY29udGV4dDtcblxuICAgIGNvbnN0IGxheWVycyA9IHRoaXMuZ2V0TGF5ZXJzKHtsYXllcklkc30pO1xuXG4gICAgcmV0dXJuIHBpY2tWaXNpYmxlT2JqZWN0cyhnbCwge1xuICAgICAgeCxcbiAgICAgIHksXG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodCxcbiAgICAgIGxheWVycyxcbiAgICAgIGxheWVyRmlsdGVyLFxuICAgICAgbW9kZTogJ3BpY2tPYmplY3RzJyxcbiAgICAgIC8vIFRPRE8gLSBob3cgZG9lcyB0aGlzIGludGVyYWN0IHdpdGggbXVsdGlwbGUgdmlld3BvcnRzP1xuICAgICAgdmlld3BvcnQ6IHRoaXMuY29udGV4dC52aWV3cG9ydCxcbiAgICAgIHZpZXdwb3J0czogdGhpcy5nZXRWaWV3cG9ydHMoKSxcbiAgICAgIG9uVmlld3BvcnRBY3RpdmU6IHRoaXMuX2FjdGl2YXRlVmlld3BvcnQuYmluZCh0aGlzKSxcbiAgICAgIHBpY2tpbmdGQk86IHRoaXMuX2dldFBpY2tpbmdCdWZmZXIoKSxcbiAgICAgIHVzZURldmljZVBpeGVsc1xuICAgIH0pO1xuICB9XG5cbiAgLy9cbiAgLy8gREVQUkVDQVRFRCBNRVRIT0RTIGluIFY1XG4gIC8vXG5cbiAgdXBkYXRlTGF5ZXJzKHtuZXdMYXllcnN9KSB7XG4gICAgbG9nLmRlcHJlY2F0ZWQoJ3VwZGF0ZUxheWVycycsICdzZXRMYXllcnMnKTtcbiAgICB0aGlzLnNldExheWVycyhuZXdMYXllcnMpO1xuICB9XG5cbiAgc2V0Vmlld3BvcnQodmlld3BvcnQpIHtcbiAgICBsb2cuZGVwcmVjYXRlZCgnc2V0Vmlld3BvcnQnLCAnc2V0Vmlld3BvcnRzJyk7XG4gICAgdGhpcy5zZXRWaWV3cG9ydHMoW3ZpZXdwb3J0XSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvL1xuICAvLyBQUklWQVRFIE1FVEhPRFNcbiAgLy9cblxuICBfY2hlY2tJZk5lZWRzUmVkcmF3KGNsZWFyUmVkcmF3RmxhZ3MpIHtcbiAgICBsZXQgcmVkcmF3ID0gdGhpcy5fbmVlZHNSZWRyYXc7XG4gICAgaWYgKGNsZWFyUmVkcmF3RmxhZ3MpIHtcbiAgICAgIHRoaXMuX25lZWRzUmVkcmF3ID0gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gVGhpcyBsYXllcnMgbGlzdCBkb2Vzbid0IGluY2x1ZGUgc3VibGF5ZXJzLCByZWx5aW5nIG9uIGNvbXBvc2l0ZSBsYXllcnNcbiAgICBmb3IgKGNvbnN0IGxheWVyIG9mIHRoaXMubGF5ZXJzKSB7XG4gICAgICAvLyBDYWxsIGV2ZXJ5IGxheWVyIHRvIGNsZWFyIHRoZWlyIGZsYWdzXG4gICAgICBjb25zdCBsYXllck5lZWRzUmVkcmF3ID0gbGF5ZXIuZ2V0TmVlZHNSZWRyYXcoe2NsZWFyUmVkcmF3RmxhZ3N9KTtcbiAgICAgIHJlZHJhdyA9IHJlZHJhdyB8fCBsYXllck5lZWRzUmVkcmF3O1xuICAgIH1cblxuICAgIHJldHVybiByZWRyYXc7XG4gIH1cblxuICAvLyBSZWJ1aWxkcyB2aWV3cG9ydHMgZnJvbSBkZXNjcmlwdG9ycyB0b3dhcmRzIGEgY2VydGFpbiB3aW5kb3cgc2l6ZVxuICBfcmVidWlsZFZpZXdwb3J0c0Zyb21WaWV3cyh7dmlld0Rlc2NyaXB0b3JzLCB3aWR0aCwgaGVpZ2h0fSkge1xuICAgIGNvbnN0IG5ld1ZpZXdwb3J0cyA9IHZpZXdEZXNjcmlwdG9ycy5tYXAoXG4gICAgICB2aWV3RGVzY3JpcHRvciA9PlxuICAgICAgICAvLyBJZiBhIGBWaWV3cG9ydGAgaW5zdGFuY2Ugd2FzIHN1cHBsaWVkLCB1c2UgaXQsIG90aGVyd2lzZSBidWlsZCBpdFxuICAgICAgICB2aWV3RGVzY3JpcHRvci52aWV3cG9ydCBpbnN0YW5jZW9mIFZpZXdwb3J0XG4gICAgICAgICAgPyB2aWV3RGVzY3JpcHRvci52aWV3cG9ydFxuICAgICAgICAgIDogdGhpcy5fbWFrZVZpZXdwb3J0RnJvbVZpZXdEZXNjcmlwdG9yKHt2aWV3RGVzY3JpcHRvciwgd2lkdGgsIGhlaWdodH0pXG4gICAgKTtcblxuICAgIHRoaXMuc2V0TmVlZHNSZWRyYXcoJ1ZpZXdwb3J0KHMpIGNoYW5nZWQnKTtcblxuICAgIC8vIEVuc3VyZSBvbmUgdmlld3BvcnQgaXMgYWN0aXZhdGVkLCBsYXllcnMgbWF5IGV4cGVjdCBpdFxuICAgIC8vIFRPRE8gLSBoYW5kbGUgZW1wdHkgdmlld3BvcnQgbGlzdCAodXNpbmcgZHVtbXkgdmlld3BvcnQpLCBvciBhc3NlcnRcbiAgICAvLyBjb25zdCBvbGRWaWV3cG9ydHMgPSB0aGlzLmNvbnRleHQudmlld3BvcnRzO1xuICAgIC8vIGlmICh2aWV3cG9ydHNDaGFuZ2VkKSB7XG5cbiAgICBjb25zdCB2aWV3cG9ydCA9IG5ld1ZpZXdwb3J0c1swXTtcbiAgICBhc3NlcnQodmlld3BvcnQgaW5zdGFuY2VvZiBWaWV3cG9ydCwgJ0ludmFsaWQgdmlld3BvcnQnKTtcblxuICAgIHRoaXMuY29udGV4dC52aWV3cG9ydHMgPSBuZXdWaWV3cG9ydHM7XG4gICAgdGhpcy5fYWN0aXZhdGVWaWV3cG9ydCh2aWV3cG9ydCk7XG4gICAgLy8gfVxuXG4gICAgLy8gV2UndmUganVzdCByZWJ1aWx0IHRoZSB2aWV3cG9ydHMgdG8gbWF0Y2ggdGhlIGRlc2NyaXB0b3JzLCBzbyBjbGVhciB0aGUgZmxhZ1xuICAgIHRoaXMudmlld3BvcnRzID0gbmV3Vmlld3BvcnRzO1xuICAgIHRoaXMudmlld0Rlc2NyaXB0b3JzQ2hhbmdlZCA9IGZhbHNlO1xuICB9XG5cbiAgLy8gQnVpbGQgYSBgVmlld3BvcnRgIGZyb20gYSB2aWV3IGRlc2NyaXB0b3JcbiAgLy8gVE9ETyAtIGFkZCBzdXBwb3J0IGZvciBhdXRvc2l6aW5nIHZpZXdwb3J0cyB1c2luZyB3aWR0aCBhbmQgaGVpZ2h0XG4gIF9tYWtlVmlld3BvcnRGcm9tVmlld0Rlc2NyaXB0b3Ioe3ZpZXdEZXNjcmlwdG9yLCB3aWR0aCwgaGVpZ2h0fSkge1xuICAgIC8vIEdldCB0aGUgdHlwZSBvZiB0aGUgdmlld3BvcnRcbiAgICAvLyBUT0RPIC0gZGVmYXVsdCB0byBXZWJNZXJjYXRvcj9cbiAgICBjb25zdCB7dHlwZTogVmlld3BvcnRUeXBlLCB2aWV3U3RhdGV9ID0gdmlld0Rlc2NyaXB0b3I7XG5cbiAgICAvLyBSZXNvbHZlIHJlbGF0aXZlIHZpZXdwb3J0IGRpbWVuc2lvbnNcbiAgICAvLyBUT0RPIC0gd2UgbmVlZCB0byBoYXZlIHdpZHRoIGFuZCBoZWlnaHQgYXZhaWxhYmxlXG4gICAgY29uc3Qgdmlld3BvcnREaW1lbnNpb25zID0gdGhpcy5fZ2V0Vmlld0RpbWVuc2lvbnMoe3ZpZXdEZXNjcmlwdG9yfSk7XG5cbiAgICAvLyBDcmVhdGUgdGhlIHZpZXdwb3J0LCBnaXZpbmcgcHJlZmVyZW5jZSB0byB2aWV3IHN0YXRlIGluIGB2aWV3U3RhdGVgXG4gICAgcmV0dXJuIG5ldyBWaWV3cG9ydFR5cGUoXG4gICAgICBPYmplY3QuYXNzaWduKFxuICAgICAgICB7fSxcbiAgICAgICAgdmlld0Rlc2NyaXB0b3IsXG4gICAgICAgIHZpZXdwb3J0RGltZW5zaW9ucyxcbiAgICAgICAgdmlld1N0YXRlIC8vIE9iamVjdC5hc3NpZ24gaGFuZGxlcyB1bmRlZmluZWRcbiAgICAgIClcbiAgICApO1xuICB9XG5cbiAgLy8gQ2hlY2sgaWYgdmlld3BvcnQgYXJyYXkgaGFzIGNoYW5nZWQsIHJldHVybnMgdHJ1ZSBpZiBhbnkgY2hhbmdlXG4gIC8vIE5vdGUgdGhhdCBkZXNjcmlwdG9ycyBjYW4gYmUgdGhlIHNhbWVcbiAgX2RpZmZWaWV3cyhuZXdWaWV3cywgb2xkVmlld3MpIHtcbiAgICBpZiAobmV3Vmlld3MubGVuZ3RoICE9PSBvbGRWaWV3cy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBuZXdWaWV3cy5zb21lKChfLCBpKSA9PiB0aGlzLl9kaWZmVmlldyhuZXdWaWV3c1tpXSwgb2xkVmlld3NbaV0pKTtcbiAgfVxuXG4gIF9kaWZmVmlldyhuZXdWaWV3LCBvbGRWaWV3KSB7XG4gICAgLy8gYFZpZXdgIGhpZWFyY2h5IHN1cHBvcnRzIGFuIGBlcXVhbHNgIG1ldGhvZFxuICAgIGlmIChuZXdWaWV3LnZpZXdwb3J0KSB7XG4gICAgICByZXR1cm4gIW9sZFZpZXcudmlld3BvcnQgfHwgIW5ld1ZpZXcudmlld3BvcnQuZXF1YWxzKG9sZFZpZXcudmlld3BvcnQpO1xuICAgIH1cbiAgICAvLyBUT0RPIC0gaW1wbGVtZW50IGRlZXAgZXF1YWwgb24gdmlldyBkZXNjcmlwdG9yc1xuICAgIHJldHVybiBuZXdWaWV3ICE9PSBvbGRWaWV3O1xuICB9XG5cbiAgLy8gU3VwcG9ydCBmb3IgcmVsYXRpdmUgdmlld3BvcnQgZGltZW5zaW9ucyAoZS5nIHt5OiAnNTAlJywgaGVpZ2h0OiAnNTAlJ30pXG4gIF9nZXRWaWV3RGltZW5zaW9ucyh7dmlld0Rlc2NyaXB0b3IsIHdpZHRoLCBoZWlnaHR9KSB7XG4gICAgY29uc3QgcGFyc2VQZXJjZW50ID0gKHZhbHVlLCBtYXgpID0+IHZhbHVlO1xuICAgIC8vIFRPRE8gLSBlbmFibGUgdG8gc3VwcG9ydCBwZXJjZW50IHNpemUgc3BlY2lmaWVyc1xuICAgIC8vIGNvbnN0IHBhcnNlUGVyY2VudCA9ICh2YWx1ZSwgbWF4KSA9PiB2YWx1ZSA/XG4gICAgLy8gICBNYXRoLnJvdW5kKHBhcnNlRmxvYXQodmFsdWUpIC8gMTAwICogbWF4KSA6XG4gICAgLy8gICAodmFsdWUgPT09IG51bGwgPyBtYXggOiB2YWx1ZSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgeDogcGFyc2VQZXJjZW50KHZpZXdEZXNjcmlwdG9yLngsIHdpZHRoKSxcbiAgICAgIHk6IHBhcnNlUGVyY2VudCh2aWV3RGVzY3JpcHRvci55LCBoZWlnaHQpLFxuICAgICAgd2lkdGg6IHBhcnNlUGVyY2VudCh2aWV3RGVzY3JpcHRvci53aWR0aCwgd2lkdGgpLFxuICAgICAgaGVpZ2h0OiBwYXJzZVBlcmNlbnQodmlld0Rlc2NyaXB0b3IuaGVpZ2h0LCBoZWlnaHQpXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnRNYW5hZ2VyICAgQSBzb3VyY2Ugb2YgRE9NIGlucHV0IGV2ZW50c1xuICAgKi9cbiAgX2luaXRFdmVudEhhbmRsaW5nKGV2ZW50TWFuYWdlcikge1xuICAgIHRoaXMuX2V2ZW50TWFuYWdlciA9IGV2ZW50TWFuYWdlcjtcblxuICAgIC8vIFRPRE86IGFkZC9yZW1vdmUgaGFuZGxlcnMgb24gZGVtYW5kIGF0IHJ1bnRpbWUsIG5vdCBhbGwgYXQgb25jZSBvbiBpbml0LlxuICAgIC8vIENvbnNpZGVyIGJvdGggdG9wLWxldmVsIGhhbmRsZXJzIGxpa2Ugb25MYXllckNsaWNrL0hvdmVyXG4gICAgLy8gYW5kIHBlci1sYXllciBoYW5kbGVycyBhdHRhY2hlZCB0byBpbmRpdmlkdWFsIGxheWVycy5cbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vdWJlci9kZWNrLmdsL2lzc3Vlcy82MzRcbiAgICB0aGlzLl9ldmVudE1hbmFnZXIub24oe1xuICAgICAgY2xpY2s6IHRoaXMuX29uQ2xpY2ssXG4gICAgICBwb2ludGVybW92ZTogdGhpcy5fb25Qb2ludGVyTW92ZSxcbiAgICAgIHBvaW50ZXJsZWF2ZTogdGhpcy5fb25Qb2ludGVyTGVhdmVcbiAgICB9KTtcbiAgfVxuXG4gIC8vIFNldCBwYXJhbWV0ZXJzIGZvciBpbnB1dCBldmVudCBoYW5kbGluZy5cbiAgX3NldEV2ZW50SGFuZGxpbmdQYXJhbWV0ZXJzKHtwaWNraW5nUmFkaXVzLCBvbkxheWVyQ2xpY2ssIG9uTGF5ZXJIb3Zlcn0pIHtcbiAgICBpZiAoIWlzTmFOKHBpY2tpbmdSYWRpdXMpKSB7XG4gICAgICB0aGlzLl9waWNraW5nUmFkaXVzID0gcGlja2luZ1JhZGl1cztcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvbkxheWVyQ2xpY2sgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aGlzLl9vbkxheWVyQ2xpY2sgPSBvbkxheWVyQ2xpY2s7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb25MYXllckhvdmVyICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhpcy5fb25MYXllckhvdmVyID0gb25MYXllckhvdmVyO1xuICAgIH1cbiAgICB0aGlzLl92YWxpZGF0ZUV2ZW50SGFuZGxpbmcoKTtcbiAgfVxuXG4gIC8vIE1ha2UgYSB2aWV3cG9ydCBcImN1cnJlbnRcIiBpbiBsYXllciBjb250ZXh0LCBwcmltZWQgZm9yIGRyYXdcbiAgX2FjdGl2YXRlVmlld3BvcnQodmlld3BvcnQpIHtcbiAgICAvLyBUT0RPIC0gdmlld3BvcnQgY2hhbmdlIGRldGVjdGlvbiBicmVha3MgTUVURVJfT0ZGU0VUUyBtb2RlXG4gICAgLy8gY29uc3Qgb2xkVmlld3BvcnQgPSB0aGlzLmNvbnRleHQudmlld3BvcnQ7XG4gICAgLy8gY29uc3Qgdmlld3BvcnRDaGFuZ2VkID0gIW9sZFZpZXdwb3J0IHx8ICF2aWV3cG9ydC5lcXVhbHMob2xkVmlld3BvcnQpO1xuICAgIGNvbnN0IHZpZXdwb3J0Q2hhbmdlZCA9IHRydWU7XG5cbiAgICBpZiAodmlld3BvcnRDaGFuZ2VkKSB7XG4gICAgICBPYmplY3QuYXNzaWduKHRoaXMub2xkQ29udGV4dCwgdGhpcy5jb250ZXh0KTtcbiAgICAgIHRoaXMuY29udGV4dC52aWV3cG9ydCA9IHZpZXdwb3J0O1xuICAgICAgdGhpcy5jb250ZXh0LnZpZXdwb3J0Q2hhbmdlZCA9IHRydWU7XG4gICAgICB0aGlzLmNvbnRleHQudW5pZm9ybXMgPSB7fTtcbiAgICAgIGxvZyg0LCB2aWV3cG9ydCk7XG5cbiAgICAgIC8vIFVwZGF0ZSBsYXllcnMgc3RhdGVzXG4gICAgICAvLyBMZXQgc2NyZWVuIHNwYWNlIGxheWVycyB1cGRhdGUgdGhlaXIgc3RhdGUgYmFzZWQgb24gdmlld3BvcnRcbiAgICAgIC8vIFRPRE8gLSByZWltcGxlbWVudCB2aWV3cG9ydCBjaGFuZ2UgZGV0ZWN0aW9uIChzaW5nbGUgdmlld3BvcnQgb3B0aW1pemF0aW9uKVxuICAgICAgLy8gVE9ETyAtIGRvbid0IHNldCB2aWV3cG9ydENoYW5nZWQgZHVyaW5nIHNldFZpZXdwb3J0cz9cbiAgICAgIGlmICh0aGlzLmNvbnRleHQudmlld3BvcnRDaGFuZ2VkKSB7XG4gICAgICAgIGZvciAoY29uc3QgbGF5ZXIgb2YgdGhpcy5sYXllcnMpIHtcbiAgICAgICAgICBsYXllci5zZXRDaGFuZ2VGbGFncyh7dmlld3BvcnRDaGFuZ2VkOiAnVmlld3BvcnQgY2hhbmdlZCd9KTtcbiAgICAgICAgICB0aGlzLl91cGRhdGVMYXllcihsYXllcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBhc3NlcnQodGhpcy5jb250ZXh0LnZpZXdwb3J0LCAnTGF5ZXJNYW5hZ2VyOiB2aWV3cG9ydCBub3Qgc2V0Jyk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIF9nZXRQaWNraW5nQnVmZmVyKCkge1xuICAgIGNvbnN0IHtnbH0gPSB0aGlzLmNvbnRleHQ7XG4gICAgLy8gQ3JlYXRlIGEgZnJhbWUgYnVmZmVyIGlmIG5vdCBhbHJlYWR5IGF2YWlsYWJsZVxuICAgIHRoaXMuY29udGV4dC5waWNraW5nRkJPID0gdGhpcy5jb250ZXh0LnBpY2tpbmdGQk8gfHwgbmV3IEZyYW1lYnVmZmVyKGdsKTtcbiAgICAvLyBSZXNpemUgaXQgdG8gY3VycmVudCBjYW52YXMgc2l6ZSAodGhpcyBpcyBhIG5vb3AgaWYgc2l6ZSBoYXNuJ3QgY2hhbmdlZClcbiAgICB0aGlzLmNvbnRleHQucGlja2luZ0ZCTy5yZXNpemUoe3dpZHRoOiBnbC5jYW52YXMud2lkdGgsIGhlaWdodDogZ2wuY2FudmFzLmhlaWdodH0pO1xuICAgIHJldHVybiB0aGlzLmNvbnRleHQucGlja2luZ0ZCTztcbiAgfVxuXG4gIC8vIE1hdGNoIGFsbCBsYXllcnMsIGNoZWNraW5nIGZvciBjYXVnaHQgZXJyb3JzXG4gIC8vIFRvIGF2b2lkIGhhdmluZyBhbiBleGNlcHRpb24gaW4gb25lIGxheWVyIGRpc3J1cHQgb3RoZXIgbGF5ZXJzXG4gIC8vIFRPRE8gLSBtYXJrIGxheWVycyB3aXRoIGV4Y2VwdGlvbnMgYXMgYmFkIGFuZCByZW1vdmUgZnJvbSByZW5kZXJpbmcgY3ljbGU/XG4gIF91cGRhdGVMYXllcnMoe29sZExheWVycywgbmV3TGF5ZXJzfSkge1xuICAgIC8vIENyZWF0ZSBvbGQgbGF5ZXIgbWFwXG4gICAgY29uc3Qgb2xkTGF5ZXJNYXAgPSB7fTtcbiAgICBmb3IgKGNvbnN0IG9sZExheWVyIG9mIG9sZExheWVycykge1xuICAgICAgaWYgKG9sZExheWVyTWFwW29sZExheWVyLmlkXSkge1xuICAgICAgICBsb2cud2FybihgTXVsdGlwbGUgb2xkIGxheWVycyB3aXRoIHNhbWUgaWQgJHtsYXllck5hbWUob2xkTGF5ZXIpfWApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb2xkTGF5ZXJNYXBbb2xkTGF5ZXIuaWRdID0gb2xkTGF5ZXI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQWxsb2NhdGUgYXJyYXkgZm9yIGdlbmVyYXRlZCBsYXllcnNcbiAgICBjb25zdCBnZW5lcmF0ZWRMYXllcnMgPSBbXTtcblxuICAgIC8vIE1hdGNoIHN1YmxheWVyc1xuICAgIGNvbnN0IGVycm9yID0gdGhpcy5fdXBkYXRlU3VibGF5ZXJzUmVjdXJzaXZlbHkoe1xuICAgICAgbmV3TGF5ZXJzLFxuICAgICAgb2xkTGF5ZXJNYXAsXG4gICAgICBnZW5lcmF0ZWRMYXllcnNcbiAgICB9KTtcblxuICAgIC8vIEZpbmFsaXplIHVubWF0Y2hlZCBsYXllcnNcbiAgICBjb25zdCBlcnJvcjIgPSB0aGlzLl9maW5hbGl6ZU9sZExheWVycyhvbGRMYXllck1hcCk7XG5cbiAgICBjb25zdCBmaXJzdEVycm9yID0gZXJyb3IgfHwgZXJyb3IyO1xuICAgIHJldHVybiB7ZXJyb3I6IGZpcnN0RXJyb3IsIGdlbmVyYXRlZExheWVyc307XG4gIH1cblxuICAvLyBOb3RlOiBhZGRzIGdlbmVyYXRlZCBsYXllcnMgdG8gYGdlbmVyYXRlZExheWVyc2AgYXJyYXkgcGFyYW1ldGVyXG4gIF91cGRhdGVTdWJsYXllcnNSZWN1cnNpdmVseSh7bmV3TGF5ZXJzLCBvbGRMYXllck1hcCwgZ2VuZXJhdGVkTGF5ZXJzfSkge1xuICAgIGxldCBlcnJvciA9IG51bGw7XG5cbiAgICBmb3IgKGNvbnN0IG5ld0xheWVyIG9mIG5ld0xheWVycykge1xuICAgICAgbmV3TGF5ZXIuY29udGV4dCA9IHRoaXMuY29udGV4dDtcblxuICAgICAgLy8gR2l2ZW4gYSBuZXcgY29taW5nIGxheWVyLCBmaW5kIGl0cyBtYXRjaGluZyBvbGQgbGF5ZXIgKGlmIGFueSlcbiAgICAgIGNvbnN0IG9sZExheWVyID0gb2xkTGF5ZXJNYXBbbmV3TGF5ZXIuaWRdO1xuICAgICAgaWYgKG9sZExheWVyID09PSBudWxsKSB7XG4gICAgICAgIC8vIG51bGwsIHJhdGhlciB0aGFuIHVuZGVmaW5lZCwgbWVhbnMgdGhpcyBpZCB3YXMgb3JpZ2luYWxseSB0aGVyZVxuICAgICAgICBsb2cud2FybihgTXVsdGlwbGUgbmV3IGxheWVycyB3aXRoIHNhbWUgaWQgJHtsYXllck5hbWUobmV3TGF5ZXIpfWApO1xuICAgICAgfVxuICAgICAgLy8gUmVtb3ZlIHRoZSBvbGQgbGF5ZXIgZnJvbSBjYW5kaWRhdGVzLCBhcyBpdCBoYXMgYmVlbiBtYXRjaGVkIHdpdGggdGhpcyBsYXllclxuICAgICAgb2xkTGF5ZXJNYXBbbmV3TGF5ZXIuaWRdID0gbnVsbDtcblxuICAgICAgbGV0IHN1YmxheWVycyA9IG51bGw7XG5cbiAgICAgIC8vIFdlIG11c3Qgbm90IGdlbmVyYXRlIGV4Y2VwdGlvbnMgdW50aWwgYWZ0ZXIgbGF5ZXIgbWF0Y2hpbmcgaXMgY29tcGxldGVcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICghb2xkTGF5ZXIpIHtcbiAgICAgICAgICB0aGlzLl9pbml0aWFsaXplTGF5ZXIobmV3TGF5ZXIpO1xuICAgICAgICAgIGluaXRMYXllckluU2VlcihuZXdMYXllcik7IC8vIEluaXRpYWxpemVzIGxheWVyIGluIHNlZXIgY2hyb21lIGV4dGVuc2lvbiAoaWYgY29ubmVjdGVkKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX3RyYW5zZmVyTGF5ZXJTdGF0ZShvbGRMYXllciwgbmV3TGF5ZXIpO1xuICAgICAgICAgIHRoaXMuX3VwZGF0ZUxheWVyKG5ld0xheWVyKTtcbiAgICAgICAgICB1cGRhdGVMYXllckluU2VlcihuZXdMYXllcik7IC8vIFVwZGF0ZXMgbGF5ZXIgaW4gc2VlciBjaHJvbWUgZXh0ZW5zaW9uIChpZiBjb25uZWN0ZWQpXG4gICAgICAgIH1cbiAgICAgICAgZ2VuZXJhdGVkTGF5ZXJzLnB1c2gobmV3TGF5ZXIpO1xuXG4gICAgICAgIC8vIENhbGwgbGF5ZXIgbGlmZWN5Y2xlIG1ldGhvZDogcmVuZGVyIHN1YmxheWVyc1xuICAgICAgICBzdWJsYXllcnMgPSBuZXdMYXllci5pc0NvbXBvc2l0ZSAmJiBuZXdMYXllci5nZXRTdWJMYXllcnMoKTtcbiAgICAgICAgLy8gRW5kIGxheWVyIGxpZmVjeWNsZSBtZXRob2Q6IHJlbmRlciBzdWJsYXllcnNcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBsb2cud2FybihgZXJyb3IgZHVyaW5nIG1hdGNoaW5nIG9mICR7bGF5ZXJOYW1lKG5ld0xheWVyKX1gLCBlcnIpO1xuICAgICAgICBlcnJvciA9IGVycm9yIHx8IGVycjsgLy8gUmVjb3JkIGZpcnN0IGV4Y2VwdGlvblxuICAgICAgfVxuXG4gICAgICBpZiAoc3VibGF5ZXJzKSB7XG4gICAgICAgIHRoaXMuX3VwZGF0ZVN1YmxheWVyc1JlY3Vyc2l2ZWx5KHtcbiAgICAgICAgICBuZXdMYXllcnM6IHN1YmxheWVycyxcbiAgICAgICAgICBvbGRMYXllck1hcCxcbiAgICAgICAgICBnZW5lcmF0ZWRMYXllcnNcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGVycm9yO1xuICB9XG5cbiAgLy8gRmluYWxpemUgYW55IG9sZCBsYXllcnMgdGhhdCB3ZXJlIG5vdCBtYXRjaGVkXG4gIF9maW5hbGl6ZU9sZExheWVycyhvbGRMYXllck1hcCkge1xuICAgIGxldCBlcnJvciA9IG51bGw7XG4gICAgZm9yIChjb25zdCBsYXllcklkIGluIG9sZExheWVyTWFwKSB7XG4gICAgICBjb25zdCBsYXllciA9IG9sZExheWVyTWFwW2xheWVySWRdO1xuICAgICAgaWYgKGxheWVyKSB7XG4gICAgICAgIGVycm9yID0gZXJyb3IgfHwgdGhpcy5fZmluYWxpemVMYXllcihsYXllcik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBlcnJvcjtcbiAgfVxuXG4gIC8vIEluaXRpYWxpemVzIGEgc2luZ2xlIGxheWVyLCBjYWxsaW5nIGxheWVyIG1ldGhvZHNcbiAgX2luaXRpYWxpemVMYXllcihsYXllcikge1xuICAgIGFzc2VydCghbGF5ZXIuc3RhdGUpO1xuICAgIGxvZyhMT0dfUFJJT1JJVFlfTElGRUNZQ0xFLCBgaW5pdGlhbGl6aW5nICR7bGF5ZXJOYW1lKGxheWVyKX1gKTtcblxuICAgIGxldCBlcnJvciA9IG51bGw7XG4gICAgdHJ5IHtcbiAgICAgIGxheWVyLl9pbml0aWFsaXplKCk7XG4gICAgICBsYXllci5saWZlY3ljbGUgPSBMSUZFQ1lDTEUuSU5JVElBTElaRUQ7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBsb2cud2FybihgZXJyb3Igd2hpbGUgaW5pdGlhbGl6aW5nICR7bGF5ZXJOYW1lKGxheWVyKX1cXG5gLCBlcnIpO1xuICAgICAgZXJyb3IgPSBlcnJvciB8fCBlcnI7XG4gICAgICAvLyBUT0RPIC0gd2hhdCBzaG91bGQgdGhlIGxpZmVjeWNsZSBzdGF0ZSBiZSBoZXJlPyBMSUZFQ1lDTEUuSU5JVElBTElaQVRJT05fRkFJTEVEP1xuICAgIH1cblxuICAgIGFzc2VydChsYXllci5zdGF0ZSk7XG5cbiAgICAvLyBTZXQgYmFjayBwb2ludGVyICh1c2VkIGluIHBpY2tpbmcpXG4gICAgbGF5ZXIuc3RhdGUubGF5ZXIgPSBsYXllcjtcblxuICAgIC8vIFNhdmUgbGF5ZXIgb24gbW9kZWwgZm9yIHBpY2tpbmcgcHVycG9zZXNcbiAgICAvLyBzdG9yZSBvbiBtb2RlbC51c2VyRGF0YSByYXRoZXIgdGhhbiBkaXJlY3RseSBvbiBtb2RlbFxuICAgIGZvciAoY29uc3QgbW9kZWwgb2YgbGF5ZXIuZ2V0TW9kZWxzKCkpIHtcbiAgICAgIG1vZGVsLnVzZXJEYXRhLmxheWVyID0gbGF5ZXI7XG4gICAgfVxuXG4gICAgcmV0dXJuIGVycm9yO1xuICB9XG5cbiAgX3RyYW5zZmVyTGF5ZXJTdGF0ZShvbGRMYXllciwgbmV3TGF5ZXIpIHtcbiAgICBpZiAobmV3TGF5ZXIgIT09IG9sZExheWVyKSB7XG4gICAgICBsb2coTE9HX1BSSU9SSVRZX0xJRkVDWUNMRV9NSU5PUiwgYG1hdGNoZWQgJHtsYXllck5hbWUobmV3TGF5ZXIpfWAsIG9sZExheWVyLCAnLT4nLCBuZXdMYXllcik7XG4gICAgICBuZXdMYXllci5saWZlY3ljbGUgPSBMSUZFQ1lDTEUuTUFUQ0hFRDtcbiAgICAgIG9sZExheWVyLmxpZmVjeWNsZSA9IExJRkVDWUNMRS5BV0FJVElOR19HQztcbiAgICAgIG5ld0xheWVyLl90cmFuc2ZlclN0YXRlKG9sZExheWVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbG9nLmxvZyhMT0dfUFJJT1JJVFlfTElGRUNZQ0xFX01JTk9SLCBgTWF0Y2hpbmcgbGF5ZXIgaXMgdW5jaGFuZ2VkICR7bmV3TGF5ZXIuaWR9YCk7XG4gICAgICBuZXdMYXllci5saWZlY3ljbGUgPSBMSUZFQ1lDTEUuTUFUQ0hFRDtcbiAgICAgIG5ld0xheWVyLm9sZFByb3BzID0gbmV3TGF5ZXIucHJvcHM7XG4gICAgfVxuICB9XG5cbiAgLy8gVXBkYXRlcyBhIHNpbmdsZSBsYXllciwgY2xlYW5pbmcgYWxsIGZsYWdzXG4gIF91cGRhdGVMYXllcihsYXllcikge1xuICAgIGxvZy5sb2coTE9HX1BSSU9SSVRZX0xJRkVDWUNMRV9NSU5PUiwgYHVwZGF0aW5nICR7bGF5ZXJ9IGJlY2F1c2U6ICR7bGF5ZXIucHJpbnRDaGFuZ2VGbGFncygpfWApO1xuICAgIGxldCBlcnJvciA9IG51bGw7XG4gICAgdHJ5IHtcbiAgICAgIGxheWVyLl91cGRhdGUoKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGxvZy53YXJuKGBlcnJvciBkdXJpbmcgdXBkYXRlIG9mICR7bGF5ZXJOYW1lKGxheWVyKX1gLCBlcnIpO1xuICAgICAgLy8gU2F2ZSBmaXJzdCBlcnJvclxuICAgICAgZXJyb3IgPSBlcnI7XG4gICAgfVxuICAgIHJldHVybiBlcnJvcjtcbiAgfVxuXG4gIC8vIEZpbmFsaXplcyBhIHNpbmdsZSBsYXllclxuICBfZmluYWxpemVMYXllcihsYXllcikge1xuICAgIGFzc2VydChsYXllci5zdGF0ZSk7XG4gICAgYXNzZXJ0KGxheWVyLmxpZmVjeWNsZSAhPT0gTElGRUNZQ0xFLkFXQUlUSU5HX0ZJTkFMSVpBVElPTik7XG4gICAgbGF5ZXIubGlmZWN5Y2xlID0gTElGRUNZQ0xFLkFXQUlUSU5HX0ZJTkFMSVpBVElPTjtcbiAgICBsZXQgZXJyb3IgPSBudWxsO1xuICAgIHRoaXMuc2V0TmVlZHNSZWRyYXcoYGZpbmFsaXplZCAke2xheWVyTmFtZShsYXllcil9YCk7XG4gICAgdHJ5IHtcbiAgICAgIGxheWVyLl9maW5hbGl6ZSgpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgbG9nLndhcm4oYGVycm9yIGR1cmluZyBmaW5hbGl6YXRpb24gb2YgJHtsYXllck5hbWUobGF5ZXIpfWAsIGVycik7XG4gICAgICBlcnJvciA9IGVycjtcbiAgICB9XG4gICAgbGF5ZXIubGlmZWN5Y2xlID0gTElGRUNZQ0xFLkZJTkFMSVpFRDtcbiAgICBsb2coTE9HX1BSSU9SSVRZX0xJRkVDWUNMRSwgYGZpbmFsaXppbmcgJHtsYXllck5hbWUobGF5ZXIpfWApO1xuICAgIHJldHVybiBlcnJvcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBXYXJuIGlmIGEgZGVjay1sZXZlbCBtb3VzZSBldmVudCBoYXMgYmVlbiBzcGVjaWZpZWQsXG4gICAqIGJ1dCBubyBsYXllcnMgYXJlIGBwaWNrYWJsZWAuXG4gICAqL1xuICBfdmFsaWRhdGVFdmVudEhhbmRsaW5nKCkge1xuICAgIGlmICh0aGlzLm9uTGF5ZXJDbGljayB8fCB0aGlzLm9uTGF5ZXJIb3Zlcikge1xuICAgICAgaWYgKHRoaXMubGF5ZXJzLmxlbmd0aCAmJiAhdGhpcy5sYXllcnMuc29tZShsYXllciA9PiBsYXllci5wcm9wcy5waWNrYWJsZSkpIHtcbiAgICAgICAgbG9nLndhcm4oXG4gICAgICAgICAgJ1lvdSBoYXZlIHN1cHBsaWVkIGEgdG9wLWxldmVsIGlucHV0IGV2ZW50IGhhbmRsZXIgKGUuZy4gYG9uTGF5ZXJDbGlja2ApLCAnICtcbiAgICAgICAgICAgICdidXQgbm9uZSBvZiB5b3VyIGxheWVycyBoYXZlIHNldCB0aGUgYHBpY2thYmxlYCBmbGFnLidcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUm91dGUgY2xpY2sgZXZlbnRzIHRvIGxheWVycy5cbiAgICogYHBpY2tMYXllcmAgd2lsbCBjYWxsIHRoZSBgb25DbGlja2AgcHJvcCBvZiBhbnkgcGlja2VkIGxheWVyLFxuICAgKiBhbmQgYG9uTGF5ZXJDbGlja2AgaXMgY2FsbGVkIGRpcmVjdGx5IGZyb20gaGVyZVxuICAgKiB3aXRoIGFueSBwaWNraW5nIGluZm8gZ2VuZXJhdGVkIGJ5IGBwaWNrTGF5ZXJgLlxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgIEFuIG9iamVjdCBlbmNhcHN1bGF0aW5nIGFuIGlucHV0IGV2ZW50LFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgIHdpdGggdGhlIGZvbGxvd2luZyBzaGFwZTpcbiAgICogICAgICAgICAgICAgICAgICAgICAgICB7T2JqZWN0OiB7eCwgeX19IG9mZnNldENlbnRlcjogY2VudGVyIG9mIHRoZSBldmVudFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgIHtPYmplY3R9IHNyY0V2ZW50OiAgICAgICAgICAgICBuYXRpdmUgSlMgRXZlbnQgb2JqZWN0XG4gICAqL1xuICBfb25DbGljayhldmVudCkge1xuICAgIGlmICghZXZlbnQub2Zmc2V0Q2VudGVyKSB7XG4gICAgICAvLyBEbyBub3QgdHJpZ2dlciBvbkhvdmVyIGNhbGxiYWNrcyB3aGVuIGNsaWNrIHBvc2l0aW9uIGlzIGludmFsaWQuXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX3BpY2tBbmRDYWxsYmFjayh7XG4gICAgICBjYWxsYmFjazogdGhpcy5fb25MYXllckNsaWNrLFxuICAgICAgZXZlbnQsXG4gICAgICBtb2RlOiAnY2xpY2snXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUm91dGUgY2xpY2sgZXZlbnRzIHRvIGxheWVycy5cbiAgICogYHBpY2tMYXllcmAgd2lsbCBjYWxsIHRoZSBgb25Ib3ZlcmAgcHJvcCBvZiBhbnkgcGlja2VkIGxheWVyLFxuICAgKiBhbmQgYG9uTGF5ZXJIb3ZlcmAgaXMgY2FsbGVkIGRpcmVjdGx5IGZyb20gaGVyZVxuICAgKiB3aXRoIGFueSBwaWNraW5nIGluZm8gZ2VuZXJhdGVkIGJ5IGBwaWNrTGF5ZXJgLlxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgIEFuIG9iamVjdCBlbmNhcHN1bGF0aW5nIGFuIGlucHV0IGV2ZW50LFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgIHdpdGggdGhlIGZvbGxvd2luZyBzaGFwZTpcbiAgICogICAgICAgICAgICAgICAgICAgICAgICB7T2JqZWN0OiB7eCwgeX19IG9mZnNldENlbnRlcjogY2VudGVyIG9mIHRoZSBldmVudFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgIHtPYmplY3R9IHNyY0V2ZW50OiAgICAgICAgICAgICBuYXRpdmUgSlMgRXZlbnQgb2JqZWN0XG4gICAqL1xuICBfb25Qb2ludGVyTW92ZShldmVudCkge1xuICAgIGlmIChldmVudC5pc0Rvd24pIHtcbiAgICAgIC8vIERvIG5vdCB0cmlnZ2VyIG9uSG92ZXIgY2FsbGJhY2tzIGlmIG1vdXNlIGJ1dHRvbiBpcyBkb3duLlxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9waWNrQW5kQ2FsbGJhY2soe1xuICAgICAgY2FsbGJhY2s6IHRoaXMuX29uTGF5ZXJIb3ZlcixcbiAgICAgIGV2ZW50LFxuICAgICAgbW9kZTogJ2hvdmVyJ1xuICAgIH0pO1xuICB9XG5cbiAgX29uUG9pbnRlckxlYXZlKGV2ZW50KSB7XG4gICAgdGhpcy5waWNrT2JqZWN0KHtcbiAgICAgIHg6IC0xLFxuICAgICAgeTogLTEsXG4gICAgICByYWRpdXM6IHRoaXMuX3BpY2tpbmdSYWRpdXMsXG4gICAgICBtb2RlOiAnaG92ZXInXG4gICAgfSk7XG4gIH1cblxuICBfcGlja0FuZENhbGxiYWNrKG9wdGlvbnMpIHtcbiAgICBjb25zdCBwb3MgPSBvcHRpb25zLmV2ZW50Lm9mZnNldENlbnRlcjtcbiAgICBjb25zdCByYWRpdXMgPSB0aGlzLl9waWNraW5nUmFkaXVzO1xuICAgIGNvbnN0IHNlbGVjdGVkSW5mb3MgPSB0aGlzLnBpY2tPYmplY3Qoe3g6IHBvcy54LCB5OiBwb3MueSwgcmFkaXVzLCBtb2RlOiBvcHRpb25zLm1vZGV9KTtcbiAgICBpZiAob3B0aW9ucy5jYWxsYmFjaykge1xuICAgICAgY29uc3QgZmlyc3RJbmZvID0gc2VsZWN0ZWRJbmZvcy5maW5kKGluZm8gPT4gaW5mby5pbmRleCA+PSAwKSB8fCBudWxsO1xuICAgICAgLy8gQXMgcGVyIGRvY3VtZW50YXRpb24sIHNlbmQgbnVsbCB2YWx1ZSB3aGVuIG5vIHZhbGlkIG9iamVjdCBpcyBwaWNrZWQuXG4gICAgICBvcHRpb25zLmNhbGxiYWNrKGZpcnN0SW5mbywgc2VsZWN0ZWRJbmZvcywgb3B0aW9ucy5ldmVudC5zcmNFdmVudCk7XG4gICAgfVxuICB9XG5cbiAgLy8gU0VFUiBJTlRFR1JBVElPTlxuXG4gIC8qKlxuICAgKiBDYWxsZWQgdXBvbiBTZWVyIGluaXRpYWxpemF0aW9uLCBtYW51YWxseSBzZW5kcyBsYXllcnMgZGF0YS5cbiAgICovXG4gIF9pbml0U2VlcigpIHtcbiAgICB0aGlzLmxheWVycy5mb3JFYWNoKGxheWVyID0+IHtcbiAgICAgIGluaXRMYXllckluU2VlcihsYXllcik7XG4gICAgICB1cGRhdGVMYXllckluU2VlcihsYXllcik7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogT24gU2VlciBwcm9wZXJ0eSBlZGl0aW9uLCBzZXQgb3ZlcnJpZGUgYW5kIHVwZGF0ZSBsYXllcnMuXG4gICAqL1xuICBfZWRpdFNlZXIocGF5bG9hZCkge1xuICAgIGlmIChwYXlsb2FkLnR5cGUgIT09ICdlZGl0JyB8fCBwYXlsb2FkLnZhbHVlUGF0aFswXSAhPT0gJ3Byb3BzJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHNldFByb3BPdmVycmlkZXMocGF5bG9hZC5pdGVtS2V5LCBwYXlsb2FkLnZhbHVlUGF0aC5zbGljZSgxKSwgcGF5bG9hZC52YWx1ZSk7XG4gICAgY29uc3QgbmV3TGF5ZXJzID0gdGhpcy5sYXllcnMubWFwKGxheWVyID0+IG5ldyBsYXllci5jb25zdHJ1Y3RvcihsYXllci5wcm9wcykpO1xuICAgIHRoaXMudXBkYXRlTGF5ZXJzKHtuZXdMYXllcnN9KTtcbiAgfVxufVxuIl19