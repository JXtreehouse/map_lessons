var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

import * as Polygon from './polygon';
import { experimental } from '../../core';
var fp64ify = experimental.fp64ify,
    fillArray = experimental.fillArray;

import earcut from 'earcut';

function getPickingColor(index) {
  return [index + 1 & 255, index + 1 >> 8 & 255, index + 1 >> 8 >> 8 & 255];
}

function arrayPush(array, values) {
  var length = values.length;
  var offset = array.length;

  for (var index = 0; index < length; index++) {
    array[offset++] = values[index];
  }
  return array;
}

function flatten(values, level) {
  var result = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];

  if (level > 1) {
    values.forEach(function (v) {
      return flatten(v, level - 1, result);
    });
  } else {
    arrayPush(result, values);
  }
  return result;
}

var DEFAULT_COLOR = [0, 0, 0, 255]; // Black

export var PolygonTesselatorExtruded = function () {
  function PolygonTesselatorExtruded(_ref) {
    var polygons = _ref.polygons,
        _ref$getHeight = _ref.getHeight,
        getHeight = _ref$getHeight === undefined ? function (x) {
      return 1000;
    } : _ref$getHeight,
        _ref$getColor = _ref.getColor,
        getColor = _ref$getColor === undefined ? function (x) {
      return DEFAULT_COLOR;
    } : _ref$getColor,
        _ref$wireframe = _ref.wireframe,
        wireframe = _ref$wireframe === undefined ? false : _ref$wireframe,
        _ref$fp = _ref.fp64,
        fp64 = _ref$fp === undefined ? false : _ref$fp;

    _classCallCheck(this, PolygonTesselatorExtruded);

    this.fp64 = fp64;

    // Expensive operation, convert all polygons to arrays
    polygons = polygons.map(function (complexPolygon, polygonIndex) {
      var height = getHeight(polygonIndex) || 0;
      return Polygon.normalize(complexPolygon).map(function (polygon) {
        return polygon.map(function (coord) {
          return [coord[0], coord[1], height];
        });
      });
    });

    var groupedVertices = polygons;
    this.groupedVertices = polygons;
    var pointCount = getPointCount(polygons);
    this.pointCount = pointCount;
    this.wireframe = wireframe;

    this.attributes = {};

    var positionsJS = calculatePositionsJS({ groupedVertices: groupedVertices, pointCount: pointCount, wireframe: wireframe });
    Object.assign(this.attributes, {
      positions: calculatePositions(positionsJS, this.fp64),
      indices: calculateIndices({ groupedVertices: groupedVertices, wireframe: wireframe }),
      normals: calculateNormals({ groupedVertices: groupedVertices, pointCount: pointCount, wireframe: wireframe }),
      // colors: calculateColors({groupedVertices, wireframe, getColor}),
      pickingColors: calculatePickingColors({ groupedVertices: groupedVertices, pointCount: pointCount, wireframe: wireframe })
    });
  }

  _createClass(PolygonTesselatorExtruded, [{
    key: 'indices',
    value: function indices() {
      return this.attributes.indices;
    }
  }, {
    key: 'positions',
    value: function positions() {
      return this.attributes.positions;
    }
  }, {
    key: 'normals',
    value: function normals() {
      return this.attributes.normals;
    }
  }, {
    key: 'colors',
    value: function colors() {
      var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref2$getColor = _ref2.getColor,
          getColor = _ref2$getColor === undefined ? function (x) {
        return DEFAULT_COLOR;
      } : _ref2$getColor;

      var groupedVertices = this.groupedVertices,
          pointCount = this.pointCount,
          wireframe = this.wireframe;

      return calculateColors({ groupedVertices: groupedVertices, pointCount: pointCount, wireframe: wireframe, getColor: getColor });
    }
  }, {
    key: 'pickingColors',
    value: function pickingColors() {
      return this.attributes.pickingColors;
    }

    // updateTriggers: {
    //   positions: ['getHeight'],
    //   colors: ['getColors']
    //   pickingColors: 'none'
    // }

  }]);

  return PolygonTesselatorExtruded;
}();

// Count number of points in a list of complex polygons
function getPointCount(polygons) {
  return polygons.reduce(function (points, polygon) {
    return points + Polygon.getVertexCount(polygon);
  }, 0);
}

function calculateIndices(_ref3) {
  var groupedVertices = _ref3.groupedVertices,
      _ref3$wireframe = _ref3.wireframe,
      wireframe = _ref3$wireframe === undefined ? false : _ref3$wireframe;

  // adjust index offset for multiple polygons
  var multiplier = wireframe ? 2 : 5;
  var offsets = [];
  groupedVertices.reduce(function (vertexIndex, vertices) {
    offsets.push(vertexIndex);
    return vertexIndex + Polygon.getVertexCount(vertices) * multiplier;
  }, 0);

  var indices = groupedVertices.map(function (vertices, polygonIndex) {
    return wireframe ? // 1. get sequentially ordered indices of each polygons wireframe
    // 2. offset them by the number of indices in previous polygons
    calculateContourIndices(vertices, offsets[polygonIndex]) : // 1. get triangulated indices for the internal areas
    // 2. offset them by the number of indices in previous polygons
    calculateSurfaceIndices(vertices, offsets[polygonIndex]);
  });

  return new Uint32Array(flatten(indices, 2));
}

// Calculate a flat position array in JS - can be mapped to 32 or 64 bit typed arrays
// Remarks:
// * each top vertex is on 3 surfaces
// * each bottom vertex is on 2 surfaces
function calculatePositionsJS(_ref4) {
  var groupedVertices = _ref4.groupedVertices,
      pointCount = _ref4.pointCount,
      _ref4$wireframe = _ref4.wireframe,
      wireframe = _ref4$wireframe === undefined ? false : _ref4$wireframe;

  var multiplier = wireframe ? 2 : 5;
  var positions = new Float32Array(pointCount * 3 * multiplier);
  var vertexIndex = 0;

  groupedVertices.forEach(function (vertices) {
    var topVertices = flatten(vertices, 3);

    var baseVertices = topVertices.slice(0);
    var i = topVertices.length - 1;
    while (i > 0) {
      baseVertices[i] = 0;
      i -= 3;
    }
    var len = topVertices.length;

    if (wireframe) {
      fillArray({ target: positions, source: topVertices, start: vertexIndex });
      fillArray({ target: positions, source: baseVertices, start: vertexIndex + len });
    } else {
      fillArray({ target: positions, source: topVertices, start: vertexIndex, count: 3 });
      fillArray({
        target: positions,
        source: baseVertices,
        start: vertexIndex + len * 3,
        count: 2
      });
    }
    vertexIndex += len * multiplier;
  });

  return positions;
}

function calculatePositions(positionsJS, fp64) {
  var positionLow = void 0;
  if (fp64) {
    // We only need x, y component
    var vertexCount = positionsJS.length / 3;
    positionLow = new Float32Array(vertexCount * 2);
    for (var i = 0; i < vertexCount; i++) {
      positionLow[i * 2 + 0] = fp64ify(positionsJS[i * 3 + 0])[1];
      positionLow[i * 2 + 1] = fp64ify(positionsJS[i * 3 + 1])[1];
    }
  }
  return { positions: positionsJS, positions64xyLow: positionLow };
}

function calculateNormals(_ref5) {
  var groupedVertices = _ref5.groupedVertices,
      pointCount = _ref5.pointCount,
      wireframe = _ref5.wireframe;

  var up = [0, 0, 1];
  var multiplier = wireframe ? 2 : 5;

  var normals = new Float32Array(pointCount * 3 * multiplier);
  var vertexIndex = 0;

  if (wireframe) {
    return fillArray({ target: normals, source: up, count: pointCount * multiplier });
  }

  groupedVertices.map(function (vertices, polygonIndex) {
    var vertexCount = Polygon.getVertexCount(vertices);

    fillArray({ target: normals, source: up, start: vertexIndex, count: vertexCount });
    vertexIndex += vertexCount * 3;

    var sideNormalsForward = [];
    var sideNormalsBackward = [];

    vertices.forEach(function (polygon) {
      var sideNormals = calculateSideNormals(polygon);
      var firstNormal = sideNormals.slice(0, 3);

      arrayPush(sideNormalsForward, sideNormals);
      arrayPush(sideNormalsForward, firstNormal);

      arrayPush(sideNormalsBackward, firstNormal);
      arrayPush(sideNormalsBackward, sideNormals);
    });

    fillArray({
      target: normals,
      start: vertexIndex,
      count: 2,
      source: sideNormalsForward.concat(sideNormalsBackward)
    });
    vertexIndex += vertexCount * 3 * 4;
  });

  return normals;
}

function calculateSideNormals(vertices) {
  var normals = [];

  var lastVertice = null;
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = vertices[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var vertice = _step.value;

      if (lastVertice) {
        // vertex[i-1], vertex[i]
        var n = getNormal(lastVertice, vertice);
        arrayPush(normals, n);
      }
      lastVertice = vertice;
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return normals;
}

function calculateColors(_ref6) {
  var groupedVertices = _ref6.groupedVertices,
      pointCount = _ref6.pointCount,
      getColor = _ref6.getColor,
      _ref6$wireframe = _ref6.wireframe,
      wireframe = _ref6$wireframe === undefined ? false : _ref6$wireframe;

  var multiplier = wireframe ? 2 : 5;
  var colors = new Uint8ClampedArray(pointCount * 4 * multiplier);
  var vertexIndex = 0;

  groupedVertices.forEach(function (complexPolygon, polygonIndex) {
    var color = getColor(polygonIndex);
    color[3] = Number.isFinite(color[3]) ? color[3] : 255;

    var numVertices = Polygon.getVertexCount(complexPolygon);

    fillArray({ target: colors, source: color, start: vertexIndex, count: numVertices * multiplier });
    vertexIndex += color.length * numVertices * multiplier;
  });

  return colors;
}

function calculatePickingColors(_ref7) {
  var groupedVertices = _ref7.groupedVertices,
      pointCount = _ref7.pointCount,
      _ref7$wireframe = _ref7.wireframe,
      wireframe = _ref7$wireframe === undefined ? false : _ref7$wireframe;

  var multiplier = wireframe ? 2 : 5;
  var colors = new Uint8ClampedArray(pointCount * 3 * multiplier);
  var vertexIndex = 0;

  groupedVertices.forEach(function (vertices, polygonIndex) {
    var numVertices = Polygon.getVertexCount(vertices);
    var color = getPickingColor(polygonIndex);

    fillArray({ target: colors, source: color, start: vertexIndex, count: numVertices * multiplier });
    vertexIndex += color.length * numVertices * multiplier;
  });
  return colors;
}

function calculateContourIndices(vertices, offset) {
  var stride = Polygon.getVertexCount(vertices);
  var indices = [];

  vertices.forEach(function (polygon) {
    indices.push(offset);
    var numVertices = polygon.length;

    // polygon top
    // use vertex pairs for GL.LINES => [0, 1, 1, 2, 2, ..., n-1, n-1, 0]
    for (var i = 1; i < numVertices - 1; i++) {
      indices.push(i + offset, i + offset);
    }
    indices.push(offset);

    // polygon sides
    for (var _i = 0; _i < numVertices - 1; _i++) {
      indices.push(_i + offset, _i + stride + offset);
    }

    offset += numVertices;
  });

  return indices;
}

function drawSurfaceRectangle(targetArray, offset, stride) {
  targetArray.push(offset + stride, offset + stride * 3, offset + stride * 2 + 1, offset + stride * 2 + 1, offset + stride * 3, offset + stride * 4 + 1);
}

function calculateSurfaceIndices(vertices, offset) {
  var stride = Polygon.getVertexCount(vertices);

  var holes = null;
  var holeCount = vertices.length - 1;

  if (holeCount) {
    holes = [];
    var vertexIndex = 0;
    for (var i = 0; i < holeCount; i++) {
      vertexIndex += vertices[i].length;
      holes[i] = vertexIndex;
    }
  }

  var indices = earcut(flatten(vertices, 3), holes, 3).map(function (index) {
    return index + offset;
  });

  vertices.forEach(function (polygon) {
    var numVertices = polygon.length;

    // polygon sides
    for (var _i2 = 0; _i2 < numVertices - 1; _i2++) {
      drawSurfaceRectangle(indices, offset + _i2, stride);
    }

    offset += numVertices;
  });

  return indices;
}

// helpers

// get normal vector of line segment
function getNormal(p1, p2) {
  return [p1[1] - p2[1], p2[0] - p1[0], 0];
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9jb3JlLWxheWVycy9zb2xpZC1wb2x5Z29uLWxheWVyL3BvbHlnb24tdGVzc2VsYXRvci1leHRydWRlZC5qcyJdLCJuYW1lcyI6WyJQb2x5Z29uIiwiZXhwZXJpbWVudGFsIiwiZnA2NGlmeSIsImZpbGxBcnJheSIsImVhcmN1dCIsImdldFBpY2tpbmdDb2xvciIsImluZGV4IiwiYXJyYXlQdXNoIiwiYXJyYXkiLCJ2YWx1ZXMiLCJsZW5ndGgiLCJvZmZzZXQiLCJmbGF0dGVuIiwibGV2ZWwiLCJyZXN1bHQiLCJmb3JFYWNoIiwidiIsIkRFRkFVTFRfQ09MT1IiLCJQb2x5Z29uVGVzc2VsYXRvckV4dHJ1ZGVkIiwicG9seWdvbnMiLCJnZXRIZWlnaHQiLCJnZXRDb2xvciIsIndpcmVmcmFtZSIsImZwNjQiLCJtYXAiLCJjb21wbGV4UG9seWdvbiIsInBvbHlnb25JbmRleCIsImhlaWdodCIsIm5vcm1hbGl6ZSIsInBvbHlnb24iLCJjb29yZCIsImdyb3VwZWRWZXJ0aWNlcyIsInBvaW50Q291bnQiLCJnZXRQb2ludENvdW50IiwiYXR0cmlidXRlcyIsInBvc2l0aW9uc0pTIiwiY2FsY3VsYXRlUG9zaXRpb25zSlMiLCJPYmplY3QiLCJhc3NpZ24iLCJwb3NpdGlvbnMiLCJjYWxjdWxhdGVQb3NpdGlvbnMiLCJpbmRpY2VzIiwiY2FsY3VsYXRlSW5kaWNlcyIsIm5vcm1hbHMiLCJjYWxjdWxhdGVOb3JtYWxzIiwicGlja2luZ0NvbG9ycyIsImNhbGN1bGF0ZVBpY2tpbmdDb2xvcnMiLCJjYWxjdWxhdGVDb2xvcnMiLCJyZWR1Y2UiLCJwb2ludHMiLCJnZXRWZXJ0ZXhDb3VudCIsIm11bHRpcGxpZXIiLCJvZmZzZXRzIiwidmVydGV4SW5kZXgiLCJ2ZXJ0aWNlcyIsInB1c2giLCJjYWxjdWxhdGVDb250b3VySW5kaWNlcyIsImNhbGN1bGF0ZVN1cmZhY2VJbmRpY2VzIiwiVWludDMyQXJyYXkiLCJGbG9hdDMyQXJyYXkiLCJ0b3BWZXJ0aWNlcyIsImJhc2VWZXJ0aWNlcyIsInNsaWNlIiwiaSIsImxlbiIsInRhcmdldCIsInNvdXJjZSIsInN0YXJ0IiwiY291bnQiLCJwb3NpdGlvbkxvdyIsInZlcnRleENvdW50IiwicG9zaXRpb25zNjR4eUxvdyIsInVwIiwic2lkZU5vcm1hbHNGb3J3YXJkIiwic2lkZU5vcm1hbHNCYWNrd2FyZCIsInNpZGVOb3JtYWxzIiwiY2FsY3VsYXRlU2lkZU5vcm1hbHMiLCJmaXJzdE5vcm1hbCIsImNvbmNhdCIsImxhc3RWZXJ0aWNlIiwidmVydGljZSIsIm4iLCJnZXROb3JtYWwiLCJjb2xvcnMiLCJVaW50OENsYW1wZWRBcnJheSIsImNvbG9yIiwiTnVtYmVyIiwiaXNGaW5pdGUiLCJudW1WZXJ0aWNlcyIsInN0cmlkZSIsImRyYXdTdXJmYWNlUmVjdGFuZ2xlIiwidGFyZ2V0QXJyYXkiLCJob2xlcyIsImhvbGVDb3VudCIsInAxIiwicDIiXSwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPLEtBQUtBLE9BQVosTUFBeUIsV0FBekI7QUFDQSxTQUFRQyxZQUFSLFFBQTJCLFlBQTNCO0lBQ09DLE8sR0FBc0JELFksQ0FBdEJDLE87SUFBU0MsUyxHQUFhRixZLENBQWJFLFM7O0FBQ2hCLE9BQU9DLE1BQVAsTUFBbUIsUUFBbkI7O0FBRUEsU0FBU0MsZUFBVCxDQUF5QkMsS0FBekIsRUFBZ0M7QUFDOUIsU0FBTyxDQUFFQSxRQUFRLENBQVQsR0FBYyxHQUFmLEVBQXNCQSxRQUFRLENBQVQsSUFBZSxDQUFoQixHQUFxQixHQUF6QyxFQUFpREEsUUFBUSxDQUFULElBQWUsQ0FBaEIsSUFBc0IsQ0FBdkIsR0FBNEIsR0FBMUUsQ0FBUDtBQUNEOztBQUVELFNBQVNDLFNBQVQsQ0FBbUJDLEtBQW5CLEVBQTBCQyxNQUExQixFQUFrQztBQUNoQyxN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QUFDQSxTQUFLLElBQUlxRCxNQUFJLENBQWIsRUFBZ0JBLE1BQUl5QixjQUFjLENBQWxDLEVBQXFDekIsS0FBckMsRUFBMEM7QUFDeEMyQiwyQkFBcUJqRCxPQUFyQixFQUE4QjlCLFNBQVNvRCxHQUF2QyxFQUEwQzBCLE1BQTFDO0FBQ0Q7O0FBRUQ5RSxjQUFVNkUsV0FBVjtBQUNELEdBVEQ7O0FBV0EsU0FBTy9DLE9BQVA7QUFDRDs7QUFFRDs7QUFFQTtBQUNBLFNBQVN5QyxTQUFULENBQW1CWSxFQUFuQixFQUF1QkMsRUFBdkIsRUFBMkI7QUFDekIsU0FBTyxDQUFDRCxHQUFHLENBQUgsSUFBUUMsR0FBRyxDQUFILENBQVQsRUFBZ0JBLEdBQUcsQ0FBSCxJQUFRRCxHQUFHLENBQUgsQ0FBeEIsRUFBK0IsQ0FBL0IsQ0FBUDtBQUNEIiwiZmlsZSI6InBvbHlnb24tdGVzc2VsYXRvci1leHRydWRlZC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgMjAxNSAtIDIwMTcgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuLy8gVEhFIFNPRlRXQVJFLlxuXG5pbXBvcnQgKiBhcyBQb2x5Z29uIGZyb20gJy4vcG9seWdvbic7XG5pbXBvcnQge2V4cGVyaW1lbnRhbH0gZnJvbSAnLi4vLi4vY29yZSc7XG5jb25zdCB7ZnA2NGlmeSwgZmlsbEFycmF5fSA9IGV4cGVyaW1lbnRhbDtcbmltcG9ydCBlYXJjdXQgZnJvbSAnZWFyY3V0JztcblxuZnVuY3Rpb24gZ2V0UGlja2luZ0NvbG9yKGluZGV4KSB7XG4gIHJldHVybiBbKGluZGV4ICsgMSkgJiAyNTUsICgoaW5kZXggKyAxKSA+PiA4KSAmIDI1NSwgKCgoaW5kZXggKyAxKSA+PiA4KSA+PiA4KSAmIDI1NV07XG59XG5cbmZ1bmN0aW9uIGFycmF5UHVzaChhcnJheSwgdmFsdWVzKSB7XG4gIGNvbnN0IGxlbmd0aCA9IHZhbHVlcy5sZW5ndGg7XG4gIGxldCBvZmZzZXQgPSBhcnJheS5sZW5ndGg7XG5cbiAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgIGFycmF5W29mZnNldCsrXSA9IHZhbHVlc1tpbmRleF07XG4gIH1cbiAgcmV0dXJuIGFycmF5O1xufVxuXG5mdW5jdGlvbiBmbGF0dGVuKHZhbHVlcywgbGV2ZWwsIHJlc3VsdCA9IFtdKSB7XG4gIGlmIChsZXZlbCA+IDEpIHtcbiAgICB2YWx1ZXMuZm9yRWFjaCh2ID0+IGZsYXR0ZW4odiwgbGV2ZWwgLSAxLCByZXN1bHQpKTtcbiAgfSBlbHNlIHtcbiAgICBhcnJheVB1c2gocmVzdWx0LCB2YWx1ZXMpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmNvbnN0IERFRkFVTFRfQ09MT1IgPSBbMCwgMCwgMCwgMjU1XTsgLy8gQmxhY2tcblxuZXhwb3J0IGNsYXNzIFBvbHlnb25UZXNzZWxhdG9yRXh0cnVkZWQge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgcG9seWdvbnMsXG4gICAgZ2V0SGVpZ2h0ID0geCA9PiAxMDAwLFxuICAgIGdldENvbG9yID0geCA9PiBERUZBVUxUX0NPTE9SLFxuICAgIHdpcmVmcmFtZSA9IGZhbHNlLFxuICAgIGZwNjQgPSBmYWxzZVxuICB9KSB7XG4gICAgdGhpcy5mcDY0ID0gZnA2NDtcblxuICAgIC8vIEV4cGVuc2l2ZSBvcGVyYXRpb24sIGNvbnZlcnQgYWxsIHBvbHlnb25zIHRvIGFycmF5c1xuICAgIHBvbHlnb25zID0gcG9seWdvbnMubWFwKChjb21wbGV4UG9seWdvbiwgcG9seWdvbkluZGV4KSA9PiB7XG4gICAgICBjb25zdCBoZWlnaHQgPSBnZXRIZWlnaHQocG9seWdvbkluZGV4KSB8fCAwO1xuICAgICAgcmV0dXJuIFBvbHlnb24ubm9ybWFsaXplKGNvbXBsZXhQb2x5Z29uKS5tYXAocG9seWdvbiA9PlxuICAgICAgICBwb2x5Z29uLm1hcChjb29yZCA9PiBbY29vcmRbMF0sIGNvb3JkWzFdLCBoZWlnaHRdKVxuICAgICAgKTtcbiAgICB9KTtcblxuICAgIGNvbnN0IGdyb3VwZWRWZXJ0aWNlcyA9IHBvbHlnb25zO1xuICAgIHRoaXMuZ3JvdXBlZFZlcnRpY2VzID0gcG9seWdvbnM7XG4gICAgY29uc3QgcG9pbnRDb3VudCA9IGdldFBvaW50Q291bnQocG9seWdvbnMpO1xuICAgIHRoaXMucG9pbnRDb3VudCA9IHBvaW50Q291bnQ7XG4gICAgdGhpcy53aXJlZnJhbWUgPSB3aXJlZnJhbWU7XG5cbiAgICB0aGlzLmF0dHJpYnV0ZXMgPSB7fTtcblxuICAgIGNvbnN0IHBvc2l0aW9uc0pTID0gY2FsY3VsYXRlUG9zaXRpb25zSlMoe2dyb3VwZWRWZXJ0aWNlcywgcG9pbnRDb3VudCwgd2lyZWZyYW1lfSk7XG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLmF0dHJpYnV0ZXMsIHtcbiAgICAgIHBvc2l0aW9uczogY2FsY3VsYXRlUG9zaXRpb25zKHBvc2l0aW9uc0pTLCB0aGlzLmZwNjQpLFxuICAgICAgaW5kaWNlczogY2FsY3VsYXRlSW5kaWNlcyh7Z3JvdXBlZFZlcnRpY2VzLCB3aXJlZnJhbWV9KSxcbiAgICAgIG5vcm1hbHM6IGNhbGN1bGF0ZU5vcm1hbHMoe2dyb3VwZWRWZXJ0aWNlcywgcG9pbnRDb3VudCwgd2lyZWZyYW1lfSksXG4gICAgICAvLyBjb2xvcnM6IGNhbGN1bGF0ZUNvbG9ycyh7Z3JvdXBlZFZlcnRpY2VzLCB3aXJlZnJhbWUsIGdldENvbG9yfSksXG4gICAgICBwaWNraW5nQ29sb3JzOiBjYWxjdWxhdGVQaWNraW5nQ29sb3JzKHtncm91cGVkVmVydGljZXMsIHBvaW50Q291bnQsIHdpcmVmcmFtZX0pXG4gICAgfSk7XG4gIH1cblxuICBpbmRpY2VzKCkge1xuICAgIHJldHVybiB0aGlzLmF0dHJpYnV0ZXMuaW5kaWNlcztcbiAgfVxuXG4gIHBvc2l0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5hdHRyaWJ1dGVzLnBvc2l0aW9ucztcbiAgfVxuXG4gIG5vcm1hbHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuYXR0cmlidXRlcy5ub3JtYWxzO1xuICB9XG5cbiAgY29sb3JzKHtnZXRDb2xvciA9IHggPT4gREVGQVVMVF9DT0xPUn0gPSB7fSkge1xuICAgIGNvbnN0IHtncm91cGVkVmVydGljZXMsIHBvaW50Q291bnQsIHdpcmVmcmFtZX0gPSB0aGlzO1xuICAgIHJldHVybiBjYWxjdWxhdGVDb2xvcnMoe2dyb3VwZWRWZXJ0aWNlcywgcG9pbnRDb3VudCwgd2lyZWZyYW1lLCBnZXRDb2xvcn0pO1xuICB9XG5cbiAgcGlja2luZ0NvbG9ycygpIHtcbiAgICByZXR1cm4gdGhpcy5hdHRyaWJ1dGVzLnBpY2tpbmdDb2xvcnM7XG4gIH1cblxuICAvLyB1cGRhdGVUcmlnZ2Vyczoge1xuICAvLyAgIHBvc2l0aW9uczogWydnZXRIZWlnaHQnXSxcbiAgLy8gICBjb2xvcnM6IFsnZ2V0Q29sb3JzJ11cbiAgLy8gICBwaWNraW5nQ29sb3JzOiAnbm9uZSdcbiAgLy8gfVxufVxuXG4vLyBDb3VudCBudW1iZXIgb2YgcG9pbnRzIGluIGEgbGlzdCBvZiBjb21wbGV4IHBvbHlnb25zXG5mdW5jdGlvbiBnZXRQb2ludENvdW50KHBvbHlnb25zKSB7XG4gIHJldHVybiBwb2x5Z29ucy5yZWR1Y2UoKHBvaW50cywgcG9seWdvbikgPT4gcG9pbnRzICsgUG9seWdvbi5nZXRWZXJ0ZXhDb3VudChwb2x5Z29uKSwgMCk7XG59XG5cbmZ1bmN0aW9uIGNhbGN1bGF0ZUluZGljZXMoe2dyb3VwZWRWZXJ0aWNlcywgd2lyZWZyYW1lID0gZmFsc2V9KSB7XG4gIC8vIGFkanVzdCBpbmRleCBvZmZzZXQgZm9yIG11bHRpcGxlIHBvbHlnb25zXG4gIGNvbnN0IG11bHRpcGxpZXIgPSB3aXJlZnJhbWUgPyAyIDogNTtcbiAgY29uc3Qgb2Zmc2V0cyA9IFtdO1xuICBncm91cGVkVmVydGljZXMucmVkdWNlKCh2ZXJ0ZXhJbmRleCwgdmVydGljZXMpID0+IHtcbiAgICBvZmZzZXRzLnB1c2godmVydGV4SW5kZXgpO1xuICAgIHJldHVybiB2ZXJ0ZXhJbmRleCArIFBvbHlnb24uZ2V0VmVydGV4Q291bnQodmVydGljZXMpICogbXVsdGlwbGllcjtcbiAgfSwgMCk7XG5cbiAgY29uc3QgaW5kaWNlcyA9IGdyb3VwZWRWZXJ0aWNlcy5tYXAoXG4gICAgKHZlcnRpY2VzLCBwb2x5Z29uSW5kZXgpID0+XG4gICAgICB3aXJlZnJhbWVcbiAgICAgICAgPyAvLyAxLiBnZXQgc2VxdWVudGlhbGx5IG9yZGVyZWQgaW5kaWNlcyBvZiBlYWNoIHBvbHlnb25zIHdpcmVmcmFtZVxuICAgICAgICAgIC8vIDIuIG9mZnNldCB0aGVtIGJ5IHRoZSBudW1iZXIgb2YgaW5kaWNlcyBpbiBwcmV2aW91cyBwb2x5Z29uc1xuICAgICAgICAgIGNhbGN1bGF0ZUNvbnRvdXJJbmRpY2VzKHZlcnRpY2VzLCBvZmZzZXRzW3BvbHlnb25JbmRleF0pXG4gICAgICAgIDogLy8gMS4gZ2V0IHRyaWFuZ3VsYXRlZCBpbmRpY2VzIGZvciB0aGUgaW50ZXJuYWwgYXJlYXNcbiAgICAgICAgICAvLyAyLiBvZmZzZXQgdGhlbSBieSB0aGUgbnVtYmVyIG9mIGluZGljZXMgaW4gcHJldmlvdXMgcG9seWdvbnNcbiAgICAgICAgICBjYWxjdWxhdGVTdXJmYWNlSW5kaWNlcyh2ZXJ0aWNlcywgb2Zmc2V0c1twb2x5Z29uSW5kZXhdKVxuICApO1xuXG4gIHJldHVybiBuZXcgVWludDMyQXJyYXkoZmxhdHRlbihpbmRpY2VzLCAyKSk7XG59XG5cbi8vIENhbGN1bGF0ZSBhIGZsYXQgcG9zaXRpb24gYXJyYXkgaW4gSlMgLSBjYW4gYmUgbWFwcGVkIHRvIDMyIG9yIDY0IGJpdCB0eXBlZCBhcnJheXNcbi8vIFJlbWFya3M6XG4vLyAqIGVhY2ggdG9wIHZlcnRleCBpcyBvbiAzIHN1cmZhY2VzXG4vLyAqIGVhY2ggYm90dG9tIHZlcnRleCBpcyBvbiAyIHN1cmZhY2VzXG5mdW5jdGlvbiBjYWxjdWxhdGVQb3NpdGlvbnNKUyh7Z3JvdXBlZFZlcnRpY2VzLCBwb2ludENvdW50LCB3aXJlZnJhbWUgPSBmYWxzZX0pIHtcbiAgY29uc3QgbXVsdGlwbGllciA9IHdpcmVmcmFtZSA/IDIgOiA1O1xuICBjb25zdCBwb3NpdGlvbnMgPSBuZXcgRmxvYXQzMkFycmF5KHBvaW50Q291bnQgKiAzICogbXVsdGlwbGllcik7XG4gIGxldCB2ZXJ0ZXhJbmRleCA9IDA7XG5cbiAgZ3JvdXBlZFZlcnRpY2VzLmZvckVhY2godmVydGljZXMgPT4ge1xuICAgIGNvbnN0IHRvcFZlcnRpY2VzID0gZmxhdHRlbih2ZXJ0aWNlcywgMyk7XG5cbiAgICBjb25zdCBiYXNlVmVydGljZXMgPSB0b3BWZXJ0aWNlcy5zbGljZSgwKTtcbiAgICBsZXQgaSA9IHRvcFZlcnRpY2VzLmxlbmd0aCAtIDE7XG4gICAgd2hpbGUgKGkgPiAwKSB7XG4gICAgICBiYXNlVmVydGljZXNbaV0gPSAwO1xuICAgICAgaSAtPSAzO1xuICAgIH1cbiAgICBjb25zdCBsZW4gPSB0b3BWZXJ0aWNlcy5sZW5ndGg7XG5cbiAgICBpZiAod2lyZWZyYW1lKSB7XG4gICAgICBmaWxsQXJyYXkoe3RhcmdldDogcG9zaXRpb25zLCBzb3VyY2U6IHRvcFZlcnRpY2VzLCBzdGFydDogdmVydGV4SW5kZXh9KTtcbiAgICAgIGZpbGxBcnJheSh7dGFyZ2V0OiBwb3NpdGlvbnMsIHNvdXJjZTogYmFzZVZlcnRpY2VzLCBzdGFydDogdmVydGV4SW5kZXggKyBsZW59KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZmlsbEFycmF5KHt0YXJnZXQ6IHBvc2l0aW9ucywgc291cmNlOiB0b3BWZXJ0aWNlcywgc3RhcnQ6IHZlcnRleEluZGV4LCBjb3VudDogM30pO1xuICAgICAgZmlsbEFycmF5KHtcbiAgICAgICAgdGFyZ2V0OiBwb3NpdGlvbnMsXG4gICAgICAgIHNvdXJjZTogYmFzZVZlcnRpY2VzLFxuICAgICAgICBzdGFydDogdmVydGV4SW5kZXggKyBsZW4gKiAzLFxuICAgICAgICBjb3VudDogMlxuICAgICAgfSk7XG4gICAgfVxuICAgIHZlcnRleEluZGV4ICs9IGxlbiAqIG11bHRpcGxpZXI7XG4gIH0pO1xuXG4gIHJldHVybiBwb3NpdGlvbnM7XG59XG5cbmZ1bmN0aW9uIGNhbGN1bGF0ZVBvc2l0aW9ucyhwb3NpdGlvbnNKUywgZnA2NCkge1xuICBsZXQgcG9zaXRpb25Mb3c7XG4gIGlmIChmcDY0KSB7XG4gICAgLy8gV2Ugb25seSBuZWVkIHgsIHkgY29tcG9uZW50XG4gICAgY29uc3QgdmVydGV4Q291bnQgPSBwb3NpdGlvbnNKUy5sZW5ndGggLyAzO1xuICAgIHBvc2l0aW9uTG93ID0gbmV3IEZsb2F0MzJBcnJheSh2ZXJ0ZXhDb3VudCAqIDIpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmVydGV4Q291bnQ7IGkrKykge1xuICAgICAgcG9zaXRpb25Mb3dbaSAqIDIgKyAwXSA9IGZwNjRpZnkocG9zaXRpb25zSlNbaSAqIDMgKyAwXSlbMV07XG4gICAgICBwb3NpdGlvbkxvd1tpICogMiArIDFdID0gZnA2NGlmeShwb3NpdGlvbnNKU1tpICogMyArIDFdKVsxXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtwb3NpdGlvbnM6IHBvc2l0aW9uc0pTLCBwb3NpdGlvbnM2NHh5TG93OiBwb3NpdGlvbkxvd307XG59XG5cbmZ1bmN0aW9uIGNhbGN1bGF0ZU5vcm1hbHMoe2dyb3VwZWRWZXJ0aWNlcywgcG9pbnRDb3VudCwgd2lyZWZyYW1lfSkge1xuICBjb25zdCB1cCA9IFswLCAwLCAxXTtcbiAgY29uc3QgbXVsdGlwbGllciA9IHdpcmVmcmFtZSA/IDIgOiA1O1xuXG4gIGNvbnN0IG5vcm1hbHMgPSBuZXcgRmxvYXQzMkFycmF5KHBvaW50Q291bnQgKiAzICogbXVsdGlwbGllcik7XG4gIGxldCB2ZXJ0ZXhJbmRleCA9IDA7XG5cbiAgaWYgKHdpcmVmcmFtZSkge1xuICAgIHJldHVybiBmaWxsQXJyYXkoe3RhcmdldDogbm9ybWFscywgc291cmNlOiB1cCwgY291bnQ6IHBvaW50Q291bnQgKiBtdWx0aXBsaWVyfSk7XG4gIH1cblxuICBncm91cGVkVmVydGljZXMubWFwKCh2ZXJ0aWNlcywgcG9seWdvbkluZGV4KSA9PiB7XG4gICAgY29uc3QgdmVydGV4Q291bnQgPSBQb2x5Z29uLmdldFZlcnRleENvdW50KHZlcnRpY2VzKTtcblxuICAgIGZpbGxBcnJheSh7dGFyZ2V0OiBub3JtYWxzLCBzb3VyY2U6IHVwLCBzdGFydDogdmVydGV4SW5kZXgsIGNvdW50OiB2ZXJ0ZXhDb3VudH0pO1xuICAgIHZlcnRleEluZGV4ICs9IHZlcnRleENvdW50ICogMztcblxuICAgIGNvbnN0IHNpZGVOb3JtYWxzRm9yd2FyZCA9IFtdO1xuICAgIGNvbnN0IHNpZGVOb3JtYWxzQmFja3dhcmQgPSBbXTtcblxuICAgIHZlcnRpY2VzLmZvckVhY2gocG9seWdvbiA9PiB7XG4gICAgICBjb25zdCBzaWRlTm9ybWFscyA9IGNhbGN1bGF0ZVNpZGVOb3JtYWxzKHBvbHlnb24pO1xuICAgICAgY29uc3QgZmlyc3ROb3JtYWwgPSBzaWRlTm9ybWFscy5zbGljZSgwLCAzKTtcblxuICAgICAgYXJyYXlQdXNoKHNpZGVOb3JtYWxzRm9yd2FyZCwgc2lkZU5vcm1hbHMpO1xuICAgICAgYXJyYXlQdXNoKHNpZGVOb3JtYWxzRm9yd2FyZCwgZmlyc3ROb3JtYWwpO1xuXG4gICAgICBhcnJheVB1c2goc2lkZU5vcm1hbHNCYWNrd2FyZCwgZmlyc3ROb3JtYWwpO1xuICAgICAgYXJyYXlQdXNoKHNpZGVOb3JtYWxzQmFja3dhcmQsIHNpZGVOb3JtYWxzKTtcbiAgICB9KTtcblxuICAgIGZpbGxBcnJheSh7XG4gICAgICB0YXJnZXQ6IG5vcm1hbHMsXG4gICAgICBzdGFydDogdmVydGV4SW5kZXgsXG4gICAgICBjb3VudDogMixcbiAgICAgIHNvdXJjZTogc2lkZU5vcm1hbHNGb3J3YXJkLmNvbmNhdChzaWRlTm9ybWFsc0JhY2t3YXJkKVxuICAgIH0pO1xuICAgIHZlcnRleEluZGV4ICs9IHZlcnRleENvdW50ICogMyAqIDQ7XG4gIH0pO1xuXG4gIHJldHVybiBub3JtYWxzO1xufVxuXG5mdW5jdGlvbiBjYWxjdWxhdGVTaWRlTm9ybWFscyh2ZXJ0aWNlcykge1xuICBjb25zdCBub3JtYWxzID0gW107XG5cbiAgbGV0IGxhc3RWZXJ0aWNlID0gbnVsbDtcbiAgZm9yIChjb25zdCB2ZXJ0aWNlIG9mIHZlcnRpY2VzKSB7XG4gICAgaWYgKGxhc3RWZXJ0aWNlKSB7XG4gICAgICAvLyB2ZXJ0ZXhbaS0xXSwgdmVydGV4W2ldXG4gICAgICBjb25zdCBuID0gZ2V0Tm9ybWFsKGxhc3RWZXJ0aWNlLCB2ZXJ0aWNlKTtcbiAgICAgIGFycmF5UHVzaChub3JtYWxzLCBuKTtcbiAgICB9XG4gICAgbGFzdFZlcnRpY2UgPSB2ZXJ0aWNlO1xuICB9XG5cbiAgcmV0dXJuIG5vcm1hbHM7XG59XG5cbmZ1bmN0aW9uIGNhbGN1bGF0ZUNvbG9ycyh7Z3JvdXBlZFZlcnRpY2VzLCBwb2ludENvdW50LCBnZXRDb2xvciwgd2lyZWZyYW1lID0gZmFsc2V9KSB7XG4gIGNvbnN0IG11bHRpcGxpZXIgPSB3aXJlZnJhbWUgPyAyIDogNTtcbiAgY29uc3QgY29sb3JzID0gbmV3IFVpbnQ4Q2xhbXBlZEFycmF5KHBvaW50Q291bnQgKiA0ICogbXVsdGlwbGllcik7XG4gIGxldCB2ZXJ0ZXhJbmRleCA9IDA7XG5cbiAgZ3JvdXBlZFZlcnRpY2VzLmZvckVhY2goKGNvbXBsZXhQb2x5Z29uLCBwb2x5Z29uSW5kZXgpID0+IHtcbiAgICBjb25zdCBjb2xvciA9IGdldENvbG9yKHBvbHlnb25JbmRleCk7XG4gICAgY29sb3JbM10gPSBOdW1iZXIuaXNGaW5pdGUoY29sb3JbM10pID8gY29sb3JbM10gOiAyNTU7XG5cbiAgICBjb25zdCBudW1WZXJ0aWNlcyA9IFBvbHlnb24uZ2V0VmVydGV4Q291bnQoY29tcGxleFBvbHlnb24pO1xuXG4gICAgZmlsbEFycmF5KHt0YXJnZXQ6IGNvbG9ycywgc291cmNlOiBjb2xvciwgc3RhcnQ6IHZlcnRleEluZGV4LCBjb3VudDogbnVtVmVydGljZXMgKiBtdWx0aXBsaWVyfSk7XG4gICAgdmVydGV4SW5kZXggKz0gY29sb3IubGVuZ3RoICogbnVtVmVydGljZXMgKiBtdWx0aXBsaWVyO1xuICB9KTtcblxuICByZXR1cm4gY29sb3JzO1xufVxuXG5mdW5jdGlvbiBjYWxjdWxhdGVQaWNraW5nQ29sb3JzKHtncm91cGVkVmVydGljZXMsIHBvaW50Q291bnQsIHdpcmVmcmFtZSA9IGZhbHNlfSkge1xuICBjb25zdCBtdWx0aXBsaWVyID0gd2lyZWZyYW1lID8gMiA6IDU7XG4gIGNvbnN0IGNvbG9ycyA9IG5ldyBVaW50OENsYW1wZWRBcnJheShwb2ludENvdW50ICogMyAqIG11bHRpcGxpZXIpO1xuICBsZXQgdmVydGV4SW5kZXggPSAwO1xuXG4gIGdyb3VwZWRWZXJ0aWNlcy5mb3JFYWNoKCh2ZXJ0aWNlcywgcG9seWdvbkluZGV4KSA9PiB7XG4gICAgY29uc3QgbnVtVmVydGljZXMgPSBQb2x5Z29uLmdldFZlcnRleENvdW50KHZlcnRpY2VzKTtcbiAgICBjb25zdCBjb2xvciA9IGdldFBpY2tpbmdDb2xvcihwb2x5Z29uSW5kZXgpO1xuXG4gICAgZmlsbEFycmF5KHt0YXJnZXQ6IGNvbG9ycywgc291cmNlOiBjb2xvciwgc3RhcnQ6IHZlcnRleEluZGV4LCBjb3VudDogbnVtVmVydGljZXMgKiBtdWx0aXBsaWVyfSk7XG4gICAgdmVydGV4SW5kZXggKz0gY29sb3IubGVuZ3RoICogbnVtVmVydGljZXMgKiBtdWx0aXBsaWVyO1xuICB9KTtcbiAgcmV0dXJuIGNvbG9ycztcbn1cblxuZnVuY3Rpb24gY2FsY3VsYXRlQ29udG91ckluZGljZXModmVydGljZXMsIG9mZnNldCkge1xuICBjb25zdCBzdHJpZGUgPSBQb2x5Z29uLmdldFZlcnRleENvdW50KHZlcnRpY2VzKTtcbiAgY29uc3QgaW5kaWNlcyA9IFtdO1xuXG4gIHZlcnRpY2VzLmZvckVhY2gocG9seWdvbiA9PiB7XG4gICAgaW5kaWNlcy5wdXNoKG9mZnNldCk7XG4gICAgY29uc3QgbnVtVmVydGljZXMgPSBwb2x5Z29uLmxlbmd0aDtcblxuICAgIC8vIHBvbHlnb24gdG9wXG4gICAgLy8gdXNlIHZlcnRleCBwYWlycyBmb3IgR0wuTElORVMgPT4gWzAsIDEsIDEsIDIsIDIsIC4uLiwgbi0xLCBuLTEsIDBdXG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBudW1WZXJ0aWNlcyAtIDE7IGkrKykge1xuICAgICAgaW5kaWNlcy5wdXNoKGkgKyBvZmZzZXQsIGkgKyBvZmZzZXQpO1xuICAgIH1cbiAgICBpbmRpY2VzLnB1c2gob2Zmc2V0KTtcblxuICAgIC8vIHBvbHlnb24gc2lkZXNcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bVZlcnRpY2VzIC0gMTsgaSsrKSB7XG4gICAgICBpbmRpY2VzLnB1c2goaSArIG9mZnNldCwgaSArIHN0cmlkZSArIG9mZnNldCk7XG4gICAgfVxuXG4gICAgb2Zmc2V0ICs9IG51bVZlcnRpY2VzO1xuICB9KTtcblxuICByZXR1cm4gaW5kaWNlcztcbn1cblxuZnVuY3Rpb24gZHJhd1N1cmZhY2VSZWN0YW5nbGUodGFyZ2V0QXJyYXksIG9mZnNldCwgc3RyaWRlKSB7XG4gIHRhcmdldEFycmF5LnB1c2goXG4gICAgb2Zmc2V0ICsgc3RyaWRlLFxuICAgIG9mZnNldCArIHN0cmlkZSAqIDMsXG4gICAgb2Zmc2V0ICsgc3RyaWRlICogMiArIDEsXG4gICAgb2Zmc2V0ICsgc3RyaWRlICogMiArIDEsXG4gICAgb2Zmc2V0ICsgc3RyaWRlICogMyxcbiAgICBvZmZzZXQgKyBzdHJpZGUgKiA0ICsgMVxuICApO1xufVxuXG5mdW5jdGlvbiBjYWxjdWxhdGVTdXJmYWNlSW5kaWNlcyh2ZXJ0aWNlcywgb2Zmc2V0KSB7XG4gIGNvbnN0IHN0cmlkZSA9IFBvbHlnb24uZ2V0VmVydGV4Q291bnQodmVydGljZXMpO1xuXG4gIGxldCBob2xlcyA9IG51bGw7XG4gIGNvbnN0IGhvbGVDb3VudCA9IHZlcnRpY2VzLmxlbmd0aCAtIDE7XG5cbiAgaWYgKGhvbGVDb3VudCkge1xuICAgIGhvbGVzID0gW107XG4gICAgbGV0IHZlcnRleEluZGV4ID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGhvbGVDb3VudDsgaSsrKSB7XG4gICAgICB2ZXJ0ZXhJbmRleCArPSB2ZXJ0aWNlc1tpXS5sZW5ndGg7XG4gICAgICBob2xlc1tpXSA9IHZlcnRleEluZGV4O1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGluZGljZXMgPSBlYXJjdXQoZmxhdHRlbih2ZXJ0aWNlcywgMyksIGhvbGVzLCAzKS5tYXAoaW5kZXggPT4gaW5kZXggKyBvZmZzZXQpO1xuXG4gIHZlcnRpY2VzLmZvckVhY2gocG9seWdvbiA9PiB7XG4gICAgY29uc3QgbnVtVmVydGljZXMgPSBwb2x5Z29uLmxlbmd0aDtcblxuICAgIC8vIHBvbHlnb24gc2lkZXNcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bVZlcnRpY2VzIC0gMTsgaSsrKSB7XG4gICAgICBkcmF3U3VyZmFjZVJlY3RhbmdsZShpbmRpY2VzLCBvZmZzZXQgKyBpLCBzdHJpZGUpO1xuICAgIH1cblxuICAgIG9mZnNldCArPSBudW1WZXJ0aWNlcztcbiAgfSk7XG5cbiAgcmV0dXJuIGluZGljZXM7XG59XG5cbi8vIGhlbHBlcnNcblxuLy8gZ2V0IG5vcm1hbCB2ZWN0b3Igb2YgbGluZSBzZWdtZW50XG5mdW5jdGlvbiBnZXROb3JtYWwocDEsIHAyKSB7XG4gIHJldHVybiBbcDFbMV0gLSBwMlsxXSwgcDJbMF0gLSBwMVswXSwgMF07XG59XG4iXX0=