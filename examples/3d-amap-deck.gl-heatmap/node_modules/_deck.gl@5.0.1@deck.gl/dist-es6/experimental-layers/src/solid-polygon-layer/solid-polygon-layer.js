var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

import { COORDINATE_SYSTEM, Layer, experimental } from 'deck.gl';
var enable64bitSupport = experimental.enable64bitSupport,
    get = experimental.get;

import { GL, Model, Geometry } from 'luma.gl';

// Polygon geometry generation is managed by the polygon tesselator
import { PolygonTesselator } from './polygon-tesselator';

import vs from './solid-polygon-layer-vertex.glsl';
import vs64 from './solid-polygon-layer-vertex-64.glsl';
import fs from './solid-polygon-layer-fragment.glsl';

var defaultLineColor = [0x0, 0x0, 0x0, 0xff];
var defaultFillColor = [0x0, 0x0, 0x0, 0xff];

var defaultProps = {
  filled: true,
  // Whether to extrude
  extruded: false,
  // Whether to draw a GL.LINES wireframe of the polygon
  wireframe: false,
  fp64: false,

  // elevation multiplier
  elevationScale: 1,

  // Accessor for polygon geometry
  getPolygon: function getPolygon(f) {
    return get(f, 'polygon') || get(f, 'geometry.coordinates');
  },
  // Accessor for extrusion height
  getElevation: function getElevation(f) {
    return get(f, 'elevation') || get(f, 'properties.height') || 0;
  },
  // Accessor for colors
  getFillColor: function getFillColor(f) {
    return get(f, 'fillColor') || get(f, 'properties.color') || defaultFillColor;
  },
  getLineColor: function getLineColor(f) {
    return get(f, 'lineColor') || get(f, 'properties.color') || defaultLineColor;
  },

  // Optional settings for 'lighting' shader module
  lightSettings: {
    lightsPosition: [-122.45, 37.75, 8000, -122.0, 38.0, 5000],
    ambientRatio: 0.05,
    diffuseRatio: 0.6,
    specularRatio: 0.8,
    lightsStrength: [2.0, 0.0, 0.0, 0.0],
    numberOfLights: 2
  }
};

// Side model attributes
var SIDE_FILL_POSITIONS = new Float32Array([
// top left corner
0, 1,
// bottom left corner
0, 0,
// top right corner
1, 1,
// bottom right corner
1, 0]);
var SIDE_WIRE_POSITIONS = new Float32Array([
// top right corner
1, 1,
// top left corner
0, 1,
// bottom left corner
0, 0,
// bottom right corner
1, 0]);

// Model types
var ATTRIBUTE_MAPS = {
  TOP: {
    indices: { instanced: false },
    positions: { instanced: false },
    positions64xyLow: { instanced: false },
    elevations: { instanced: false },
    fillColors: { name: 'colors', instanced: false },
    pickingColors: { instanced: false }
  },
  SIDE: {
    positions: { instanced: true },
    positions64xyLow: { instanced: true },
    nextPositions: { instanced: true },
    nextPositions64xyLow: { instanced: true },
    elevations: { instanced: true },
    fillColors: { name: 'colors', instanced: true },
    pickingColors: { instanced: true }
  },
  WIRE: {
    positions: { instanced: true },
    positions64xyLow: { instanced: true },
    nextPositions: { instanced: true },
    nextPositions64xyLow: { instanced: true },
    elevations: { instanced: true },
    lineColors: { name: 'colors', instanced: true },
    pickingColors: { instanced: true }
  }
};

var SolidPolygonLayer = function (_Layer) {
  _inherits(SolidPolygonLayer, _Layer);

  function SolidPolygonLayer() {
    _classCallCheck(this, SolidPolygonLayer);

    return _possibleConstructorReturn(this, (SolidPolygonLayer.__proto__ || Object.getPrototypeOf(SolidPolygonLayer)).apply(this, arguments));
  }

  _createClass(SolidPolygonLayer, [{
    key: 'getShaders',
    value: function getShaders() {
      return enable64bitSupport(this.props) ? { vs: vs64, fs: fs, modules: ['project64', 'lighting', 'picking'] } : { vs: vs, fs: fs, modules: ['lighting', 'picking'] }; // 'project' module added by default.
    }
  }, {
    key: 'initializeState',
    value: function initializeState() {
      var gl = this.context.gl;

      this.setState({
        numInstances: 0,
        IndexType: gl.getExtension('OES_element_index_uint') ? Uint32Array : Uint16Array
      });

      var attributeManager = this.state.attributeManager;

      var noAlloc = true;
      /* eslint-disable max-len */
      attributeManager.add({
        indices: { size: 1, isIndexed: true, update: this.calculateIndices, noAlloc: noAlloc },
        positions: {
          size: 3,
          accessor: ['extruded', 'fp64'],
          update: this.calculatePositions,
          noAlloc: noAlloc
        },
        nextPositions: {
          size: 3,
          accessor: ['extruded', 'fp64'],
          update: this.calculateNextPositions,
          noAlloc: noAlloc
        },
        elevations: {
          size: 1,
          accessor: ['extruded', 'getElevation'],
          update: this.calculateElevations,
          noAlloc: noAlloc
        },
        fillColors: {
          alias: 'colors',
          size: 4,
          type: GL.UNSIGNED_BYTE,
          accessor: 'getFillColor',
          update: this.calculateFillColors,
          noAlloc: noAlloc
        },
        lineColors: {
          alias: 'colors',
          size: 4,
          type: GL.UNSIGNED_BYTE,
          accessor: 'getLineColor',
          update: this.calculateLineColors,
          noAlloc: noAlloc
        },
        pickingColors: { size: 3, type: GL.UNSIGNED_BYTE, update: this.calculatePickingColors, noAlloc: noAlloc }
      });
      /* eslint-enable max-len */
    }
  }, {
    key: 'updateAttribute',
    value: function updateAttribute(_ref) {
      var props = _ref.props,
          oldProps = _ref.oldProps;

      if (props.fp64 !== oldProps.fp64) {
        var attributeManager = this.state.attributeManager;


        if (props.fp64 && props.coordinateSystem === COORDINATE_SYSTEM.LNGLAT) {
          /* eslint-disable max-len */
          attributeManager.add({
            positions64xyLow: { size: 2, accessor: 'fp64', update: this.calculatePositionsLow },
            nextPositions64xyLow: { size: 2, accessor: 'fp64', update: this.calculateNextPositionsLow }
          });
          /* eslint-enable max-len */
        } else {
          attributeManager.remove(['positions64xyLow', 'nextPositions64xyLow']);
        }
      }
    }
  }, {
    key: 'draw',
    value: function draw(_ref2) {
      var uniforms = _ref2.uniforms;
      var _props = this.props,
          extruded = _props.extruded,
          lightSettings = _props.lightSettings,
          elevationScale = _props.elevationScale;


      var renderUniforms = Object.assign({}, uniforms, {
        extruded: extruded ? 1.0 : 0.0,
        elevationScale: elevationScale
      }, lightSettings);

      this.state.models.forEach(function (model) {
        model.render(renderUniforms);
      });
    }
  }, {
    key: 'updateState',
    value: function updateState(updateParams) {
      _get(SolidPolygonLayer.prototype.__proto__ || Object.getPrototypeOf(SolidPolygonLayer.prototype), 'updateState', this).call(this, updateParams);

      this.updateGeometry(updateParams);
      this.updateAttribute(updateParams);

      var props = updateParams.props,
          oldProps = updateParams.oldProps;


      var regenerateModels = props.fp64 !== oldProps.fp64 || props.filled !== oldProps.filled || props.extruded !== oldProps.extruded || props.wireframe !== oldProps.wireframe;

      if (regenerateModels) {
        this.setState(Object.assign({
          // Set a flag to set attributes to new models
          modelsChanged: true
        }, this._getModels(this.context.gl)));
      }

      if (props.extruded !== oldProps.extruded) {
        this.state.attributeManager.invalidate('extruded');
      }
      if (props.fp64 !== oldProps.fp64) {
        this.state.attributeManager.invalidate('fp64');
      }
    }
  }, {
    key: 'updateGeometry',
    value: function updateGeometry(_ref3) {
      var props = _ref3.props,
          oldProps = _ref3.oldProps,
          changeFlags = _ref3.changeFlags;

      var geometryConfigChanged = changeFlags.dataChanged || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getPolygon);

      // When the geometry config  or the data is changed,
      // tessellator needs to be invoked
      if (geometryConfigChanged) {
        // TODO - avoid creating a temporary array here: let the tesselator iterate
        var polygons = props.data.map(props.getPolygon);

        this.setState({
          polygonTesselator: new PolygonTesselator({ polygons: polygons, IndexType: this.state.IndexType })
        });

        this.state.attributeManager.invalidateAll();
      }

      if (geometryConfigChanged || props.extruded !== oldProps.extruded || props.fp64 !== oldProps.fp64) {
        this.state.polygonTesselator.updatePositions({
          fp64: props.fp64,
          extruded: props.extruded
        });
      }
    }
  }, {
    key: 'updateAttributes',
    value: function updateAttributes(props) {
      var _state = this.state,
          attributeManager = _state.attributeManager,
          modelsChanged = _state.modelsChanged;

      // Figure out data length

      attributeManager.update({
        data: props.data,
        numInstances: 0,
        props: props,
        buffers: props,
        context: this,
        // Don't worry about non-attribute props
        ignoreUnknownAttributes: true
      });

      if (modelsChanged) {
        this._updateAttributes(attributeManager.attributes);
        // clear the flag
        this.setState({ modelsChanged: false });
      } else {
        var changedAttributes = attributeManager.getChangedAttributes({ clearChangedFlags: true });
        this._updateAttributes(changedAttributes);
      }
    }
  }, {
    key: '_updateAttributes',
    value: function _updateAttributes(attributes) {
      var modelsByName = this.state.modelsByName;


      for (var modelName in modelsByName) {
        var model = modelsByName[modelName];

        if (modelName === 'TOP') {
          model.setVertexCount(this.state.numVertex);
        } else {
          model.setInstanceCount(this.state.numInstances);
        }

        var attributeMap = ATTRIBUTE_MAPS[modelName];
        var newAttributes = {};
        for (var attributeName in attributes) {
          var attribute = attributes[attributeName];
          var attributeOverride = attributeMap[attributeName];

          if (attributeOverride) {
            var newAttribute = Object.assign({}, attribute, attributeOverride);

            // Hack: elevations is ignored when not extruded
            // TODO/xiaoji: replace with generic vertex
            newAttribute.instanced |= !this.props.extruded && attributeName === 'elevations';
            newAttributes[attributeOverride.name || attributeName] = newAttribute;
          }
        }
        model.setAttributes(newAttributes);
      }
    }
  }, {
    key: '_getModels',
    value: function _getModels(gl) {
      var _props2 = this.props,
          id = _props2.id,
          filled = _props2.filled,
          extruded = _props2.extruded,
          wireframe = _props2.wireframe;


      var models = {};

      if (filled) {
        models.TOP = new Model(gl, Object.assign({}, this.getShaders(), {
          id: id + '-top',
          geometry: new Geometry({
            drawMode: GL.TRIANGLES,
            attributes: {
              vertexPositions: { size: 2, instanced: 1, value: new Float32Array([0, 1]) },
              nextPositions: { size: 3, instanced: 1, value: new Float32Array(3) },
              nextPositions64xyLow: { size: 2, instanced: 1, value: new Float32Array(2) }
            }
          }),
          uniforms: {
            isSideVertex: 0
          },
          instanceCount: 1,
          vertexCount: 0,
          isInstanced: true,
          isIndexed: true,
          shaderCache: this.context.shaderCache
        }));
      }
      if (filled && extruded) {
        models.SIDE = new Model(gl, Object.assign({}, this.getShaders(), {
          id: id + '-side',
          geometry: new Geometry({
            drawMode: GL.TRIANGLE_STRIP,
            vertexCount: 4,
            attributes: {
              vertexPositions: { size: 2, value: SIDE_FILL_POSITIONS }
            }
          }),
          uniforms: {
            isSideVertex: 1
          },
          isInstanced: true,
          shaderCache: this.context.shaderCache
        }));
      }
      if (extruded && wireframe) {
        models.WIRE = new Model(gl, Object.assign({}, this.getShaders(), {
          id: id + '-wire',
          geometry: new Geometry({
            drawMode: GL.LINE_STRIP,
            vertexCount: 4,
            attributes: {
              vertexPositions: { size: 2, value: SIDE_WIRE_POSITIONS }
            }
          }),
          uniforms: {
            isSideVertex: 1
          },
          isInstanced: true,
          shaderCache: this.context.shaderCache
        }));
      }

      return {
        models: [models.WIRE, models.SIDE, models.TOP].filter(Boolean),
        modelsByName: models
      };
    }
  }, {
    key: 'calculateIndices',
    value: function calculateIndices(attribute) {
      attribute.value = this.state.polygonTesselator.indices();
      attribute.target = GL.ELEMENT_ARRAY_BUFFER;
      var numVertex = attribute.value.length / attribute.size;
      this.setState({ numVertex: numVertex });
    }
  }, {
    key: 'calculatePositions',
    value: function calculatePositions(attribute) {
      attribute.value = this.state.polygonTesselator.positions();
      var numInstances = attribute.value.length / attribute.size;
      this.setState({ numInstances: numInstances });
    }
  }, {
    key: 'calculatePositionsLow',
    value: function calculatePositionsLow(attribute) {
      attribute.value = this.state.polygonTesselator.positions64xyLow();
    }
  }, {
    key: 'calculateNextPositions',
    value: function calculateNextPositions(attribute) {
      attribute.value = this.state.polygonTesselator.nextPositions();
    }
  }, {
    key: 'calculateNextPositionsLow',
    value: function calculateNextPositionsLow(attribute) {
      attribute.value = this.state.polygonTesselator.nextPositions64xyLow();
    }
  }, {
    key: 'calculateElevations',
    value: function calculateElevations(attribute) {
      var _this2 = this;

      if (this.props.extruded) {
        attribute.value = this.state.polygonTesselator.elevations({
          getElevation: function getElevation(polygonIndex) {
            return _this2.props.getElevation(_this2.props.data[polygonIndex]);
          }
        });
      } else {
        attribute.value = new Float32Array(1);
      }
    }
  }, {
    key: 'calculateFillColors',
    value: function calculateFillColors(attribute) {
      var _this3 = this;

      attribute.value = this.state.polygonTesselator.colors({
        key: 'fillColors',
        getColor: function getColor(polygonIndex) {
          return _this3.props.getFillColor(_this3.props.data[polygonIndex]);
        }
      });
    }
  }, {
    key: 'calculateLineColors',
    value: function calculateLineColors(attribute) {
      var _this4 = this;

      attribute.value = this.state.polygonTesselator.colors({
        key: 'lineColors',
        getColor: function getColor(polygonIndex) {
          return _this4.props.getLineColor(_this4.props.data[polygonIndex]);
        }
      });
    }

    // Override the default picking colors calculation

  }, {
    key: 'calculatePickingColors',
    value: function calculatePickingColors(attribute) {
      attribute.value = this.state.polygonTesselator.pickingColors();
    }
  }]);

  return SolidPolygonLayer;
}(Layer);

export default SolidPolygonLayer;


SolidPolygonLayer.layerName = 'SolidPolygonLayer';
SolidPolygonLayer.defaultProps = defaultProps;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9leHBlcmltZW50YWwtbGF5ZXJzL3NyYy9zb2xpZC1wb2x5Z29uLWxheWVyL3NvbGlkLXBvbHlnb24tbGF5ZXIuanMiXSwibmFtZXMiOlsiQ09PUkRJTkFURV9TWVNURU0iLCJMYXllciIsImV4cGVyaW1lbnRhbCIsImVuYWJsZTY0Yml0U3VwcG9ydCIsImdldCIsIkdMIiwiTW9kZWwiLCJHZW9tZXRyeSIsIlBvbHlnb25UZXNzZWxhdG9yIiwidnMiLCJ2czY0IiwiZnMiLCJkZWZhdWx0TGluZUNvbG9yIiwiZGVmYXVsdEZpbGxDb2xvciIsImRlZmF1bHRQcm9wcyIsImZpbGxlZCIsImV4dHJ1ZGVkIiwid2lyZWZyYW1lIiwiZnA2NCIsImVsZXZhdGlvblNjYWxlIiwiZ2V0UG9seWdvbiIsImYiLCJnZXRFbGV2YXRpb24iLCJnZXRGaWxsQ29sb3IiLCJnZXRMaW5lQ29sb3IiLCJsaWdodFNldHRpbmdzIiwibGlnaHRzUG9zaXRpb24iLCJhbWJpZW50UmF0aW8iLCJkaWZmdXNlUmF0aW8iLCJzcGVjdWxhclJhdGlvIiwibGlnaHRzU3RyZW5ndGgiLCJudW1iZXJPZkxpZ2h0cyIsIlNJREVfRklMTF9QT1NJVElPTlMiLCJGbG9hdDMyQXJyYXkiLCJTSURFX1dJUkVfUE9TSVRJT05TIiwiQVRUUklCVVRFX01BUFMiLCJUT1AiLCJpbmRpY2VzIiwiaW5zdGFuY2VkIiwicG9zaXRpb25zIiwicG9zaXRpb25zNjR4eUxvdyIsImVsZXZhdGlvbnMiLCJmaWxsQ29sb3JzIiwibmFtZSIsInBpY2tpbmdDb2xvcnMiLCJTSURFIiwibmV4dFBvc2l0aW9ucyIsIm5leHRQb3NpdGlvbnM2NHh5TG93IiwiV0lSRSIsImxpbmVDb2xvcnMiLCJTb2xpZFBvbHlnb25MYXllciIsInByb3BzIiwibW9kdWxlcyIsImdsIiwiY29udGV4dCIsInNldFN0YXRlIiwibnVtSW5zdGFuY2VzIiwiSW5kZXhUeXBlIiwiZ2V0RXh0ZW5zaW9uIiwiVWludDMyQXJyYXkiLCJVaW50MTZBcnJheSIsImF0dHJpYnV0ZU1hbmFnZXIiLCJzdGF0ZSIsIm5vQWxsb2MiLCJhZGQiLCJzaXplIiwiaXNJbmRleGVkIiwidXBkYXRlIiwiY2FsY3VsYXRlSW5kaWNlcyIsImFjY2Vzc29yIiwiY2FsY3VsYXRlUG9zaXRpb25zIiwiY2FsY3VsYXRlTmV4dFBvc2l0aW9ucyIsImNhbGN1bGF0ZUVsZXZhdGlvbnMiLCJhbGlhcyIsInR5cGUiLCJVTlNJR05FRF9CWVRFIiwiY2FsY3VsYXRlRmlsbENvbG9ycyIsImNhbGN1bGF0ZUxpbmVDb2xvcnMiLCJjYWxjdWxhdGVQaWNraW5nQ29sb3JzIiwib2xkUHJvcHMiLCJjb29yZGluYXRlU3lzdGVtIiwiTE5HTEFUIiwiY2FsY3VsYXRlUG9zaXRpb25zTG93IiwiY2FsY3VsYXRlTmV4dFBvc2l0aW9uc0xvdyIsInJlbW92ZSIsInVuaWZvcm1zIiwicmVuZGVyVW5pZm9ybXMiLCJPYmplY3QiLCJhc3NpZ24iLCJtb2RlbHMiLCJmb3JFYWNoIiwibW9kZWwiLCJyZW5kZXIiLCJ1cGRhdGVQYXJhbXMiLCJ1cGRhdGVHZW9tZXRyeSIsInVwZGF0ZUF0dHJpYnV0ZSIsInJlZ2VuZXJhdGVNb2RlbHMiLCJtb2RlbHNDaGFuZ2VkIiwiX2dldE1vZGVscyIsImludmFsaWRhdGUiLCJjaGFuZ2VGbGFncyIsImdlb21ldHJ5Q29uZmlnQ2hhbmdlZCIsImRhdGFDaGFuZ2VkIiwidXBkYXRlVHJpZ2dlcnNDaGFuZ2VkIiwiYWxsIiwicG9seWdvbnMiLCJkYXRhIiwibWFwIiwicG9seWdvblRlc3NlbGF0b3IiLCJpbnZhbGlkYXRlQWxsIiwidXBkYXRlUG9zaXRpb25zIiwiYnVmZmVycyIsImlnbm9yZVVua25vd25BdHRyaWJ1dGVzIiwiX3VwZGF0ZUF0dHJpYnV0ZXMiLCJhdHRyaWJ1dGVzIiwiY2hhbmdlZEF0dHJpYnV0ZXMiLCJnZXRDaGFuZ2VkQXR0cmlidXRlcyIsImNsZWFyQ2hhbmdlZEZsYWdzIiwibW9kZWxzQnlOYW1lIiwibW9kZWxOYW1lIiwic2V0VmVydGV4Q291bnQiLCJudW1WZXJ0ZXgiLCJzZXRJbnN0YW5jZUNvdW50IiwiYXR0cmlidXRlTWFwIiwibmV3QXR0cmlidXRlcyIsImF0dHJpYnV0ZU5hbWUiLCJhdHRyaWJ1dGUiLCJhdHRyaWJ1dGVPdmVycmlkZSIsIm5ld0F0dHJpYnV0ZSIsInNldEF0dHJpYnV0ZXMiLCJpZCIsImdldFNoYWRlcnMiLCJnZW9tZXRyeSIsImRyYXdNb2RlIiwiVFJJQU5HTEVTIiwidmVydGV4UG9zaXRpb25zIiwidmFsdWUiLCJpc1NpZGVWZXJ0ZXgiLCJpbnN0YW5jZUNvdW50IiwidmVydGV4Q291bnQiLCJpc0luc3RhbmNlZCIsInNoYWRlckNhY2hlIiwiVFJJQU5HTEVfU1RSSVAiLCJMSU5FX1NUUklQIiwiZmlsdGVyIiwiQm9vbGVhbiIsInRhcmdldCIsIkVMRU1FTlRfQVJSQVlfQlVGRkVSIiwibGVuZ3RoIiwicG9seWdvbkluZGV4IiwiY29sb3JzIiwia2V5IiwiZ2V0Q29sb3IiLCJsYXllck5hbWUiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFRQSxpQkFBUixFQUEyQkMsS0FBM0IsRUFBa0NDLFlBQWxDLFFBQXFELFNBQXJEO0lBQ09DLGtCLEdBQTJCRCxZLENBQTNCQyxrQjtJQUFvQkMsRyxHQUFPRixZLENBQVBFLEc7O0FBQzNCLFNBQVFDLEVBQVIsRUFBWUMsS0FBWixFQUFtQkMsUUFBbkIsUUFBa0MsU0FBbEM7O0FBRUE7QUFDQSxTQUFRQyxpQkFBUixRQUFnQyxzQkFBaEM7O0FBRUEsT0FBT0MsRUFBUCxNQUFlLG1DQUFmO0FBQ0EsT0FBT0MsSUFBUCxNQUFpQixzQ0FBakI7QUFDQSxPQUFPQyxFQUFQLE1BQWUscUNBQWY7O0FBRUEsSUFBTUMsbUJBQW1CLENBQUMsR0FBRCxFQUFNLEdBQU4sRUFBVyxHQUFY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QUFDTHZCLGtCQUFVVSxLQUFWLEdBQWtCLElBQUl2RyxZQUFKLENBQWlCLENBQWpCLENBQWxCO0FBQ0Q7QUFDRjs7O3dDQUVtQjZGLFMsRUFBVztBQUFBOztBQUM3QkEsZ0JBQVVVLEtBQVYsR0FBa0IsS0FBSzFFLEtBQUwsQ0FBVzhDLGlCQUFYLENBQTZCMEMsTUFBN0IsQ0FBb0M7QUFDcERDLGFBQUssWUFEK0M7QUFFcERDLGtCQUFVO0FBQUEsaUJBQWdCLE9BQUtyRyxLQUFMLENBQVc1QixZQUFYLENBQXdCLE9BQUs0QixLQUFMLENBQVd1RCxJQUFYLENBQWdCMkMsWUFBaEIsQ0FBeEIsQ0FBaEI7QUFBQTtBQUYwQyxPQUFwQyxDQUFsQjtBQUlEOzs7d0NBQ21CdkIsUyxFQUFXO0FBQUE7O0FBQzdCQSxnQkFBVVUsS0FBVixHQUFrQixLQUFLMUUsS0FBTCxDQUFXOEMsaUJBQVgsQ0FBNkIwQyxNQUE3QixDQUFvQztBQUNwREMsYUFBSyxZQUQrQztBQUVwREMsa0JBQVU7QUFBQSxpQkFBZ0IsT0FBS3JHLEtBQUwsQ0FBVzNCLFlBQVgsQ0FBd0IsT0FBSzJCLEtBQUwsQ0FBV3VELElBQVgsQ0FBZ0IyQyxZQUFoQixDQUF4QixDQUFoQjtBQUFBO0FBRjBDLE9BQXBDLENBQWxCO0FBSUQ7O0FBRUQ7Ozs7MkNBQ3VCdkIsUyxFQUFXO0FBQ2hDQSxnQkFBVVUsS0FBVixHQUFrQixLQUFLMUUsS0FBTCxDQUFXOEMsaUJBQVgsQ0FBNkJoRSxhQUE3QixFQUFsQjtBQUNEOzs7O0VBbFY0QzNDLEs7O2VBQTFCaUQsaUI7OztBQXFWckJBLGtCQUFrQnVHLFNBQWxCLEdBQThCLG1CQUE5QjtBQUNBdkcsa0JBQWtCcEMsWUFBbEIsR0FBaUNBLFlBQWpDIiwiZmlsZSI6InNvbGlkLXBvbHlnb24tbGF5ZXIuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIDIwMTUgLSAyMDE3IFViZXIgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbi8vIFRIRSBTT0ZUV0FSRS5cblxuaW1wb3J0IHtDT09SRElOQVRFX1NZU1RFTSwgTGF5ZXIsIGV4cGVyaW1lbnRhbH0gZnJvbSAnZGVjay5nbCc7XG5jb25zdCB7ZW5hYmxlNjRiaXRTdXBwb3J0LCBnZXR9ID0gZXhwZXJpbWVudGFsO1xuaW1wb3J0IHtHTCwgTW9kZWwsIEdlb21ldHJ5fSBmcm9tICdsdW1hLmdsJztcblxuLy8gUG9seWdvbiBnZW9tZXRyeSBnZW5lcmF0aW9uIGlzIG1hbmFnZWQgYnkgdGhlIHBvbHlnb24gdGVzc2VsYXRvclxuaW1wb3J0IHtQb2x5Z29uVGVzc2VsYXRvcn0gZnJvbSAnLi9wb2x5Z29uLXRlc3NlbGF0b3InO1xuXG5pbXBvcnQgdnMgZnJvbSAnLi9zb2xpZC1wb2x5Z29uLWxheWVyLXZlcnRleC5nbHNsJztcbmltcG9ydCB2czY0IGZyb20gJy4vc29saWQtcG9seWdvbi1sYXllci12ZXJ0ZXgtNjQuZ2xzbCc7XG5pbXBvcnQgZnMgZnJvbSAnLi9zb2xpZC1wb2x5Z29uLWxheWVyLWZyYWdtZW50Lmdsc2wnO1xuXG5jb25zdCBkZWZhdWx0TGluZUNvbG9yID0gWzB4MCwgMHgwLCAweDAsIDB4ZmZdO1xuY29uc3QgZGVmYXVsdEZpbGxDb2xvciA9IFsweDAsIDB4MCwgMHgwLCAweGZmXTtcblxuY29uc3QgZGVmYXVsdFByb3BzID0ge1xuICBmaWxsZWQ6IHRydWUsXG4gIC8vIFdoZXRoZXIgdG8gZXh0cnVkZVxuICBleHRydWRlZDogZmFsc2UsXG4gIC8vIFdoZXRoZXIgdG8gZHJhdyBhIEdMLkxJTkVTIHdpcmVmcmFtZSBvZiB0aGUgcG9seWdvblxuICB3aXJlZnJhbWU6IGZhbHNlLFxuICBmcDY0OiBmYWxzZSxcblxuICAvLyBlbGV2YXRpb24gbXVsdGlwbGllclxuICBlbGV2YXRpb25TY2FsZTogMSxcblxuICAvLyBBY2Nlc3NvciBmb3IgcG9seWdvbiBnZW9tZXRyeVxuICBnZXRQb2x5Z29uOiBmID0+IGdldChmLCAncG9seWdvbicpIHx8IGdldChmLCAnZ2VvbWV0cnkuY29vcmRpbmF0ZXMnKSxcbiAgLy8gQWNjZXNzb3IgZm9yIGV4dHJ1c2lvbiBoZWlnaHRcbiAgZ2V0RWxldmF0aW9uOiBmID0+IGdldChmLCAnZWxldmF0aW9uJykgfHwgZ2V0KGYsICdwcm9wZXJ0aWVzLmhlaWdodCcpIHx8IDAsXG4gIC8vIEFjY2Vzc29yIGZvciBjb2xvcnNcbiAgZ2V0RmlsbENvbG9yOiBmID0+IGdldChmLCAnZmlsbENvbG9yJykgfHwgZ2V0KGYsICdwcm9wZXJ0aWVzLmNvbG9yJykgfHwgZGVmYXVsdEZpbGxDb2xvcixcbiAgZ2V0TGluZUNvbG9yOiBmID0+IGdldChmLCAnbGluZUNvbG9yJykgfHwgZ2V0KGYsICdwcm9wZXJ0aWVzLmNvbG9yJykgfHwgZGVmYXVsdExpbmVDb2xvcixcblxuICAvLyBPcHRpb25hbCBzZXR0aW5ncyBmb3IgJ2xpZ2h0aW5nJyBzaGFkZXIgbW9kdWxlXG4gIGxpZ2h0U2V0dGluZ3M6IHtcbiAgICBsaWdodHNQb3NpdGlvbjogWy0xMjIuNDUsIDM3Ljc1LCA4MDAwLCAtMTIyLjAsIDM4LjAsIDUwMDBdLFxuICAgIGFtYmllbnRSYXRpbzogMC4wNSxcbiAgICBkaWZmdXNlUmF0aW86IDAuNixcbiAgICBzcGVjdWxhclJhdGlvOiAwLjgsXG4gICAgbGlnaHRzU3RyZW5ndGg6IFsyLjAsIDAuMCwgMC4wLCAwLjBdLFxuICAgIG51bWJlck9mTGlnaHRzOiAyXG4gIH1cbn07XG5cbi8vIFNpZGUgbW9kZWwgYXR0cmlidXRlc1xuY29uc3QgU0lERV9GSUxMX1BPU0lUSU9OUyA9IG5ldyBGbG9hdDMyQXJyYXkoW1xuICAvLyB0b3AgbGVmdCBjb3JuZXJcbiAgMCxcbiAgMSxcbiAgLy8gYm90dG9tIGxlZnQgY29ybmVyXG4gIDAsXG4gIDAsXG4gIC8vIHRvcCByaWdodCBjb3JuZXJcbiAgMSxcbiAgMSxcbiAgLy8gYm90dG9tIHJpZ2h0IGNvcm5lclxuICAxLFxuICAwXG5dKTtcbmNvbnN0IFNJREVfV0lSRV9QT1NJVElPTlMgPSBuZXcgRmxvYXQzMkFycmF5KFtcbiAgLy8gdG9wIHJpZ2h0IGNvcm5lclxuICAxLFxuICAxLFxuICAvLyB0b3AgbGVmdCBjb3JuZXJcbiAgMCxcbiAgMSxcbiAgLy8gYm90dG9tIGxlZnQgY29ybmVyXG4gIDAsXG4gIDAsXG4gIC8vIGJvdHRvbSByaWdodCBjb3JuZXJcbiAgMSxcbiAgMFxuXSk7XG5cbi8vIE1vZGVsIHR5cGVzXG5jb25zdCBBVFRSSUJVVEVfTUFQUyA9IHtcbiAgVE9QOiB7XG4gICAgaW5kaWNlczoge2luc3RhbmNlZDogZmFsc2V9LFxuICAgIHBvc2l0aW9uczoge2luc3RhbmNlZDogZmFsc2V9LFxuICAgIHBvc2l0aW9uczY0eHlMb3c6IHtpbnN0YW5jZWQ6IGZhbHNlfSxcbiAgICBlbGV2YXRpb25zOiB7aW5zdGFuY2VkOiBmYWxzZX0sXG4gICAgZmlsbENvbG9yczoge25hbWU6ICdjb2xvcnMnLCBpbnN0YW5jZWQ6IGZhbHNlfSxcbiAgICBwaWNraW5nQ29sb3JzOiB7aW5zdGFuY2VkOiBmYWxzZX1cbiAgfSxcbiAgU0lERToge1xuICAgIHBvc2l0aW9uczoge2luc3RhbmNlZDogdHJ1ZX0sXG4gICAgcG9zaXRpb25zNjR4eUxvdzoge2luc3RhbmNlZDogdHJ1ZX0sXG4gICAgbmV4dFBvc2l0aW9uczoge2luc3RhbmNlZDogdHJ1ZX0sXG4gICAgbmV4dFBvc2l0aW9uczY0eHlMb3c6IHtpbnN0YW5jZWQ6IHRydWV9LFxuICAgIGVsZXZhdGlvbnM6IHtpbnN0YW5jZWQ6IHRydWV9LFxuICAgIGZpbGxDb2xvcnM6IHtuYW1lOiAnY29sb3JzJywgaW5zdGFuY2VkOiB0cnVlfSxcbiAgICBwaWNraW5nQ29sb3JzOiB7aW5zdGFuY2VkOiB0cnVlfVxuICB9LFxuICBXSVJFOiB7XG4gICAgcG9zaXRpb25zOiB7aW5zdGFuY2VkOiB0cnVlfSxcbiAgICBwb3NpdGlvbnM2NHh5TG93OiB7aW5zdGFuY2VkOiB0cnVlfSxcbiAgICBuZXh0UG9zaXRpb25zOiB7aW5zdGFuY2VkOiB0cnVlfSxcbiAgICBuZXh0UG9zaXRpb25zNjR4eUxvdzoge2luc3RhbmNlZDogdHJ1ZX0sXG4gICAgZWxldmF0aW9uczoge2luc3RhbmNlZDogdHJ1ZX0sXG4gICAgbGluZUNvbG9yczoge25hbWU6ICdjb2xvcnMnLCBpbnN0YW5jZWQ6IHRydWV9LFxuICAgIHBpY2tpbmdDb2xvcnM6IHtpbnN0YW5jZWQ6IHRydWV9XG4gIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNvbGlkUG9seWdvbkxheWVyIGV4dGVuZHMgTGF5ZXIge1xuICBnZXRTaGFkZXJzKCkge1xuICAgIHJldHVybiBlbmFibGU2NGJpdFN1cHBvcnQodGhpcy5wcm9wcylcbiAgICAgID8ge3ZzOiB2czY0LCBmcywgbW9kdWxlczogWydwcm9qZWN0NjQnLCAnbGlnaHRpbmcnLCAncGlja2luZyddfVxuICAgICAgOiB7dnMsIGZzLCBtb2R1bGVzOiBbJ2xpZ2h0aW5nJywgJ3BpY2tpbmcnXX07IC8vICdwcm9qZWN0JyBtb2R1bGUgYWRkZWQgYnkgZGVmYXVsdC5cbiAgfVxuXG4gIGluaXRpYWxpemVTdGF0ZSgpIHtcbiAgICBjb25zdCB7Z2x9ID0gdGhpcy5jb250ZXh0O1xuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgbnVtSW5zdGFuY2VzOiAwLFxuICAgICAgSW5kZXhUeXBlOiBnbC5nZXRFeHRlbnNpb24oJ09FU19lbGVtZW50X2luZGV4X3VpbnQnKSA/IFVpbnQzMkFycmF5IDogVWludDE2QXJyYXlcbiAgICB9KTtcblxuICAgIGNvbnN0IHthdHRyaWJ1dGVNYW5hZ2VyfSA9IHRoaXMuc3RhdGU7XG4gICAgY29uc3Qgbm9BbGxvYyA9IHRydWU7XG4gICAgLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiAqL1xuICAgIGF0dHJpYnV0ZU1hbmFnZXIuYWRkKHtcbiAgICAgIGluZGljZXM6IHtzaXplOiAxLCBpc0luZGV4ZWQ6IHRydWUsIHVwZGF0ZTogdGhpcy5jYWxjdWxhdGVJbmRpY2VzLCBub0FsbG9jfSxcbiAgICAgIHBvc2l0aW9uczoge1xuICAgICAgICBzaXplOiAzLFxuICAgICAgICBhY2Nlc3NvcjogWydleHRydWRlZCcsICdmcDY0J10sXG4gICAgICAgIHVwZGF0ZTogdGhpcy5jYWxjdWxhdGVQb3NpdGlvbnMsXG4gICAgICAgIG5vQWxsb2NcbiAgICAgIH0sXG4gICAgICBuZXh0UG9zaXRpb25zOiB7XG4gICAgICAgIHNpemU6IDMsXG4gICAgICAgIGFjY2Vzc29yOiBbJ2V4dHJ1ZGVkJywgJ2ZwNjQnXSxcbiAgICAgICAgdXBkYXRlOiB0aGlzLmNhbGN1bGF0ZU5leHRQb3NpdGlvbnMsXG4gICAgICAgIG5vQWxsb2NcbiAgICAgIH0sXG4gICAgICBlbGV2YXRpb25zOiB7XG4gICAgICAgIHNpemU6IDEsXG4gICAgICAgIGFjY2Vzc29yOiBbJ2V4dHJ1ZGVkJywgJ2dldEVsZXZhdGlvbiddLFxuICAgICAgICB1cGRhdGU6IHRoaXMuY2FsY3VsYXRlRWxldmF0aW9ucyxcbiAgICAgICAgbm9BbGxvY1xuICAgICAgfSxcbiAgICAgIGZpbGxDb2xvcnM6IHtcbiAgICAgICAgYWxpYXM6ICdjb2xvcnMnLFxuICAgICAgICBzaXplOiA0LFxuICAgICAgICB0eXBlOiBHTC5VTlNJR05FRF9CWVRFLFxuICAgICAgICBhY2Nlc3NvcjogJ2dldEZpbGxDb2xvcicsXG4gICAgICAgIHVwZGF0ZTogdGhpcy5jYWxjdWxhdGVGaWxsQ29sb3JzLFxuICAgICAgICBub0FsbG9jXG4gICAgICB9LFxuICAgICAgbGluZUNvbG9yczoge1xuICAgICAgICBhbGlhczogJ2NvbG9ycycsXG4gICAgICAgIHNpemU6IDQsXG4gICAgICAgIHR5cGU6IEdMLlVOU0lHTkVEX0JZVEUsXG4gICAgICAgIGFjY2Vzc29yOiAnZ2V0TGluZUNvbG9yJyxcbiAgICAgICAgdXBkYXRlOiB0aGlzLmNhbGN1bGF0ZUxpbmVDb2xvcnMsXG4gICAgICAgIG5vQWxsb2NcbiAgICAgIH0sXG4gICAgICBwaWNraW5nQ29sb3JzOiB7c2l6ZTogMywgdHlwZTogR0wuVU5TSUdORURfQllURSwgdXBkYXRlOiB0aGlzLmNhbGN1bGF0ZVBpY2tpbmdDb2xvcnMsIG5vQWxsb2N9XG4gICAgfSk7XG4gICAgLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuICovXG4gIH1cblxuICB1cGRhdGVBdHRyaWJ1dGUoe3Byb3BzLCBvbGRQcm9wc30pIHtcbiAgICBpZiAocHJvcHMuZnA2NCAhPT0gb2xkUHJvcHMuZnA2NCkge1xuICAgICAgY29uc3Qge2F0dHJpYnV0ZU1hbmFnZXJ9ID0gdGhpcy5zdGF0ZTtcblxuICAgICAgaWYgKHByb3BzLmZwNjQgJiYgcHJvcHMuY29vcmRpbmF0ZVN5c3RlbSA9PT0gQ09PUkRJTkFURV9TWVNURU0uTE5HTEFUKSB7XG4gICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4gKi9cbiAgICAgICAgYXR0cmlidXRlTWFuYWdlci5hZGQoe1xuICAgICAgICAgIHBvc2l0aW9uczY0eHlMb3c6IHtzaXplOiAyLCBhY2Nlc3NvcjogJ2ZwNjQnLCB1cGRhdGU6IHRoaXMuY2FsY3VsYXRlUG9zaXRpb25zTG93fSxcbiAgICAgICAgICBuZXh0UG9zaXRpb25zNjR4eUxvdzoge3NpemU6IDIsIGFjY2Vzc29yOiAnZnA2NCcsIHVwZGF0ZTogdGhpcy5jYWxjdWxhdGVOZXh0UG9zaXRpb25zTG93fVxuICAgICAgICB9KTtcbiAgICAgICAgLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuICovXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhdHRyaWJ1dGVNYW5hZ2VyLnJlbW92ZShbJ3Bvc2l0aW9uczY0eHlMb3cnLCAnbmV4dFBvc2l0aW9uczY0eHlMb3cnXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZHJhdyh7dW5pZm9ybXN9KSB7XG4gICAgY29uc3Qge2V4dHJ1ZGVkLCBsaWdodFNldHRpbmdzLCBlbGV2YXRpb25TY2FsZX0gPSB0aGlzLnByb3BzO1xuXG4gICAgY29uc3QgcmVuZGVyVW5pZm9ybXMgPSBPYmplY3QuYXNzaWduKFxuICAgICAge30sXG4gICAgICB1bmlmb3JtcyxcbiAgICAgIHtcbiAgICAgICAgZXh0cnVkZWQ6IGV4dHJ1ZGVkID8gMS4wIDogMC4wLFxuICAgICAgICBlbGV2YXRpb25TY2FsZVxuICAgICAgfSxcbiAgICAgIGxpZ2h0U2V0dGluZ3NcbiAgICApO1xuXG4gICAgdGhpcy5zdGF0ZS5tb2RlbHMuZm9yRWFjaChtb2RlbCA9PiB7XG4gICAgICBtb2RlbC5yZW5kZXIocmVuZGVyVW5pZm9ybXMpO1xuICAgIH0pO1xuICB9XG5cbiAgdXBkYXRlU3RhdGUodXBkYXRlUGFyYW1zKSB7XG4gICAgc3VwZXIudXBkYXRlU3RhdGUodXBkYXRlUGFyYW1zKTtcblxuICAgIHRoaXMudXBkYXRlR2VvbWV0cnkodXBkYXRlUGFyYW1zKTtcbiAgICB0aGlzLnVwZGF0ZUF0dHJpYnV0ZSh1cGRhdGVQYXJhbXMpO1xuXG4gICAgY29uc3Qge3Byb3BzLCBvbGRQcm9wc30gPSB1cGRhdGVQYXJhbXM7XG5cbiAgICBjb25zdCByZWdlbmVyYXRlTW9kZWxzID1cbiAgICAgIHByb3BzLmZwNjQgIT09IG9sZFByb3BzLmZwNjQgfHxcbiAgICAgIHByb3BzLmZpbGxlZCAhPT0gb2xkUHJvcHMuZmlsbGVkIHx8XG4gICAgICBwcm9wcy5leHRydWRlZCAhPT0gb2xkUHJvcHMuZXh0cnVkZWQgfHxcbiAgICAgIHByb3BzLndpcmVmcmFtZSAhPT0gb2xkUHJvcHMud2lyZWZyYW1lO1xuXG4gICAgaWYgKHJlZ2VuZXJhdGVNb2RlbHMpIHtcbiAgICAgIHRoaXMuc2V0U3RhdGUoXG4gICAgICAgIE9iamVjdC5hc3NpZ24oXG4gICAgICAgICAge1xuICAgICAgICAgICAgLy8gU2V0IGEgZmxhZyB0byBzZXQgYXR0cmlidXRlcyB0byBuZXcgbW9kZWxzXG4gICAgICAgICAgICBtb2RlbHNDaGFuZ2VkOiB0cnVlXG4gICAgICAgICAgfSxcbiAgICAgICAgICB0aGlzLl9nZXRNb2RlbHModGhpcy5jb250ZXh0LmdsKVxuICAgICAgICApXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmIChwcm9wcy5leHRydWRlZCAhPT0gb2xkUHJvcHMuZXh0cnVkZWQpIHtcbiAgICAgIHRoaXMuc3RhdGUuYXR0cmlidXRlTWFuYWdlci5pbnZhbGlkYXRlKCdleHRydWRlZCcpO1xuICAgIH1cbiAgICBpZiAocHJvcHMuZnA2NCAhPT0gb2xkUHJvcHMuZnA2NCkge1xuICAgICAgdGhpcy5zdGF0ZS5hdHRyaWJ1dGVNYW5hZ2VyLmludmFsaWRhdGUoJ2ZwNjQnKTtcbiAgICB9XG4gIH1cblxuICB1cGRhdGVHZW9tZXRyeSh7cHJvcHMsIG9sZFByb3BzLCBjaGFuZ2VGbGFnc30pIHtcbiAgICBjb25zdCBnZW9tZXRyeUNvbmZpZ0NoYW5nZWQgPVxuICAgICAgY2hhbmdlRmxhZ3MuZGF0YUNoYW5nZWQgfHxcbiAgICAgIChjaGFuZ2VGbGFncy51cGRhdGVUcmlnZ2Vyc0NoYW5nZWQgJiZcbiAgICAgICAgKGNoYW5nZUZsYWdzLnVwZGF0ZVRyaWdnZXJzQ2hhbmdlZC5hbGwgfHwgY2hhbmdlRmxhZ3MudXBkYXRlVHJpZ2dlcnNDaGFuZ2VkLmdldFBvbHlnb24pKTtcblxuICAgIC8vIFdoZW4gdGhlIGdlb21ldHJ5IGNvbmZpZyAgb3IgdGhlIGRhdGEgaXMgY2hhbmdlZCxcbiAgICAvLyB0ZXNzZWxsYXRvciBuZWVkcyB0byBiZSBpbnZva2VkXG4gICAgaWYgKGdlb21ldHJ5Q29uZmlnQ2hhbmdlZCkge1xuICAgICAgLy8gVE9ETyAtIGF2b2lkIGNyZWF0aW5nIGEgdGVtcG9yYXJ5IGFycmF5IGhlcmU6IGxldCB0aGUgdGVzc2VsYXRvciBpdGVyYXRlXG4gICAgICBjb25zdCBwb2x5Z29ucyA9IHByb3BzLmRhdGEubWFwKHByb3BzLmdldFBvbHlnb24pO1xuXG4gICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgcG9seWdvblRlc3NlbGF0b3I6IG5ldyBQb2x5Z29uVGVzc2VsYXRvcih7cG9seWdvbnMsIEluZGV4VHlwZTogdGhpcy5zdGF0ZS5JbmRleFR5cGV9KVxuICAgICAgfSk7XG5cbiAgICAgIHRoaXMuc3RhdGUuYXR0cmlidXRlTWFuYWdlci5pbnZhbGlkYXRlQWxsKCk7XG4gICAgfVxuXG4gICAgaWYgKFxuICAgICAgZ2VvbWV0cnlDb25maWdDaGFuZ2VkIHx8XG4gICAgICBwcm9wcy5leHRydWRlZCAhPT0gb2xkUHJvcHMuZXh0cnVkZWQgfHxcbiAgICAgIHByb3BzLmZwNjQgIT09IG9sZFByb3BzLmZwNjRcbiAgICApIHtcbiAgICAgIHRoaXMuc3RhdGUucG9seWdvblRlc3NlbGF0b3IudXBkYXRlUG9zaXRpb25zKHtcbiAgICAgICAgZnA2NDogcHJvcHMuZnA2NCxcbiAgICAgICAgZXh0cnVkZWQ6IHByb3BzLmV4dHJ1ZGVkXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICB1cGRhdGVBdHRyaWJ1dGVzKHByb3BzKSB7XG4gICAgY29uc3Qge2F0dHJpYnV0ZU1hbmFnZXIsIG1vZGVsc0NoYW5nZWR9ID0gdGhpcy5zdGF0ZTtcblxuICAgIC8vIEZpZ3VyZSBvdXQgZGF0YSBsZW5ndGhcbiAgICBhdHRyaWJ1dGVNYW5hZ2VyLnVwZGF0ZSh7XG4gICAgICBkYXRhOiBwcm9wcy5kYXRhLFxuICAgICAgbnVtSW5zdGFuY2VzOiAwLFxuICAgICAgcHJvcHMsXG4gICAgICBidWZmZXJzOiBwcm9wcyxcbiAgICAgIGNvbnRleHQ6IHRoaXMsXG4gICAgICAvLyBEb24ndCB3b3JyeSBhYm91dCBub24tYXR0cmlidXRlIHByb3BzXG4gICAgICBpZ25vcmVVbmtub3duQXR0cmlidXRlczogdHJ1ZVxuICAgIH0pO1xuXG4gICAgaWYgKG1vZGVsc0NoYW5nZWQpIHtcbiAgICAgIHRoaXMuX3VwZGF0ZUF0dHJpYnV0ZXMoYXR0cmlidXRlTWFuYWdlci5hdHRyaWJ1dGVzKTtcbiAgICAgIC8vIGNsZWFyIHRoZSBmbGFnXG4gICAgICB0aGlzLnNldFN0YXRlKHttb2RlbHNDaGFuZ2VkOiBmYWxzZX0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBjaGFuZ2VkQXR0cmlidXRlcyA9IGF0dHJpYnV0ZU1hbmFnZXIuZ2V0Q2hhbmdlZEF0dHJpYnV0ZXMoe2NsZWFyQ2hhbmdlZEZsYWdzOiB0cnVlfSk7XG4gICAgICB0aGlzLl91cGRhdGVBdHRyaWJ1dGVzKGNoYW5nZWRBdHRyaWJ1dGVzKTtcbiAgICB9XG4gIH1cblxuICBfdXBkYXRlQXR0cmlidXRlcyhhdHRyaWJ1dGVzKSB7XG4gICAgY29uc3Qge21vZGVsc0J5TmFtZX0gPSB0aGlzLnN0YXRlO1xuXG4gICAgZm9yIChjb25zdCBtb2RlbE5hbWUgaW4gbW9kZWxzQnlOYW1lKSB7XG4gICAgICBjb25zdCBtb2RlbCA9IG1vZGVsc0J5TmFtZVttb2RlbE5hbWVdO1xuXG4gICAgICBpZiAobW9kZWxOYW1lID09PSAnVE9QJykge1xuICAgICAgICBtb2RlbC5zZXRWZXJ0ZXhDb3VudCh0aGlzLnN0YXRlLm51bVZlcnRleCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtb2RlbC5zZXRJbnN0YW5jZUNvdW50KHRoaXMuc3RhdGUubnVtSW5zdGFuY2VzKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgYXR0cmlidXRlTWFwID0gQVRUUklCVVRFX01BUFNbbW9kZWxOYW1lXTtcbiAgICAgIGNvbnN0IG5ld0F0dHJpYnV0ZXMgPSB7fTtcbiAgICAgIGZvciAoY29uc3QgYXR0cmlidXRlTmFtZSBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgICAgIGNvbnN0IGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXNbYXR0cmlidXRlTmFtZV07XG4gICAgICAgIGNvbnN0IGF0dHJpYnV0ZU92ZXJyaWRlID0gYXR0cmlidXRlTWFwW2F0dHJpYnV0ZU5hbWVdO1xuXG4gICAgICAgIGlmIChhdHRyaWJ1dGVPdmVycmlkZSkge1xuICAgICAgICAgIGNvbnN0IG5ld0F0dHJpYnV0ZSA9IE9iamVjdC5hc3NpZ24oe30sIGF0dHJpYnV0ZSwgYXR0cmlidXRlT3ZlcnJpZGUpO1xuXG4gICAgICAgICAgLy8gSGFjazogZWxldmF0aW9ucyBpcyBpZ25vcmVkIHdoZW4gbm90IGV4dHJ1ZGVkXG4gICAgICAgICAgLy8gVE9ETy94aWFvamk6IHJlcGxhY2Ugd2l0aCBnZW5lcmljIHZlcnRleFxuICAgICAgICAgIG5ld0F0dHJpYnV0ZS5pbnN0YW5jZWQgfD0gIXRoaXMucHJvcHMuZXh0cnVkZWQgJiYgYXR0cmlidXRlTmFtZSA9PT0gJ2VsZXZhdGlvbnMnO1xuICAgICAgICAgIG5ld0F0dHJpYnV0ZXNbYXR0cmlidXRlT3ZlcnJpZGUubmFtZSB8fCBhdHRyaWJ1dGVOYW1lXSA9IG5ld0F0dHJpYnV0ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbW9kZWwuc2V0QXR0cmlidXRlcyhuZXdBdHRyaWJ1dGVzKTtcbiAgICB9XG4gIH1cblxuICBfZ2V0TW9kZWxzKGdsKSB7XG4gICAgY29uc3Qge2lkLCBmaWxsZWQsIGV4dHJ1ZGVkLCB3aXJlZnJhbWV9ID0gdGhpcy5wcm9wcztcblxuICAgIGNvbnN0IG1vZGVscyA9IHt9O1xuXG4gICAgaWYgKGZpbGxlZCkge1xuICAgICAgbW9kZWxzLlRPUCA9IG5ldyBNb2RlbChcbiAgICAgICAgZ2wsXG4gICAgICAgIE9iamVjdC5hc3NpZ24oe30sIHRoaXMuZ2V0U2hhZGVycygpLCB7XG4gICAgICAgICAgaWQ6IGAke2lkfS10b3BgLFxuICAgICAgICAgIGdlb21ldHJ5OiBuZXcgR2VvbWV0cnkoe1xuICAgICAgICAgICAgZHJhd01vZGU6IEdMLlRSSUFOR0xFUyxcbiAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgdmVydGV4UG9zaXRpb25zOiB7c2l6ZTogMiwgaW5zdGFuY2VkOiAxLCB2YWx1ZTogbmV3IEZsb2F0MzJBcnJheShbMCwgMV0pfSxcbiAgICAgICAgICAgICAgbmV4dFBvc2l0aW9uczoge3NpemU6IDMsIGluc3RhbmNlZDogMSwgdmFsdWU6IG5ldyBGbG9hdDMyQXJyYXkoMyl9LFxuICAgICAgICAgICAgICBuZXh0UG9zaXRpb25zNjR4eUxvdzoge3NpemU6IDIsIGluc3RhbmNlZDogMSwgdmFsdWU6IG5ldyBGbG9hdDMyQXJyYXkoMil9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSksXG4gICAgICAgICAgdW5pZm9ybXM6IHtcbiAgICAgICAgICAgIGlzU2lkZVZlcnRleDogMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgaW5zdGFuY2VDb3VudDogMSxcbiAgICAgICAgICB2ZXJ0ZXhDb3VudDogMCxcbiAgICAgICAgICBpc0luc3RhbmNlZDogdHJ1ZSxcbiAgICAgICAgICBpc0luZGV4ZWQ6IHRydWUsXG4gICAgICAgICAgc2hhZGVyQ2FjaGU6IHRoaXMuY29udGV4dC5zaGFkZXJDYWNoZVxuICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKGZpbGxlZCAmJiBleHRydWRlZCkge1xuICAgICAgbW9kZWxzLlNJREUgPSBuZXcgTW9kZWwoXG4gICAgICAgIGdsLFxuICAgICAgICBPYmplY3QuYXNzaWduKHt9LCB0aGlzLmdldFNoYWRlcnMoKSwge1xuICAgICAgICAgIGlkOiBgJHtpZH0tc2lkZWAsXG4gICAgICAgICAgZ2VvbWV0cnk6IG5ldyBHZW9tZXRyeSh7XG4gICAgICAgICAgICBkcmF3TW9kZTogR0wuVFJJQU5HTEVfU1RSSVAsXG4gICAgICAgICAgICB2ZXJ0ZXhDb3VudDogNCxcbiAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgdmVydGV4UG9zaXRpb25zOiB7c2l6ZTogMiwgdmFsdWU6IFNJREVfRklMTF9QT1NJVElPTlN9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSksXG4gICAgICAgICAgdW5pZm9ybXM6IHtcbiAgICAgICAgICAgIGlzU2lkZVZlcnRleDogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgaXNJbnN0YW5jZWQ6IHRydWUsXG4gICAgICAgICAgc2hhZGVyQ2FjaGU6IHRoaXMuY29udGV4dC5zaGFkZXJDYWNoZVxuICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKGV4dHJ1ZGVkICYmIHdpcmVmcmFtZSkge1xuICAgICAgbW9kZWxzLldJUkUgPSBuZXcgTW9kZWwoXG4gICAgICAgIGdsLFxuICAgICAgICBPYmplY3QuYXNzaWduKHt9LCB0aGlzLmdldFNoYWRlcnMoKSwge1xuICAgICAgICAgIGlkOiBgJHtpZH0td2lyZWAsXG4gICAgICAgICAgZ2VvbWV0cnk6IG5ldyBHZW9tZXRyeSh7XG4gICAgICAgICAgICBkcmF3TW9kZTogR0wuTElORV9TVFJJUCxcbiAgICAgICAgICAgIHZlcnRleENvdW50OiA0LFxuICAgICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgICB2ZXJ0ZXhQb3NpdGlvbnM6IHtzaXplOiAyLCB2YWx1ZTogU0lERV9XSVJFX1BPU0lUSU9OU31cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KSxcbiAgICAgICAgICB1bmlmb3Jtczoge1xuICAgICAgICAgICAgaXNTaWRlVmVydGV4OiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBpc0luc3RhbmNlZDogdHJ1ZSxcbiAgICAgICAgICBzaGFkZXJDYWNoZTogdGhpcy5jb250ZXh0LnNoYWRlckNhY2hlXG4gICAgICAgIH0pXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBtb2RlbHM6IFttb2RlbHMuV0lSRSwgbW9kZWxzLlNJREUsIG1vZGVscy5UT1BdLmZpbHRlcihCb29sZWFuKSxcbiAgICAgIG1vZGVsc0J5TmFtZTogbW9kZWxzXG4gICAgfTtcbiAgfVxuXG4gIGNhbGN1bGF0ZUluZGljZXMoYXR0cmlidXRlKSB7XG4gICAgYXR0cmlidXRlLnZhbHVlID0gdGhpcy5zdGF0ZS5wb2x5Z29uVGVzc2VsYXRvci5pbmRpY2VzKCk7XG4gICAgYXR0cmlidXRlLnRhcmdldCA9IEdMLkVMRU1FTlRfQVJSQVlfQlVGRkVSO1xuICAgIGNvbnN0IG51bVZlcnRleCA9IGF0dHJpYnV0ZS52YWx1ZS5sZW5ndGggLyBhdHRyaWJ1dGUuc2l6ZTtcbiAgICB0aGlzLnNldFN0YXRlKHtudW1WZXJ0ZXh9KTtcbiAgfVxuXG4gIGNhbGN1bGF0ZVBvc2l0aW9ucyhhdHRyaWJ1dGUpIHtcbiAgICBhdHRyaWJ1dGUudmFsdWUgPSB0aGlzLnN0YXRlLnBvbHlnb25UZXNzZWxhdG9yLnBvc2l0aW9ucygpO1xuICAgIGNvbnN0IG51bUluc3RhbmNlcyA9IGF0dHJpYnV0ZS52YWx1ZS5sZW5ndGggLyBhdHRyaWJ1dGUuc2l6ZTtcbiAgICB0aGlzLnNldFN0YXRlKHtudW1JbnN0YW5jZXN9KTtcbiAgfVxuICBjYWxjdWxhdGVQb3NpdGlvbnNMb3coYXR0cmlidXRlKSB7XG4gICAgYXR0cmlidXRlLnZhbHVlID0gdGhpcy5zdGF0ZS5wb2x5Z29uVGVzc2VsYXRvci5wb3NpdGlvbnM2NHh5TG93KCk7XG4gIH1cblxuICBjYWxjdWxhdGVOZXh0UG9zaXRpb25zKGF0dHJpYnV0ZSkge1xuICAgIGF0dHJpYnV0ZS52YWx1ZSA9IHRoaXMuc3RhdGUucG9seWdvblRlc3NlbGF0b3IubmV4dFBvc2l0aW9ucygpO1xuICB9XG4gIGNhbGN1bGF0ZU5leHRQb3NpdGlvbnNMb3coYXR0cmlidXRlKSB7XG4gICAgYXR0cmlidXRlLnZhbHVlID0gdGhpcy5zdGF0ZS5wb2x5Z29uVGVzc2VsYXRvci5uZXh0UG9zaXRpb25zNjR4eUxvdygpO1xuICB9XG5cbiAgY2FsY3VsYXRlRWxldmF0aW9ucyhhdHRyaWJ1dGUpIHtcbiAgICBpZiAodGhpcy5wcm9wcy5leHRydWRlZCkge1xuICAgICAgYXR0cmlidXRlLnZhbHVlID0gdGhpcy5zdGF0ZS5wb2x5Z29uVGVzc2VsYXRvci5lbGV2YXRpb25zKHtcbiAgICAgICAgZ2V0RWxldmF0aW9uOiBwb2x5Z29uSW5kZXggPT4gdGhpcy5wcm9wcy5nZXRFbGV2YXRpb24odGhpcy5wcm9wcy5kYXRhW3BvbHlnb25JbmRleF0pXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXR0cmlidXRlLnZhbHVlID0gbmV3IEZsb2F0MzJBcnJheSgxKTtcbiAgICB9XG4gIH1cblxuICBjYWxjdWxhdGVGaWxsQ29sb3JzKGF0dHJpYnV0ZSkge1xuICAgIGF0dHJpYnV0ZS52YWx1ZSA9IHRoaXMuc3RhdGUucG9seWdvblRlc3NlbGF0b3IuY29sb3JzKHtcbiAgICAgIGtleTogJ2ZpbGxDb2xvcnMnLFxuICAgICAgZ2V0Q29sb3I6IHBvbHlnb25JbmRleCA9PiB0aGlzLnByb3BzLmdldEZpbGxDb2xvcih0aGlzLnByb3BzLmRhdGFbcG9seWdvbkluZGV4XSlcbiAgICB9KTtcbiAgfVxuICBjYWxjdWxhdGVMaW5lQ29sb3JzKGF0dHJpYnV0ZSkge1xuICAgIGF0dHJpYnV0ZS52YWx1ZSA9IHRoaXMuc3RhdGUucG9seWdvblRlc3NlbGF0b3IuY29sb3JzKHtcbiAgICAgIGtleTogJ2xpbmVDb2xvcnMnLFxuICAgICAgZ2V0Q29sb3I6IHBvbHlnb25JbmRleCA9PiB0aGlzLnByb3BzLmdldExpbmVDb2xvcih0aGlzLnByb3BzLmRhdGFbcG9seWdvbkluZGV4XSlcbiAgICB9KTtcbiAgfVxuXG4gIC8vIE92ZXJyaWRlIHRoZSBkZWZhdWx0IHBpY2tpbmcgY29sb3JzIGNhbGN1bGF0aW9uXG4gIGNhbGN1bGF0ZVBpY2tpbmdDb2xvcnMoYXR0cmlidXRlKSB7XG4gICAgYXR0cmlidXRlLnZhbHVlID0gdGhpcy5zdGF0ZS5wb2x5Z29uVGVzc2VsYXRvci5waWNraW5nQ29sb3JzKCk7XG4gIH1cbn1cblxuU29saWRQb2x5Z29uTGF5ZXIubGF5ZXJOYW1lID0gJ1NvbGlkUG9seWdvbkxheWVyJztcblNvbGlkUG9seWdvbkxheWVyLmRlZmF1bHRQcm9wcyA9IGRlZmF1bHRQcm9wcztcbiJdfQ==