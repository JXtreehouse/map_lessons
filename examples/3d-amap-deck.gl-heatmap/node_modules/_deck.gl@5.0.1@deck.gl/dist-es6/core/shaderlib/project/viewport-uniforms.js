// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

/* global window */
import mat4_multiply from 'gl-mat4/multiply';
import vec4_transformMat4 from 'gl-vec4/transformMat4';

import log from '../../utils/log';
import assert from 'assert';
import { COORDINATE_SYSTEM } from '../../lib/constants';

import { projectFlat } from 'viewport-mercator-project';

// To quickly set a vector to zero
var ZERO_VECTOR = [0, 0, 0, 0];
// 4x4 matrix that drops 4th component of vector
var VECTOR_TO_POINT_MATRIX = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0];
var IDENTITY_MATRIX = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
var DEFAULT_PIXELS_PER_UNIT2 = [0, 0, 0];

// TODO - import these utils from fp64 package
function fp64ify(a) {
  var array = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  var startIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

  var hiPart = Math.fround(a);
  var loPart = a - hiPart;
  array[startIndex] = hiPart;
  array[startIndex + 1] = loPart;
  return array;
}

// calculate WebGL 64 bit matrix (transposed "Float64Array")
function fp64ifyMatrix4(matrix) {
  // Transpose the projection matrix to column major for GLSL.
  var matrixFP64 = new Float32Array(32);
  for (var i = 0; i < 4; ++i) {
    for (var j = 0; j < 4; ++j) {
      var index = i * 4 + j;
      fp64ify(matrix[j * 4 + i], matrixFP64, index * 2);
    }
  }
  return matrixFP64;
}

// The code that utilizes Matrix4 does the same calculation as their mat4 counterparts,
// has lower performance but provides error checking.
// Uncomment when debugging
function calculateMatrixAndOffset(_ref) {
  var viewport = _ref.viewport,
      modelMatrix = _ref.modelMatrix,
      coordinateSystem = _ref.coordinateSystem,
      coordinateOrigin = _ref.coordinateOrigin,
      coordinateZoom = _ref.coordinateZoom;
  var viewMatrixUncentered = viewport.viewMatrixUncentered;
  var viewMatrix = viewport.viewMatrix;
  var projectionMatrix = viewport.projectionMatrix;
  var viewProjectionMatrix = viewport.viewProjectionMatrix;


  var projectionCenter = void 0;

  switch (coordinateSystem) {
    case COORDINATE_SYSTEM.IDENTITY:
    case COORDINATE_SYSTEM.LNGLAT:
      projectionCenter = ZERO_VECTOR;
      break;

    // TODO: make lighting work for meter offset mode
    case COORDINATE_SYSTEM.LNGLAT_OFFSETS:
    case COORDINATE_SYSTEM.METER_OFFSETS:
      // Calculate transformed projectionCenter (using 64 bit precision JS)
      // This is the key to offset mode precision
      // (avoids doing this addition in 32 bit precision in GLSL)
      var positionPixels = projectFlat(coordinateOrigin, Math.pow(2, coordinateZoom));
      // projectionCenter = new Matrix4(viewProjectionMatrix)
      //   .transformVector([positionPixels[0], positionPixels[1], 0.0, 1.0]);
      projectionCenter = vec4_transformMat4([], [positionPixels[0], positionPixels[1], 0.0, 1.0], viewProjectionMatrix);

      // Always apply uncentered projection matrix if available (shader adds center)
      viewMatrix = viewMatrixUncentered || viewMatrix;

      // Zero out 4th coordinate ("after" model matrix) - avoids further translations
      // viewMatrix = new Matrix4(viewMatrixUncentered || viewMatrix)
      //   .multiplyRight(VECTOR_TO_POINT_MATRIX);
      viewProjectionMatrix = mat4_multiply([], projectionMatrix, viewMatrix);
      viewProjectionMatrix = mat4_multiply([], viewProjectionMatrix, VECTOR_TO_POINT_MATRIX);
      break;

    default:
      throw new Error('Unknown projection mode');
  }

  return {
    viewMatrix: viewMatrix,
    viewProjectionMatrix: viewProjectionMatrix,
    projectionCenter: projectionCenter,
    cameraPos: viewport.cameraPosition
  };
}

/**
 * Returns uniforms for shaders based on current projection
 * includes: projection matrix suitable for shaders
 *
 * TODO - Ensure this works with any viewport, not just WebMercatorViewports
 *
 * @param {WebMercatorViewport} viewport -
 * @return {Float32Array} - 4x4 projection matrix that can be used in shaders
 */
export function getUniformsFromViewport() {
  var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      viewport = _ref2.viewport,
      _ref2$modelMatrix = _ref2.modelMatrix,
      modelMatrix = _ref2$modelMatrix === undefined ? null : _ref2$modelMatrix,
      _ref2$coordinateSyste = _ref2.coordinateSystem,
      coordinateSystem = _ref2$coordinateSyste === undefined ? COORDINATE_SYSTEM.LNGLAT : _ref2$coordinateSyste,
      _ref2$coordinateOrigi = _ref2.coordinateOrigin,
      coordinateOrigin = _ref2$coordinateOrigi === undefined ? [0, 0] : _ref2$coordinateOrigi,
      _ref2$fp = _ref2.fp64,
      fp64 = _ref2$fp === undefined ? false : _ref2$fp,
      projectionMode = _ref2.projectionMode,
      positionOrigin = _ref2.positionOrigin;

  assert(viewport);

  if (projectionMode !== undefined) {
    log.removed('projectionMode', 'coordinateSystem');
  }
  if (positionOrigin !== undefined) {
    log.removed('positionOrigin', 'coordinateOrigin');
  }

  var coordinateZoom = viewport.zoom;
  assert(coordinateZoom >= 0);

  var _calculateMatrixAndOf = calculateMatrixAndOffset({
    coordinateSystem: coordinateSystem,
    coordinateOrigin: coordinateOrigin,
    coordinateZoom: coordinateZoom,
    modelMatrix: modelMatrix,
    viewport: viewport
  }),
      projectionCenter = _calculateMatrixAndOf.projectionCenter,
      viewProjectionMatrix = _calculateMatrixAndOf.viewProjectionMatrix,
      cameraPos = _calculateMatrixAndOf.cameraPos;

  assert(viewProjectionMatrix, 'Viewport missing modelViewProjectionMatrix');

  // Calculate projection pixels per unit
  var distanceScales = viewport.getDistanceScales();

  // TODO - does this depend on useDevicePixels?
  var devicePixelRatio = window && window.devicePixelRatio || 1;
  var viewportSize = [viewport.width * devicePixelRatio, viewport.height * devicePixelRatio];

  var glModelMatrix = modelMatrix || IDENTITY_MATRIX;

  var uniforms = {
    // Projection mode values
    project_uCoordinateSystem: coordinateSystem,
    project_uCenter: projectionCenter,

    // Screen size
    project_uViewportSize: viewportSize,
    project_uDevicePixelRatio: devicePixelRatio,

    // Distance at which screen pixels are projected
    project_uFocalDistance: viewport.focalDistance || 1,
    project_uPixelsPerMeter: distanceScales.pixelsPerMeter,
    project_uPixelsPerDegree: distanceScales.pixelsPerDegree,
    project_uPixelsPerUnit: distanceScales.pixelsPerMeter,
    project_uPixelsPerUnit2: DEFAULT_PIXELS_PER_UNIT2,
    project_uScale: viewport.scale, // This is the mercator scale (2 ** zoom)

    project_uModelMatrix: glModelMatrix,
    project_uViewProjectionMatrix: viewProjectionMatrix,

    // This is for lighting calculations
    project_uCameraPosition: cameraPos
  };

  if (coordinateSystem === COORDINATE_SYSTEM.METER_OFFSETS) {
    var distanceScalesAtOrigin = viewport.getDistanceScales(coordinateOrigin);
    uniforms.project_uPixelsPerUnit = distanceScalesAtOrigin.pixelsPerMeter;
    uniforms.project_uPixelsPerUnit2 = distanceScalesAtOrigin.pixelsPerMeter2;
  }
  if (coordinateSystem === COORDINATE_SYSTEM.LNGLAT_OFFSETS) {
    var _distanceScalesAtOrigin = viewport.getDistanceScales(coordinateOrigin);
    uniforms.project_uPixelsPerUnit = _distanceScalesAtOrigin.pixelsPerDegree;
    uniforms.project_uPixelsPerUnit2 = _distanceScalesAtOrigin.pixelsPerDegree2;
  }

  // TODO - fp64 flag should be from shader module, not layer props
  return fp64 ? addFP64Uniforms(uniforms) : uniforms;
}

// 64 bit projection support
function addFP64Uniforms(uniforms) {
  var glViewProjectionMatrixFP64 = fp64ifyMatrix4(uniforms.project_uViewProjectionMatrix);
  var scaleFP64 = fp64ify(uniforms.project_uScale);

  uniforms.project_uViewProjectionMatrixFP64 = glViewProjectionMatrixFP64;
  uniforms.project64_uViewProjectionMatrix = glViewProjectionMatrixFP64;
  uniforms.project64_uScale = scaleFP64;

  return uniforms;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9jb3JlL3NoYWRlcmxpYi9wcm9qZWN0L3ZpZXdwb3J0LXVuaWZvcm1zLmpzIl0sIm5hbWVzIjpbIm1hdDRfbXVsdGlwbHkiLCJ2ZWM0X3RyYW5zZm9ybU1hdDQiLCJsb2ciLCJhc3NlcnQiLCJDT09SRElOQVRFX1NZU1RFTSIsInByb2plY3RGbGF0IiwiWkVST19WRUNUT1IiLCJWRUNUT1JfVE9fUE9JTlRfTUFUUklYIiwiSURFTlRJVFlfTUFUUklYIiwiREVGQVVMVF9QSVhFTFNfUEVSX1VOSVQyIiwiZnA2NGlmeSIsImEiLCJhcnJheSIsInN0YXJ0SW5kZXgiLCJoaVBhcnQiLCJNYXRoIiwiZnJvdW5kIiwibG9QYXJ0IiwiZnA2NGlmeU1hdHJpeDQiLCJtYXRyaXgiLCJtYXRyaXhGUDY0IiwiRmxvYXQzMkFycmF5IiwiaSIsImoiLCJpbmRleCIsImNhbGN1bGF0ZU1hdHJpeEFuZE9mZnNldCIsInZpZXdwb3J0IiwibW9kZWxNYXRyaXgiLCJjb29yZGluYXRlU3lzdGVtIiwiY29vcmRpbmF0ZU9yaWdpbiIsImNvb3JkaW5hdGVab29tIiwidmlld01hdHJpeFVuY2VudGVyZWQiLCJ2aWV3TWF0cml4IiwicHJvamVjdGlvbk1hdHJpeCIsInZpZXdQcm9qZWN0aW9uTWF0cml4IiwicHJvamVjdGlvbkNlbnRlciIsIklERU5USVRZIiwiTE5HTEFUIiwiTE5HTEFUX09GRlNFVFMiLCJNRVRFUl9PRkZTRVRTIiwicG9zaXRpb25QaXhlbHMiLCJwb3ciLCJFcnJvciIsImNhbWVyYVBvcyIsImNhbWVyYVBvc2l0aW9uIiwiZ2V0VW5pZm9ybXNGcm9tVmlld3BvcnQiLCJmcDY0IiwicHJvamVjdGlvbk1vZGUiLCJwb3NpdGlvbk9yaWdpbiIsInVuZGVmaW5lZCIsInJlbW92ZWQiLCJ6b29tIiwiZGlzdGFuY2VTY2FsZXMiLCJnZXREaXN0YW5jZVNjYWxlcyIsImRldmljZVBpeGVsUmF0aW8iLCJ3aW5kb3ciLCJ2aWV3cG9ydFNpemUiLCJ3aWR0aCIsImhlaWdodCIsImdsTW9kZWxNYXRyaXgiLCJ1bmlmb3JtcyIsInByb2plY3RfdUNvb3JkaW5hdGVTeXN0ZW0iLCJwcm9qZWN0X3VDZW50ZXIiLCJwcm9qZWN0X3VWaWV3cG9ydFNpemUiLCJwcm9qZWN0X3VEZXZpY2VQaXhlbFJhdGlvIiwicHJvamVjdF91Rm9jYWxEaXN0YW5jZSIsImZvY2FsRGlzdGFuY2UiLCJwcm9qZWN0X3VQaXhlbHNQZXJNZXRlciIsInBpeGVsc1Blck1ldGVyIiwicHJvamVjdF91UGl4ZWxzUGVyRGVncmVlIiwicGl4ZWxzUGVyRGVncmVlIiwicHJvamVjdF91UGl4ZWxzUGVyVW5pdCIsInByb2plY3RfdVBpeGVsc1BlclVuaXQyIiwicHJvamVjdF91U2NhbGUiLCJzY2FsZSIsInByb2plY3RfdU1vZGVsTWF0cml4IiwicHJvamVjdF91Vmlld1Byb2plY3Rpb25NYXRyaXgiLCJwcm9qZWN0X3VDYW1lcmFQb3NpdGlvbiIsImRpc3RhbmNlU2NhbGVzQXRPcmlnaW4iLCJwaXhlbHNQZXJNZXRlcjIiLCJwaXhlbHNQZXJEZWdyZWUyIiwiYWRkRlA2NFVuaWZvcm1zIiwiZ2xWaWV3UHJvamVjdGlvbk1hdHJpeEZQNjQiLCJzY2FsZUZQNjQiLCJwcm9qZWN0X3VWaWV3UHJvamVjdGlvbk1hdHJpeEZQNjQiLCJwcm9qZWN0NjRfdVZpZXdQcm9qZWN0aW9uTWF0cml4IiwicHJvamVjdDY0X3VTY2FsZSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPQSxhQUFQLE1BQTBCLGtCQUExQjtBQUNBLE9BQU9DLGtCQUFQLE1BQStCLHVCQUEvQjs7QUFFQSxPQUFPQyxHQUFQLE1BQWdCLGlCQUFoQjtBQUNBLE9BQU9DLE1BQVAsTUFBbUIsUUFBbkI7QUFDQSxTQUFRQyxpQkFBUixRQUFnQyxxQkFBaEM7O0FB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QUFTZ0QsS0FmVixFQWVpQjs7QUFFaENDLDBCQUFzQmhCLGFBakJQO0FBa0JmaUIsbUNBQStCMUMsb0JBbEJoQjs7QUFvQmY7QUFDQTJDLDZCQUF5QmxDO0FBckJWLEdBQWpCOztBQXdCQSxNQUFJZixxQkFBcUJ4QixrQkFBa0JtQyxhQUEzQyxFQUEwRDtBQUN4RCxRQUFNdUMseUJBQXlCcEQsU0FBUzJCLGlCQUFULENBQTJCeEIsZ0JBQTNCLENBQS9CO0FBQ0ErQixhQUFTVyxzQkFBVCxHQUFrQ08sdUJBQXVCVixjQUF6RDtBQUNBUixhQUFTWSx1QkFBVCxHQUFtQ00sdUJBQXVCQyxlQUExRDtBQUNEO0FBQ0QsTUFBSW5ELHFCQUFxQnhCLGtCQUFrQmtDLGNBQTNDLEVBQTJEO0FBQ3pELFFBQU13QywwQkFBeUJwRCxTQUFTMkIsaUJBQVQsQ0FBMkJ4QixnQkFBM0IsQ0FBL0I7QUFDQStCLGFBQVNXLHNCQUFULEdBQWtDTyx3QkFBdUJSLGVBQXpEO0FBQ0FWLGFBQVNZLHVCQUFULEdBQW1DTSx3QkFBdUJFLGdCQUExRDtBQUNEOztBQUVEO0FBQ0EsU0FBT2xDLE9BQU9tQyxnQkFBZ0JyQixRQUFoQixDQUFQLEdBQW1DQSxRQUExQztBQUNEOztBQUVEO0FBQ0EsU0FBU3FCLGVBQVQsQ0FBeUJyQixRQUF6QixFQUFtQztBQUNqQyxNQUFNc0IsNkJBQTZCaEUsZUFBZTBDLFNBQVNnQiw2QkFBeEIsQ0FBbkM7QUFDQSxNQUFNTyxZQUFZekUsUUFBUWtELFNBQVNhLGNBQWpCLENBQWxCOztBQUVBYixXQUFTd0IsaUNBQVQsR0FBNkNGLDBCQUE3QztBQUNBdEIsV0FBU3lCLCtCQUFULEdBQTJDSCwwQkFBM0M7QUFDQXRCLFdBQVMwQixnQkFBVCxHQUE0QkgsU0FBNUI7O0FBRUEsU0FBT3ZCLFFBQVA7QUFDRCIsImZpbGUiOiJ2aWV3cG9ydC11bmlmb3Jtcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgMjAxNSAtIDIwMTcgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuLy8gVEhFIFNPRlRXQVJFLlxuXG4vKiBnbG9iYWwgd2luZG93ICovXG5pbXBvcnQgbWF0NF9tdWx0aXBseSBmcm9tICdnbC1tYXQ0L211bHRpcGx5JztcbmltcG9ydCB2ZWM0X3RyYW5zZm9ybU1hdDQgZnJvbSAnZ2wtdmVjNC90cmFuc2Zvcm1NYXQ0JztcblxuaW1wb3J0IGxvZyBmcm9tICcuLi8uLi91dGlscy9sb2cnO1xuaW1wb3J0IGFzc2VydCBmcm9tICdhc3NlcnQnO1xuaW1wb3J0IHtDT09SRElOQVRFX1NZU1RFTX0gZnJvbSAnLi4vLi4vbGliL2NvbnN0YW50cyc7XG5cbmltcG9ydCB7cHJvamVjdEZsYXR9IGZyb20gJ3ZpZXdwb3J0LW1lcmNhdG9yLXByb2plY3QnO1xuXG4vLyBUbyBxdWlja2x5IHNldCBhIHZlY3RvciB0byB6ZXJvXG5jb25zdCBaRVJPX1ZFQ1RPUiA9IFswLCAwLCAwLCAwXTtcbi8vIDR4NCBtYXRyaXggdGhhdCBkcm9wcyA0dGggY29tcG9uZW50IG9mIHZlY3RvclxuY29uc3QgVkVDVE9SX1RPX1BPSU5UX01BVFJJWCA9IFsxLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAwXTtcbmNvbnN0IElERU5USVRZX01BVFJJWCA9IFsxLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAxXTtcbmNvbnN0IERFRkFVTFRfUElYRUxTX1BFUl9VTklUMiA9IFswLCAwLCAwXTtcblxuLy8gVE9ETyAtIGltcG9ydCB0aGVzZSB1dGlscyBmcm9tIGZwNjQgcGFja2FnZVxuZnVuY3Rpb24gZnA2NGlmeShhLCBhcnJheSA9IFtdLCBzdGFydEluZGV4ID0gMCkge1xuICBjb25zdCBoaVBhcnQgPSBNYXRoLmZyb3VuZChhKTtcbiAgY29uc3QgbG9QYXJ0ID0gYSAtIGhpUGFydDtcbiAgYXJyYXlbc3RhcnRJbmRleF0gPSBoaVBhcnQ7XG4gIGFycmF5W3N0YXJ0SW5kZXggKyAxXSA9IGxvUGFydDtcbiAgcmV0dXJuIGFycmF5O1xufVxuXG4vLyBjYWxjdWxhdGUgV2ViR0wgNjQgYml0IG1hdHJpeCAodHJhbnNwb3NlZCBcIkZsb2F0NjRBcnJheVwiKVxuZnVuY3Rpb24gZnA2NGlmeU1hdHJpeDQobWF0cml4KSB7XG4gIC8vIFRyYW5zcG9zZSB0aGUgcHJvamVjdGlvbiBtYXRyaXggdG8gY29sdW1uIG1ham9yIGZvciBHTFNMLlxuICBjb25zdCBtYXRyaXhGUDY0ID0gbmV3IEZsb2F0MzJBcnJheSgzMik7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgNDsgKytpKSB7XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCA0OyArK2opIHtcbiAgICAgIGNvbnN0IGluZGV4ID0gaSAqIDQgKyBqO1xuICAgICAgZnA2NGlmeShtYXRyaXhbaiAqIDQgKyBpXSwgbWF0cml4RlA2NCwgaW5kZXggKiAyKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1hdHJpeEZQNjQ7XG59XG5cbi8vIFRoZSBjb2RlIHRoYXQgdXRpbGl6ZXMgTWF0cml4NCBkb2VzIHRoZSBzYW1lIGNhbGN1bGF0aW9uIGFzIHRoZWlyIG1hdDQgY291bnRlcnBhcnRzLFxuLy8gaGFzIGxvd2VyIHBlcmZvcm1hbmNlIGJ1dCBwcm92aWRlcyBlcnJvciBjaGVja2luZy5cbi8vIFVuY29tbWVudCB3aGVuIGRlYnVnZ2luZ1xuZnVuY3Rpb24gY2FsY3VsYXRlTWF0cml4QW5kT2Zmc2V0KHtcbiAgLy8gVU5DSEFOR0VEXG4gIHZpZXdwb3J0LFxuICBtb2RlbE1hdHJpeCxcbiAgLy8gTkVXIFBBUkFNU1xuICBjb29yZGluYXRlU3lzdGVtLFxuICBjb29yZGluYXRlT3JpZ2luLFxuICBjb29yZGluYXRlWm9vbVxufSkge1xuICBjb25zdCB7dmlld01hdHJpeFVuY2VudGVyZWR9ID0gdmlld3BvcnQ7XG4gIGxldCB7dmlld01hdHJpeH0gPSB2aWV3cG9ydDtcbiAgY29uc3Qge3Byb2plY3Rpb25NYXRyaXh9ID0gdmlld3BvcnQ7XG4gIGxldCB7dmlld1Byb2plY3Rpb25NYXRyaXh9ID0gdmlld3BvcnQ7XG5cbiAgbGV0IHByb2plY3Rpb25DZW50ZXI7XG5cbiAgc3dpdGNoIChjb29yZGluYXRlU3lzdGVtKSB7XG4gICAgY2FzZSBDT09SRElOQVRFX1NZU1RFTS5JREVOVElUWTpcbiAgICBjYXNlIENPT1JESU5BVEVfU1lTVEVNLkxOR0xBVDpcbiAgICAgIHByb2plY3Rpb25DZW50ZXIgPSBaRVJPX1ZFQ1RPUjtcbiAgICAgIGJyZWFrO1xuXG4gICAgLy8gVE9ETzogbWFrZSBsaWdodGluZyB3b3JrIGZvciBtZXRlciBvZmZzZXQgbW9kZVxuICAgIGNhc2UgQ09PUkRJTkFURV9TWVNURU0uTE5HTEFUX09GRlNFVFM6XG4gICAgY2FzZSBDT09SRElOQVRFX1NZU1RFTS5NRVRFUl9PRkZTRVRTOlxuICAgICAgLy8gQ2FsY3VsYXRlIHRyYW5zZm9ybWVkIHByb2plY3Rpb25DZW50ZXIgKHVzaW5nIDY0IGJpdCBwcmVjaXNpb24gSlMpXG4gICAgICAvLyBUaGlzIGlzIHRoZSBrZXkgdG8gb2Zmc2V0IG1vZGUgcHJlY2lzaW9uXG4gICAgICAvLyAoYXZvaWRzIGRvaW5nIHRoaXMgYWRkaXRpb24gaW4gMzIgYml0IHByZWNpc2lvbiBpbiBHTFNMKVxuICAgICAgY29uc3QgcG9zaXRpb25QaXhlbHMgPSBwcm9qZWN0RmxhdChjb29yZGluYXRlT3JpZ2luLCBNYXRoLnBvdygyLCBjb29yZGluYXRlWm9vbSkpO1xuICAgICAgLy8gcHJvamVjdGlvbkNlbnRlciA9IG5ldyBNYXRyaXg0KHZpZXdQcm9qZWN0aW9uTWF0cml4KVxuICAgICAgLy8gICAudHJhbnNmb3JtVmVjdG9yKFtwb3NpdGlvblBpeGVsc1swXSwgcG9zaXRpb25QaXhlbHNbMV0sIDAuMCwgMS4wXSk7XG4gICAgICBwcm9qZWN0aW9uQ2VudGVyID0gdmVjNF90cmFuc2Zvcm1NYXQ0KFxuICAgICAgICBbXSxcbiAgICAgICAgW3Bvc2l0aW9uUGl4ZWxzWzBdLCBwb3NpdGlvblBpeGVsc1sxXSwgMC4wLCAxLjBdLFxuICAgICAgICB2aWV3UHJvamVjdGlvbk1hdHJpeFxuICAgICAgKTtcblxuICAgICAgLy8gQWx3YXlzIGFwcGx5IHVuY2VudGVyZWQgcHJvamVjdGlvbiBtYXRyaXggaWYgYXZhaWxhYmxlIChzaGFkZXIgYWRkcyBjZW50ZXIpXG4gICAgICB2aWV3TWF0cml4ID0gdmlld01hdHJpeFVuY2VudGVyZWQgfHwgdmlld01hdHJpeDtcblxuICAgICAgLy8gWmVybyBvdXQgNHRoIGNvb3JkaW5hdGUgKFwiYWZ0ZXJcIiBtb2RlbCBtYXRyaXgpIC0gYXZvaWRzIGZ1cnRoZXIgdHJhbnNsYXRpb25zXG4gICAgICAvLyB2aWV3TWF0cml4ID0gbmV3IE1hdHJpeDQodmlld01hdHJpeFVuY2VudGVyZWQgfHwgdmlld01hdHJpeClcbiAgICAgIC8vICAgLm11bHRpcGx5UmlnaHQoVkVDVE9SX1RPX1BPSU5UX01BVFJJWCk7XG4gICAgICB2aWV3UHJvamVjdGlvbk1hdHJpeCA9IG1hdDRfbXVsdGlwbHkoW10sIHByb2plY3Rpb25NYXRyaXgsIHZpZXdNYXRyaXgpO1xuICAgICAgdmlld1Byb2plY3Rpb25NYXRyaXggPSBtYXQ0X211bHRpcGx5KFtdLCB2aWV3UHJvamVjdGlvbk1hdHJpeCwgVkVDVE9SX1RPX1BPSU5UX01BVFJJWCk7XG4gICAgICBicmVhaztcblxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gcHJvamVjdGlvbiBtb2RlJyk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHZpZXdNYXRyaXgsXG4gICAgdmlld1Byb2plY3Rpb25NYXRyaXgsXG4gICAgcHJvamVjdGlvbkNlbnRlcixcbiAgICBjYW1lcmFQb3M6IHZpZXdwb3J0LmNhbWVyYVBvc2l0aW9uXG4gIH07XG59XG5cbi8qKlxuICogUmV0dXJucyB1bmlmb3JtcyBmb3Igc2hhZGVycyBiYXNlZCBvbiBjdXJyZW50IHByb2plY3Rpb25cbiAqIGluY2x1ZGVzOiBwcm9qZWN0aW9uIG1hdHJpeCBzdWl0YWJsZSBmb3Igc2hhZGVyc1xuICpcbiAqIFRPRE8gLSBFbnN1cmUgdGhpcyB3b3JrcyB3aXRoIGFueSB2aWV3cG9ydCwgbm90IGp1c3QgV2ViTWVyY2F0b3JWaWV3cG9ydHNcbiAqXG4gKiBAcGFyYW0ge1dlYk1lcmNhdG9yVmlld3BvcnR9IHZpZXdwb3J0IC1cbiAqIEByZXR1cm4ge0Zsb2F0MzJBcnJheX0gLSA0eDQgcHJvamVjdGlvbiBtYXRyaXggdGhhdCBjYW4gYmUgdXNlZCBpbiBzaGFkZXJzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRVbmlmb3Jtc0Zyb21WaWV3cG9ydCh7XG4gIHZpZXdwb3J0LFxuICBtb2RlbE1hdHJpeCA9IG51bGwsXG4gIGNvb3JkaW5hdGVTeXN0ZW0gPSBDT09SRElOQVRFX1NZU1RFTS5MTkdMQVQsXG4gIGNvb3JkaW5hdGVPcmlnaW4gPSBbMCwgMF0sXG4gIGZwNjQgPSBmYWxzZSxcbiAgLy8gRGVwcmVjYXRlZFxuICBwcm9qZWN0aW9uTW9kZSxcbiAgcG9zaXRpb25PcmlnaW5cbn0gPSB7fSkge1xuICBhc3NlcnQodmlld3BvcnQpO1xuXG4gIGlmIChwcm9qZWN0aW9uTW9kZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgbG9nLnJlbW92ZWQoJ3Byb2plY3Rpb25Nb2RlJywgJ2Nvb3JkaW5hdGVTeXN0ZW0nKTtcbiAgfVxuICBpZiAocG9zaXRpb25PcmlnaW4gIT09IHVuZGVmaW5lZCkge1xuICAgIGxvZy5yZW1vdmVkKCdwb3NpdGlvbk9yaWdpbicsICdjb29yZGluYXRlT3JpZ2luJyk7XG4gIH1cblxuICBjb25zdCBjb29yZGluYXRlWm9vbSA9IHZpZXdwb3J0Lnpvb207XG4gIGFzc2VydChjb29yZGluYXRlWm9vbSA+PSAwKTtcblxuICBjb25zdCB7cHJvamVjdGlvbkNlbnRlciwgdmlld1Byb2plY3Rpb25NYXRyaXgsIGNhbWVyYVBvc30gPSBjYWxjdWxhdGVNYXRyaXhBbmRPZmZzZXQoe1xuICAgIGNvb3JkaW5hdGVTeXN0ZW0sXG4gICAgY29vcmRpbmF0ZU9yaWdpbixcbiAgICBjb29yZGluYXRlWm9vbSxcbiAgICBtb2RlbE1hdHJpeCxcbiAgICB2aWV3cG9ydFxuICB9KTtcblxuICBhc3NlcnQodmlld1Byb2plY3Rpb25NYXRyaXgsICdWaWV3cG9ydCBtaXNzaW5nIG1vZGVsVmlld1Byb2plY3Rpb25NYXRyaXgnKTtcblxuICAvLyBDYWxjdWxhdGUgcHJvamVjdGlvbiBwaXhlbHMgcGVyIHVuaXRcbiAgY29uc3QgZGlzdGFuY2VTY2FsZXMgPSB2aWV3cG9ydC5nZXREaXN0YW5jZVNjYWxlcygpO1xuXG4gIC8vIFRPRE8gLSBkb2VzIHRoaXMgZGVwZW5kIG9uIHVzZURldmljZVBpeGVscz9cbiAgY29uc3QgZGV2aWNlUGl4ZWxSYXRpbyA9ICh3aW5kb3cgJiYgd2luZG93LmRldmljZVBpeGVsUmF0aW8pIHx8IDE7XG4gIGNvbnN0IHZpZXdwb3J0U2l6ZSA9IFt2aWV3cG9ydC53aWR0aCAqIGRldmljZVBpeGVsUmF0aW8sIHZpZXdwb3J0LmhlaWdodCAqIGRldmljZVBpeGVsUmF0aW9dO1xuXG4gIGNvbnN0IGdsTW9kZWxNYXRyaXggPSBtb2RlbE1hdHJpeCB8fCBJREVOVElUWV9NQVRSSVg7XG5cbiAgY29uc3QgdW5pZm9ybXMgPSB7XG4gICAgLy8gUHJvamVjdGlvbiBtb2RlIHZhbHVlc1xuICAgIHByb2plY3RfdUNvb3JkaW5hdGVTeXN0ZW06IGNvb3JkaW5hdGVTeXN0ZW0sXG4gICAgcHJvamVjdF91Q2VudGVyOiBwcm9qZWN0aW9uQ2VudGVyLFxuXG4gICAgLy8gU2NyZWVuIHNpemVcbiAgICBwcm9qZWN0X3VWaWV3cG9ydFNpemU6IHZpZXdwb3J0U2l6ZSxcbiAgICBwcm9qZWN0X3VEZXZpY2VQaXhlbFJhdGlvOiBkZXZpY2VQaXhlbFJhdGlvLFxuXG4gICAgLy8gRGlzdGFuY2UgYXQgd2hpY2ggc2NyZWVuIHBpeGVscyBhcmUgcHJvamVjdGVkXG4gICAgcHJvamVjdF91Rm9jYWxEaXN0YW5jZTogdmlld3BvcnQuZm9jYWxEaXN0YW5jZSB8fCAxLFxuICAgIHByb2plY3RfdVBpeGVsc1Blck1ldGVyOiBkaXN0YW5jZVNjYWxlcy5waXhlbHNQZXJNZXRlcixcbiAgICBwcm9qZWN0X3VQaXhlbHNQZXJEZWdyZWU6IGRpc3RhbmNlU2NhbGVzLnBpeGVsc1BlckRlZ3JlZSxcbiAgICBwcm9qZWN0X3VQaXhlbHNQZXJVbml0OiBkaXN0YW5jZVNjYWxlcy5waXhlbHNQZXJNZXRlcixcbiAgICBwcm9qZWN0X3VQaXhlbHNQZXJVbml0MjogREVGQVVMVF9QSVhFTFNfUEVSX1VOSVQyLFxuICAgIHByb2plY3RfdVNjYWxlOiB2aWV3cG9ydC5zY2FsZSwgLy8gVGhpcyBpcyB0aGUgbWVyY2F0b3Igc2NhbGUgKDIgKiogem9vbSlcblxuICAgIHByb2plY3RfdU1vZGVsTWF0cml4OiBnbE1vZGVsTWF0cml4LFxuICAgIHByb2plY3RfdVZpZXdQcm9qZWN0aW9uTWF0cml4OiB2aWV3UHJvamVjdGlvbk1hdHJpeCxcblxuICAgIC8vIFRoaXMgaXMgZm9yIGxpZ2h0aW5nIGNhbGN1bGF0aW9uc1xuICAgIHByb2plY3RfdUNhbWVyYVBvc2l0aW9uOiBjYW1lcmFQb3NcbiAgfTtcblxuICBpZiAoY29vcmRpbmF0ZVN5c3RlbSA9PT0gQ09PUkRJTkFURV9TWVNURU0uTUVURVJfT0ZGU0VUUykge1xuICAgIGNvbnN0IGRpc3RhbmNlU2NhbGVzQXRPcmlnaW4gPSB2aWV3cG9ydC5nZXREaXN0YW5jZVNjYWxlcyhjb29yZGluYXRlT3JpZ2luKTtcbiAgICB1bmlmb3Jtcy5wcm9qZWN0X3VQaXhlbHNQZXJVbml0ID0gZGlzdGFuY2VTY2FsZXNBdE9yaWdpbi5waXhlbHNQZXJNZXRlcjtcbiAgICB1bmlmb3Jtcy5wcm9qZWN0X3VQaXhlbHNQZXJVbml0MiA9IGRpc3RhbmNlU2NhbGVzQXRPcmlnaW4ucGl4ZWxzUGVyTWV0ZXIyO1xuICB9XG4gIGlmIChjb29yZGluYXRlU3lzdGVtID09PSBDT09SRElOQVRFX1NZU1RFTS5MTkdMQVRfT0ZGU0VUUykge1xuICAgIGNvbnN0IGRpc3RhbmNlU2NhbGVzQXRPcmlnaW4gPSB2aWV3cG9ydC5nZXREaXN0YW5jZVNjYWxlcyhjb29yZGluYXRlT3JpZ2luKTtcbiAgICB1bmlmb3Jtcy5wcm9qZWN0X3VQaXhlbHNQZXJVbml0ID0gZGlzdGFuY2VTY2FsZXNBdE9yaWdpbi5waXhlbHNQZXJEZWdyZWU7XG4gICAgdW5pZm9ybXMucHJvamVjdF91UGl4ZWxzUGVyVW5pdDIgPSBkaXN0YW5jZVNjYWxlc0F0T3JpZ2luLnBpeGVsc1BlckRlZ3JlZTI7XG4gIH1cblxuICAvLyBUT0RPIC0gZnA2NCBmbGFnIHNob3VsZCBiZSBmcm9tIHNoYWRlciBtb2R1bGUsIG5vdCBsYXllciBwcm9wc1xuICByZXR1cm4gZnA2NCA/IGFkZEZQNjRVbmlmb3Jtcyh1bmlmb3JtcykgOiB1bmlmb3Jtcztcbn1cblxuLy8gNjQgYml0IHByb2plY3Rpb24gc3VwcG9ydFxuZnVuY3Rpb24gYWRkRlA2NFVuaWZvcm1zKHVuaWZvcm1zKSB7XG4gIGNvbnN0IGdsVmlld1Byb2plY3Rpb25NYXRyaXhGUDY0ID0gZnA2NGlmeU1hdHJpeDQodW5pZm9ybXMucHJvamVjdF91Vmlld1Byb2plY3Rpb25NYXRyaXgpO1xuICBjb25zdCBzY2FsZUZQNjQgPSBmcDY0aWZ5KHVuaWZvcm1zLnByb2plY3RfdVNjYWxlKTtcblxuICB1bmlmb3Jtcy5wcm9qZWN0X3VWaWV3UHJvamVjdGlvbk1hdHJpeEZQNjQgPSBnbFZpZXdQcm9qZWN0aW9uTWF0cml4RlA2NDtcbiAgdW5pZm9ybXMucHJvamVjdDY0X3VWaWV3UHJvamVjdGlvbk1hdHJpeCA9IGdsVmlld1Byb2plY3Rpb25NYXRyaXhGUDY0O1xuICB1bmlmb3Jtcy5wcm9qZWN0NjRfdVNjYWxlID0gc2NhbGVGUDY0O1xuXG4gIHJldHVybiB1bmlmb3Jtcztcbn1cbiJdfQ==