var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// Copyright (c) 2015 Uber Technologies, Inc.

// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:

// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.

// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

import MapState from './map-state';
import assert from 'assert';

// EVENT HANDLING PARAMETERS
var ZOOM_ACCEL = 0.01;

var PITCH_MOUSE_THRESHOLD = 5;
var PITCH_ACCEL = 1.2;

var EVENT_TYPES = {
  WHEEL: ['wheel'],
  PAN: ['panstart', 'panmove', 'panend'],
  PINCH: ['pinchstart', 'pinchmove', 'pinchend'],
  DOUBLE_TAP: ['doubletap'],
  KEYBOARD: ['keydown', 'keyup']
};

var ViewportControls = function () {
  /**
   * @classdesc
   * A class that handles events and updates mercator style viewport parameters
   */
  function ViewportControls(ViewportState) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, ViewportControls);

    assert(ViewportState);
    this.ViewportState = ViewportState;
    this.viewportState = null;
    this.viewportStateProps = null;
    this.eventManager = null;
    this._events = null;

    this._state = {
      isDragging: false
    };

    this.handleEvent = this.handleEvent.bind(this);

    this.setOptions(options);

    if (this.constructor === ViewportControls) {
      Object.seal(this);
    }
  }

  /**
   * Callback for events
   * @param {hammer.Event} event
   */


  _createClass(ViewportControls, [{
    key: 'handleEvent',
    value: function handleEvent(event) {
      var ViewportState = this.ViewportState;

      this.viewportState = new ViewportState(Object.assign({}, this.viewportStateProps, this._state));

      switch (event.type) {
        case 'panstart':
          return this._onPanStart(event);
        case 'panmove':
          return this._onPan(event);
        case 'panend':
          return this._onPanEnd(event);
        case 'pinchstart':
          return this._onPinchStart(event);
        case 'pinch':
          return this._onPinch(event);
        case 'pinchend':
          return this._onPinchEnd(event);
        case 'doubletap':
          return this._onDoubleTap(event);
        case 'wheel':
          return this._onWheel(event);
        case 'keydown':
          return this._onKeyDown(event);
        case 'keyup':
          return this._onKeyUp(event);
        default:
          return false;
      }
    }

    /* Event utils */
    // Event object: http://hammerjs.github.io/api/#event-object

  }, {
    key: 'getCenter',
    value: function getCenter(event) {
      var _event$offsetCenter = event.offsetCenter,
          x = _event$offsetCenter.x,
          y = _event$offsetCenter.y;

      return [x, y];
    }
  }, {
    key: 'isFunctionKeyPressed',
    value: function isFunctionKeyPressed(event) {
      var srcEvent = event.srcEvent;

      return Boolean(srcEvent.metaKey || srcEvent.altKey || srcEvent.ctrlKey || srcEvent.shiftKey);
    }
  }, {
    key: 'isDragging',
    value: function isDragging() {
      return this._state.isDragging;
    }

    /**
     * Extract interactivity options
     */

  }, {
    key: 'setOptions',
    value: function setOptions(options) {
      var onViewportChange = options.onViewportChange,
          _options$onStateChang = options.onStateChange,
          onStateChange = _options$onStateChang === undefined ? this.onStateChange : _options$onStateChang,
          _options$eventManager = options.eventManager,
          eventManager = _options$eventManager === undefined ? this.eventManager : _options$eventManager,
          _options$scrollZoom = options.scrollZoom,
          scrollZoom = _options$scrollZoom === undefined ? true : _options$scrollZoom,
          _options$dragPan = options.dragPan,
          dragPan = _options$dragPan === undefined ? true : _options$dragPan,
          _options$dragRotate = options.dragRotate,
          dragRotate = _options$dragRotate === undefined ? true : _options$dragRotate,
          _options$doubleClickZ = options.doubleClickZoom,
          doubleClickZoom = _options$doubleClickZ === undefined ? true : _options$doubleClickZ,
          _options$touchZoomRot = options.touchZoomRotate,
          touchZoomRotate = _options$touchZoomRot === undefined ? true : _options$touchZoomRot,
          _options$keyboard = options.keyboard,
          keyboard = _options$keyboard === undefined ? true : _options$keyboard;


      this.onViewportChange = onViewportChange;
      this.onStateChange = onStateChange;
      this.viewportStateProps = options;

      if (this.eventManager !== eventManager) {
        // EventManager has changed
        this.eventManager = eventManager;
        this._events = {};
      }

      // Register/unregister events
      var isInteractive = Boolean(this.onViewportChange);
      this.toggleEvents(EVENT_TYPES.WHEEL, isInteractive && scrollZoom);
      this.toggleEvents(EVENT_TYPES.PAN, isInteractive && (dragPan || dragRotate));
      this.toggleEvents(EVENT_TYPES.PINCH, isInteractive && touchZoomRotate);
      this.toggleEvents(EVENT_TYPES.DOUBLE_TAP, isInteractive && doubleClickZoom);
      this.toggleEvents(EVENT_TYPES.KEYBOARD, isInteractive && keyboard);

      this.scrollZoom = scrollZoom;
      this.dragPan = dragPan;
      this.dragRotate = dragRotate;
      this.doubleClickZoom = doubleClickZoom;
      this.touchZoomRotate = touchZoomRotate;
    }
  }, {
    key: 'toggleEvents',
    value: function toggleEvents(eventNames, enabled) {
      var _this = this;

      if (this.eventManager) {
        eventNames.forEach(function (eventName) {
          if (_this._events[eventName] !== enabled) {
            _this._events[eventName] = enabled;
            if (enabled) {
              _this.eventManager.on(eventName, _this.handleEvent);
            } else {
              _this.eventManager.off(eventName, _this.handleEvent);
            }
          }
        });
      }
    }

    // Private Methods

  }, {
    key: 'setState',
    value: function setState(newState) {
      Object.assign(this._state, newState);
      if (this.onStateChange) {
        this.onStateChange(this._state);
      }
    }

    /* Callback util */
    // formats map state and invokes callback function

  }, {
    key: 'updateViewport',
    value: function updateViewport(newViewportState) {
      var extraState = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      var oldViewport = this.viewportState.getViewportProps();
      var newViewport = newViewportState.getViewportProps();

      if (this.onViewportChange && Object.keys(newViewport).some(function (key) {
        return oldViewport[key] !== newViewport[key];
      })) {
        // Viewport has changed
        var viewport = this.viewportState.getViewport ? this.viewportState.getViewport() : null;
        this.onViewportChange(newViewport, viewport);
      }

      this.setState(Object.assign({}, newViewportState.getInteractiveState(), extraState));
    }

    /* Event handlers */
    // Default handler for the `panstart` event.

  }, {
    key: '_onPanStart',
    value: function _onPanStart(event) {
      var pos = this.getCenter(event);
      var newViewportState = this.viewportState.panStart({ pos: pos }).rotateStart({ pos: pos });
      return this.updateViewport(newViewportState, { isDragging: true });
    }

    // Default handler for the `panmove` event.

  }, {
    key: '_onPan',
    value: function _onPan(event) {
      return this.isFunctionKeyPressed(event) ? this._onPanMove(event) : this._onPanRotate(event);
    }

    // Default handler for the `panend` event.

  }, {
    key: '_onPanEnd',
    value: function _onPanEnd(event) {
      var newViewportState = this.viewportState.panEnd().rotateEnd();
      return this.updateViewport(newViewportState, { isDragging: false });
    }

    // Default handler for panning to move.
    // Called by `_onPan` when panning without function key pressed.

  }, {
    key: '_onPanMove',
    value: function _onPanMove(event) {
      if (!this.dragPan) {
        return false;
      }
      var pos = this.getCenter(event);
      var newViewportState = this.viewportState.pan({ pos: pos });
      return this.updateViewport(newViewportState);
    }

    // Default handler for panning to rotate.
    // Called by `_onPan` when panning with function key pressed.

  }, {
    key: '_onPanRotate',
    value: function _onPanRotate(event) {
      return this.viewportState instanceof MapState ? this._onPanRotateMap(event) : this._onPanRotateStandard(event);
    }

    // Normal pan to rotate

  }, {
    key: '_onPanRotateStandard',
    value: function _onPanRotateStandard(event) {
      if (!this.dragRotate) {
        return false;
      }

      var deltaX = event.deltaX,
          deltaY = event.deltaY;

      var _viewportState$getVie = this.viewportState.getViewportProps(),
          width = _viewportState$getVie.width,
          height = _viewportState$getVie.height;

      var deltaScaleX = deltaX / width;
      var deltaScaleY = deltaY / height;

      var newViewportState = this.viewportState.rotate({ deltaScaleX: deltaScaleX, deltaScaleY: deltaScaleY });
      return this.updateViewport(newViewportState);
    }

    // Map specific pan to rotate
    // TODO - is this mapStateSpecific?

  }, {
    key: '_onPanRotateMap',
    value: function _onPanRotateMap(event) {
      if (!this.dragRotate) {
        return false;
      }

      var deltaX = event.deltaX,
          deltaY = event.deltaY;

      var _getCenter = this.getCenter(event),
          _getCenter2 = _slicedToArray(_getCenter, 2),
          centerY = _getCenter2[1];

      var startY = centerY - deltaY;

      var _viewportState$getVie2 = this.viewportState.getViewportProps(),
          width = _viewportState$getVie2.width,
          height = _viewportState$getVie2.height;

      var deltaScaleX = deltaX / width;
      var deltaScaleY = 0;

      if (deltaY > 0) {
        if (Math.abs(height - startY) > PITCH_MOUSE_THRESHOLD) {
          // Move from 0 to -1 as we drag upwards
          deltaScaleY = deltaY / (startY - height) * PITCH_ACCEL;
        }
      } else if (deltaY < 0) {
        if (startY > PITCH_MOUSE_THRESHOLD) {
          // Move from 0 to 1 as we drag upwards
          deltaScaleY = 1 - centerY / startY;
        }
      }
      deltaScaleY = Math.min(1, Math.max(-1, deltaScaleY));

      var newMapState = this.viewportState.rotate({ deltaScaleX: deltaScaleX, deltaScaleY: deltaScaleY });
      return this.updateViewport(newMapState);
    }

    // Default handler for the `wheel` event.

  }, {
    key: '_onWheel',
    value: function _onWheel(event) {
      if (!this.scrollZoom) {
        return false;
      }
      event.srcEvent.preventDefault();

      var pos = this.getCenter(event);
      var delta = event.delta;

      // Map wheel delta to relative scale

      var scale = 2 / (1 + Math.exp(-Math.abs(delta * ZOOM_ACCEL)));
      if (delta < 0 && scale !== 0) {
        scale = 1 / scale;
      }

      var newViewportState = this.viewportState.zoom({ pos: pos, scale: scale });
      return this.updateViewport(newViewportState);
    }

    // Default handler for the `pinchstart` event.

  }, {
    key: '_onPinchStart',
    value: function _onPinchStart(event) {
      var pos = this.getCenter(event);
      var newViewportState = this.viewportState.zoomStart({ pos: pos });
      return this.updateViewport(newViewportState, { isDragging: true });
    }

    // Default handler for the `pinch` event.

  }, {
    key: '_onPinch',
    value: function _onPinch(event) {
      if (!this.touchZoomRotate) {
        return false;
      }
      var pos = this.getCenter(event);
      var scale = event.scale;

      var newViewportState = this.viewportState.zoom({ pos: pos, scale: scale });
      return this.updateViewport(newViewportState);
    }

    // Default handler for the `pinchend` event.

  }, {
    key: '_onPinchEnd',
    value: function _onPinchEnd(event) {
      var newViewportState = this.viewportState.zoomEnd();
      return this.updateViewport(newViewportState, { isDragging: false });
    }

    // Default handler for the `doubletap` event.

  }, {
    key: '_onDoubleTap',
    value: function _onDoubleTap(event) {
      if (!this.doubleClickZoom) {
        return false;
      }
      var pos = this.getCenter(event);
      var isZoomOut = this.isFunctionKeyPressed(event);

      var newViewportState = this.viewportState.zoom({ pos: pos, scale: isZoomOut ? 0.5 : 2 });
      return this.updateViewport(newViewportState);
    }
  }, {
    key: '_onKeyDown',
    value: function _onKeyDown(event) {
      if (this.viewportState.isDragging) {
        return;
      }

      var KEY_BINDINGS = {
        w: 'moveForward',
        W: 'moveForward',
        ArrowUp: 'moveForward',

        s: 'moveBackward',
        S: 'moveBackward',
        ArrowDown: 'moveBackward',

        a: 'moveLeft',
        A: 'moveLeft',
        ArrowLeft: 'moveLeft',

        d: 'moveRight',
        D: 'moveRight',
        ArrowRight: 'moveRight',

        '=': 'zoomIn',
        '+': 'zoomIn',

        '-': 'zoomOut',

        '[': 'moveDown',
        ']': 'moveUp'
      };

      // keyCode is deprecated from web standards
      // code is not supported by IE/Edge
      var key = event.key;
      var handler = KEY_BINDINGS[key];
      if (this.viewportState[handler]) {
        var newViewportState = this.viewportState[handler]();
        this.updateViewport(newViewportState);
      }
    }
    /* eslint-enable complexity */

  }, {
    key: '_onKeyUp',
    value: function _onKeyUp(event) {}
  }]);

  return ViewportControls;
}();

export default ViewportControls;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9jb3JlL2NvbnRyb2xsZXJzL3ZpZXdwb3J0LWNvbnRyb2xzLmpzIl0sIm5hbWVzIjpbIk1hcFN0YXRlIiwiYXNzZXJ0IiwiWk9PTV9BQ0NFTCIsIlBJVENIX01PVVNFX1RIUkVTSE9MRCIsIlBJVENIX0FDQ0VMIiwiRVZFTlRfVFlQRVMiLCJXSEVFTCIsIlBBTiIsIlBJTkNIIiwiRE9VQkxFX1RBUCIsIktFWUJPQVJEIiwiVmlld3BvcnRDb250cm9scyIsIlZpZXdwb3J0U3RhdGUiLCJvcHRpb25zIiwidmlld3BvcnRTdGF0ZSIsInZpZXdwb3J0U3RhdGVQcm9wcyIsImV2ZW50TWFuYWdlciIsIl9ldmVudHMiLCJfc3RhdGUiLCJpc0RyYWdnaW5nIiwiaGFuZGxlRXZlbnQiLCJiaW5kIiwic2V0T3B0aW9ucyIsImNvbnN0cnVjdG9yIiwiT2JqZWN0Iiwic2VhbCIsImV2ZW50IiwiYXNzaWduIiwidHlwZSIsIl9vblBhblN0YXJ0IiwiX29uUGFuIiwiX29uUGFuRW5kIiwiX29uUGluY2hTdGFydCIsIl9vblBpbmNoIiwiX29uUGluY2hFbmQiLCJfb25Eb3VibGVUYXAiLCJfb25XaGVlbCIsIl9vbktleURvd24iLCJfb25LZXlVcCIsIm9mZnNldENlbnRlciIsIngiLCJ5Iiwic3JjRXZlbnQiLCJCb29sZWFuIiwibWV0YUtleSIsImFsdEtleSIsImN0cmxLZXkiLCJzaGlmdEtleSIsIm9uVmlld3BvcnRDaGFuZ2UiLCJvblN0YXRlQ2hhbmdlIiwic2Nyb2xsWm9vbSIsImRyYWdQYW4iLCJkcmFnUm90YXRlIiwiZG91YmxlQ2xpY2tab29tIiwidG91Y2hab29tUm90YXRlIiwia2V5Ym9hcmQiLCJpc0ludGVyYWN0aXZlIiwidG9nZ2xlRXZlbnRzIiwiZXZlbnROYW1lcyIsImVuYWJsZWQiLCJmb3JFYWNoIiwiZXZlbnROYW1lIiwib24iLCJvZmYiLCJuZXdTdGF0ZSIsIm5ld1ZpZXdwb3J0U3RhdGUiLCJleHRyYVN0YXRlIiwib2xkVmlld3BvcnQiLCJnZXRWaWV3cG9ydFByb3BzIiwibmV3Vmlld3BvcnQiLCJrZXlzIiwic29tZSIsImtleSIsInZpZXdwb3J0IiwiZ2V0Vmlld3BvcnQiLCJzZXRTdGF0ZSIsImdldEludGVyYWN0aXZlU3RhdGUiLCJwb3MiLCJnZXRDZW50ZXIiLCJwYW5TdGFydCIsInJvdGF0ZVN0YXJ0IiwidXBkYXRlVmlld3BvcnQiLCJpc0Z1bmN0aW9uS2V5UHJlc3NlZCIsIl9vblBhbk1vdmUiLCJfb25QYW5Sb3RhdGUiLCJwYW5FbmQiLCJyb3RhdGVFbmQiLCJwYW4iLCJfb25QYW5Sb3RhdGVNYXAiLCJfb25QYW5Sb3RhdGVTdGFuZGFyZCIsImRlbHRhWCIsImRlbHRhWSIsIndpZHRoIiwiaGVpZ2h0IiwiZGVsdGFTY2FsZVgiLCJkZWx0YVNjYWxlWSIsInJvdGF0ZSIsImNlbnRlclkiLCJzdGFydFkiLCJNYXRoIiwiYWJzIiwibWluIiwibWF4IiwibmV3TWFwU3RhdGUiLCJwcmV2ZW50RGVmYXVsdCIsImRlbHRhIiwic2NhbGUiLCJleHAiLCJ6b29tIiwiem9vbVN0YXJ0Iiwiem9vbUVuZCIsImlzWm9vbU91dCIsIktFWV9CSU5ESU5HUyIsInciLCJXIiwiQXJyb3dVcCIsInMiLCJTIiwiQXJyb3dEb3duIiwiYSIsIkEiLCJBcnJvd0xlZnQiLCJkIiwiRCIsIkFycm93UmlnaHQiLCJoYW5kbGVyIl0sIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPQSxRQUFQLE1BQXFCLGFBQXJCO0FBQ0EsT0FBT0MsTUFBUCxNQUFtQixRQUFuQjs7QUFFQTtBQUNBLElBQU1DLGFBQWEsSUFBbkI7O0FBRUEsSUFBTUMsd0JBQXdCLENBQTlCO0FBQ0EsSUFBTUMsY0FBYyxHQUFwQjs7QUFFQSxJQUFNQyxjQUFjO0FBQ2xCQyxTQUFPLENBQUMsT0FBRCxDQURXO0FBRWxCQyxPQUFL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bkJDLFdBQUcsVUFUZ0I7QUFVbkJDLFdBQUcsVUFWZ0I7QUFXbkJDLG1CQUFXLFVBWFE7O0FBYW5CQyxXQUFHLFdBYmdCO0FBY25CQyxXQUFHLFdBZGdCO0FBZW5CQyxvQkFBWSxXQWZPOztBQWlCbkIsYUFBSyxRQWpCYztBQWtCbkIsYUFBSyxRQWxCYzs7QUFvQm5CLGFBQUssU0FwQmM7O0FBc0JuQixhQUFLLFVBdEJjO0FBdUJuQixhQUFLO0FBdkJjLE9BQXJCOztBQTBCQTtBQUNBO0FBQ0EsVUFBTXBELE1BQU05QyxNQUFNOEMsR0FBbEI7QUFDQSxVQUFNcUQsVUFBVWIsYUFBYXhDLEdBQWIsQ0FBaEI7QUFDQSxVQUFJLEtBQUsxRCxhQUFMLENBQW1CK0csT0FBbkIsQ0FBSixFQUFpQztBQUMvQixZQUFNNUQsbUJBQW1CLEtBQUtuRCxhQUFMLENBQW1CK0csT0FBbkIsR0FBekI7QUFDQSxhQUFLNUMsY0FBTCxDQUFvQmhCLGdCQUFwQjtBQUNEO0FBQ0Y7QUFDRDs7Ozs2QkFFU3ZDLEssRUFBTyxDQUFFOzs7Ozs7ZUF2VkNmLGdCIiwiZmlsZSI6InZpZXdwb3J0LWNvbnRyb2xzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSAyMDE1IFViZXIgVGVjaG5vbG9naWVzLCBJbmMuXG5cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbi8vIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbi8vIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbi8vIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbi8vIFRIRSBTT0ZUV0FSRS5cblxuaW1wb3J0IE1hcFN0YXRlIGZyb20gJy4vbWFwLXN0YXRlJztcbmltcG9ydCBhc3NlcnQgZnJvbSAnYXNzZXJ0JztcblxuLy8gRVZFTlQgSEFORExJTkcgUEFSQU1FVEVSU1xuY29uc3QgWk9PTV9BQ0NFTCA9IDAuMDE7XG5cbmNvbnN0IFBJVENIX01PVVNFX1RIUkVTSE9MRCA9IDU7XG5jb25zdCBQSVRDSF9BQ0NFTCA9IDEuMjtcblxuY29uc3QgRVZFTlRfVFlQRVMgPSB7XG4gIFdIRUVMOiBbJ3doZWVsJ10sXG4gIFBBTjogWydwYW5zdGFydCcsICdwYW5tb3ZlJywgJ3BhbmVuZCddLFxuICBQSU5DSDogWydwaW5jaHN0YXJ0JywgJ3BpbmNobW92ZScsICdwaW5jaGVuZCddLFxuICBET1VCTEVfVEFQOiBbJ2RvdWJsZXRhcCddLFxuICBLRVlCT0FSRDogWydrZXlkb3duJywgJ2tleXVwJ11cbn07XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFZpZXdwb3J0Q29udHJvbHMge1xuICAvKipcbiAgICogQGNsYXNzZGVzY1xuICAgKiBBIGNsYXNzIHRoYXQgaGFuZGxlcyBldmVudHMgYW5kIHVwZGF0ZXMgbWVyY2F0b3Igc3R5bGUgdmlld3BvcnQgcGFyYW1ldGVyc1xuICAgKi9cbiAgY29uc3RydWN0b3IoVmlld3BvcnRTdGF0ZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgYXNzZXJ0KFZpZXdwb3J0U3RhdGUpO1xuICAgIHRoaXMuVmlld3BvcnRTdGF0ZSA9IFZpZXdwb3J0U3RhdGU7XG4gICAgdGhpcy52aWV3cG9ydFN0YXRlID0gbnVsbDtcbiAgICB0aGlzLnZpZXdwb3J0U3RhdGVQcm9wcyA9IG51bGw7XG4gICAgdGhpcy5ldmVudE1hbmFnZXIgPSBudWxsO1xuICAgIHRoaXMuX2V2ZW50cyA9IG51bGw7XG5cbiAgICB0aGlzLl9zdGF0ZSA9IHtcbiAgICAgIGlzRHJhZ2dpbmc6IGZhbHNlXG4gICAgfTtcblxuICAgIHRoaXMuaGFuZGxlRXZlbnQgPSB0aGlzLmhhbmRsZUV2ZW50LmJpbmQodGhpcyk7XG5cbiAgICB0aGlzLnNldE9wdGlvbnMob3B0aW9ucyk7XG5cbiAgICBpZiAodGhpcy5jb25zdHJ1Y3RvciA9PT0gVmlld3BvcnRDb250cm9scykge1xuICAgICAgT2JqZWN0LnNlYWwodGhpcyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENhbGxiYWNrIGZvciBldmVudHNcbiAgICogQHBhcmFtIHtoYW1tZXIuRXZlbnR9IGV2ZW50XG4gICAqL1xuICBoYW5kbGVFdmVudChldmVudCkge1xuICAgIGNvbnN0IHtWaWV3cG9ydFN0YXRlfSA9IHRoaXM7XG4gICAgdGhpcy52aWV3cG9ydFN0YXRlID0gbmV3IFZpZXdwb3J0U3RhdGUoT2JqZWN0LmFzc2lnbih7fSwgdGhpcy52aWV3cG9ydFN0YXRlUHJvcHMsIHRoaXMuX3N0YXRlKSk7XG5cbiAgICBzd2l0Y2ggKGV2ZW50LnR5cGUpIHtcbiAgICAgIGNhc2UgJ3BhbnN0YXJ0JzpcbiAgICAgICAgcmV0dXJuIHRoaXMuX29uUGFuU3RhcnQoZXZlbnQpO1xuICAgICAgY2FzZSAncGFubW92ZSc6XG4gICAgICAgIHJldHVybiB0aGlzLl9vblBhbihldmVudCk7XG4gICAgICBjYXNlICdwYW5lbmQnOlxuICAgICAgICByZXR1cm4gdGhpcy5fb25QYW5FbmQoZXZlbnQpO1xuICAgICAgY2FzZSAncGluY2hzdGFydCc6XG4gICAgICAgIHJldHVybiB0aGlzLl9vblBpbmNoU3RhcnQoZXZlbnQpO1xuICAgICAgY2FzZSAncGluY2gnOlxuICAgICAgICByZXR1cm4gdGhpcy5fb25QaW5jaChldmVudCk7XG4gICAgICBjYXNlICdwaW5jaGVuZCc6XG4gICAgICAgIHJldHVybiB0aGlzLl9vblBpbmNoRW5kKGV2ZW50KTtcbiAgICAgIGNhc2UgJ2RvdWJsZXRhcCc6XG4gICAgICAgIHJldHVybiB0aGlzLl9vbkRvdWJsZVRhcChldmVudCk7XG4gICAgICBjYXNlICd3aGVlbCc6XG4gICAgICAgIHJldHVybiB0aGlzLl9vbldoZWVsKGV2ZW50KTtcbiAgICAgIGNhc2UgJ2tleWRvd24nOlxuICAgICAgICByZXR1cm4gdGhpcy5fb25LZXlEb3duKGV2ZW50KTtcbiAgICAgIGNhc2UgJ2tleXVwJzpcbiAgICAgICAgcmV0dXJuIHRoaXMuX29uS2V5VXAoZXZlbnQpO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIC8qIEV2ZW50IHV0aWxzICovXG4gIC8vIEV2ZW50IG9iamVjdDogaHR0cDovL2hhbW1lcmpzLmdpdGh1Yi5pby9hcGkvI2V2ZW50LW9iamVjdFxuICBnZXRDZW50ZXIoZXZlbnQpIHtcbiAgICBjb25zdCB7b2Zmc2V0Q2VudGVyOiB7eCwgeX19ID0gZXZlbnQ7XG4gICAgcmV0dXJuIFt4LCB5XTtcbiAgfVxuXG4gIGlzRnVuY3Rpb25LZXlQcmVzc2VkKGV2ZW50KSB7XG4gICAgY29uc3Qge3NyY0V2ZW50fSA9IGV2ZW50O1xuICAgIHJldHVybiBCb29sZWFuKHNyY0V2ZW50Lm1ldGFLZXkgfHwgc3JjRXZlbnQuYWx0S2V5IHx8IHNyY0V2ZW50LmN0cmxLZXkgfHwgc3JjRXZlbnQuc2hpZnRLZXkpO1xuICB9XG5cbiAgaXNEcmFnZ2luZygpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RhdGUuaXNEcmFnZ2luZztcbiAgfVxuXG4gIC8qKlxuICAgKiBFeHRyYWN0IGludGVyYWN0aXZpdHkgb3B0aW9uc1xuICAgKi9cbiAgc2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgY29uc3Qge1xuICAgICAgb25WaWV3cG9ydENoYW5nZSxcbiAgICAgIG9uU3RhdGVDaGFuZ2UgPSB0aGlzLm9uU3RhdGVDaGFuZ2UsXG4gICAgICBldmVudE1hbmFnZXIgPSB0aGlzLmV2ZW50TWFuYWdlcixcbiAgICAgIHNjcm9sbFpvb20gPSB0cnVlLFxuICAgICAgZHJhZ1BhbiA9IHRydWUsXG4gICAgICBkcmFnUm90YXRlID0gdHJ1ZSxcbiAgICAgIGRvdWJsZUNsaWNrWm9vbSA9IHRydWUsXG4gICAgICB0b3VjaFpvb21Sb3RhdGUgPSB0cnVlLFxuICAgICAga2V5Ym9hcmQgPSB0cnVlXG4gICAgfSA9IG9wdGlvbnM7XG5cbiAgICB0aGlzLm9uVmlld3BvcnRDaGFuZ2UgPSBvblZpZXdwb3J0Q2hhbmdlO1xuICAgIHRoaXMub25TdGF0ZUNoYW5nZSA9IG9uU3RhdGVDaGFuZ2U7XG4gICAgdGhpcy52aWV3cG9ydFN0YXRlUHJvcHMgPSBvcHRpb25zO1xuXG4gICAgaWYgKHRoaXMuZXZlbnRNYW5hZ2VyICE9PSBldmVudE1hbmFnZXIpIHtcbiAgICAgIC8vIEV2ZW50TWFuYWdlciBoYXMgY2hhbmdlZFxuICAgICAgdGhpcy5ldmVudE1hbmFnZXIgPSBldmVudE1hbmFnZXI7XG4gICAgICB0aGlzLl9ldmVudHMgPSB7fTtcbiAgICB9XG5cbiAgICAvLyBSZWdpc3Rlci91bnJlZ2lzdGVyIGV2ZW50c1xuICAgIGNvbnN0IGlzSW50ZXJhY3RpdmUgPSBCb29sZWFuKHRoaXMub25WaWV3cG9ydENoYW5nZSk7XG4gICAgdGhpcy50b2dnbGVFdmVudHMoRVZFTlRfVFlQRVMuV0hFRUwsIGlzSW50ZXJhY3RpdmUgJiYgc2Nyb2xsWm9vbSk7XG4gICAgdGhpcy50b2dnbGVFdmVudHMoRVZFTlRfVFlQRVMuUEFOLCBpc0ludGVyYWN0aXZlICYmIChkcmFnUGFuIHx8IGRyYWdSb3RhdGUpKTtcbiAgICB0aGlzLnRvZ2dsZUV2ZW50cyhFVkVOVF9UWVBFUy5QSU5DSCwgaXNJbnRlcmFjdGl2ZSAmJiB0b3VjaFpvb21Sb3RhdGUpO1xuICAgIHRoaXMudG9nZ2xlRXZlbnRzKEVWRU5UX1RZUEVTLkRPVUJMRV9UQVAsIGlzSW50ZXJhY3RpdmUgJiYgZG91YmxlQ2xpY2tab29tKTtcbiAgICB0aGlzLnRvZ2dsZUV2ZW50cyhFVkVOVF9UWVBFUy5LRVlCT0FSRCwgaXNJbnRlcmFjdGl2ZSAmJiBrZXlib2FyZCk7XG5cbiAgICB0aGlzLnNjcm9sbFpvb20gPSBzY3JvbGxab29tO1xuICAgIHRoaXMuZHJhZ1BhbiA9IGRyYWdQYW47XG4gICAgdGhpcy5kcmFnUm90YXRlID0gZHJhZ1JvdGF0ZTtcbiAgICB0aGlzLmRvdWJsZUNsaWNrWm9vbSA9IGRvdWJsZUNsaWNrWm9vbTtcbiAgICB0aGlzLnRvdWNoWm9vbVJvdGF0ZSA9IHRvdWNoWm9vbVJvdGF0ZTtcbiAgfVxuXG4gIHRvZ2dsZUV2ZW50cyhldmVudE5hbWVzLCBlbmFibGVkKSB7XG4gICAgaWYgKHRoaXMuZXZlbnRNYW5hZ2VyKSB7XG4gICAgICBldmVudE5hbWVzLmZvckVhY2goZXZlbnROYW1lID0+IHtcbiAgICAgICAgaWYgKHRoaXMuX2V2ZW50c1tldmVudE5hbWVdICE9PSBlbmFibGVkKSB7XG4gICAgICAgICAgdGhpcy5fZXZlbnRzW2V2ZW50TmFtZV0gPSBlbmFibGVkO1xuICAgICAgICAgIGlmIChlbmFibGVkKSB7XG4gICAgICAgICAgICB0aGlzLmV2ZW50TWFuYWdlci5vbihldmVudE5hbWUsIHRoaXMuaGFuZGxlRXZlbnQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmV2ZW50TWFuYWdlci5vZmYoZXZlbnROYW1lLCB0aGlzLmhhbmRsZUV2ZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8vIFByaXZhdGUgTWV0aG9kc1xuXG4gIHNldFN0YXRlKG5ld1N0YXRlKSB7XG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLl9zdGF0ZSwgbmV3U3RhdGUpO1xuICAgIGlmICh0aGlzLm9uU3RhdGVDaGFuZ2UpIHtcbiAgICAgIHRoaXMub25TdGF0ZUNoYW5nZSh0aGlzLl9zdGF0ZSk7XG4gICAgfVxuICB9XG5cbiAgLyogQ2FsbGJhY2sgdXRpbCAqL1xuICAvLyBmb3JtYXRzIG1hcCBzdGF0ZSBhbmQgaW52b2tlcyBjYWxsYmFjayBmdW5jdGlvblxuICB1cGRhdGVWaWV3cG9ydChuZXdWaWV3cG9ydFN0YXRlLCBleHRyYVN0YXRlID0ge30pIHtcbiAgICBjb25zdCBvbGRWaWV3cG9ydCA9IHRoaXMudmlld3BvcnRTdGF0ZS5nZXRWaWV3cG9ydFByb3BzKCk7XG4gICAgY29uc3QgbmV3Vmlld3BvcnQgPSBuZXdWaWV3cG9ydFN0YXRlLmdldFZpZXdwb3J0UHJvcHMoKTtcblxuICAgIGlmIChcbiAgICAgIHRoaXMub25WaWV3cG9ydENoYW5nZSAmJlxuICAgICAgT2JqZWN0LmtleXMobmV3Vmlld3BvcnQpLnNvbWUoa2V5ID0+IG9sZFZpZXdwb3J0W2tleV0gIT09IG5ld1ZpZXdwb3J0W2tleV0pXG4gICAgKSB7XG4gICAgICAvLyBWaWV3cG9ydCBoYXMgY2hhbmdlZFxuICAgICAgY29uc3Qgdmlld3BvcnQgPSB0aGlzLnZpZXdwb3J0U3RhdGUuZ2V0Vmlld3BvcnQgPyB0aGlzLnZpZXdwb3J0U3RhdGUuZ2V0Vmlld3BvcnQoKSA6IG51bGw7XG4gICAgICB0aGlzLm9uVmlld3BvcnRDaGFuZ2UobmV3Vmlld3BvcnQsIHZpZXdwb3J0KTtcbiAgICB9XG5cbiAgICB0aGlzLnNldFN0YXRlKE9iamVjdC5hc3NpZ24oe30sIG5ld1ZpZXdwb3J0U3RhdGUuZ2V0SW50ZXJhY3RpdmVTdGF0ZSgpLCBleHRyYVN0YXRlKSk7XG4gIH1cblxuICAvKiBFdmVudCBoYW5kbGVycyAqL1xuICAvLyBEZWZhdWx0IGhhbmRsZXIgZm9yIHRoZSBgcGFuc3RhcnRgIGV2ZW50LlxuICBfb25QYW5TdGFydChldmVudCkge1xuICAgIGNvbnN0IHBvcyA9IHRoaXMuZ2V0Q2VudGVyKGV2ZW50KTtcbiAgICBjb25zdCBuZXdWaWV3cG9ydFN0YXRlID0gdGhpcy52aWV3cG9ydFN0YXRlLnBhblN0YXJ0KHtwb3N9KS5yb3RhdGVTdGFydCh7cG9zfSk7XG4gICAgcmV0dXJuIHRoaXMudXBkYXRlVmlld3BvcnQobmV3Vmlld3BvcnRTdGF0ZSwge2lzRHJhZ2dpbmc6IHRydWV9KTtcbiAgfVxuXG4gIC8vIERlZmF1bHQgaGFuZGxlciBmb3IgdGhlIGBwYW5tb3ZlYCBldmVudC5cbiAgX29uUGFuKGV2ZW50KSB7XG4gICAgcmV0dXJuIHRoaXMuaXNGdW5jdGlvbktleVByZXNzZWQoZXZlbnQpID8gdGhpcy5fb25QYW5Nb3ZlKGV2ZW50KSA6IHRoaXMuX29uUGFuUm90YXRlKGV2ZW50KTtcbiAgfVxuXG4gIC8vIERlZmF1bHQgaGFuZGxlciBmb3IgdGhlIGBwYW5lbmRgIGV2ZW50LlxuICBfb25QYW5FbmQoZXZlbnQpIHtcbiAgICBjb25zdCBuZXdWaWV3cG9ydFN0YXRlID0gdGhpcy52aWV3cG9ydFN0YXRlLnBhbkVuZCgpLnJvdGF0ZUVuZCgpO1xuICAgIHJldHVybiB0aGlzLnVwZGF0ZVZpZXdwb3J0KG5ld1ZpZXdwb3J0U3RhdGUsIHtpc0RyYWdnaW5nOiBmYWxzZX0pO1xuICB9XG5cbiAgLy8gRGVmYXVsdCBoYW5kbGVyIGZvciBwYW5uaW5nIHRvIG1vdmUuXG4gIC8vIENhbGxlZCBieSBgX29uUGFuYCB3aGVuIHBhbm5pbmcgd2l0aG91dCBmdW5jdGlvbiBrZXkgcHJlc3NlZC5cbiAgX29uUGFuTW92ZShldmVudCkge1xuICAgIGlmICghdGhpcy5kcmFnUGFuKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IHBvcyA9IHRoaXMuZ2V0Q2VudGVyKGV2ZW50KTtcbiAgICBjb25zdCBuZXdWaWV3cG9ydFN0YXRlID0gdGhpcy52aWV3cG9ydFN0YXRlLnBhbih7cG9zfSk7XG4gICAgcmV0dXJuIHRoaXMudXBkYXRlVmlld3BvcnQobmV3Vmlld3BvcnRTdGF0ZSk7XG4gIH1cblxuICAvLyBEZWZhdWx0IGhhbmRsZXIgZm9yIHBhbm5pbmcgdG8gcm90YXRlLlxuICAvLyBDYWxsZWQgYnkgYF9vblBhbmAgd2hlbiBwYW5uaW5nIHdpdGggZnVuY3Rpb24ga2V5IHByZXNzZWQuXG4gIF9vblBhblJvdGF0ZShldmVudCkge1xuICAgIHJldHVybiB0aGlzLnZpZXdwb3J0U3RhdGUgaW5zdGFuY2VvZiBNYXBTdGF0ZVxuICAgICAgPyB0aGlzLl9vblBhblJvdGF0ZU1hcChldmVudClcbiAgICAgIDogdGhpcy5fb25QYW5Sb3RhdGVTdGFuZGFyZChldmVudCk7XG4gIH1cblxuICAvLyBOb3JtYWwgcGFuIHRvIHJvdGF0ZVxuICBfb25QYW5Sb3RhdGVTdGFuZGFyZChldmVudCkge1xuICAgIGlmICghdGhpcy5kcmFnUm90YXRlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgY29uc3Qge2RlbHRhWCwgZGVsdGFZfSA9IGV2ZW50O1xuICAgIGNvbnN0IHt3aWR0aCwgaGVpZ2h0fSA9IHRoaXMudmlld3BvcnRTdGF0ZS5nZXRWaWV3cG9ydFByb3BzKCk7XG5cbiAgICBjb25zdCBkZWx0YVNjYWxlWCA9IGRlbHRhWCAvIHdpZHRoO1xuICAgIGNvbnN0IGRlbHRhU2NhbGVZID0gZGVsdGFZIC8gaGVpZ2h0O1xuXG4gICAgY29uc3QgbmV3Vmlld3BvcnRTdGF0ZSA9IHRoaXMudmlld3BvcnRTdGF0ZS5yb3RhdGUoe2RlbHRhU2NhbGVYLCBkZWx0YVNjYWxlWX0pO1xuICAgIHJldHVybiB0aGlzLnVwZGF0ZVZpZXdwb3J0KG5ld1ZpZXdwb3J0U3RhdGUpO1xuICB9XG5cbiAgLy8gTWFwIHNwZWNpZmljIHBhbiB0byByb3RhdGVcbiAgLy8gVE9ETyAtIGlzIHRoaXMgbWFwU3RhdGVTcGVjaWZpYz9cbiAgX29uUGFuUm90YXRlTWFwKGV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLmRyYWdSb3RhdGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBjb25zdCB7ZGVsdGFYLCBkZWx0YVl9ID0gZXZlbnQ7XG4gICAgY29uc3QgWywgY2VudGVyWV0gPSB0aGlzLmdldENlbnRlcihldmVudCk7XG4gICAgY29uc3Qgc3RhcnRZID0gY2VudGVyWSAtIGRlbHRhWTtcbiAgICBjb25zdCB7d2lkdGgsIGhlaWdodH0gPSB0aGlzLnZpZXdwb3J0U3RhdGUuZ2V0Vmlld3BvcnRQcm9wcygpO1xuXG4gICAgY29uc3QgZGVsdGFTY2FsZVggPSBkZWx0YVggLyB3aWR0aDtcbiAgICBsZXQgZGVsdGFTY2FsZVkgPSAwO1xuXG4gICAgaWYgKGRlbHRhWSA+IDApIHtcbiAgICAgIGlmIChNYXRoLmFicyhoZWlnaHQgLSBzdGFydFkpID4gUElUQ0hfTU9VU0VfVEhSRVNIT0xEKSB7XG4gICAgICAgIC8vIE1vdmUgZnJvbSAwIHRvIC0xIGFzIHdlIGRyYWcgdXB3YXJkc1xuICAgICAgICBkZWx0YVNjYWxlWSA9IGRlbHRhWSAvIChzdGFydFkgLSBoZWlnaHQpICogUElUQ0hfQUNDRUw7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChkZWx0YVkgPCAwKSB7XG4gICAgICBpZiAoc3RhcnRZID4gUElUQ0hfTU9VU0VfVEhSRVNIT0xEKSB7XG4gICAgICAgIC8vIE1vdmUgZnJvbSAwIHRvIDEgYXMgd2UgZHJhZyB1cHdhcmRzXG4gICAgICAgIGRlbHRhU2NhbGVZID0gMSAtIGNlbnRlclkgLyBzdGFydFk7XG4gICAgICB9XG4gICAgfVxuICAgIGRlbHRhU2NhbGVZID0gTWF0aC5taW4oMSwgTWF0aC5tYXgoLTEsIGRlbHRhU2NhbGVZKSk7XG5cbiAgICBjb25zdCBuZXdNYXBTdGF0ZSA9IHRoaXMudmlld3BvcnRTdGF0ZS5yb3RhdGUoe2RlbHRhU2NhbGVYLCBkZWx0YVNjYWxlWX0pO1xuICAgIHJldHVybiB0aGlzLnVwZGF0ZVZpZXdwb3J0KG5ld01hcFN0YXRlKTtcbiAgfVxuXG4gIC8vIERlZmF1bHQgaGFuZGxlciBmb3IgdGhlIGB3aGVlbGAgZXZlbnQuXG4gIF9vbldoZWVsKGV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLnNjcm9sbFpvb20pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZXZlbnQuc3JjRXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgIGNvbnN0IHBvcyA9IHRoaXMuZ2V0Q2VudGVyKGV2ZW50KTtcbiAgICBjb25zdCB7ZGVsdGF9ID0gZXZlbnQ7XG5cbiAgICAvLyBNYXAgd2hlZWwgZGVsdGEgdG8gcmVsYXRpdmUgc2NhbGVcbiAgICBsZXQgc2NhbGUgPSAyIC8gKDEgKyBNYXRoLmV4cCgtTWF0aC5hYnMoZGVsdGEgKiBaT09NX0FDQ0VMKSkpO1xuICAgIGlmIChkZWx0YSA8IDAgJiYgc2NhbGUgIT09IDApIHtcbiAgICAgIHNjYWxlID0gMSAvIHNjYWxlO1xuICAgIH1cblxuICAgIGNvbnN0IG5ld1ZpZXdwb3J0U3RhdGUgPSB0aGlzLnZpZXdwb3J0U3RhdGUuem9vbSh7cG9zLCBzY2FsZX0pO1xuICAgIHJldHVybiB0aGlzLnVwZGF0ZVZpZXdwb3J0KG5ld1ZpZXdwb3J0U3RhdGUpO1xuICB9XG5cbiAgLy8gRGVmYXVsdCBoYW5kbGVyIGZvciB0aGUgYHBpbmNoc3RhcnRgIGV2ZW50LlxuICBfb25QaW5jaFN0YXJ0KGV2ZW50KSB7XG4gICAgY29uc3QgcG9zID0gdGhpcy5nZXRDZW50ZXIoZXZlbnQpO1xuICAgIGNvbnN0IG5ld1ZpZXdwb3J0U3RhdGUgPSB0aGlzLnZpZXdwb3J0U3RhdGUuem9vbVN0YXJ0KHtwb3N9KTtcbiAgICByZXR1cm4gdGhpcy51cGRhdGVWaWV3cG9ydChuZXdWaWV3cG9ydFN0YXRlLCB7aXNEcmFnZ2luZzogdHJ1ZX0pO1xuICB9XG5cbiAgLy8gRGVmYXVsdCBoYW5kbGVyIGZvciB0aGUgYHBpbmNoYCBldmVudC5cbiAgX29uUGluY2goZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMudG91Y2hab29tUm90YXRlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IHBvcyA9IHRoaXMuZ2V0Q2VudGVyKGV2ZW50KTtcbiAgICBjb25zdCB7c2NhbGV9ID0gZXZlbnQ7XG4gICAgY29uc3QgbmV3Vmlld3BvcnRTdGF0ZSA9IHRoaXMudmlld3BvcnRTdGF0ZS56b29tKHtwb3MsIHNjYWxlfSk7XG4gICAgcmV0dXJuIHRoaXMudXBkYXRlVmlld3BvcnQobmV3Vmlld3BvcnRTdGF0ZSk7XG4gIH1cblxuICAvLyBEZWZhdWx0IGhhbmRsZXIgZm9yIHRoZSBgcGluY2hlbmRgIGV2ZW50LlxuICBfb25QaW5jaEVuZChldmVudCkge1xuICAgIGNvbnN0IG5ld1ZpZXdwb3J0U3RhdGUgPSB0aGlzLnZpZXdwb3J0U3RhdGUuem9vbUVuZCgpO1xuICAgIHJldHVybiB0aGlzLnVwZGF0ZVZpZXdwb3J0KG5ld1ZpZXdwb3J0U3RhdGUsIHtpc0RyYWdnaW5nOiBmYWxzZX0pO1xuICB9XG5cbiAgLy8gRGVmYXVsdCBoYW5kbGVyIGZvciB0aGUgYGRvdWJsZXRhcGAgZXZlbnQuXG4gIF9vbkRvdWJsZVRhcChldmVudCkge1xuICAgIGlmICghdGhpcy5kb3VibGVDbGlja1pvb20pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgcG9zID0gdGhpcy5nZXRDZW50ZXIoZXZlbnQpO1xuICAgIGNvbnN0IGlzWm9vbU91dCA9IHRoaXMuaXNGdW5jdGlvbktleVByZXNzZWQoZXZlbnQpO1xuXG4gICAgY29uc3QgbmV3Vmlld3BvcnRTdGF0ZSA9IHRoaXMudmlld3BvcnRTdGF0ZS56b29tKHtwb3MsIHNjYWxlOiBpc1pvb21PdXQgPyAwLjUgOiAyfSk7XG4gICAgcmV0dXJuIHRoaXMudXBkYXRlVmlld3BvcnQobmV3Vmlld3BvcnRTdGF0ZSk7XG4gIH1cblxuICBfb25LZXlEb3duKGV2ZW50KSB7XG4gICAgaWYgKHRoaXMudmlld3BvcnRTdGF0ZS5pc0RyYWdnaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgS0VZX0JJTkRJTkdTID0ge1xuICAgICAgdzogJ21vdmVGb3J3YXJkJyxcbiAgICAgIFc6ICdtb3ZlRm9yd2FyZCcsXG4gICAgICBBcnJvd1VwOiAnbW92ZUZvcndhcmQnLFxuXG4gICAgICBzOiAnbW92ZUJhY2t3YXJkJyxcbiAgICAgIFM6ICdtb3ZlQmFja3dhcmQnLFxuICAgICAgQXJyb3dEb3duOiAnbW92ZUJhY2t3YXJkJyxcblxuICAgICAgYTogJ21vdmVMZWZ0JyxcbiAgICAgIEE6ICdtb3ZlTGVmdCcsXG4gICAgICBBcnJvd0xlZnQ6ICdtb3ZlTGVmdCcsXG5cbiAgICAgIGQ6ICdtb3ZlUmlnaHQnLFxuICAgICAgRDogJ21vdmVSaWdodCcsXG4gICAgICBBcnJvd1JpZ2h0OiAnbW92ZVJpZ2h0JyxcblxuICAgICAgJz0nOiAnem9vbUluJyxcbiAgICAgICcrJzogJ3pvb21JbicsXG5cbiAgICAgICctJzogJ3pvb21PdXQnLFxuXG4gICAgICAnWyc6ICdtb3ZlRG93bicsXG4gICAgICAnXSc6ICdtb3ZlVXAnXG4gICAgfTtcblxuICAgIC8vIGtleUNvZGUgaXMgZGVwcmVjYXRlZCBmcm9tIHdlYiBzdGFuZGFyZHNcbiAgICAvLyBjb2RlIGlzIG5vdCBzdXBwb3J0ZWQgYnkgSUUvRWRnZVxuICAgIGNvbnN0IGtleSA9IGV2ZW50LmtleTtcbiAgICBjb25zdCBoYW5kbGVyID0gS0VZX0JJTkRJTkdTW2tleV07XG4gICAgaWYgKHRoaXMudmlld3BvcnRTdGF0ZVtoYW5kbGVyXSkge1xuICAgICAgY29uc3QgbmV3Vmlld3BvcnRTdGF0ZSA9IHRoaXMudmlld3BvcnRTdGF0ZVtoYW5kbGVyXSgpO1xuICAgICAgdGhpcy51cGRhdGVWaWV3cG9ydChuZXdWaWV3cG9ydFN0YXRlKTtcbiAgICB9XG4gIH1cbiAgLyogZXNsaW50LWVuYWJsZSBjb21wbGV4aXR5ICovXG5cbiAgX29uS2V5VXAoZXZlbnQpIHt9XG59XG4iXX0=