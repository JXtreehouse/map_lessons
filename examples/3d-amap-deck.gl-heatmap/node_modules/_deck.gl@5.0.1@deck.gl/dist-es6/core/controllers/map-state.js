var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

import ViewState from './view-state';
import PerspectiveMercatorViewport from '../viewports/web-mercator-viewport';
import assert from 'assert';
import { mod } from '../utils/math-utils';

// MAPBOX LIMITS
export var MAPBOX_LIMITS = {
  minZoom: 0,
  maxZoom: 20,
  minPitch: 0,
  maxPitch: 60
};

var defaultState = {
  pitch: 0,
  bearing: 0,
  altitude: 1.5
};

function ensureFinite(value, fallbackValue) {
  return Number.isFinite(value) ? value : fallbackValue;
}

var MapState = function (_ViewState) {
  _inherits(MapState, _ViewState);

  function MapState() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        width = _ref.width,
        height = _ref.height,
        latitude = _ref.latitude,
        longitude = _ref.longitude,
        zoom = _ref.zoom,
        bearing = _ref.bearing,
        pitch = _ref.pitch,
        altitude = _ref.altitude,
        maxZoom = _ref.maxZoom,
        minZoom = _ref.minZoom,
        maxPitch = _ref.maxPitch,
        minPitch = _ref.minPitch,
        startPanLngLat = _ref.startPanLngLat,
        startZoomLngLat = _ref.startZoomLngLat,
        startBearing = _ref.startBearing,
        startPitch = _ref.startPitch,
        startZoom = _ref.startZoom;

    _classCallCheck(this, MapState);

    assert(Number.isFinite(longitude), '`longitude` must be supplied');
    assert(Number.isFinite(latitude), '`latitude` must be supplied');
    assert(Number.isFinite(zoom), '`zoom` must be supplied');

    var _this = _possibleConstructorReturn(this, (MapState.__proto__ || Object.getPrototypeOf(MapState)).call(this, {
      width: width,
      height: height,
      latitude: latitude,
      longitude: longitude,
      zoom: zoom,
      bearing: bearing,
      pitch: pitch,

      altitude: ensureFinite(altitude, defaultState.altitude),
      maxZoom: ensureFinite(maxZoom, MAPBOX_LIMITS.maxZoom),
      minZoom: ensureFinite(minZoom, MAPBOX_LIMITS.minZoom),
      maxPitch: ensureFinite(maxPitch, MAPBOX_LIMITS.maxPitch),
      minPitch: ensureFinite(minPitch, MAPBOX_LIMITS.minPitch)
    }));

    _this._interactiveState = {
      startPanLngLat: startPanLngLat,
      startZoomLngLat: startZoomLngLat,
      startBearing: startBearing,
      startPitch: startPitch,
      startZoom: startZoom
    };
    return _this;
  }

  /* Public API */

  _createClass(MapState, [{
    key: 'getInteractiveState',
    value: function getInteractiveState() {
      return this._interactiveState;
    }

    /**
     * Start panning
     * @param {[Number, Number]} pos - position on screen where the pointer grabs
     */

  }, {
    key: 'panStart',
    value: function panStart(_ref2) {
      var pos = _ref2.pos;

      return this._getUpdatedState({
        startPanLngLat: this._unproject(pos)
      });
    }

    /**
     * Pan
     * @param {[Number, Number]} pos - position on screen where the pointer is
     * @param {[Number, Number], optional} startPos - where the pointer grabbed at
     *   the start of the operation. Must be supplied of `panStart()` was not called
     */

  }, {
    key: 'pan',
    value: function pan(_ref3) {
      var pos = _ref3.pos,
          startPos = _ref3.startPos;

      var startPanLngLat = this._interactiveState.startPanLngLat || this._unproject(startPos);

      // take the start lnglat and put it where the mouse is down.
      assert(startPanLngLat, '`startPanLngLat` prop is required ' + 'for mouse pan behavior to calculate where to position the map.');

      var _calculateNewLngLat2 = this._calculateNewLngLat({ startPanLngLat: startPanLngLat, pos: pos }),
          _calculateNewLngLat3 = _slicedToArray(_calculateNewLngLat2, 2),
          longitude = _calculateNewLngLat3[0],
          latitude = _calculateNewLngLat3[1];

      return this._getUpdatedState({
        longitude: longitude,
        latitude: latitude
      });
    }

    /**
     * End panning
     * Must call if `panStart()` was called
     */

  }, {
    key: 'panEnd',
    value: function panEnd() {
      return this._getUpdatedState({
        startPanLngLat: null
      });
    }

    /**
     * Start rotating
     * @param {[Number, Number]} pos - position on screen where the center is
     */

  }, {
    key: 'rotateStart',
    value: function rotateStart(_ref4) {
      var pos = _ref4.pos;

      return this._getUpdatedState({
        startBearing: this._viewportProps.bearing,
        startPitch: this._viewportProps.pitch
      });
    }

    /**
     * Rotate
     * @param {Number} deltaScaleX - a number between [-1, 1] specifying the
     *   change to bearing.
     * @param {Number} deltaScaleY - a number between [-1, 1] specifying the
     *   change to pitch. -1 sets to minPitch and 1 sets to maxPitch.
     */

  }, {
    key: 'rotate',
    value: function rotate(_ref5) {
      var deltaScaleX = _ref5.deltaScaleX,
          deltaScaleY = _ref5.deltaScaleY;

      assert(deltaScaleX >= -1 && deltaScaleX <= 1, '`deltaScaleX` must be a number between [-1, 1]');
      assert(deltaScaleY >= -1 && deltaScaleY <= 1, '`deltaScaleY` must be a number between [-1, 1]');

      var _interactiveState = this._interactiveState,
          startBearing = _interactiveState.startBearing,
          startPitch = _interactiveState.startPitch;


      if (!Number.isFinite(startBearing)) {
        startBearing = this._viewportProps.bearing;
      }
      if (!Number.isFinite(startPitch)) {
        startPitch = this._viewportProps.pitch;
      }

      var _calculateNewPitchAnd = this._calculateNewPitchAndBearing({
        deltaScaleX: deltaScaleX,
        deltaScaleY: deltaScaleY,
        startBearing: startBearing,
        startPitch: startPitch
      }),
          pitch = _calculateNewPitchAnd.pitch,
          bearing = _calculateNewPitchAnd.bearing;

      return this._getUpdatedState({
        bearing: bearing,
        pitch: pitch
      });
    }

    /**
     * End rotating
     * Must call if `rotateStart()` was called
     */

  }, {
    key: 'rotateEnd',
    value: function rotateEnd() {
      return this._getUpdatedState({
        startBearing: null,
        startPitch: null
      });
    }

    /**
     * Start zooming
     * @param {[Number, Number]} pos - position on screen where the center is
     */

  }, {
    key: 'zoomStart',
    value: function zoomStart(_ref6) {
      var pos = _ref6.pos;

      return this._getUpdatedState({
        startZoomLngLat: this._unproject(pos),
        startZoom: this._viewportProps.zoom
      });
    }

    /**
     * Zoom
     * @param {[Number, Number]} pos - position on screen where the current center is
     * @param {[Number, Number]} startPos - the center position at
     *   the start of the operation. Must be supplied of `zoomStart()` was not called
     * @param {Number} scale - a number between [0, 1] specifying the accumulated
     *   relative scale.
     */

  }, {
    key: 'zoom',
    value: function zoom(_ref7) {
      var pos = _ref7.pos,
          startPos = _ref7.startPos,
          scale = _ref7.scale;

      assert(scale > 0, '`scale` must be a positive number');

      // Make sure we zoom around the current mouse position rather than map center
      var startZoomLngLat = this._interactiveState.startZoomLngLat || this._unproject(startPos) || this._unproject(pos);
      var startZoom = this._interactiveState.startZoom;


      if (!Number.isFinite(startZoom)) {
        startZoom = this._viewportProps.zoom;
      }

      // take the start lnglat and put it where the mouse is down.
      assert(startZoomLngLat, '`startZoomLngLat` prop is required ' + 'for zoom behavior to calculate where to position the map.');

      var zoom = this._calculateNewZoom({ scale: scale, startZoom: startZoom });

      var zoomedViewport = new PerspectiveMercatorViewport(Object.assign({}, this._viewportProps, { zoom: zoom }));

      var _zoomedViewport$getLo = zoomedViewport.getLocationAtPoint({ lngLat: startZoomLngLat, pos: pos }),
          _zoomedViewport$getLo2 = _slicedToArray(_zoomedViewport$getLo, 2),
          longitude = _zoomedViewport$getLo2[0],
          latitude = _zoomedViewport$getLo2[1];

      return this._getUpdatedState({
        zoom: zoom,
        longitude: longitude,
        latitude: latitude
      });
    }

    /**
     * End zooming
     * Must call if `zoomStart()` was called
     */

  }, {
    key: 'zoomEnd',
    value: function zoomEnd() {
      return this._getUpdatedState({
        startZoomLngLat: null,
        startZoom: null
      });
    }
  }, {
    key: 'moveLeft',
    value: function moveLeft() {
      return this._getUpdatedState({
        bearing: this._viewportProps.bearing - 3
      });
    }
  }, {
    key: 'moveRight',
    value: function moveRight() {
      return this._getUpdatedState({
        bearing: this._viewportProps.bearing + 3
      });
    }
  }, {
    key: 'moveForward',
    value: function moveForward() {
      return this._getUpdatedState({
        pitch: this._viewportProps.pitch + 3
      });
    }
  }, {
    key: 'moveBackward',
    value: function moveBackward() {
      return this._getUpdatedState({
        pitch: this._viewportProps.pitch - 3
      });
    }
  }, {
    key: 'zoomIn',
    value: function zoomIn() {
      return this._getUpdatedState({
        zoom: this._viewportProps.zoom + 0.2
      });
    }
  }, {
    key: 'zoomOut',
    value: function zoomOut() {
      return this._getUpdatedState({
        zoom: this._viewportProps.zoom - 0.2
      });
    }

    /* Private methods */

  }, {
    key: '_getUpdatedState',
    value: function _getUpdatedState(newProps) {
      // Update _viewportProps
      return new MapState(Object.assign({}, this._viewportProps, this._interactiveState, newProps));
    }

    // Apply any constraints (mathematical or defined by _viewportProps) to map state

  }, {
    key: '_applyConstraints',
    value: function _applyConstraints(props) {
      // Normalize degrees
      props.longitude = mod(props.longitude + 180, 360) - 180;
      props.bearing = mod(props.bearing + 180, 360) - 180;

      // Ensure zoom is within specified range
      var maxZoom = props.maxZoom,
          minZoom = props.minZoom,
          zoom = props.zoom;

      props.zoom = zoom > maxZoom ? maxZoom : zoom;
      props.zoom = props.zoom < minZoom ? minZoom : props.zoom;

      // Ensure pitch is within specified range
      var maxPitch = props.maxPitch,
          minPitch = props.minPitch,
          pitch = props.pitch;


      props.pitch = pitch > maxPitch ? maxPitch : pitch;
      props.pitch = props.pitch < minPitch ? minPitch : props.pitch;

      return props;
    }
  }, {
    key: '_unproject',
    value: function _unproject(pos) {
      var viewport = new PerspectiveMercatorViewport(this._viewportProps);
      return pos && viewport.unproject(pos, { topLeft: true });
    }

    // Calculate a new lnglat based on pixel dragging position

  }, {
    key: '_calculateNewLngLat',
    value: function _calculateNewLngLat(_ref8) {
      var startPanLngLat = _ref8.startPanLngLat,
          pos = _ref8.pos;

      var viewport = new PerspectiveMercatorViewport(this._viewportProps);
      return viewport.getLocationAtPoint({ lngLat: startPanLngLat, pos: pos });
    }

    // Calculates new zoom

  }, {
    key: '_calculateNewZoom',
    value: function _calculateNewZoom(_ref9) {
      var scale = _ref9.scale,
          startZoom = _ref9.startZoom;
      var _viewportProps = this._viewportProps,
          maxZoom = _viewportProps.maxZoom,
          minZoom = _viewportProps.minZoom;

      var zoom = startZoom + Math.log2(scale);
      zoom = zoom > maxZoom ? maxZoom : zoom;
      zoom = zoom < minZoom ? minZoom : zoom;
      return zoom;
    }

    // Calculates a new pitch and bearing from a position (coming from an event)

  }, {
    key: '_calculateNewPitchAndBearing',
    value: function _calculateNewPitchAndBearing(_ref10) {
      var deltaScaleX = _ref10.deltaScaleX,
          deltaScaleY = _ref10.deltaScaleY,
          startBearing = _ref10.startBearing,
          startPitch = _ref10.startPitch;
      var _viewportProps2 = this._viewportProps,
          minPitch = _viewportProps2.minPitch,
          maxPitch = _viewportProps2.maxPitch;


      var bearing = startBearing + 180 * deltaScaleX;
      var pitch = startPitch;
      if (deltaScaleY > 0) {
        // Gradually increase pitch
        pitch = startPitch + deltaScaleY * (maxPitch - startPitch);
      } else if (deltaScaleY < 0) {
        // Gradually decrease pitch
        pitch = startPitch - deltaScaleY * (minPitch - startPitch);
      }

      return {
        pitch: pitch,
        bearing: bearing
      };
    }
  }]);

  return MapState;
}(ViewState);

export default MapState;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9jb3JlL2NvbnRyb2xsZXJzL21hcC1zdGF0ZS5qcyJdLCJuYW1lcyI6WyJWaWV3U3RhdGUiLCJQZXJzcGVjdGl2ZU1lcmNhdG9yVmlld3BvcnQiLCJhc3NlcnQiLCJtb2QiLCJNQVBCT1hfTElNSVRTIiwibWluWm9vbSIsIm1heFpvb20iLCJtaW5QaXRjaCIsIm1heFBpdGNoIiwiZGVmYXVsdFN0YXRlIiwicGl0Y2giLCJiZWFyaW5nIiwiYWx0aXR1ZGUiLCJlbnN1cmVGaW5pdGUiLCJ2YWx1ZSIsImZhbGxiYWNrVmFsdWUiLCJOdW1iZXIiLCJpc0Zpbml0ZSIsIk1hcFN0YXRlIiwid2lkdGgiLCJoZWlnaHQiLCJsYXRpdHVkZSIsImxvbmdpdHVkZSIsInpvb20iLCJzdGFydFBhbkxuZ0xhdCIsInN0YXJ0Wm9vbUxuZ0xhdCIsInN0YXJ0QmVhcmluZyIsInN0YXJ0UGl0Y2giLCJzdGFydFpvb20iLCJfaW50ZXJhY3RpdmVTdGF0ZSIsInBvcyIsIl9nZXRVcGRhdGVkU3RhdGUiLCJfdW5wcm9qZWN0Iiwic3RhcnRQb3MiLCJfY2FsY3VsYXRlTmV3TG5nTGF0IiwiX3ZpZXdwb3J0UHJvcHMiLCJkZWx0YVNjYWxlWCIsImRlbHRhU2NhbGVZIiwiX2NhbGN1bGF0ZU5ld1BpdGNoQW5kQmVhcmluZyIsInNjYWxlIiwiX2NhbGN1bGF0ZU5ld1pvb20iLCJ6b29tZWRWaWV3cG9ydCIsIk9iamVjdCIsImFzc2lnbiIsImdldExvY2F0aW9uQXRQb2ludCIsImxuZ0xhdCIsIm5ld1Byb3BzIiwicHJvcHMiLCJ2aWV3cG9ydCIsInVucHJvamVjdCIsInRvcExlZnQiLCJNYXRoIiwibG9nMiJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBLE9BQU9BLFNBQVAsTUFBc0IsY0FBdEI7QUFDQSxPQUFPQywyQkFBUCxNQUF3QyxvQ0FBeEM7QUFDQSxPQUFPQyxNQUFQLE1BQW1CLFFBQW5CO0FBQ0EsU0FBUUMsR0FBUixRQUFrQixxQkFBbEI7O0FBRUE7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S0FBVixDQUF2QjtBQUNBaEIsYUFBT0EsT0FBT2pCLE9BQVAsR0FBaUJBLE9BQWpCLEdBQTJCaUIsSUFBbEM7QUFDQUEsYUFBT0EsT0FBT2xCLE9BQVAsR0FBaUJBLE9BQWpCLEdBQTJCa0IsSUFBbEM7QUFDQSxhQUFPQSxJQUFQO0FBQ0Q7O0FBRUQ7Ozs7eURBQ21GO0FBQUEsVUFBckRhLFdBQXFELFVBQXJEQSxXQUFxRDtBQUFBLFVBQXhDQyxXQUF3QyxVQUF4Q0EsV0FBd0M7QUFBQSxVQUEzQlgsWUFBMkIsVUFBM0JBLFlBQTJCO0FBQUEsVUFBYkMsVUFBYSxVQUFiQSxVQUFhO0FBQUEsNEJBQ3BELEtBQUtRLGNBRCtDO0FBQUEsVUFDMUU1QixRQUQwRSxtQkFDMUVBLFFBRDBFO0FBQUEsVUFDaEVDLFFBRGdFLG1CQUNoRUEsUUFEZ0U7OztBQUdqRixVQUFNRyxVQUFVZSxlQUFlLE1BQU1VLFdBQXJDO0FBQ0EsVUFBSTFCLFFBQVFpQixVQUFaO0FBQ0EsVUFBSVUsY0FBYyxDQUFsQixFQUFxQjtBQUNuQjtBQUNBM0IsZ0JBQVFpQixhQUFhVSxlQUFlN0IsV0FBV21CLFVBQTFCLENBQXJCO0FBQ0QsT0FIRCxNQUdPLElBQUlVLGNBQWMsQ0FBbEIsRUFBcUI7QUFDMUI7QUFDQTNCLGdCQUFRaUIsYUFBYVUsZUFBZTlCLFdBQVdvQixVQUExQixDQUFyQjtBQUNEOztBQUVELGFBQU87QUFDTGpCLG9CQURLO0FBRUxDO0FBRkssT0FBUDtBQUlEOzs7O0VBcFZtQ1gsUzs7ZUFBakJrQixRIiwiZmlsZSI6Im1hcC1zdGF0ZS5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBWaWV3U3RhdGUgZnJvbSAnLi92aWV3LXN0YXRlJztcbmltcG9ydCBQZXJzcGVjdGl2ZU1lcmNhdG9yVmlld3BvcnQgZnJvbSAnLi4vdmlld3BvcnRzL3dlYi1tZXJjYXRvci12aWV3cG9ydCc7XG5pbXBvcnQgYXNzZXJ0IGZyb20gJ2Fzc2VydCc7XG5pbXBvcnQge21vZH0gZnJvbSAnLi4vdXRpbHMvbWF0aC11dGlscyc7XG5cbi8vIE1BUEJPWCBMSU1JVFNcbmV4cG9ydCBjb25zdCBNQVBCT1hfTElNSVRTID0ge1xuICBtaW5ab29tOiAwLFxuICBtYXhab29tOiAyMCxcbiAgbWluUGl0Y2g6IDAsXG4gIG1heFBpdGNoOiA2MFxufTtcblxuY29uc3QgZGVmYXVsdFN0YXRlID0ge1xuICBwaXRjaDogMCxcbiAgYmVhcmluZzogMCxcbiAgYWx0aXR1ZGU6IDEuNVxufTtcblxuZnVuY3Rpb24gZW5zdXJlRmluaXRlKHZhbHVlLCBmYWxsYmFja1ZhbHVlKSB7XG4gIHJldHVybiBOdW1iZXIuaXNGaW5pdGUodmFsdWUpID8gdmFsdWUgOiBmYWxsYmFja1ZhbHVlO1xufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNYXBTdGF0ZSBleHRlbmRzIFZpZXdTdGF0ZSB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICAvKiogTWFwYm94IHZpZXdwb3J0IHByb3BlcnRpZXMgKi9cbiAgICAvKiogVGhlIHdpZHRoIG9mIHRoZSB2aWV3cG9ydCAqL1xuICAgIHdpZHRoLFxuICAgIC8qKiBUaGUgaGVpZ2h0IG9mIHRoZSB2aWV3cG9ydCAqL1xuICAgIGhlaWdodCxcbiAgICAvKiogVGhlIGxhdGl0dWRlIGF0IHRoZSBjZW50ZXIgb2YgdGhlIHZpZXdwb3J0ICovXG4gICAgbGF0aXR1ZGUsXG4gICAgLyoqIFRoZSBsb25naXR1ZGUgYXQgdGhlIGNlbnRlciBvZiB0aGUgdmlld3BvcnQgKi9cbiAgICBsb25naXR1ZGUsXG4gICAgLyoqIFRoZSB0aWxlIHpvb20gbGV2ZWwgb2YgdGhlIG1hcC4gKi9cbiAgICB6b29tLFxuICAgIC8qKiBUaGUgYmVhcmluZyBvZiB0aGUgdmlld3BvcnQgaW4gZGVncmVlcyAqL1xuICAgIGJlYXJpbmcsXG4gICAgLyoqIFRoZSBwaXRjaCBvZiB0aGUgdmlld3BvcnQgaW4gZGVncmVlcyAqL1xuICAgIHBpdGNoLFxuICAgIC8qKlxuICAgICAqIFNwZWNpZnkgdGhlIGFsdGl0dWRlIG9mIHRoZSB2aWV3cG9ydCBjYW1lcmFcbiAgICAgKiBVbml0OiBtYXAgaGVpZ2h0cywgZGVmYXVsdCAxLjVcbiAgICAgKiBOb24tcHVibGljIEFQSSwgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXBib3gvbWFwYm94LWdsLWpzL2lzc3Vlcy8xMTM3XG4gICAgICovXG4gICAgYWx0aXR1ZGUsXG5cbiAgICAvKiogVmlld3BvcnQgY29uc3RyYWludHMgKi9cbiAgICBtYXhab29tLFxuICAgIG1pblpvb20sXG4gICAgbWF4UGl0Y2gsXG4gICAgbWluUGl0Y2gsXG5cbiAgICAvKiogSW50ZXJhY3Rpb24gc3RhdGVzLCByZXF1aXJlZCB0byBjYWxjdWxhdGUgY2hhbmdlIGR1cmluZyB0cmFuc2Zvcm0gKi9cbiAgICAvKiBUaGUgcG9pbnQgb24gbWFwIGJlaW5nIGdyYWJiZWQgd2hlbiB0aGUgb3BlcmF0aW9uIGZpcnN0IHN0YXJ0ZWQgKi9cbiAgICBzdGFydFBhbkxuZ0xhdCxcbiAgICAvKiBDZW50ZXIgb2YgdGhlIHpvb20gd2hlbiB0aGUgb3BlcmF0aW9uIGZpcnN0IHN0YXJ0ZWQgKi9cbiAgICBzdGFydFpvb21MbmdMYXQsXG4gICAgLyoqIEJlYXJpbmcgd2hlbiBjdXJyZW50IHBlcnNwZWN0aXZlIHJvdGF0ZSBvcGVyYXRpb24gc3RhcnRlZCAqL1xuICAgIHN0YXJ0QmVhcmluZyxcbiAgICAvKiogUGl0Y2ggd2hlbiBjdXJyZW50IHBlcnNwZWN0aXZlIHJvdGF0ZSBvcGVyYXRpb24gc3RhcnRlZCAqL1xuICAgIHN0YXJ0UGl0Y2gsXG4gICAgLyoqIFpvb20gd2hlbiBjdXJyZW50IHpvb20gb3BlcmF0aW9uIHN0YXJ0ZWQgKi9cbiAgICBzdGFydFpvb21cbiAgfSA9IHt9KSB7XG4gICAgYXNzZXJ0KE51bWJlci5pc0Zpbml0ZShsb25naXR1ZGUpLCAnYGxvbmdpdHVkZWAgbXVzdCBiZSBzdXBwbGllZCcpO1xuICAgIGFzc2VydChOdW1iZXIuaXNGaW5pdGUobGF0aXR1ZGUpLCAnYGxhdGl0dWRlYCBtdXN0IGJlIHN1cHBsaWVkJyk7XG4gICAgYXNzZXJ0KE51bWJlci5pc0Zpbml0ZSh6b29tKSwgJ2B6b29tYCBtdXN0IGJlIHN1cHBsaWVkJyk7XG5cbiAgICBzdXBlcih7XG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodCxcbiAgICAgIGxhdGl0dWRlLFxuICAgICAgbG9uZ2l0dWRlLFxuICAgICAgem9vbSxcbiAgICAgIGJlYXJpbmcsXG4gICAgICBwaXRjaCxcblxuICAgICAgYWx0aXR1ZGU6IGVuc3VyZUZpbml0ZShhbHRpdHVkZSwgZGVmYXVsdFN0YXRlLmFsdGl0dWRlKSxcbiAgICAgIG1heFpvb206IGVuc3VyZUZpbml0ZShtYXhab29tLCBNQVBCT1hfTElNSVRTLm1heFpvb20pLFxuICAgICAgbWluWm9vbTogZW5zdXJlRmluaXRlKG1pblpvb20sIE1BUEJPWF9MSU1JVFMubWluWm9vbSksXG4gICAgICBtYXhQaXRjaDogZW5zdXJlRmluaXRlKG1heFBpdGNoLCBNQVBCT1hfTElNSVRTLm1heFBpdGNoKSxcbiAgICAgIG1pblBpdGNoOiBlbnN1cmVGaW5pdGUobWluUGl0Y2gsIE1BUEJPWF9MSU1JVFMubWluUGl0Y2gpXG4gICAgfSk7XG5cbiAgICB0aGlzLl9pbnRlcmFjdGl2ZVN0YXRlID0ge1xuICAgICAgc3RhcnRQYW5MbmdMYXQsXG4gICAgICBzdGFydFpvb21MbmdMYXQsXG4gICAgICBzdGFydEJlYXJpbmcsXG4gICAgICBzdGFydFBpdGNoLFxuICAgICAgc3RhcnRab29tXG4gICAgfTtcbiAgfVxuXG4gIC8qIFB1YmxpYyBBUEkgKi9cblxuICBnZXRJbnRlcmFjdGl2ZVN0YXRlKCkge1xuICAgIHJldHVybiB0aGlzLl9pbnRlcmFjdGl2ZVN0YXRlO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0YXJ0IHBhbm5pbmdcbiAgICogQHBhcmFtIHtbTnVtYmVyLCBOdW1iZXJdfSBwb3MgLSBwb3NpdGlvbiBvbiBzY3JlZW4gd2hlcmUgdGhlIHBvaW50ZXIgZ3JhYnNcbiAgICovXG4gIHBhblN0YXJ0KHtwb3N9KSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldFVwZGF0ZWRTdGF0ZSh7XG4gICAgICBzdGFydFBhbkxuZ0xhdDogdGhpcy5fdW5wcm9qZWN0KHBvcylcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYW5cbiAgICogQHBhcmFtIHtbTnVtYmVyLCBOdW1iZXJdfSBwb3MgLSBwb3NpdGlvbiBvbiBzY3JlZW4gd2hlcmUgdGhlIHBvaW50ZXIgaXNcbiAgICogQHBhcmFtIHtbTnVtYmVyLCBOdW1iZXJdLCBvcHRpb25hbH0gc3RhcnRQb3MgLSB3aGVyZSB0aGUgcG9pbnRlciBncmFiYmVkIGF0XG4gICAqICAgdGhlIHN0YXJ0IG9mIHRoZSBvcGVyYXRpb24uIE11c3QgYmUgc3VwcGxpZWQgb2YgYHBhblN0YXJ0KClgIHdhcyBub3QgY2FsbGVkXG4gICAqL1xuICBwYW4oe3Bvcywgc3RhcnRQb3N9KSB7XG4gICAgY29uc3Qgc3RhcnRQYW5MbmdMYXQgPSB0aGlzLl9pbnRlcmFjdGl2ZVN0YXRlLnN0YXJ0UGFuTG5nTGF0IHx8IHRoaXMuX3VucHJvamVjdChzdGFydFBvcyk7XG5cbiAgICAvLyB0YWtlIHRoZSBzdGFydCBsbmdsYXQgYW5kIHB1dCBpdCB3aGVyZSB0aGUgbW91c2UgaXMgZG93bi5cbiAgICBhc3NlcnQoXG4gICAgICBzdGFydFBhbkxuZ0xhdCxcbiAgICAgICdgc3RhcnRQYW5MbmdMYXRgIHByb3AgaXMgcmVxdWlyZWQgJyArXG4gICAgICAgICdmb3IgbW91c2UgcGFuIGJlaGF2aW9yIHRvIGNhbGN1bGF0ZSB3aGVyZSB0byBwb3NpdGlvbiB0aGUgbWFwLidcbiAgICApO1xuXG4gICAgY29uc3QgW2xvbmdpdHVkZSwgbGF0aXR1ZGVdID0gdGhpcy5fY2FsY3VsYXRlTmV3TG5nTGF0KHtzdGFydFBhbkxuZ0xhdCwgcG9zfSk7XG5cbiAgICByZXR1cm4gdGhpcy5fZ2V0VXBkYXRlZFN0YXRlKHtcbiAgICAgIGxvbmdpdHVkZSxcbiAgICAgIGxhdGl0dWRlXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogRW5kIHBhbm5pbmdcbiAgICogTXVzdCBjYWxsIGlmIGBwYW5TdGFydCgpYCB3YXMgY2FsbGVkXG4gICAqL1xuICBwYW5FbmQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldFVwZGF0ZWRTdGF0ZSh7XG4gICAgICBzdGFydFBhbkxuZ0xhdDogbnVsbFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0YXJ0IHJvdGF0aW5nXG4gICAqIEBwYXJhbSB7W051bWJlciwgTnVtYmVyXX0gcG9zIC0gcG9zaXRpb24gb24gc2NyZWVuIHdoZXJlIHRoZSBjZW50ZXIgaXNcbiAgICovXG4gIHJvdGF0ZVN0YXJ0KHtwb3N9KSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldFVwZGF0ZWRTdGF0ZSh7XG4gICAgICBzdGFydEJlYXJpbmc6IHRoaXMuX3ZpZXdwb3J0UHJvcHMuYmVhcmluZyxcbiAgICAgIHN0YXJ0UGl0Y2g6IHRoaXMuX3ZpZXdwb3J0UHJvcHMucGl0Y2hcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSb3RhdGVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGRlbHRhU2NhbGVYIC0gYSBudW1iZXIgYmV0d2VlbiBbLTEsIDFdIHNwZWNpZnlpbmcgdGhlXG4gICAqICAgY2hhbmdlIHRvIGJlYXJpbmcuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBkZWx0YVNjYWxlWSAtIGEgbnVtYmVyIGJldHdlZW4gWy0xLCAxXSBzcGVjaWZ5aW5nIHRoZVxuICAgKiAgIGNoYW5nZSB0byBwaXRjaC4gLTEgc2V0cyB0byBtaW5QaXRjaCBhbmQgMSBzZXRzIHRvIG1heFBpdGNoLlxuICAgKi9cbiAgcm90YXRlKHtkZWx0YVNjYWxlWCwgZGVsdGFTY2FsZVl9KSB7XG4gICAgYXNzZXJ0KGRlbHRhU2NhbGVYID49IC0xICYmIGRlbHRhU2NhbGVYIDw9IDEsICdgZGVsdGFTY2FsZVhgIG11c3QgYmUgYSBudW1iZXIgYmV0d2VlbiBbLTEsIDFdJyk7XG4gICAgYXNzZXJ0KGRlbHRhU2NhbGVZID49IC0xICYmIGRlbHRhU2NhbGVZIDw9IDEsICdgZGVsdGFTY2FsZVlgIG11c3QgYmUgYSBudW1iZXIgYmV0d2VlbiBbLTEsIDFdJyk7XG5cbiAgICBsZXQge3N0YXJ0QmVhcmluZywgc3RhcnRQaXRjaH0gPSB0aGlzLl9pbnRlcmFjdGl2ZVN0YXRlO1xuXG4gICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUoc3RhcnRCZWFyaW5nKSkge1xuICAgICAgc3RhcnRCZWFyaW5nID0gdGhpcy5fdmlld3BvcnRQcm9wcy5iZWFyaW5nO1xuICAgIH1cbiAgICBpZiAoIU51bWJlci5pc0Zpbml0ZShzdGFydFBpdGNoKSkge1xuICAgICAgc3RhcnRQaXRjaCA9IHRoaXMuX3ZpZXdwb3J0UHJvcHMucGl0Y2g7XG4gICAgfVxuXG4gICAgY29uc3Qge3BpdGNoLCBiZWFyaW5nfSA9IHRoaXMuX2NhbGN1bGF0ZU5ld1BpdGNoQW5kQmVhcmluZyh7XG4gICAgICBkZWx0YVNjYWxlWCxcbiAgICAgIGRlbHRhU2NhbGVZLFxuICAgICAgc3RhcnRCZWFyaW5nLFxuICAgICAgc3RhcnRQaXRjaFxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXMuX2dldFVwZGF0ZWRTdGF0ZSh7XG4gICAgICBiZWFyaW5nLFxuICAgICAgcGl0Y2hcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFbmQgcm90YXRpbmdcbiAgICogTXVzdCBjYWxsIGlmIGByb3RhdGVTdGFydCgpYCB3YXMgY2FsbGVkXG4gICAqL1xuICByb3RhdGVFbmQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldFVwZGF0ZWRTdGF0ZSh7XG4gICAgICBzdGFydEJlYXJpbmc6IG51bGwsXG4gICAgICBzdGFydFBpdGNoOiBudWxsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogU3RhcnQgem9vbWluZ1xuICAgKiBAcGFyYW0ge1tOdW1iZXIsIE51bWJlcl19IHBvcyAtIHBvc2l0aW9uIG9uIHNjcmVlbiB3aGVyZSB0aGUgY2VudGVyIGlzXG4gICAqL1xuICB6b29tU3RhcnQoe3Bvc30pIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0VXBkYXRlZFN0YXRlKHtcbiAgICAgIHN0YXJ0Wm9vbUxuZ0xhdDogdGhpcy5fdW5wcm9qZWN0KHBvcyksXG4gICAgICBzdGFydFpvb206IHRoaXMuX3ZpZXdwb3J0UHJvcHMuem9vbVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFpvb21cbiAgICogQHBhcmFtIHtbTnVtYmVyLCBOdW1iZXJdfSBwb3MgLSBwb3NpdGlvbiBvbiBzY3JlZW4gd2hlcmUgdGhlIGN1cnJlbnQgY2VudGVyIGlzXG4gICAqIEBwYXJhbSB7W051bWJlciwgTnVtYmVyXX0gc3RhcnRQb3MgLSB0aGUgY2VudGVyIHBvc2l0aW9uIGF0XG4gICAqICAgdGhlIHN0YXJ0IG9mIHRoZSBvcGVyYXRpb24uIE11c3QgYmUgc3VwcGxpZWQgb2YgYHpvb21TdGFydCgpYCB3YXMgbm90IGNhbGxlZFxuICAgKiBAcGFyYW0ge051bWJlcn0gc2NhbGUgLSBhIG51bWJlciBiZXR3ZWVuIFswLCAxXSBzcGVjaWZ5aW5nIHRoZSBhY2N1bXVsYXRlZFxuICAgKiAgIHJlbGF0aXZlIHNjYWxlLlxuICAgKi9cbiAgem9vbSh7cG9zLCBzdGFydFBvcywgc2NhbGV9KSB7XG4gICAgYXNzZXJ0KHNjYWxlID4gMCwgJ2BzY2FsZWAgbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlcicpO1xuXG4gICAgLy8gTWFrZSBzdXJlIHdlIHpvb20gYXJvdW5kIHRoZSBjdXJyZW50IG1vdXNlIHBvc2l0aW9uIHJhdGhlciB0aGFuIG1hcCBjZW50ZXJcbiAgICBjb25zdCBzdGFydFpvb21MbmdMYXQgPVxuICAgICAgdGhpcy5faW50ZXJhY3RpdmVTdGF0ZS5zdGFydFpvb21MbmdMYXQgfHwgdGhpcy5fdW5wcm9qZWN0KHN0YXJ0UG9zKSB8fCB0aGlzLl91bnByb2plY3QocG9zKTtcbiAgICBsZXQge3N0YXJ0Wm9vbX0gPSB0aGlzLl9pbnRlcmFjdGl2ZVN0YXRlO1xuXG4gICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUoc3RhcnRab29tKSkge1xuICAgICAgc3RhcnRab29tID0gdGhpcy5fdmlld3BvcnRQcm9wcy56b29tO1xuICAgIH1cblxuICAgIC8vIHRha2UgdGhlIHN0YXJ0IGxuZ2xhdCBhbmQgcHV0IGl0IHdoZXJlIHRoZSBtb3VzZSBpcyBkb3duLlxuICAgIGFzc2VydChcbiAgICAgIHN0YXJ0Wm9vbUxuZ0xhdCxcbiAgICAgICdgc3RhcnRab29tTG5nTGF0YCBwcm9wIGlzIHJlcXVpcmVkICcgK1xuICAgICAgICAnZm9yIHpvb20gYmVoYXZpb3IgdG8gY2FsY3VsYXRlIHdoZXJlIHRvIHBvc2l0aW9uIHRoZSBtYXAuJ1xuICAgICk7XG5cbiAgICBjb25zdCB6b29tID0gdGhpcy5fY2FsY3VsYXRlTmV3Wm9vbSh7c2NhbGUsIHN0YXJ0Wm9vbX0pO1xuXG4gICAgY29uc3Qgem9vbWVkVmlld3BvcnQgPSBuZXcgUGVyc3BlY3RpdmVNZXJjYXRvclZpZXdwb3J0KFxuICAgICAgT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5fdmlld3BvcnRQcm9wcywge3pvb219KVxuICAgICk7XG4gICAgY29uc3QgW2xvbmdpdHVkZSwgbGF0aXR1ZGVdID0gem9vbWVkVmlld3BvcnQuZ2V0TG9jYXRpb25BdFBvaW50KHtsbmdMYXQ6IHN0YXJ0Wm9vbUxuZ0xhdCwgcG9zfSk7XG5cbiAgICByZXR1cm4gdGhpcy5fZ2V0VXBkYXRlZFN0YXRlKHtcbiAgICAgIHpvb20sXG4gICAgICBsb25naXR1ZGUsXG4gICAgICBsYXRpdHVkZVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEVuZCB6b29taW5nXG4gICAqIE11c3QgY2FsbCBpZiBgem9vbVN0YXJ0KClgIHdhcyBjYWxsZWRcbiAgICovXG4gIHpvb21FbmQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldFVwZGF0ZWRTdGF0ZSh7XG4gICAgICBzdGFydFpvb21MbmdMYXQ6IG51bGwsXG4gICAgICBzdGFydFpvb206IG51bGxcbiAgICB9KTtcbiAgfVxuXG4gIG1vdmVMZWZ0KCkge1xuICAgIHJldHVybiB0aGlzLl9nZXRVcGRhdGVkU3RhdGUoe1xuICAgICAgYmVhcmluZzogdGhpcy5fdmlld3BvcnRQcm9wcy5iZWFyaW5nIC0gM1xuICAgIH0pO1xuICB9XG5cbiAgbW92ZVJpZ2h0KCkge1xuICAgIHJldHVybiB0aGlzLl9nZXRVcGRhdGVkU3RhdGUoe1xuICAgICAgYmVhcmluZzogdGhpcy5fdmlld3BvcnRQcm9wcy5iZWFyaW5nICsgM1xuICAgIH0pO1xuICB9XG5cbiAgbW92ZUZvcndhcmQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldFVwZGF0ZWRTdGF0ZSh7XG4gICAgICBwaXRjaDogdGhpcy5fdmlld3BvcnRQcm9wcy5waXRjaCArIDNcbiAgICB9KTtcbiAgfVxuXG4gIG1vdmVCYWNrd2FyZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0VXBkYXRlZFN0YXRlKHtcbiAgICAgIHBpdGNoOiB0aGlzLl92aWV3cG9ydFByb3BzLnBpdGNoIC0gM1xuICAgIH0pO1xuICB9XG5cbiAgem9vbUluKCkge1xuICAgIHJldHVybiB0aGlzLl9nZXRVcGRhdGVkU3RhdGUoe1xuICAgICAgem9vbTogdGhpcy5fdmlld3BvcnRQcm9wcy56b29tICsgMC4yXG4gICAgfSk7XG4gIH1cblxuICB6b29tT3V0KCkge1xuICAgIHJldHVybiB0aGlzLl9nZXRVcGRhdGVkU3RhdGUoe1xuICAgICAgem9vbTogdGhpcy5fdmlld3BvcnRQcm9wcy56b29tIC0gMC4yXG4gICAgfSk7XG4gIH1cblxuICAvKiBQcml2YXRlIG1ldGhvZHMgKi9cblxuICBfZ2V0VXBkYXRlZFN0YXRlKG5ld1Byb3BzKSB7XG4gICAgLy8gVXBkYXRlIF92aWV3cG9ydFByb3BzXG4gICAgcmV0dXJuIG5ldyBNYXBTdGF0ZShPYmplY3QuYXNzaWduKHt9LCB0aGlzLl92aWV3cG9ydFByb3BzLCB0aGlzLl9pbnRlcmFjdGl2ZVN0YXRlLCBuZXdQcm9wcykpO1xuICB9XG5cbiAgLy8gQXBwbHkgYW55IGNvbnN0cmFpbnRzIChtYXRoZW1hdGljYWwgb3IgZGVmaW5lZCBieSBfdmlld3BvcnRQcm9wcykgdG8gbWFwIHN0YXRlXG4gIF9hcHBseUNvbnN0cmFpbnRzKHByb3BzKSB7XG4gICAgLy8gTm9ybWFsaXplIGRlZ3JlZXNcbiAgICBwcm9wcy5sb25naXR1ZGUgPSBtb2QocHJvcHMubG9uZ2l0dWRlICsgMTgwLCAzNjApIC0gMTgwO1xuICAgIHByb3BzLmJlYXJpbmcgPSBtb2QocHJvcHMuYmVhcmluZyArIDE4MCwgMzYwKSAtIDE4MDtcblxuICAgIC8vIEVuc3VyZSB6b29tIGlzIHdpdGhpbiBzcGVjaWZpZWQgcmFuZ2VcbiAgICBjb25zdCB7bWF4Wm9vbSwgbWluWm9vbSwgem9vbX0gPSBwcm9wcztcbiAgICBwcm9wcy56b29tID0gem9vbSA+IG1heFpvb20gPyBtYXhab29tIDogem9vbTtcbiAgICBwcm9wcy56b29tID0gcHJvcHMuem9vbSA8IG1pblpvb20gPyBtaW5ab29tIDogcHJvcHMuem9vbTtcblxuICAgIC8vIEVuc3VyZSBwaXRjaCBpcyB3aXRoaW4gc3BlY2lmaWVkIHJhbmdlXG4gICAgY29uc3Qge21heFBpdGNoLCBtaW5QaXRjaCwgcGl0Y2h9ID0gcHJvcHM7XG5cbiAgICBwcm9wcy5waXRjaCA9IHBpdGNoID4gbWF4UGl0Y2ggPyBtYXhQaXRjaCA6IHBpdGNoO1xuICAgIHByb3BzLnBpdGNoID0gcHJvcHMucGl0Y2ggPCBtaW5QaXRjaCA/IG1pblBpdGNoIDogcHJvcHMucGl0Y2g7XG5cbiAgICByZXR1cm4gcHJvcHM7XG4gIH1cblxuICBfdW5wcm9qZWN0KHBvcykge1xuICAgIGNvbnN0IHZpZXdwb3J0ID0gbmV3IFBlcnNwZWN0aXZlTWVyY2F0b3JWaWV3cG9ydCh0aGlzLl92aWV3cG9ydFByb3BzKTtcbiAgICByZXR1cm4gcG9zICYmIHZpZXdwb3J0LnVucHJvamVjdChwb3MsIHt0b3BMZWZ0OiB0cnVlfSk7XG4gIH1cblxuICAvLyBDYWxjdWxhdGUgYSBuZXcgbG5nbGF0IGJhc2VkIG9uIHBpeGVsIGRyYWdnaW5nIHBvc2l0aW9uXG4gIF9jYWxjdWxhdGVOZXdMbmdMYXQoe3N0YXJ0UGFuTG5nTGF0LCBwb3N9KSB7XG4gICAgY29uc3Qgdmlld3BvcnQgPSBuZXcgUGVyc3BlY3RpdmVNZXJjYXRvclZpZXdwb3J0KHRoaXMuX3ZpZXdwb3J0UHJvcHMpO1xuICAgIHJldHVybiB2aWV3cG9ydC5nZXRMb2NhdGlvbkF0UG9pbnQoe2xuZ0xhdDogc3RhcnRQYW5MbmdMYXQsIHBvc30pO1xuICB9XG5cbiAgLy8gQ2FsY3VsYXRlcyBuZXcgem9vbVxuICBfY2FsY3VsYXRlTmV3Wm9vbSh7c2NhbGUsIHN0YXJ0Wm9vbX0pIHtcbiAgICBjb25zdCB7bWF4Wm9vbSwgbWluWm9vbX0gPSB0aGlzLl92aWV3cG9ydFByb3BzO1xuICAgIGxldCB6b29tID0gc3RhcnRab29tICsgTWF0aC5sb2cyKHNjYWxlKTtcbiAgICB6b29tID0gem9vbSA+IG1heFpvb20gPyBtYXhab29tIDogem9vbTtcbiAgICB6b29tID0gem9vbSA8IG1pblpvb20gPyBtaW5ab29tIDogem9vbTtcbiAgICByZXR1cm4gem9vbTtcbiAgfVxuXG4gIC8vIENhbGN1bGF0ZXMgYSBuZXcgcGl0Y2ggYW5kIGJlYXJpbmcgZnJvbSBhIHBvc2l0aW9uIChjb21pbmcgZnJvbSBhbiBldmVudClcbiAgX2NhbGN1bGF0ZU5ld1BpdGNoQW5kQmVhcmluZyh7ZGVsdGFTY2FsZVgsIGRlbHRhU2NhbGVZLCBzdGFydEJlYXJpbmcsIHN0YXJ0UGl0Y2h9KSB7XG4gICAgY29uc3Qge21pblBpdGNoLCBtYXhQaXRjaH0gPSB0aGlzLl92aWV3cG9ydFByb3BzO1xuXG4gICAgY29uc3QgYmVhcmluZyA9IHN0YXJ0QmVhcmluZyArIDE4MCAqIGRlbHRhU2NhbGVYO1xuICAgIGxldCBwaXRjaCA9IHN0YXJ0UGl0Y2g7XG4gICAgaWYgKGRlbHRhU2NhbGVZID4gMCkge1xuICAgICAgLy8gR3JhZHVhbGx5IGluY3JlYXNlIHBpdGNoXG4gICAgICBwaXRjaCA9IHN0YXJ0UGl0Y2ggKyBkZWx0YVNjYWxlWSAqIChtYXhQaXRjaCAtIHN0YXJ0UGl0Y2gpO1xuICAgIH0gZWxzZSBpZiAoZGVsdGFTY2FsZVkgPCAwKSB7XG4gICAgICAvLyBHcmFkdWFsbHkgZGVjcmVhc2UgcGl0Y2hcbiAgICAgIHBpdGNoID0gc3RhcnRQaXRjaCAtIGRlbHRhU2NhbGVZICogKG1pblBpdGNoIC0gc3RhcnRQaXRjaCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHBpdGNoLFxuICAgICAgYmVhcmluZ1xuICAgIH07XG4gIH1cbn1cbiJdfQ==