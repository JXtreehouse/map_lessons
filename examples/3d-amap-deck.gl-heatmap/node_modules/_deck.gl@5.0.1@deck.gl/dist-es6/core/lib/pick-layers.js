// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

import { drawPickingBuffer, getPixelRatio } from './draw-layers';
import log from '../utils/log';
import assert from 'assert';

var NO_PICKED_OBJECT = {
  pickedColor: null,
  pickedLayer: null,
  pickedObjectIndex: -1
};

/* eslint-disable max-depth, max-statements */
// Pick the closest object at the given (x,y) coordinate
export function pickObject(gl, _ref) {
  var layers = _ref.layers,
      viewports = _ref.viewports,
      x = _ref.x,
      y = _ref.y,
      radius = _ref.radius,
      layerFilter = _ref.layerFilter,
      mode = _ref.mode,
      onViewportActive = _ref.onViewportActive,
      pickingFBO = _ref.pickingFBO,
      lastPickedInfo = _ref.lastPickedInfo,
      useDevicePixels = _ref.useDevicePixels;

  // Convert from canvas top-left to WebGL bottom-left coordinates
  // And compensate for pixelRatio
  var pixelRatio = getPixelRatio({ useDevicePixels: useDevicePixels });
  var deviceX = Math.round(x * pixelRatio);
  var deviceY = Math.round(gl.canvas.height - y * pixelRatio);
  var deviceRadius = Math.round(radius * pixelRatio);

  var deviceRect = getPickingRect({
    deviceX: deviceX,
    deviceY: deviceY,
    deviceRadius: deviceRadius,
    deviceWidth: pickingFBO.width,
    deviceHeight: pickingFBO.height
  });

  var pickedColors = deviceRect && drawAndSamplePickingBuffer(gl, {
    layers: layers,
    viewports: viewports,
    onViewportActive: onViewportActive,
    useDevicePixels: useDevicePixels,
    pickingFBO: pickingFBO,
    deviceRect: deviceRect,
    layerFilter: layerFilter,
    redrawReason: mode
  });

  var pickInfo = pickedColors && getClosestFromPickingBuffer(gl, {
    pickedColors: pickedColors,
    layers: layers,
    deviceX: deviceX,
    deviceY: deviceY,
    deviceRadius: deviceRadius,
    deviceRect: deviceRect
  }) || NO_PICKED_OBJECT;

  return processPickInfo({
    pickInfo: pickInfo,
    lastPickedInfo: lastPickedInfo,
    mode: mode,
    layers: layers,
    viewports: viewports,
    x: x,
    y: y,
    deviceX: deviceX,
    deviceY: deviceY,
    pixelRatio: pixelRatio
  });
}

// Pick all objects within the given bounding box
export function pickVisibleObjects(gl, _ref2) {
  var layers = _ref2.layers,
      viewports = _ref2.viewports,
      x = _ref2.x,
      y = _ref2.y,
      width = _ref2.width,
      height = _ref2.height,
      mode = _ref2.mode,
      layerFilter = _ref2.layerFilter,
      onViewportActive = _ref2.onViewportActive,
      pickingFBO = _ref2.pickingFBO,
      useDevicePixels = _ref2.useDevicePixels;

  // Convert from canvas top-left to WebGL bottom-left coordinates
  // And compensate for pixelRatio
  var pixelRatio = getPixelRatio({ useDevicePixels: useDevicePixels });

  var deviceLeft = Math.round(x * pixelRatio);
  var deviceBottom = Math.round(gl.canvas.height - y * pixelRatio);
  var deviceRight = Math.round((x + width) * pixelRatio);
  var deviceTop = Math.round(gl.canvas.height - (y + height) * pixelRatio);

  var deviceRect = {
    x: deviceLeft,
    y: deviceTop,
    width: deviceRight - deviceLeft,
    height: deviceBottom - deviceTop
  };

  var pickedColors = drawAndSamplePickingBuffer(gl, {
    layers: layers,
    viewports: viewports,
    onViewportActive: onViewportActive,
    pickingFBO: pickingFBO,
    useDevicePixels: useDevicePixels,
    deviceRect: deviceRect,
    layerFilter: layerFilter,
    redrawReason: mode
  });

  var pickInfos = getUniquesFromPickingBuffer(gl, { pickedColors: pickedColors, layers: layers });

  // Only return unique infos, identified by info.object
  var uniqueInfos = new Map();

  pickInfos.forEach(function (pickInfo) {
    var viewport = getViewportFromCoordinates({ viewports: viewports }); // TODO - add coords
    var info = createInfo([pickInfo.x / pixelRatio, pickInfo.y / pixelRatio], viewport);
    info.devicePixel = [pickInfo.x, pickInfo.y];
    info.pixelRatio = pixelRatio;
    info.color = pickInfo.pickedColor;
    info.index = pickInfo.pickedObjectIndex;
    info.picked = true;

    info = getLayerPickingInfo({ layer: pickInfo.pickedLayer, info: info, mode: mode });
    if (!uniqueInfos.has(info.object)) {
      uniqueInfos.set(info.object, info);
    }
  });

  return Array.from(uniqueInfos.values());
}

// HELPER METHODS

// returns pickedColor or null if no pickable layers found.
function drawAndSamplePickingBuffer(gl, _ref3) {
  var layers = _ref3.layers,
      viewports = _ref3.viewports,
      onViewportActive = _ref3.onViewportActive,
      useDevicePixels = _ref3.useDevicePixels,
      pickingFBO = _ref3.pickingFBO,
      deviceRect = _ref3.deviceRect,
      layerFilter = _ref3.layerFilter,
      redrawReason = _ref3.redrawReason;

  assert(deviceRect);
  assert(Number.isFinite(deviceRect.width) && deviceRect.width > 0, '`width` must be > 0');
  assert(Number.isFinite(deviceRect.height) && deviceRect.height > 0, '`height` must be > 0');

  var pickableLayers = layers.filter(function (layer) {
    return layer.isPickable();
  });
  if (pickableLayers.length < 1) {
    return null;
  }

  drawPickingBuffer(gl, {
    layers: layers,
    viewports: viewports,
    onViewportActive: onViewportActive,
    useDevicePixels: useDevicePixels,
    pickingFBO: pickingFBO,
    deviceRect: deviceRect,
    layerFilter: layerFilter,
    redrawReason: redrawReason
  });

  // Read from an already rendered picking buffer
  // Returns an Uint8ClampedArray of picked pixels
  var x = deviceRect.x,
      y = deviceRect.y,
      width = deviceRect.width,
      height = deviceRect.height;

  var pickedColors = new Uint8Array(width * height * 4);
  pickingFBO.readPixels({ x: x, y: y, width: width, height: height, pixelArray: pickedColors });
  return pickedColors;
}

// Indentifies which viewport, if any corresponds to x and y
// Returns first viewport if no match
// TODO - need to determine which viewport we are in
// TODO - document concept of "primary viewport" that matches all coords?
// TODO - static method on Viewport class?
function getViewportFromCoordinates(_ref4) {
  var viewports = _ref4.viewports;

  var viewport = viewports[0];
  return viewport;
}

// Calculate a picking rect centered on deviceX and deviceY and clipped to device
// Returns null if pixel is outside of device
function getPickingRect(_ref5) {
  var deviceX = _ref5.deviceX,
      deviceY = _ref5.deviceY,
      deviceRadius = _ref5.deviceRadius,
      deviceWidth = _ref5.deviceWidth,
      deviceHeight = _ref5.deviceHeight;

  var valid = deviceX >= 0 && deviceY >= 0 && deviceX < deviceWidth && deviceY < deviceHeight;

  // x, y out of bounds.
  if (!valid) {
    return null;
  }

  // Create a box of size `radius * 2 + 1` centered at [deviceX, deviceY]
  var x = Math.max(0, deviceX - deviceRadius);
  var y = Math.max(0, deviceY - deviceRadius);
  var width = Math.min(deviceWidth, deviceX + deviceRadius) - x + 1;
  var height = Math.min(deviceHeight, deviceY + deviceRadius) - y + 1;

  return { x: x, y: y, width: width, height: height };
}

// TODO - break this monster function into 3+ parts
function processPickInfo(_ref6) {
  var pickInfo = _ref6.pickInfo,
      lastPickedInfo = _ref6.lastPickedInfo,
      mode = _ref6.mode,
      layers = _ref6.layers,
      viewports = _ref6.viewports,
      x = _ref6.x,
      y = _ref6.y,
      deviceX = _ref6.deviceX,
      deviceY = _ref6.deviceY,
      pixelRatio = _ref6.pixelRatio;
  var pickedColor = pickInfo.pickedColor,
      pickedLayer = pickInfo.pickedLayer,
      pickedObjectIndex = pickInfo.pickedObjectIndex;


  var affectedLayers = pickedLayer ? [pickedLayer] : [];

  if (mode === 'hover') {
    // only invoke onHover events if picked object has changed
    var lastPickedObjectIndex = lastPickedInfo.index;
    var lastPickedLayerId = lastPickedInfo.layerId;
    var pickedLayerId = pickedLayer && pickedLayer.props.id;

    // proceed only if picked object changed
    if (pickedLayerId !== lastPickedLayerId || pickedObjectIndex !== lastPickedObjectIndex) {
      if (pickedLayerId !== lastPickedLayerId) {
        // We cannot store a ref to lastPickedLayer in the context because
        // the state of an outdated layer is no longer valid
        // and the props may have changed
        var lastPickedLayer = layers.find(function (layer) {
          return layer.props.id === lastPickedLayerId;
        });
        if (lastPickedLayer) {
          // Let leave event fire before enter event
          affectedLayers.unshift(lastPickedLayer);
        }
      }

      // Update layer manager context
      lastPickedInfo.layerId = pickedLayerId;
      lastPickedInfo.index = pickedObjectIndex;
    }
  }

  var viewport = getViewportFromCoordinates({ viewports: viewports }); // TODO - add coords

  var baseInfo = createInfo([x, y], viewport);
  baseInfo.devicePixel = [deviceX, deviceY];
  baseInfo.pixelRatio = pixelRatio;

  // Use a Map to store all picking infos.
  // The following two forEach loops are the result of
  // https://github.com/uber/deck.gl/issues/443
  // Please be very careful when changing this pattern
  var infos = new Map();

  affectedLayers.forEach(function (layer) {
    var info = Object.assign({}, baseInfo);

    if (layer === pickedLayer) {
      info.color = pickedColor;
      info.index = pickedObjectIndex;
      info.picked = true;
    }

    info = getLayerPickingInfo({ layer: layer, info: info, mode: mode });

    // This guarantees that there will be only one copy of info for
    // one composite layer
    if (info) {
      infos.set(info.layer.id, info);
    }

    var pickingSelectedColor = layer.props.autoHighlight && pickedLayer === layer ? pickedColor : null;

    var pickingParameters = {
      pickingSelectedColor: pickingSelectedColor
    };

    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = layer.getModels()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var model = _step.value;

        model.updateModuleSettings(pickingParameters);
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
  });

  var unhandledPickInfos = callLayerPickingCallbacks(infos, mode);

  return unhandledPickInfos;
}

// Per-layer event handlers (e.g. onClick, onHover) are provided by the
// user and out of deck.gl's control. It's very much possible that
// the user calls React lifecycle methods in these function, such as
// ReactComponent.setState(). React lifecycle methods sometimes induce
// a re-render and re-generation of props of deck.gl and its layers,
// which invalidates all layers currently passed to this very function.

// Therefore, per-layer event handlers must be invoked at the end
// of the picking operation. NO operation that relies on the states of current
// layers should be called after this code.
function callLayerPickingCallbacks(infos, mode) {
  var unhandledPickInfos = [];

  infos.forEach(function (info) {
    var handled = false;
    switch (mode) {
      case 'click':
        handled = info.layer.props.onClick(info);
        break;
      case 'hover':
        handled = info.layer.props.onHover(info);
        break;
      case 'query':
        break;
      default:
        throw new Error('unknown pick type');
    }

    if (!handled) {
      unhandledPickInfos.push(info);
    }
  });

  return unhandledPickInfos;
}

/**
 * Pick at a specified pixel with a tolerance radius
 * Returns the closest object to the pixel in shape `{pickedColor, pickedLayer, pickedObjectIndex}`
 */
export function getClosestFromPickingBuffer(gl, _ref7) {
  var pickedColors = _ref7.pickedColors,
      layers = _ref7.layers,
      deviceX = _ref7.deviceX,
      deviceY = _ref7.deviceY,
      deviceRadius = _ref7.deviceRadius,
      deviceRect = _ref7.deviceRect;

  assert(pickedColors);

  // Traverse all pixels in picking results and find the one closest to the supplied
  // [deviceX, deviceY]
  var x = deviceRect.x,
      y = deviceRect.y,
      width = deviceRect.width,
      height = deviceRect.height;

  var minSquareDistanceToCenter = deviceRadius * deviceRadius;
  var closestPixelIndex = -1;
  var i = 0;

  for (var row = 0; row < height; row++) {
    var dy = row + y - deviceY;
    var dy2 = dy * dy;

    if (dy2 > minSquareDistanceToCenter) {
      // skip this row
      i += 4 * width;
    } else {
      for (var col = 0; col < width; col++) {
        // Decode picked layer from color
        var pickedLayerIndex = pickedColors[i + 3] - 1;

        if (pickedLayerIndex >= 0) {
          var dx = col + x - deviceX;
          var d2 = dx * dx + dy2;

          if (d2 <= minSquareDistanceToCenter) {
            minSquareDistanceToCenter = d2;
            closestPixelIndex = i;
          }
        }
        i += 4;
      }
    }
  }

  if (closestPixelIndex >= 0) {
    // Decode picked object index from color
    var _pickedLayerIndex = pickedColors[closestPixelIndex + 3] - 1;
    var pickedColor = pickedColors.slice(closestPixelIndex, closestPixelIndex + 4);
    var pickedLayer = layers[_pickedLayerIndex];
    if (pickedLayer) {
      var pickedObjectIndex = pickedLayer.decodePickingColor(pickedColor);
      return { pickedColor: pickedColor, pickedLayer: pickedLayer, pickedObjectIndex: pickedObjectIndex };
    }
    log.error('Picked non-existent layer. Is picking buffer corrupt?');
  }

  return NO_PICKED_OBJECT;
}
/* eslint-enable max-depth, max-statements */

/**
 * Examines a picking buffer for unique colors
 * Returns array of unique objects in shape `{x, y, pickedColor, pickedLayer, pickedObjectIndex}`
 */
function getUniquesFromPickingBuffer(gl, _ref8) {
  var pickedColors = _ref8.pickedColors,
      layers = _ref8.layers;

  var uniqueColors = new Map();

  // Traverse all pixels in picking results and get unique colors
  if (pickedColors) {
    for (var i = 0; i < pickedColors.length; i += 4) {
      // Decode picked layer from color
      var pickedLayerIndex = pickedColors[i + 3] - 1;

      if (pickedLayerIndex >= 0) {
        var pickedColor = pickedColors.slice(i, i + 4);
        var colorKey = pickedColor.join(',');
        // eslint-disable-next-line
        if (!uniqueColors.has(colorKey)) {
          var pickedLayer = layers[pickedLayerIndex];
          // eslint-disable-next-line
          if (pickedLayer) {
            uniqueColors.set(colorKey, {
              pickedColor: pickedColor,
              pickedLayer: pickedLayer,
              pickedObjectIndex: pickedLayer.decodePickingColor(pickedColor)
            });
          } else {
            log.error('Picked non-existent layer. Is picking buffer corrupt?');
          }
        }
      }
    }
  }

  return Array.from(uniqueColors.values());
}

function createInfo(pixel, viewport) {
  // Assign a number of potentially useful props to the "info" object
  return {
    color: null,
    layer: null,
    index: -1,
    picked: false,
    x: pixel[0],
    y: pixel[1],
    pixel: pixel,
    lngLat: viewport.unproject(pixel)
  };
}

// Walk up the layer composite chain to populate the info object
function getLayerPickingInfo(_ref9) {
  var layer = _ref9.layer,
      info = _ref9.info,
      mode = _ref9.mode;

  while (layer && info) {
    // For a composite layer, sourceLayer will point to the sublayer
    // where the event originates from.
    // It provides additional context for the composite layer's
    // getPickingInfo() method to populate the info object
    var sourceLayer = info.layer || layer;
    info.layer = layer;
    // layer.pickLayer() function requires a non-null ```layer.state```
    // object to funtion properly. So the layer refereced here
    // must be the "current" layer, not an "out-dated" / "invalidated" layer
    info = layer.pickLayer({ info: info, mode: mode, sourceLayer: sourceLayer });
    layer = layer.parentLayer;
  }
  return info;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9jb3JlL2xpYi9waWNrLWxheWVycy5qcyJdLCJuYW1lcyI6WyJkcmF3UGlja2luZ0J1ZmZlciIsImdldFBpeGVsUmF0aW8iLCJsb2ciLCJhc3NlcnQiLCJOT19QSUNLRURfT0JKRUNUIiwicGlja2VkQ29sb3IiLCJwaWNrZWRMYXllciIsInBpY2tlZE9iamVjdEluZGV4IiwicGlja09iamVjdCIsImdsIiwibGF5ZXJzIiwidmlld3BvcnRzIiwieCIsInkiLCJyYWRpdXMiLCJsYXllckZpbHRlciIsIm1vZGUiLCJvblZpZXdwb3J0QWN0aXZlIiwicGlja2luZ0ZCTyIsImxhc3RQaWNrZWRJbmZvIiwidXNlRGV2aWNlUGl4ZWxzIiwicGl4ZWxSYXRpbyIsImRldmljZVgiLCJNYXRoIiwicm91bmQiLCJkZXZpY2VZIiwiY2FudmFzIiwiaGVpZ2h0IiwiZGV2aWNlUmFkaXVzIiwiZGV2aWNlUmVjdCIsImdldFBpY2tpbmdSZWN0IiwiZGV2aWNlV2lkdGgiLCJ3aWR0aCIsImRldmljZUhlaWdodCIsInBpY2tlZENvbG9ycyIsImRyYXdBbmRTYW1wbGVQaWNraW5nQnVmZmVyIiwicmVkcmF3UmVhc29uIiwicGlja0luZm8iLCJnZXRDbG9zZXN0RnJvbVBpY2tpbmdCdWZmZXIiLCJwcm9jZXNzUGlja0luZm8iLCJwaWNrVmlzaWJsZU9iamVjdHMiLCJkZXZpY2VMZWZ0IiwiZGV2aWNlQm90dG9tIiwiZGV2aWNlUmlnaHQiLCJkZXZpY2VUb3AiLCJwaWNrSW5mb3MiLCJnZXRVbmlxdWVzRnJvbVBpY2tpbmdCdWZmZXIiLCJ1bmlxdWVJbmZvcyIsIk1hcCIsImZvckVhY2giLCJ2aWV3cG9ydCIsImdldFZpZXdwb3J0RnJvbUNvb3JkaW5hdGVzIiwiaW5mbyIsImNyZWF0ZUluZm8iLCJkZXZpY2VQaXhlbCIsImNvbG9yIiwiaW5kZXgiLCJwaWNrZWQiLCJnZXRMYXllclBpY2tpbmdJbmZvIiwibGF5ZXIiLCJoYXMiLCJvYmplY3QiLCJzZXQiLCJBcnJheSIsImZyb20iLCJ2YWx1ZXMiLCJOdW1iZXIiLCJpc0Zpbml0ZSIsInBpY2thYmxlTGF5ZXJzIiwiZmlsdGVyIiwiaXNQaWNrYWJsZSIsImxlbmd0aCIsIlVpbnQ4QXJyYXkiLCJyZWFkUGl4ZWxzIiwicGl4ZWxBcnJheSIsInZhbGlkIiwibWF4IiwibWluIiwiYWZmZWN0ZWRMYXllcnMiLCJsYXN0UGlja2VkT2JqZWN0SW5kZXgiLCJsYXN0UGlja2VkTGF5ZXJJZCIsImxheWVySWQiLCJwaWNrZWRMYXllcklkIiwicHJvcHMiLCJpZCIsImxhc3RQaWNrZWRMYXllciIsImZpbmQiLCJ1bnNoaWZ0IiwiYmFzZUluZm8iLCJpbmZvcyIsIk9iamVjdCIsImFzc2lnbiIsInBpY2tpbmdTZWxlY3RlZENvbG9yIiwiYXV0b0hpZ2hsaWdodCIsInBpY2tpbmdQYXJhbWV0ZXJzIiwiZ2V0TW9kZWxzIiwibW9kZWwiLCJ1cGRhdGVNb2R1bGVTZXR0aW5ncyIsInVuaGFuZGxlZFBpY2tJbmZvcyIsImNhbGxMYXllclBpY2tpbmdDYWxsYmFja3MiLCJoYW5kbGVkIiwib25DbGljayIsIm9uSG92ZXIiLCJFcnJvciIsInB1c2giLCJtaW5TcXVhcmVEaXN0YW5jZVRvQ2VudGVyIiwiY2xvc2VzdFBpeGVsSW5kZXgiLCJpIiwicm93IiwiZHkiLCJkeTIiLCJjb2wiLCJwaWNrZWRMYXllckluZGV4IiwiZHgiLCJkMiIsInNsaWNlIiwiZGVjb2RlUGlja2luZ0NvbG9yIiwiZXJyb3IiLCJ1bmlxdWVDb2xvcnMiLCJjb2xvcktleSIsImpvaW4iLCJwaXhlbCIsImxuZ0xhdCIsInVucHJvamVjdCIsInNvdXJjZUxheWVyIiwicGlja0xheWVyIiwicGFyZW50TGF5ZXIiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVFBLGlCQUFSLEVBQTJCQyxhQUEzQixR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QVk4RyxrQkFBWixDQUErQi9HLFdBQS9CO0FBSE0sYUFBM0I7QUFLRCxXQU5ELE1BTU87QUFDTEgsZ0JBQUltSCxLQUFKLENBQVUsdURBQVY7QUFDRDtBQUNGO0FBQ0Y7QUFDRjtBQUNGOztBQUVELFNBQU90RCxNQUFNQyxJQUFOLENBQVdzRCxhQUFhckQsTUFBYixFQUFYLENBQVA7QUFDRDs7QUFFRCxTQUFTWixVQUFULENBQW9Cb0UsS0FBcEIsRUFBMkJ2RSxRQUEzQixFQUFxQztBQUNuQztBQUNBLFNBQU87QUFDTEssV0FBTyxJQURGO0FBRUxJLFdBQU8sSUFGRjtBQUdMSCxXQUFPLENBQUMsQ0FISDtBQUlMQyxZQUFRLEtBSkg7QUFLTDdDLE9BQUc2RyxNQUFNLENBQU4sQ0FMRTtBQU1MNUcsT0FBRzRHLE1BQU0sQ0FBTixDQU5FO0FBT0xBLGdCQVBLO0FBUUxDLFlBQVF4RSxTQUFTeUUsU0FBVCxDQUFtQkYsS0FBbkI7QUFSSCxHQUFQO0FBVUQ7O0FBRUQ7QUFDQSxTQUFTL0QsbUJBQVQsUUFBa0Q7QUFBQSxNQUFwQkMsS0FBb0IsU0FBcEJBLEtBQW9CO0FBQUEsTUFBYlAsSUFBYSxTQUFiQSxJQUFhO0FBQUEsTUFBUHBDLElBQU8sU0FBUEEsSUFBTzs7QUFDaEQsU0FBTzJDLFNBQVNQLElBQWhCLEVBQXNCO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTXdFLGNBQWN4RSxLQUFLTyxLQUFMLElBQWNBLEtBQWxDO0FBQ0FQLFNBQUtPLEtBQUwsR0FBYUEsS0FBYjtBQUNBO0FBQ0E7QUFDQTtBQUNBUCxXQUFPTyxNQUFNa0UsU0FBTixDQUFnQixFQUFDekUsVUFBRCxFQUFPcEMsVUFBUCxFQUFhNEcsd0JBQWIsRUFBaEIsQ0FBUDtBQUNBakUsWUFBUUEsTUFBTW1FLFdBQWQ7QUFDRDtBQUNELFNBQU8xRSxJQUFQO0FBQ0QiLCJmaWxlIjoicGljay1sYXllcnMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIDIwMTUgLSAyMDE3IFViZXIgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbi8vIFRIRSBTT0ZUV0FSRS5cblxuaW1wb3J0IHtkcmF3UGlja2luZ0J1ZmZlciwgZ2V0UGl4ZWxSYXRpb30gZnJvbSAnLi9kcmF3LWxheWVycyc7XG5pbXBvcnQgbG9nIGZyb20gJy4uL3V0aWxzL2xvZyc7XG5pbXBvcnQgYXNzZXJ0IGZyb20gJ2Fzc2VydCc7XG5cbmNvbnN0IE5PX1BJQ0tFRF9PQkpFQ1QgPSB7XG4gIHBpY2tlZENvbG9yOiBudWxsLFxuICBwaWNrZWRMYXllcjogbnVsbCxcbiAgcGlja2VkT2JqZWN0SW5kZXg6IC0xXG59O1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtZGVwdGgsIG1heC1zdGF0ZW1lbnRzICovXG4vLyBQaWNrIHRoZSBjbG9zZXN0IG9iamVjdCBhdCB0aGUgZ2l2ZW4gKHgseSkgY29vcmRpbmF0ZVxuZXhwb3J0IGZ1bmN0aW9uIHBpY2tPYmplY3QoXG4gIGdsLFxuICB7XG4gICAgbGF5ZXJzLFxuICAgIHZpZXdwb3J0cyxcbiAgICB4LFxuICAgIHksXG4gICAgcmFkaXVzLFxuICAgIGxheWVyRmlsdGVyLFxuICAgIG1vZGUsXG4gICAgb25WaWV3cG9ydEFjdGl2ZSxcbiAgICBwaWNraW5nRkJPLFxuICAgIGxhc3RQaWNrZWRJbmZvLFxuICAgIHVzZURldmljZVBpeGVsc1xuICB9XG4pIHtcbiAgLy8gQ29udmVydCBmcm9tIGNhbnZhcyB0b3AtbGVmdCB0byBXZWJHTCBib3R0b20tbGVmdCBjb29yZGluYXRlc1xuICAvLyBBbmQgY29tcGVuc2F0ZSBmb3IgcGl4ZWxSYXRpb1xuICBjb25zdCBwaXhlbFJhdGlvID0gZ2V0UGl4ZWxSYXRpbyh7dXNlRGV2aWNlUGl4ZWxzfSk7XG4gIGNvbnN0IGRldmljZVggPSBNYXRoLnJvdW5kKHggKiBwaXhlbFJhdGlvKTtcbiAgY29uc3QgZGV2aWNlWSA9IE1hdGgucm91bmQoZ2wuY2FudmFzLmhlaWdodCAtIHkgKiBwaXhlbFJhdGlvKTtcbiAgY29uc3QgZGV2aWNlUmFkaXVzID0gTWF0aC5yb3VuZChyYWRpdXMgKiBwaXhlbFJhdGlvKTtcblxuICBjb25zdCBkZXZpY2VSZWN0ID0gZ2V0UGlja2luZ1JlY3Qoe1xuICAgIGRldmljZVgsXG4gICAgZGV2aWNlWSxcbiAgICBkZXZpY2VSYWRpdXMsXG4gICAgZGV2aWNlV2lkdGg6IHBpY2tpbmdGQk8ud2lkdGgsXG4gICAgZGV2aWNlSGVpZ2h0OiBwaWNraW5nRkJPLmhlaWdodFxuICB9KTtcblxuICBjb25zdCBwaWNrZWRDb2xvcnMgPVxuICAgIGRldmljZVJlY3QgJiZcbiAgICBkcmF3QW5kU2FtcGxlUGlja2luZ0J1ZmZlcihnbCwge1xuICAgICAgbGF5ZXJzLFxuICAgICAgdmlld3BvcnRzLFxuICAgICAgb25WaWV3cG9ydEFjdGl2ZSxcbiAgICAgIHVzZURldmljZVBpeGVscyxcbiAgICAgIHBpY2tpbmdGQk8sXG4gICAgICBkZXZpY2VSZWN0LFxuICAgICAgbGF5ZXJGaWx0ZXIsXG4gICAgICByZWRyYXdSZWFzb246IG1vZGVcbiAgICB9KTtcblxuICBjb25zdCBwaWNrSW5mbyA9XG4gICAgKHBpY2tlZENvbG9ycyAmJlxuICAgICAgZ2V0Q2xvc2VzdEZyb21QaWNraW5nQnVmZmVyKGdsLCB7XG4gICAgICAgIHBpY2tlZENvbG9ycyxcbiAgICAgICAgbGF5ZXJzLFxuICAgICAgICBkZXZpY2VYLFxuICAgICAgICBkZXZpY2VZLFxuICAgICAgICBkZXZpY2VSYWRpdXMsXG4gICAgICAgIGRldmljZVJlY3RcbiAgICAgIH0pKSB8fFxuICAgIE5PX1BJQ0tFRF9PQkpFQ1Q7XG5cbiAgcmV0dXJuIHByb2Nlc3NQaWNrSW5mbyh7XG4gICAgcGlja0luZm8sXG4gICAgbGFzdFBpY2tlZEluZm8sXG4gICAgbW9kZSxcbiAgICBsYXllcnMsXG4gICAgdmlld3BvcnRzLFxuICAgIHgsXG4gICAgeSxcbiAgICBkZXZpY2VYLFxuICAgIGRldmljZVksXG4gICAgcGl4ZWxSYXRpb1xuICB9KTtcbn1cblxuLy8gUGljayBhbGwgb2JqZWN0cyB3aXRoaW4gdGhlIGdpdmVuIGJvdW5kaW5nIGJveFxuZXhwb3J0IGZ1bmN0aW9uIHBpY2tWaXNpYmxlT2JqZWN0cyhcbiAgZ2wsXG4gIHtcbiAgICBsYXllcnMsXG4gICAgdmlld3BvcnRzLFxuICAgIHgsXG4gICAgeSxcbiAgICB3aWR0aCxcbiAgICBoZWlnaHQsXG4gICAgbW9kZSxcbiAgICBsYXllckZpbHRlcixcbiAgICBvblZpZXdwb3J0QWN0aXZlLFxuICAgIHBpY2tpbmdGQk8sXG4gICAgdXNlRGV2aWNlUGl4ZWxzXG4gIH1cbikge1xuICAvLyBDb252ZXJ0IGZyb20gY2FudmFzIHRvcC1sZWZ0IHRvIFdlYkdMIGJvdHRvbS1sZWZ0IGNvb3JkaW5hdGVzXG4gIC8vIEFuZCBjb21wZW5zYXRlIGZvciBwaXhlbFJhdGlvXG4gIGNvbnN0IHBpeGVsUmF0aW8gPSBnZXRQaXhlbFJhdGlvKHt1c2VEZXZpY2VQaXhlbHN9KTtcblxuICBjb25zdCBkZXZpY2VMZWZ0ID0gTWF0aC5yb3VuZCh4ICogcGl4ZWxSYXRpbyk7XG4gIGNvbnN0IGRldmljZUJvdHRvbSA9IE1hdGgucm91bmQoZ2wuY2FudmFzLmhlaWdodCAtIHkgKiBwaXhlbFJhdGlvKTtcbiAgY29uc3QgZGV2aWNlUmlnaHQgPSBNYXRoLnJvdW5kKCh4ICsgd2lkdGgpICogcGl4ZWxSYXRpbyk7XG4gIGNvbnN0IGRldmljZVRvcCA9IE1hdGgucm91bmQoZ2wuY2FudmFzLmhlaWdodCAtICh5ICsgaGVpZ2h0KSAqIHBpeGVsUmF0aW8pO1xuXG4gIGNvbnN0IGRldmljZVJlY3QgPSB7XG4gICAgeDogZGV2aWNlTGVmdCxcbiAgICB5OiBkZXZpY2VUb3AsXG4gICAgd2lkdGg6IGRldmljZVJpZ2h0IC0gZGV2aWNlTGVmdCxcbiAgICBoZWlnaHQ6IGRldmljZUJvdHRvbSAtIGRldmljZVRvcFxuICB9O1xuXG4gIGNvbnN0IHBpY2tlZENvbG9ycyA9IGRyYXdBbmRTYW1wbGVQaWNraW5nQnVmZmVyKGdsLCB7XG4gICAgbGF5ZXJzLFxuICAgIHZpZXdwb3J0cyxcbiAgICBvblZpZXdwb3J0QWN0aXZlLFxuICAgIHBpY2tpbmdGQk8sXG4gICAgdXNlRGV2aWNlUGl4ZWxzLFxuICAgIGRldmljZVJlY3QsXG4gICAgbGF5ZXJGaWx0ZXIsXG4gICAgcmVkcmF3UmVhc29uOiBtb2RlXG4gIH0pO1xuXG4gIGNvbnN0IHBpY2tJbmZvcyA9IGdldFVuaXF1ZXNGcm9tUGlja2luZ0J1ZmZlcihnbCwge3BpY2tlZENvbG9ycywgbGF5ZXJzfSk7XG5cbiAgLy8gT25seSByZXR1cm4gdW5pcXVlIGluZm9zLCBpZGVudGlmaWVkIGJ5IGluZm8ub2JqZWN0XG4gIGNvbnN0IHVuaXF1ZUluZm9zID0gbmV3IE1hcCgpO1xuXG4gIHBpY2tJbmZvcy5mb3JFYWNoKHBpY2tJbmZvID0+IHtcbiAgICBjb25zdCB2aWV3cG9ydCA9IGdldFZpZXdwb3J0RnJvbUNvb3JkaW5hdGVzKHt2aWV3cG9ydHN9KTsgLy8gVE9ETyAtIGFkZCBjb29yZHNcbiAgICBsZXQgaW5mbyA9IGNyZWF0ZUluZm8oW3BpY2tJbmZvLnggLyBwaXhlbFJhdGlvLCBwaWNrSW5mby55IC8gcGl4ZWxSYXRpb10sIHZpZXdwb3J0KTtcbiAgICBpbmZvLmRldmljZVBpeGVsID0gW3BpY2tJbmZvLngsIHBpY2tJbmZvLnldO1xuICAgIGluZm8ucGl4ZWxSYXRpbyA9IHBpeGVsUmF0aW87XG4gICAgaW5mby5jb2xvciA9IHBpY2tJbmZvLnBpY2tlZENvbG9yO1xuICAgIGluZm8uaW5kZXggPSBwaWNrSW5mby5waWNrZWRPYmplY3RJbmRleDtcbiAgICBpbmZvLnBpY2tlZCA9IHRydWU7XG5cbiAgICBpbmZvID0gZ2V0TGF5ZXJQaWNraW5nSW5mbyh7bGF5ZXI6IHBpY2tJbmZvLnBpY2tlZExheWVyLCBpbmZvLCBtb2RlfSk7XG4gICAgaWYgKCF1bmlxdWVJbmZvcy5oYXMoaW5mby5vYmplY3QpKSB7XG4gICAgICB1bmlxdWVJbmZvcy5zZXQoaW5mby5vYmplY3QsIGluZm8pO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIEFycmF5LmZyb20odW5pcXVlSW5mb3MudmFsdWVzKCkpO1xufVxuXG4vLyBIRUxQRVIgTUVUSE9EU1xuXG4vLyByZXR1cm5zIHBpY2tlZENvbG9yIG9yIG51bGwgaWYgbm8gcGlja2FibGUgbGF5ZXJzIGZvdW5kLlxuZnVuY3Rpb24gZHJhd0FuZFNhbXBsZVBpY2tpbmdCdWZmZXIoXG4gIGdsLFxuICB7XG4gICAgbGF5ZXJzLFxuICAgIHZpZXdwb3J0cyxcbiAgICBvblZpZXdwb3J0QWN0aXZlLFxuICAgIHVzZURldmljZVBpeGVscyxcbiAgICBwaWNraW5nRkJPLFxuICAgIGRldmljZVJlY3QsXG4gICAgbGF5ZXJGaWx0ZXIsXG4gICAgcmVkcmF3UmVhc29uXG4gIH1cbikge1xuICBhc3NlcnQoZGV2aWNlUmVjdCk7XG4gIGFzc2VydChOdW1iZXIuaXNGaW5pdGUoZGV2aWNlUmVjdC53aWR0aCkgJiYgZGV2aWNlUmVjdC53aWR0aCA+IDAsICdgd2lkdGhgIG11c3QgYmUgPiAwJyk7XG4gIGFzc2VydChOdW1iZXIuaXNGaW5pdGUoZGV2aWNlUmVjdC5oZWlnaHQpICYmIGRldmljZVJlY3QuaGVpZ2h0ID4gMCwgJ2BoZWlnaHRgIG11c3QgYmUgPiAwJyk7XG5cbiAgY29uc3QgcGlja2FibGVMYXllcnMgPSBsYXllcnMuZmlsdGVyKGxheWVyID0+IGxheWVyLmlzUGlja2FibGUoKSk7XG4gIGlmIChwaWNrYWJsZUxheWVycy5sZW5ndGggPCAxKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBkcmF3UGlja2luZ0J1ZmZlcihnbCwge1xuICAgIGxheWVycyxcbiAgICB2aWV3cG9ydHMsXG4gICAgb25WaWV3cG9ydEFjdGl2ZSxcbiAgICB1c2VEZXZpY2VQaXhlbHMsXG4gICAgcGlja2luZ0ZCTyxcbiAgICBkZXZpY2VSZWN0LFxuICAgIGxheWVyRmlsdGVyLFxuICAgIHJlZHJhd1JlYXNvblxuICB9KTtcblxuICAvLyBSZWFkIGZyb20gYW4gYWxyZWFkeSByZW5kZXJlZCBwaWNraW5nIGJ1ZmZlclxuICAvLyBSZXR1cm5zIGFuIFVpbnQ4Q2xhbXBlZEFycmF5IG9mIHBpY2tlZCBwaXhlbHNcbiAgY29uc3Qge3gsIHksIHdpZHRoLCBoZWlnaHR9ID0gZGV2aWNlUmVjdDtcbiAgY29uc3QgcGlja2VkQ29sb3JzID0gbmV3IFVpbnQ4QXJyYXkod2lkdGggKiBoZWlnaHQgKiA0KTtcbiAgcGlja2luZ0ZCTy5yZWFkUGl4ZWxzKHt4LCB5LCB3aWR0aCwgaGVpZ2h0LCBwaXhlbEFycmF5OiBwaWNrZWRDb2xvcnN9KTtcbiAgcmV0dXJuIHBpY2tlZENvbG9ycztcbn1cblxuLy8gSW5kZW50aWZpZXMgd2hpY2ggdmlld3BvcnQsIGlmIGFueSBjb3JyZXNwb25kcyB0byB4IGFuZCB5XG4vLyBSZXR1cm5zIGZpcnN0IHZpZXdwb3J0IGlmIG5vIG1hdGNoXG4vLyBUT0RPIC0gbmVlZCB0byBkZXRlcm1pbmUgd2hpY2ggdmlld3BvcnQgd2UgYXJlIGluXG4vLyBUT0RPIC0gZG9jdW1lbnQgY29uY2VwdCBvZiBcInByaW1hcnkgdmlld3BvcnRcIiB0aGF0IG1hdGNoZXMgYWxsIGNvb3Jkcz9cbi8vIFRPRE8gLSBzdGF0aWMgbWV0aG9kIG9uIFZpZXdwb3J0IGNsYXNzP1xuZnVuY3Rpb24gZ2V0Vmlld3BvcnRGcm9tQ29vcmRpbmF0ZXMoe3ZpZXdwb3J0c30pIHtcbiAgY29uc3Qgdmlld3BvcnQgPSB2aWV3cG9ydHNbMF07XG4gIHJldHVybiB2aWV3cG9ydDtcbn1cblxuLy8gQ2FsY3VsYXRlIGEgcGlja2luZyByZWN0IGNlbnRlcmVkIG9uIGRldmljZVggYW5kIGRldmljZVkgYW5kIGNsaXBwZWQgdG8gZGV2aWNlXG4vLyBSZXR1cm5zIG51bGwgaWYgcGl4ZWwgaXMgb3V0c2lkZSBvZiBkZXZpY2VcbmZ1bmN0aW9uIGdldFBpY2tpbmdSZWN0KHtkZXZpY2VYLCBkZXZpY2VZLCBkZXZpY2VSYWRpdXMsIGRldmljZVdpZHRoLCBkZXZpY2VIZWlnaHR9KSB7XG4gIGNvbnN0IHZhbGlkID0gZGV2aWNlWCA+PSAwICYmIGRldmljZVkgPj0gMCAmJiBkZXZpY2VYIDwgZGV2aWNlV2lkdGggJiYgZGV2aWNlWSA8IGRldmljZUhlaWdodDtcblxuICAvLyB4LCB5IG91dCBvZiBib3VuZHMuXG4gIGlmICghdmFsaWQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8vIENyZWF0ZSBhIGJveCBvZiBzaXplIGByYWRpdXMgKiAyICsgMWAgY2VudGVyZWQgYXQgW2RldmljZVgsIGRldmljZVldXG4gIGNvbnN0IHggPSBNYXRoLm1heCgwLCBkZXZpY2VYIC0gZGV2aWNlUmFkaXVzKTtcbiAgY29uc3QgeSA9IE1hdGgubWF4KDAsIGRldmljZVkgLSBkZXZpY2VSYWRpdXMpO1xuICBjb25zdCB3aWR0aCA9IE1hdGgubWluKGRldmljZVdpZHRoLCBkZXZpY2VYICsgZGV2aWNlUmFkaXVzKSAtIHggKyAxO1xuICBjb25zdCBoZWlnaHQgPSBNYXRoLm1pbihkZXZpY2VIZWlnaHQsIGRldmljZVkgKyBkZXZpY2VSYWRpdXMpIC0geSArIDE7XG5cbiAgcmV0dXJuIHt4LCB5LCB3aWR0aCwgaGVpZ2h0fTtcbn1cblxuLy8gVE9ETyAtIGJyZWFrIHRoaXMgbW9uc3RlciBmdW5jdGlvbiBpbnRvIDMrIHBhcnRzXG5mdW5jdGlvbiBwcm9jZXNzUGlja0luZm8oe1xuICBwaWNrSW5mbyxcbiAgbGFzdFBpY2tlZEluZm8sXG4gIG1vZGUsXG4gIGxheWVycyxcbiAgdmlld3BvcnRzLFxuICB4LFxuICB5LFxuICBkZXZpY2VYLFxuICBkZXZpY2VZLFxuICBwaXhlbFJhdGlvXG59KSB7XG4gIGNvbnN0IHtwaWNrZWRDb2xvciwgcGlja2VkTGF5ZXIsIHBpY2tlZE9iamVjdEluZGV4fSA9IHBpY2tJbmZvO1xuXG4gIGNvbnN0IGFmZmVjdGVkTGF5ZXJzID0gcGlja2VkTGF5ZXIgPyBbcGlja2VkTGF5ZXJdIDogW107XG5cbiAgaWYgKG1vZGUgPT09ICdob3ZlcicpIHtcbiAgICAvLyBvbmx5IGludm9rZSBvbkhvdmVyIGV2ZW50cyBpZiBwaWNrZWQgb2JqZWN0IGhhcyBjaGFuZ2VkXG4gICAgY29uc3QgbGFzdFBpY2tlZE9iamVjdEluZGV4ID0gbGFzdFBpY2tlZEluZm8uaW5kZXg7XG4gICAgY29uc3QgbGFzdFBpY2tlZExheWVySWQgPSBsYXN0UGlja2VkSW5mby5sYXllcklkO1xuICAgIGNvbnN0IHBpY2tlZExheWVySWQgPSBwaWNrZWRMYXllciAmJiBwaWNrZWRMYXllci5wcm9wcy5pZDtcblxuICAgIC8vIHByb2NlZWQgb25seSBpZiBwaWNrZWQgb2JqZWN0IGNoYW5nZWRcbiAgICBpZiAocGlja2VkTGF5ZXJJZCAhPT0gbGFzdFBpY2tlZExheWVySWQgfHwgcGlja2VkT2JqZWN0SW5kZXggIT09IGxhc3RQaWNrZWRPYmplY3RJbmRleCkge1xuICAgICAgaWYgKHBpY2tlZExheWVySWQgIT09IGxhc3RQaWNrZWRMYXllcklkKSB7XG4gICAgICAgIC8vIFdlIGNhbm5vdCBzdG9yZSBhIHJlZiB0byBsYXN0UGlja2VkTGF5ZXIgaW4gdGhlIGNvbnRleHQgYmVjYXVzZVxuICAgICAgICAvLyB0aGUgc3RhdGUgb2YgYW4gb3V0ZGF0ZWQgbGF5ZXIgaXMgbm8gbG9uZ2VyIHZhbGlkXG4gICAgICAgIC8vIGFuZCB0aGUgcHJvcHMgbWF5IGhhdmUgY2hhbmdlZFxuICAgICAgICBjb25zdCBsYXN0UGlja2VkTGF5ZXIgPSBsYXllcnMuZmluZChsYXllciA9PiBsYXllci5wcm9wcy5pZCA9PT0gbGFzdFBpY2tlZExheWVySWQpO1xuICAgICAgICBpZiAobGFzdFBpY2tlZExheWVyKSB7XG4gICAgICAgICAgLy8gTGV0IGxlYXZlIGV2ZW50IGZpcmUgYmVmb3JlIGVudGVyIGV2ZW50XG4gICAgICAgICAgYWZmZWN0ZWRMYXllcnMudW5zaGlmdChsYXN0UGlja2VkTGF5ZXIpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFVwZGF0ZSBsYXllciBtYW5hZ2VyIGNvbnRleHRcbiAgICAgIGxhc3RQaWNrZWRJbmZvLmxheWVySWQgPSBwaWNrZWRMYXllcklkO1xuICAgICAgbGFzdFBpY2tlZEluZm8uaW5kZXggPSBwaWNrZWRPYmplY3RJbmRleDtcbiAgICB9XG4gIH1cblxuICBjb25zdCB2aWV3cG9ydCA9IGdldFZpZXdwb3J0RnJvbUNvb3JkaW5hdGVzKHt2aWV3cG9ydHN9KTsgLy8gVE9ETyAtIGFkZCBjb29yZHNcblxuICBjb25zdCBiYXNlSW5mbyA9IGNyZWF0ZUluZm8oW3gsIHldLCB2aWV3cG9ydCk7XG4gIGJhc2VJbmZvLmRldmljZVBpeGVsID0gW2RldmljZVgsIGRldmljZVldO1xuICBiYXNlSW5mby5waXhlbFJhdGlvID0gcGl4ZWxSYXRpbztcblxuICAvLyBVc2UgYSBNYXAgdG8gc3RvcmUgYWxsIHBpY2tpbmcgaW5mb3MuXG4gIC8vIFRoZSBmb2xsb3dpbmcgdHdvIGZvckVhY2ggbG9vcHMgYXJlIHRoZSByZXN1bHQgb2ZcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3ViZXIvZGVjay5nbC9pc3N1ZXMvNDQzXG4gIC8vIFBsZWFzZSBiZSB2ZXJ5IGNhcmVmdWwgd2hlbiBjaGFuZ2luZyB0aGlzIHBhdHRlcm5cbiAgY29uc3QgaW5mb3MgPSBuZXcgTWFwKCk7XG5cbiAgYWZmZWN0ZWRMYXllcnMuZm9yRWFjaChsYXllciA9PiB7XG4gICAgbGV0IGluZm8gPSBPYmplY3QuYXNzaWduKHt9LCBiYXNlSW5mbyk7XG5cbiAgICBpZiAobGF5ZXIgPT09IHBpY2tlZExheWVyKSB7XG4gICAgICBpbmZvLmNvbG9yID0gcGlja2VkQ29sb3I7XG4gICAgICBpbmZvLmluZGV4ID0gcGlja2VkT2JqZWN0SW5kZXg7XG4gICAgICBpbmZvLnBpY2tlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgaW5mbyA9IGdldExheWVyUGlja2luZ0luZm8oe2xheWVyLCBpbmZvLCBtb2RlfSk7XG5cbiAgICAvLyBUaGlzIGd1YXJhbnRlZXMgdGhhdCB0aGVyZSB3aWxsIGJlIG9ubHkgb25lIGNvcHkgb2YgaW5mbyBmb3JcbiAgICAvLyBvbmUgY29tcG9zaXRlIGxheWVyXG4gICAgaWYgKGluZm8pIHtcbiAgICAgIGluZm9zLnNldChpbmZvLmxheWVyLmlkLCBpbmZvKTtcbiAgICB9XG5cbiAgICBjb25zdCBwaWNraW5nU2VsZWN0ZWRDb2xvciA9XG4gICAgICBsYXllci5wcm9wcy5hdXRvSGlnaGxpZ2h0ICYmIHBpY2tlZExheWVyID09PSBsYXllciA/IHBpY2tlZENvbG9yIDogbnVsbDtcblxuICAgIGNvbnN0IHBpY2tpbmdQYXJhbWV0ZXJzID0ge1xuICAgICAgcGlja2luZ1NlbGVjdGVkQ29sb3JcbiAgICB9O1xuXG4gICAgZm9yIChjb25zdCBtb2RlbCBvZiBsYXllci5nZXRNb2RlbHMoKSkge1xuICAgICAgbW9kZWwudXBkYXRlTW9kdWxlU2V0dGluZ3MocGlja2luZ1BhcmFtZXRlcnMpO1xuICAgIH1cbiAgfSk7XG5cbiAgY29uc3QgdW5oYW5kbGVkUGlja0luZm9zID0gY2FsbExheWVyUGlja2luZ0NhbGxiYWNrcyhpbmZvcywgbW9kZSk7XG5cbiAgcmV0dXJuIHVuaGFuZGxlZFBpY2tJbmZvcztcbn1cblxuLy8gUGVyLWxheWVyIGV2ZW50IGhhbmRsZXJzIChlLmcuIG9uQ2xpY2ssIG9uSG92ZXIpIGFyZSBwcm92aWRlZCBieSB0aGVcbi8vIHVzZXIgYW5kIG91dCBvZiBkZWNrLmdsJ3MgY29udHJvbC4gSXQncyB2ZXJ5IG11Y2ggcG9zc2libGUgdGhhdFxuLy8gdGhlIHVzZXIgY2FsbHMgUmVhY3QgbGlmZWN5Y2xlIG1ldGhvZHMgaW4gdGhlc2UgZnVuY3Rpb24sIHN1Y2ggYXNcbi8vIFJlYWN0Q29tcG9uZW50LnNldFN0YXRlKCkuIFJlYWN0IGxpZmVjeWNsZSBtZXRob2RzIHNvbWV0aW1lcyBpbmR1Y2Vcbi8vIGEgcmUtcmVuZGVyIGFuZCByZS1nZW5lcmF0aW9uIG9mIHByb3BzIG9mIGRlY2suZ2wgYW5kIGl0cyBsYXllcnMsXG4vLyB3aGljaCBpbnZhbGlkYXRlcyBhbGwgbGF5ZXJzIGN1cnJlbnRseSBwYXNzZWQgdG8gdGhpcyB2ZXJ5IGZ1bmN0aW9uLlxuXG4vLyBUaGVyZWZvcmUsIHBlci1sYXllciBldmVudCBoYW5kbGVycyBtdXN0IGJlIGludm9rZWQgYXQgdGhlIGVuZFxuLy8gb2YgdGhlIHBpY2tpbmcgb3BlcmF0aW9uLiBOTyBvcGVyYXRpb24gdGhhdCByZWxpZXMgb24gdGhlIHN0YXRlcyBvZiBjdXJyZW50XG4vLyBsYXllcnMgc2hvdWxkIGJlIGNhbGxlZCBhZnRlciB0aGlzIGNvZGUuXG5mdW5jdGlvbiBjYWxsTGF5ZXJQaWNraW5nQ2FsbGJhY2tzKGluZm9zLCBtb2RlKSB7XG4gIGNvbnN0IHVuaGFuZGxlZFBpY2tJbmZvcyA9IFtdO1xuXG4gIGluZm9zLmZvckVhY2goaW5mbyA9PiB7XG4gICAgbGV0IGhhbmRsZWQgPSBmYWxzZTtcbiAgICBzd2l0Y2ggKG1vZGUpIHtcbiAgICAgIGNhc2UgJ2NsaWNrJzpcbiAgICAgICAgaGFuZGxlZCA9IGluZm8ubGF5ZXIucHJvcHMub25DbGljayhpbmZvKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdob3Zlcic6XG4gICAgICAgIGhhbmRsZWQgPSBpbmZvLmxheWVyLnByb3BzLm9uSG92ZXIoaW5mbyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAncXVlcnknOlxuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndW5rbm93biBwaWNrIHR5cGUnKTtcbiAgICB9XG5cbiAgICBpZiAoIWhhbmRsZWQpIHtcbiAgICAgIHVuaGFuZGxlZFBpY2tJbmZvcy5wdXNoKGluZm8pO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHVuaGFuZGxlZFBpY2tJbmZvcztcbn1cblxuLyoqXG4gKiBQaWNrIGF0IGEgc3BlY2lmaWVkIHBpeGVsIHdpdGggYSB0b2xlcmFuY2UgcmFkaXVzXG4gKiBSZXR1cm5zIHRoZSBjbG9zZXN0IG9iamVjdCB0byB0aGUgcGl4ZWwgaW4gc2hhcGUgYHtwaWNrZWRDb2xvciwgcGlja2VkTGF5ZXIsIHBpY2tlZE9iamVjdEluZGV4fWBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldENsb3Nlc3RGcm9tUGlja2luZ0J1ZmZlcihcbiAgZ2wsXG4gIHtwaWNrZWRDb2xvcnMsIGxheWVycywgZGV2aWNlWCwgZGV2aWNlWSwgZGV2aWNlUmFkaXVzLCBkZXZpY2VSZWN0fVxuKSB7XG4gIGFzc2VydChwaWNrZWRDb2xvcnMpO1xuXG4gIC8vIFRyYXZlcnNlIGFsbCBwaXhlbHMgaW4gcGlja2luZyByZXN1bHRzIGFuZCBmaW5kIHRoZSBvbmUgY2xvc2VzdCB0byB0aGUgc3VwcGxpZWRcbiAgLy8gW2RldmljZVgsIGRldmljZVldXG4gIGNvbnN0IHt4LCB5LCB3aWR0aCwgaGVpZ2h0fSA9IGRldmljZVJlY3Q7XG4gIGxldCBtaW5TcXVhcmVEaXN0YW5jZVRvQ2VudGVyID0gZGV2aWNlUmFkaXVzICogZGV2aWNlUmFkaXVzO1xuICBsZXQgY2xvc2VzdFBpeGVsSW5kZXggPSAtMTtcbiAgbGV0IGkgPSAwO1xuXG4gIGZvciAobGV0IHJvdyA9IDA7IHJvdyA8IGhlaWdodDsgcm93KyspIHtcbiAgICBjb25zdCBkeSA9IHJvdyArIHkgLSBkZXZpY2VZO1xuICAgIGNvbnN0IGR5MiA9IGR5ICogZHk7XG5cbiAgICBpZiAoZHkyID4gbWluU3F1YXJlRGlzdGFuY2VUb0NlbnRlcikge1xuICAgICAgLy8gc2tpcCB0aGlzIHJvd1xuICAgICAgaSArPSA0ICogd2lkdGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAobGV0IGNvbCA9IDA7IGNvbCA8IHdpZHRoOyBjb2wrKykge1xuICAgICAgICAvLyBEZWNvZGUgcGlja2VkIGxheWVyIGZyb20gY29sb3JcbiAgICAgICAgY29uc3QgcGlja2VkTGF5ZXJJbmRleCA9IHBpY2tlZENvbG9yc1tpICsgM10gLSAxO1xuXG4gICAgICAgIGlmIChwaWNrZWRMYXllckluZGV4ID49IDApIHtcbiAgICAgICAgICBjb25zdCBkeCA9IGNvbCArIHggLSBkZXZpY2VYO1xuICAgICAgICAgIGNvbnN0IGQyID0gZHggKiBkeCArIGR5MjtcblxuICAgICAgICAgIGlmIChkMiA8PSBtaW5TcXVhcmVEaXN0YW5jZVRvQ2VudGVyKSB7XG4gICAgICAgICAgICBtaW5TcXVhcmVEaXN0YW5jZVRvQ2VudGVyID0gZDI7XG4gICAgICAgICAgICBjbG9zZXN0UGl4ZWxJbmRleCA9IGk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGkgKz0gNDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoY2xvc2VzdFBpeGVsSW5kZXggPj0gMCkge1xuICAgIC8vIERlY29kZSBwaWNrZWQgb2JqZWN0IGluZGV4IGZyb20gY29sb3JcbiAgICBjb25zdCBwaWNrZWRMYXllckluZGV4ID0gcGlja2VkQ29sb3JzW2Nsb3Nlc3RQaXhlbEluZGV4ICsgM10gLSAxO1xuICAgIGNvbnN0IHBpY2tlZENvbG9yID0gcGlja2VkQ29sb3JzLnNsaWNlKGNsb3Nlc3RQaXhlbEluZGV4LCBjbG9zZXN0UGl4ZWxJbmRleCArIDQpO1xuICAgIGNvbnN0IHBpY2tlZExheWVyID0gbGF5ZXJzW3BpY2tlZExheWVySW5kZXhdO1xuICAgIGlmIChwaWNrZWRMYXllcikge1xuICAgICAgY29uc3QgcGlja2VkT2JqZWN0SW5kZXggPSBwaWNrZWRMYXllci5kZWNvZGVQaWNraW5nQ29sb3IocGlja2VkQ29sb3IpO1xuICAgICAgcmV0dXJuIHtwaWNrZWRDb2xvciwgcGlja2VkTGF5ZXIsIHBpY2tlZE9iamVjdEluZGV4fTtcbiAgICB9XG4gICAgbG9nLmVycm9yKCdQaWNrZWQgbm9uLWV4aXN0ZW50IGxheWVyLiBJcyBwaWNraW5nIGJ1ZmZlciBjb3JydXB0PycpO1xuICB9XG5cbiAgcmV0dXJuIE5PX1BJQ0tFRF9PQkpFQ1Q7XG59XG4vKiBlc2xpbnQtZW5hYmxlIG1heC1kZXB0aCwgbWF4LXN0YXRlbWVudHMgKi9cblxuLyoqXG4gKiBFeGFtaW5lcyBhIHBpY2tpbmcgYnVmZmVyIGZvciB1bmlxdWUgY29sb3JzXG4gKiBSZXR1cm5zIGFycmF5IG9mIHVuaXF1ZSBvYmplY3RzIGluIHNoYXBlIGB7eCwgeSwgcGlja2VkQ29sb3IsIHBpY2tlZExheWVyLCBwaWNrZWRPYmplY3RJbmRleH1gXG4gKi9cbmZ1bmN0aW9uIGdldFVuaXF1ZXNGcm9tUGlja2luZ0J1ZmZlcihnbCwge3BpY2tlZENvbG9ycywgbGF5ZXJzfSkge1xuICBjb25zdCB1bmlxdWVDb2xvcnMgPSBuZXcgTWFwKCk7XG5cbiAgLy8gVHJhdmVyc2UgYWxsIHBpeGVscyBpbiBwaWNraW5nIHJlc3VsdHMgYW5kIGdldCB1bmlxdWUgY29sb3JzXG4gIGlmIChwaWNrZWRDb2xvcnMpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBpY2tlZENvbG9ycy5sZW5ndGg7IGkgKz0gNCkge1xuICAgICAgLy8gRGVjb2RlIHBpY2tlZCBsYXllciBmcm9tIGNvbG9yXG4gICAgICBjb25zdCBwaWNrZWRMYXllckluZGV4ID0gcGlja2VkQ29sb3JzW2kgKyAzXSAtIDE7XG5cbiAgICAgIGlmIChwaWNrZWRMYXllckluZGV4ID49IDApIHtcbiAgICAgICAgY29uc3QgcGlja2VkQ29sb3IgPSBwaWNrZWRDb2xvcnMuc2xpY2UoaSwgaSArIDQpO1xuICAgICAgICBjb25zdCBjb2xvcktleSA9IHBpY2tlZENvbG9yLmpvaW4oJywnKTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgICAgIGlmICghdW5pcXVlQ29sb3JzLmhhcyhjb2xvcktleSkpIHtcbiAgICAgICAgICBjb25zdCBwaWNrZWRMYXllciA9IGxheWVyc1twaWNrZWRMYXllckluZGV4XTtcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgICAgICBpZiAocGlja2VkTGF5ZXIpIHtcbiAgICAgICAgICAgIHVuaXF1ZUNvbG9ycy5zZXQoY29sb3JLZXksIHtcbiAgICAgICAgICAgICAgcGlja2VkQ29sb3IsXG4gICAgICAgICAgICAgIHBpY2tlZExheWVyLFxuICAgICAgICAgICAgICBwaWNrZWRPYmplY3RJbmRleDogcGlja2VkTGF5ZXIuZGVjb2RlUGlja2luZ0NvbG9yKHBpY2tlZENvbG9yKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxvZy5lcnJvcignUGlja2VkIG5vbi1leGlzdGVudCBsYXllci4gSXMgcGlja2luZyBidWZmZXIgY29ycnVwdD8nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gQXJyYXkuZnJvbSh1bmlxdWVDb2xvcnMudmFsdWVzKCkpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVJbmZvKHBpeGVsLCB2aWV3cG9ydCkge1xuICAvLyBBc3NpZ24gYSBudW1iZXIgb2YgcG90ZW50aWFsbHkgdXNlZnVsIHByb3BzIHRvIHRoZSBcImluZm9cIiBvYmplY3RcbiAgcmV0dXJuIHtcbiAgICBjb2xvcjogbnVsbCxcbiAgICBsYXllcjogbnVsbCxcbiAgICBpbmRleDogLTEsXG4gICAgcGlja2VkOiBmYWxzZSxcbiAgICB4OiBwaXhlbFswXSxcbiAgICB5OiBwaXhlbFsxXSxcbiAgICBwaXhlbCxcbiAgICBsbmdMYXQ6IHZpZXdwb3J0LnVucHJvamVjdChwaXhlbClcbiAgfTtcbn1cblxuLy8gV2FsayB1cCB0aGUgbGF5ZXIgY29tcG9zaXRlIGNoYWluIHRvIHBvcHVsYXRlIHRoZSBpbmZvIG9iamVjdFxuZnVuY3Rpb24gZ2V0TGF5ZXJQaWNraW5nSW5mbyh7bGF5ZXIsIGluZm8sIG1vZGV9KSB7XG4gIHdoaWxlIChsYXllciAmJiBpbmZvKSB7XG4gICAgLy8gRm9yIGEgY29tcG9zaXRlIGxheWVyLCBzb3VyY2VMYXllciB3aWxsIHBvaW50IHRvIHRoZSBzdWJsYXllclxuICAgIC8vIHdoZXJlIHRoZSBldmVudCBvcmlnaW5hdGVzIGZyb20uXG4gICAgLy8gSXQgcHJvdmlkZXMgYWRkaXRpb25hbCBjb250ZXh0IGZvciB0aGUgY29tcG9zaXRlIGxheWVyJ3NcbiAgICAvLyBnZXRQaWNraW5nSW5mbygpIG1ldGhvZCB0byBwb3B1bGF0ZSB0aGUgaW5mbyBvYmplY3RcbiAgICBjb25zdCBzb3VyY2VMYXllciA9IGluZm8ubGF5ZXIgfHwgbGF5ZXI7XG4gICAgaW5mby5sYXllciA9IGxheWVyO1xuICAgIC8vIGxheWVyLnBpY2tMYXllcigpIGZ1bmN0aW9uIHJlcXVpcmVzIGEgbm9uLW51bGwgYGBgbGF5ZXIuc3RhdGVgYGBcbiAgICAvLyBvYmplY3QgdG8gZnVudGlvbiBwcm9wZXJseS4gU28gdGhlIGxheWVyIHJlZmVyZWNlZCBoZXJlXG4gICAgLy8gbXVzdCBiZSB0aGUgXCJjdXJyZW50XCIgbGF5ZXIsIG5vdCBhbiBcIm91dC1kYXRlZFwiIC8gXCJpbnZhbGlkYXRlZFwiIGxheWVyXG4gICAgaW5mbyA9IGxheWVyLnBpY2tMYXllcih7aW5mbywgbW9kZSwgc291cmNlTGF5ZXJ9KTtcbiAgICBsYXllciA9IGxheWVyLnBhcmVudExheWVyO1xuICB9XG4gIHJldHVybiBpbmZvO1xufVxuIl19