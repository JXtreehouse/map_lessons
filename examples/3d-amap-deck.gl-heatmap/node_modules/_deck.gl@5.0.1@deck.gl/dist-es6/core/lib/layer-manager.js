var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

import assert from 'assert';
import { Framebuffer, ShaderCache } from 'luma.gl';
import seer from 'seer';
import Layer from './layer';
import { drawLayers as _drawLayers } from './draw-layers';
import { pickObject as _pickObject, pickVisibleObjects } from './pick-layers';
import { LIFECYCLE } from './constants';
import Viewport from '../viewports/viewport';
// TODO - remove, just for dummy initialization
import WebMercatorViewport from '../viewports/web-mercator-viewport';
import log from '../utils/log';
import { flatten } from '../utils/flatten';

import { setPropOverrides, layerEditListener, seerInitListener, initLayerInSeer, updateLayerInSeer } from './seer-integration';

var LOG_PRIORITY_LIFECYCLE = 2;
var LOG_PRIORITY_LIFECYCLE_MINOR = 4;

var initialContext = {
  uniforms: {},
  viewports: [],
  viewport: null,
  layerFilter: null,
  viewportChanged: true,
  pickingFBO: null,
  useDevicePixels: true,
  lastPickedInfo: {
    index: -1,
    layerId: null
  }
};

var layerName = function layerName(layer) {
  return layer instanceof Layer ? '' + layer : !layer ? 'null' : 'invalid';
};

var LayerManager = function () {
  // eslint-disable-next-line
  function LayerManager(gl) {
    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        eventManager = _ref.eventManager;

    _classCallCheck(this, LayerManager);

    // Currently deck.gl expects the DeckGL.layers array to be different
    // whenever React rerenders. If the same layers array is used, the
    // LayerManager's diffing algorithm will generate a fatal error and
    // break the rendering.

    // `this.lastRenderedLayers` stores the UNFILTERED layers sent
    // down to LayerManager, so that `layers` reference can be compared.
    // If it's the same across two React render calls, the diffing logic
    // will be skipped.
    this.lastRenderedLayers = [];
    this.prevLayers = [];
    this.layers = [];

    this.oldContext = {};
    this.context = Object.assign({}, initialContext, {
      gl: gl,
      // Enabling luma.gl Program caching using private API (_cachePrograms)
      shaderCache: new ShaderCache({ gl: gl, _cachePrograms: true })
    });

    // List of view descriptors, gets re-evaluated when width/height changes
    this.width = 100;
    this.height = 100;
    this.viewDescriptors = [];
    this.viewDescriptorsChanged = true;
    this.viewports = []; // Generated viewports
    this._needsRedraw = 'Initial render';

    // Event handling
    this._pickingRadius = 0;

    this._eventManager = null;
    this._onLayerClick = null;
    this._onLayerHover = null;
    this._onClick = this._onClick.bind(this);
    this._onPointerMove = this._onPointerMove.bind(this);
    this._onPointerLeave = this._onPointerLeave.bind(this);
    this._pickAndCallback = this._pickAndCallback.bind(this);

    // Seer integration
    this._initSeer = this._initSeer.bind(this);
    this._editSeer = this._editSeer.bind(this);
    seerInitListener(this._initSeer);
    layerEditListener(this._editSeer);

    Object.seal(this);

    if (eventManager) {
      this._initEventHandling(eventManager);
    }

    // Init with dummy viewport
    this.setViewports([new WebMercatorViewport({ width: 1, height: 1, latitude: 0, longitude: 0, zoom: 1 })]);
  }

  /**
   * Method to call when the layer manager is not needed anymore.
   *
   * Currently used in the <DeckGL> componentWillUnmount lifecycle to unbind Seer listeners.
   */


  _createClass(LayerManager, [{
    key: 'finalize',
    value: function finalize() {
      seer.removeListener(this._initSeer);
      seer.removeListener(this._editSeer);
    }
  }, {
    key: 'needsRedraw',
    value: function needsRedraw() {
      var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref2$clearRedrawFlag = _ref2.clearRedrawFlags,
          clearRedrawFlags = _ref2$clearRedrawFlag === undefined ? true : _ref2$clearRedrawFlag;

      return this._checkIfNeedsRedraw(clearRedrawFlags);
    }

    // Normally not called by app

  }, {
    key: 'setNeedsRedraw',
    value: function setNeedsRedraw(reason) {
      this._needsRedraw = this._needsRedraw || reason;
    }

    // Gets an (optionally) filtered list of layers

  }, {
    key: 'getLayers',
    value: function getLayers() {
      var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref3$layerIds = _ref3.layerIds,
          layerIds = _ref3$layerIds === undefined ? null : _ref3$layerIds;

      // Filtering by layerId compares beginning of strings, so that sublayers will be included
      // Dependes on the convention of adding suffixes to the parent's layer name
      return layerIds ? this.layers.filter(function (layer) {
        return layerIds.find(function (layerId) {
          return layer.id.indexOf(layerId) === 0;
        });
      }) : this.layers;
    }

    // Get a set of viewports for a given width and height
    // TODO - Intention is for deck.gl to autodeduce width and height and drop the need for props

  }, {
    key: 'getViewports',
    value: function getViewports() {
      var _ref4 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          width = _ref4.width,
          height = _ref4.height;

      if (width !== this.width || height !== this.height || this.viewDescriptorsChanged) {
        this._rebuildViewportsFromViews({ viewDescriptors: this.viewDescriptors, width: width, height: height });
        this.width = width;
        this.height = height;
      }
      return this.viewports;
    }

    /**
     * Set parameters needed for layer rendering and picking.
     * Parameters are to be passed as a single object, with the following values:
     * @param {Boolean} useDevicePixels
     */

  }, {
    key: 'setParameters',
    value: function setParameters(parameters) {
      if ('eventManager' in parameters) {
        this._initEventHandling(parameters.eventManager);
      }

      if ('pickingRadius' in parameters || 'onLayerClick' in parameters || 'onLayerHover' in parameters) {
        this._setEventHandlingParameters(parameters);
      }

      // TODO - For now we set layers before viewports to preservenchangeFlags
      if ('layers' in parameters) {
        this.setLayers(parameters.layers);
      }

      if ('viewports' in parameters) {
        this.setViewports(parameters.viewports);
      }

      if ('layerFilter' in parameters) {
        this.context.layerFilter = parameters.layerFilter;
        if (this.context.layerFilter !== parameters.layerFilter) {
          this.setNeedsRedraw('layerFilter changed');
        }
      }

      if ('drawPickingColors' in parameters) {
        if (this.context.drawPickingColors !== parameters.drawPickingColors) {
          this.setNeedsRedraw('drawPickingColors changed');
        }
      }

      Object.assign(this.context, parameters);
    }

    // Update the view descriptor list and set change flag if needed

  }, {
    key: 'setViewports',
    value: function setViewports(viewports) {
      // Ensure viewports are wrapped in descriptors
      var viewDescriptors = flatten(viewports, { filter: Boolean }).map(function (viewport) {
        return viewport instanceof Viewport ? { viewport: viewport } : viewport;
      });

      this.viewDescriptorsChanged = this.viewDescriptorsChanged || this._diffViews(viewDescriptors, this.viewDescriptors);

      // Try to not actually rebuild the viewports until `getViewports` is called
      if (this.viewDescriptorsChanged) {
        this.viewDescriptors = viewDescriptors;
        this._rebuildViewportsFromViews({ viewDescriptors: this.viewDescriptors });
        this.viewDescriptorsChanged = false;
      }
    }

    // Supply a new layer list, initiating sublayer generation and layer matching

  }, {
    key: 'setLayers',
    value: function setLayers(newLayers) {
      assert(this.context.viewport, 'LayerManager.updateLayers: viewport not set');

      // TODO - something is generating state updates that cause rerender of the same
      if (newLayers === this.lastRenderedLayers) {
        log.log(3, 'Ignoring layer update due to layer array not changed');
        return this;
      }
      this.lastRenderedLayers = newLayers;

      newLayers = flatten(newLayers, { filter: Boolean });

      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = newLayers[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var layer = _step.value;

          layer.context = this.context;
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      this.prevLayers = this.layers;

      var _updateLayers2 = this._updateLayers({
        oldLayers: this.prevLayers,
        newLayers: newLayers
      }),
          error = _updateLayers2.error,
          generatedLayers = _updateLayers2.generatedLayers;

      this.layers = generatedLayers;
      // Throw first error found, if any
      if (error) {
        throw error;
      }
      return this;
    }
  }, {
    key: 'drawLayers',
    value: function drawLayers() {
      var _ref5 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref5$pass = _ref5.pass,
          pass = _ref5$pass === undefined ? 'render to screen' : _ref5$pass,
          _ref5$redrawReason = _ref5.redrawReason,
          redrawReason = _ref5$redrawReason === undefined ? 'unknown reason' : _ref5$redrawReason;

      var _context = this.context,
          gl = _context.gl,
          useDevicePixels = _context.useDevicePixels,
          drawPickingColors = _context.drawPickingColors;

      // render this viewport

      _drawLayers(gl, {
        layers: this.layers,
        viewports: this.getViewports(),
        onViewportActive: this._activateViewport.bind(this),
        useDevicePixels: useDevicePixels,
        drawPickingColors: drawPickingColors,
        pass: pass,
        layerFilter: this.context.layerFilter,
        redrawReason: redrawReason
      });
    }

    // Pick the closest info at given coordinate

  }, {
    key: 'pickObject',
    value: function pickObject(_ref6) {
      var x = _ref6.x,
          y = _ref6.y,
          mode = _ref6.mode,
          _ref6$radius = _ref6.radius,
          radius = _ref6$radius === undefined ? 0 : _ref6$radius,
          layerIds = _ref6.layerIds,
          layerFilter = _ref6.layerFilter;
      var _context2 = this.context,
          gl = _context2.gl,
          useDevicePixels = _context2.useDevicePixels;


      var layers = this.getLayers({ layerIds: layerIds });

      return _pickObject(gl, {
        // User params
        x: x,
        y: y,
        radius: radius,
        layers: layers,
        mode: mode,
        layerFilter: layerFilter,
        // Injected params
        viewports: this.getViewports(),
        onViewportActive: this._activateViewport.bind(this),
        pickingFBO: this._getPickingBuffer(),
        lastPickedInfo: this.context.lastPickedInfo,
        useDevicePixels: useDevicePixels
      });
    }

    // Get all unique infos within a bounding box

  }, {
    key: 'pickObjects',
    value: function pickObjects(_ref7) {
      var x = _ref7.x,
          y = _ref7.y,
          width = _ref7.width,
          height = _ref7.height,
          layerIds = _ref7.layerIds,
          layerFilter = _ref7.layerFilter;
      var _context3 = this.context,
          gl = _context3.gl,
          useDevicePixels = _context3.useDevicePixels;


      var layers = this.getLayers({ layerIds: layerIds });

      return pickVisibleObjects(gl, {
        x: x,
        y: y,
        width: width,
        height: height,
        layers: layers,
        layerFilter: layerFilter,
        mode: 'pickObjects',
        // TODO - how does this interact with multiple viewports?
        viewport: this.context.viewport,
        viewports: this.getViewports(),
        onViewportActive: this._activateViewport.bind(this),
        pickingFBO: this._getPickingBuffer(),
        useDevicePixels: useDevicePixels
      });
    }

    //
    // DEPRECATED METHODS in V5
    //

  }, {
    key: 'updateLayers',
    value: function updateLayers(_ref8) {
      var newLayers = _ref8.newLayers;

      log.deprecated('updateLayers', 'setLayers');
      this.setLayers(newLayers);
    }
  }, {
    key: 'setViewport',
    value: function setViewport(viewport) {
      log.deprecated('setViewport', 'setViewports');
      this.setViewports([viewport]);
      return this;
    }

    //
    // PRIVATE METHODS
    //

  }, {
    key: '_checkIfNeedsRedraw',
    value: function _checkIfNeedsRedraw(clearRedrawFlags) {
      var redraw = this._needsRedraw;
      if (clearRedrawFlags) {
        this._needsRedraw = false;
      }

      // This layers list doesn't include sublayers, relying on composite layers
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = this.layers[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var layer = _step2.value;

          // Call every layer to clear their flags
          var layerNeedsRedraw = layer.getNeedsRedraw({ clearRedrawFlags: clearRedrawFlags });
          redraw = redraw || layerNeedsRedraw;
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      return redraw;
    }

    // Rebuilds viewports from descriptors towards a certain window size

  }, {
    key: '_rebuildViewportsFromViews',
    value: function _rebuildViewportsFromViews(_ref9) {
      var _this = this;

      var viewDescriptors = _ref9.viewDescriptors,
          width = _ref9.width,
          height = _ref9.height;

      var newViewports = viewDescriptors.map(function (viewDescriptor) {
        return (
          // If a `Viewport` instance was supplied, use it, otherwise build it
          viewDescriptor.viewport instanceof Viewport ? viewDescriptor.viewport : _this._makeViewportFromViewDescriptor({ viewDescriptor: viewDescriptor, width: width, height: height })
        );
      });

      this.setNeedsRedraw('Viewport(s) changed');

      // Ensure one viewport is activated, layers may expect it
      // TODO - handle empty viewport list (using dummy viewport), or assert
      // const oldViewports = this.context.viewports;
      // if (viewportsChanged) {

      var viewport = newViewports[0];
      assert(viewport instanceof Viewport, 'Invalid viewport');

      this.context.viewports = newViewports;
      this._activateViewport(viewport);
      // }

      // We've just rebuilt the viewports to match the descriptors, so clear the flag
      this.viewports = newViewports;
      this.viewDescriptorsChanged = false;
    }

    // Build a `Viewport` from a view descriptor
    // TODO - add support for autosizing viewports using width and height

  }, {
    key: '_makeViewportFromViewDescriptor',
    value: function _makeViewportFromViewDescriptor(_ref10) {
      var viewDescriptor = _ref10.viewDescriptor,
          width = _ref10.width,
          height = _ref10.height;

      // Get the type of the viewport
      // TODO - default to WebMercator?
      var ViewportType = viewDescriptor.type,
          viewState = viewDescriptor.viewState;

      // Resolve relative viewport dimensions
      // TODO - we need to have width and height available

      var viewportDimensions = this._getViewDimensions({ viewDescriptor: viewDescriptor });

      // Create the viewport, giving preference to view state in `viewState`
      return new ViewportType(Object.assign({}, viewDescriptor, viewportDimensions, viewState // Object.assign handles undefined
      ));
    }

    // Check if viewport array has changed, returns true if any change
    // Note that descriptors can be the same

  }, {
    key: '_diffViews',
    value: function _diffViews(newViews, oldViews) {
      var _this2 = this;

      if (newViews.length !== oldViews.length) {
        return true;
      }

      return newViews.some(function (_, i) {
        return _this2._diffView(newViews[i], oldViews[i]);
      });
    }
  }, {
    key: '_diffView',
    value: function _diffView(newView, oldView) {
      // `View` hiearchy supports an `equals` method
      if (newView.viewport) {
        return !oldView.viewport || !newView.viewport.equals(oldView.viewport);
      }
      // TODO - implement deep equal on view descriptors
      return newView !== oldView;
    }

    // Support for relative viewport dimensions (e.g {y: '50%', height: '50%'})

  }, {
    key: '_getViewDimensions',
    value: function _getViewDimensions(_ref11) {
      var viewDescriptor = _ref11.viewDescriptor,
          width = _ref11.width,
          height = _ref11.height;

      var parsePercent = function parsePercent(value, max) {
        return value;
      };
      // TODO - enable to support percent size specifiers
      // const parsePercent = (value, max) => value ?
      //   Math.round(parseFloat(value) / 100 * max) :
      //   (value === null ? max : value);

      return {
        x: parsePercent(viewDescriptor.x, width),
        y: parsePercent(viewDescriptor.y, height),
        width: parsePercent(viewDescriptor.width, width),
        height: parsePercent(viewDescriptor.height, height)
      };
    }

    /**
     * @param {Object} eventManager   A source of DOM input events
     */

  }, {
    key: '_initEventHandling',
    value: function _initEventHandling(eventManager) {
      this._eventManager = eventManager;

      // TODO: add/remove handlers on demand at runtime, not all at once on init.
      // Consider both top-level handlers like onLayerClick/Hover
      // and per-layer handlers attached to individual layers.
      // https://github.com/uber/deck.gl/issues/634
      this._eventManager.on({
        click: this._onClick,
        pointermove: this._onPointerMove,
        pointerleave: this._onPointerLeave
      });
    }

    // Set parameters for input event handling.

  }, {
    key: '_setEventHandlingParameters',
    value: function _setEventHandlingParameters(_ref12) {
      var pickingRadius = _ref12.pickingRadius,
          onLayerClick = _ref12.onLayerClick,
          onLayerHover = _ref12.onLayerHover;

      if (!isNaN(pickingRadius)) {
        this._pickingRadius = pickingRadius;
      }
      if (typeof onLayerClick !== 'undefined') {
        this._onLayerClick = onLayerClick;
      }
      if (typeof onLayerHover !== 'undefined') {
        this._onLayerHover = onLayerHover;
      }
      this._validateEventHandling();
    }

    // Make a viewport "current" in layer context, primed for draw

  }, {
    key: '_activateViewport',
    value: function _activateViewport(viewport) {
      // TODO - viewport change detection breaks METER_OFFSETS mode
      // const oldViewport = this.context.viewport;
      // const viewportChanged = !oldViewport || !viewport.equals(oldViewport);
      var viewportChanged = true;

      if (viewportChanged) {
        Object.assign(this.oldContext, this.context);
        this.context.viewport = viewport;
        this.context.viewportChanged = true;
        this.context.uniforms = {};
        log(4, viewport);

        // Update layers states
        // Let screen space layers update their state based on viewport
        // TODO - reimplement viewport change detection (single viewport optimization)
        // TODO - don't set viewportChanged during setViewports?
        if (this.context.viewportChanged) {
          var _iteratorNormalCompletion3 = true;
          var _didIteratorError3 = false;
          var _iteratorError3 = undefined;

          try {
            for (var _iterator3 = this.layers[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
              var layer = _step3.value;

              layer.setChangeFlags({ viewportChanged: 'Viewport changed' });
              this._updateLayer(layer);
            }
          } catch (err) {
            _didIteratorError3 = true;
            _iteratorError3 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion3 && _iterator3.return) {
                _iterator3.return();
              }
            } finally {
              if (_didIteratorError3) {
                throw _iteratorError3;
              }
            }
          }
        }
      }

      assert(this.context.viewport, 'LayerManager: viewport not set');

      return this;
    }
  }, {
    key: '_getPickingBuffer',
    value: function _getPickingBuffer() {
      var gl = this.context.gl;
      // Create a frame buffer if not already available

      this.context.pickingFBO = this.context.pickingFBO || new Framebuffer(gl);
      // Resize it to current canvas size (this is a noop if size hasn't changed)
      this.context.pickingFBO.resize({ width: gl.canvas.width, height: gl.canvas.height });
      return this.context.pickingFBO;
    }

    // Match all layers, checking for caught errors
    // To avoid having an exception in one layer disrupt other layers
    // TODO - mark layers with exceptions as bad and remove from rendering cycle?

  }, {
    key: '_updateLayers',
    value: function _updateLayers(_ref13) {
      var oldLayers = _ref13.oldLayers,
          newLayers = _ref13.newLayers;

      // Create old layer map
      var oldLayerMap = {};
      var _iteratorNormalCompletion4 = true;
      var _didIteratorError4 = false;
      var _iteratorError4 = undefined;

      try {
        for (var _iterator4 = oldLayers[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
          var oldLayer = _step4.value;

          if (oldLayerMap[oldLayer.id]) {
            log.warn('Multiple old layers with same id ' + layerName(oldLayer));
          } else {
            oldLayerMap[oldLayer.id] = oldLayer;
          }
        }

        // Allocate array for generated layers
      } catch (err) {
        _didIteratorError4 = true;
        _iteratorError4 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion4 && _iterator4.return) {
            _iterator4.return();
          }
        } finally {
          if (_didIteratorError4) {
            throw _iteratorError4;
          }
        }
      }

      var generatedLayers = [];

      // Match sublayers
      var error = this._updateSublayersRecursively({
        newLayers: newLayers,
        oldLayerMap: oldLayerMap,
        generatedLayers: generatedLayers
      });

      // Finalize unmatched layers
      var error2 = this._finalizeOldLayers(oldLayerMap);

      var firstError = error || error2;
      return { error: firstError, generatedLayers: generatedLayers };
    }

    // Note: adds generated layers to `generatedLayers` array parameter

  }, {
    key: '_updateSublayersRecursively',
    value: function _updateSublayersRecursively(_ref14) {
      var newLayers = _ref14.newLayers,
          oldLayerMap = _ref14.oldLayerMap,
          generatedLayers = _ref14.generatedLayers;

      var error = null;

      var _iteratorNormalCompletion5 = true;
      var _didIteratorError5 = false;
      var _iteratorError5 = undefined;

      try {
        for (var _iterator5 = newLayers[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
          var newLayer = _step5.value;

          newLayer.context = this.context;

          // Given a new coming layer, find its matching old layer (if any)
          var oldLayer = oldLayerMap[newLayer.id];
          if (oldLayer === null) {
            // null, rather than undefined, means this id was originally there
            log.warn('Multiple new layers with same id ' + layerName(newLayer));
          }
          // Remove the old layer from candidates, as it has been matched with this layer
          oldLayerMap[newLayer.id] = null;

          var sublayers = null;

          // We must not generate exceptions until after layer matching is complete
          try {
            if (!oldLayer) {
              this._initializeLayer(newLayer);
              initLayerInSeer(newLayer); // Initializes layer in seer chrome extension (if connected)
            } else {
              this._transferLayerState(oldLayer, newLayer);
              this._updateLayer(newLayer);
              updateLayerInSeer(newLayer); // Updates layer in seer chrome extension (if connected)
            }
            generatedLayers.push(newLayer);

            // Call layer lifecycle method: render sublayers
            sublayers = newLayer.isComposite && newLayer.getSubLayers();
            // End layer lifecycle method: render sublayers
          } catch (err) {
            log.warn('error during matching of ' + layerName(newLayer), err);
            error = error || err; // Record first exception
          }

          if (sublayers) {
            this._updateSublayersRecursively({
              newLayers: sublayers,
              oldLayerMap: oldLayerMap,
              generatedLayers: generatedLayers
            });
          }
        }
      } catch (err) {
        _didIteratorError5 = true;
        _iteratorError5 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion5 && _iterator5.return) {
            _iterator5.return();
          }
        } finally {
          if (_didIteratorError5) {
            throw _iteratorError5;
          }
        }
      }

      return error;
    }

    // Finalize any old layers that were not matched

  }, {
    key: '_finalizeOldLayers',
    value: function _finalizeOldLayers(oldLayerMap) {
      var error = null;
      for (var layerId in oldLayerMap) {
        var layer = oldLayerMap[layerId];
        if (layer) {
          error = error || this._finalizeLayer(layer);
        }
      }
      return error;
    }

    // Initializes a single layer, calling layer methods

  }, {
    key: '_initializeLayer',
    value: function _initializeLayer(layer) {
      assert(!layer.state);
      log(LOG_PRIORITY_LIFECYCLE, 'initializing ' + layerName(layer));

      var error = null;
      try {
        layer._initialize();
        layer.lifecycle = LIFECYCLE.INITIALIZED;
      } catch (err) {
        log.warn('error while initializing ' + layerName(layer) + '\n', err);
        error = error || err;
        // TODO - what should the lifecycle state be here? LIFECYCLE.INITIALIZATION_FAILED?
      }

      assert(layer.state);

      // Set back pointer (used in picking)
      layer.state.layer = layer;

      // Save layer on model for picking purposes
      // store on model.userData rather than directly on model
      var _iteratorNormalCompletion6 = true;
      var _didIteratorError6 = false;
      var _iteratorError6 = undefined;

      try {
        for (var _iterator6 = layer.getModels()[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
          var model = _step6.value;

          model.userData.layer = layer;
        }
      } catch (err) {
        _didIteratorError6 = true;
        _iteratorError6 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion6 && _iterator6.return) {
            _iterator6.return();
          }
        } finally {
          if (_didIteratorError6) {
            throw _iteratorError6;
          }
        }
      }

      return error;
    }
  }, {
    key: '_transferLayerState',
    value: function _transferLayerState(oldLayer, newLayer) {
      if (newLayer !== oldLayer) {
        log(LOG_PRIORITY_LIFECYCLE_MINOR, 'matched ' + layerName(newLayer), oldLayer, '->', newLayer);
        newLayer.lifecycle = LIFECYCLE.MATCHED;
        oldLayer.lifecycle = LIFECYCLE.AWAITING_GC;
        newLayer._transferState(oldLayer);
      } else {
        log.log(LOG_PRIORITY_LIFECYCLE_MINOR, 'Matching layer is unchanged ' + newLayer.id);
        newLayer.lifecycle = LIFECYCLE.MATCHED;
        newLayer.oldProps = newLayer.props;
      }
    }

    // Updates a single layer, cleaning all flags

  }, {
    key: '_updateLayer',
    value: function _updateLayer(layer) {
      log.log(LOG_PRIORITY_LIFECYCLE_MINOR, 'updating ' + layer + ' because: ' + layer.printChangeFlags());
      var error = null;
      try {
        layer._update();
      } catch (err) {
        log.warn('error during update of ' + layerName(layer), err);
        // Save first error
        error = err;
      }
      return error;
    }

    // Finalizes a single layer

  }, {
    key: '_finalizeLayer',
    value: function _finalizeLayer(layer) {
      assert(layer.state);
      assert(layer.lifecycle !== LIFECYCLE.AWAITING_FINALIZATION);
      layer.lifecycle = LIFECYCLE.AWAITING_FINALIZATION;
      var error = null;
      this.setNeedsRedraw('finalized ' + layerName(layer));
      try {
        layer._finalize();
      } catch (err) {
        log.warn('error during finalization of ' + layerName(layer), err);
        error = err;
      }
      layer.lifecycle = LIFECYCLE.FINALIZED;
      log(LOG_PRIORITY_LIFECYCLE, 'finalizing ' + layerName(layer));
      return error;
    }

    /**
     * Warn if a deck-level mouse event has been specified,
     * but no layers are `pickable`.
     */

  }, {
    key: '_validateEventHandling',
    value: function _validateEventHandling() {
      if (this.onLayerClick || this.onLayerHover) {
        if (this.layers.length && !this.layers.some(function (layer) {
          return layer.props.pickable;
        })) {
          log.warn('You have supplied a top-level input event handler (e.g. `onLayerClick`), ' + 'but none of your layers have set the `pickable` flag.');
        }
      }
    }

    /**
     * Route click events to layers.
     * `pickLayer` will call the `onClick` prop of any picked layer,
     * and `onLayerClick` is called directly from here
     * with any picking info generated by `pickLayer`.
     * @param {Object} event  An object encapsulating an input event,
     *                        with the following shape:
     *                        {Object: {x, y}} offsetCenter: center of the event
     *                        {Object} srcEvent:             native JS Event object
     */

  }, {
    key: '_onClick',
    value: function _onClick(event) {
      if (!event.offsetCenter) {
        // Do not trigger onHover callbacks when click position is invalid.
        return;
      }
      this._pickAndCallback({
        callback: this._onLayerClick,
        event: event,
        mode: 'click'
      });
    }

    /**
     * Route click events to layers.
     * `pickLayer` will call the `onHover` prop of any picked layer,
     * and `onLayerHover` is called directly from here
     * with any picking info generated by `pickLayer`.
     * @param {Object} event  An object encapsulating an input event,
     *                        with the following shape:
     *                        {Object: {x, y}} offsetCenter: center of the event
     *                        {Object} srcEvent:             native JS Event object
     */

  }, {
    key: '_onPointerMove',
    value: function _onPointerMove(event) {
      if (event.isDown) {
        // Do not trigger onHover callbacks if mouse button is down.
        return;
      }
      this._pickAndCallback({
        callback: this._onLayerHover,
        event: event,
        mode: 'hover'
      });
    }
  }, {
    key: '_onPointerLeave',
    value: function _onPointerLeave(event) {
      this.pickObject({
        x: -1,
        y: -1,
        radius: this._pickingRadius,
        mode: 'hover'
      });
    }
  }, {
    key: '_pickAndCallback',
    value: function _pickAndCallback(options) {
      var pos = options.event.offsetCenter;
      var radius = this._pickingRadius;
      var selectedInfos = this.pickObject({ x: pos.x, y: pos.y, radius: radius, mode: options.mode });
      if (options.callback) {
        var firstInfo = selectedInfos.find(function (info) {
          return info.index >= 0;
        }) || null;
        // As per documentation, send null value when no valid object is picked.
        options.callback(firstInfo, selectedInfos, options.event.srcEvent);
      }
    }

    // SEER INTEGRATION

    /**
     * Called upon Seer initialization, manually sends layers data.
     */

  }, {
    key: '_initSeer',
    value: function _initSeer() {
      this.layers.forEach(function (layer) {
        initLayerInSeer(layer);
        updateLayerInSeer(layer);
      });
    }

    /**
     * On Seer property edition, set override and update layers.
     */

  }, {
    key: '_editSeer',
    value: function _editSeer(payload) {
      if (payload.type !== 'edit' || payload.valuePath[0] !== 'props') {
        return;
      }

      setPropOverrides(payload.itemKey, payload.valuePath.slice(1), payload.value);
      var newLayers = this.layers.map(function (layer) {
        return new layer.constructor(layer.props);
      });
      this.updateLayers({ newLayers: newLayers });
    }
  }]);

  return LayerManager;
}();

export default LayerManager;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9jb3JlL2xpYi9sYXllci1tYW5hZ2VyLmpzIl0sIm5hbWVzIjpbImFzc2VydCIsIkZyYW1lYnVmZmVyIiwiU2hhZGVyQ2FjaGUiLCJzZWVyIiwiTGF5ZXIiLCJkcmF3TGF5ZXJzIiwicGlja09iamVjdCIsInBpY2tWaXNpYmxlT2JqZWN0cyIsIkxJRkVDWUNMRSIsIlZpZXdwb3J0IiwiV2ViTWVyY2F0b3JWaWV3cG9ydCIsImxvZyIsImZsYXR0ZW4iLCJzZXRQcm9wT3ZlcnJpZGVzIiwibGF5ZXJFZGl0TGlzdGVuZXIiLCJzZWVySW5pdExpc3RlbmVyIiwiaW5pdExheWVySW5TZWVyIiwidXBkYXRlTGF5ZXJJblNlZXIiLCJMT0dfUFJJT1JJVFlfTElGRUNZQ0xFIiwiTE9HX1BSSU9SSVRZX0xJRkVDWUNMRV9NSU5PUiIsImluaXRpYWxDb250ZXh0IiwidW5pZm9ybXMiLCJ2aWV3cG9ydHMiLCJ2aWV3cG9ydCIsImxheWVyRmlsdGVyIiwidmlld3BvcnRDaGFuZ2VkIiwicGlja2luZ0ZCTyIsInVzZURldmljZVBpeGVscyIsImxhc3RQaWNrZWRJbmZvIiwiaW5kZXgiLCJsYXllcklkIiwibGF5ZXJOYW1lIiwibGF5ZXIiLCJMYXllck1hbmFnZXIiLCJnbCIsImV2ZW50TWFuYWdlciIsImxhc3RSZW5kZXJlZExheWVycyIsInByZXZMYXllcnMiLCJsYXllcnMiLCJvbGRDb250ZXh0IiwiY29udGV4dCIsIk9iamVjdCIsImFzc2lnbiIsInNoYWRlckNhY2hlIiwiX2NhY2hlUHJvZ3JhbXMiLCJ3aWR0aCIsImhlaWdodCIsInZpZXdEZXNjcmlwdG9ycyIsInZpZXdEZXNjcmlwdG9yc0NoYW5nZWQiLCJfbmVlZHNSZWRyYXciLCJfcGlja2luZ1JhZGl1cyIsIl9ldmVudE1hbmFnZXIiLCJfb25MYXllckNsaWNrIiwiX29uTGF5ZXJIb3ZlciIsIl9vbkNsaWNrIiwiYmluZCIsIl9vblBvaW50ZXJNb3ZlIiwiX29uUG9pbnRlckxlYXZlIiwiX3BpY2tBbmRDYWxsYmFjayIsIl9pbml0U2VlciIsIl9lZGl0U2VlciIsInNlYWwiLCJfaW5pdEV2ZW50SGFuZGxpbmciLCJzZXRWaWV3cG9ydHMiLCJsYXRpdHVkZSIsImxvbmdpdHVkZSIsInpvb20iLCJyZW1vdmVMaXN0ZW5lciIsImNsZWFyUmVkcmF3RmxhZ3MiLCJfY2hlY2tJZk5lZWRzUmVkcmF3IiwicmVhc29uIiwibGF5ZXJJZHMiLCJmaWx0ZXIiLCJmaW5kIiwiaWQiLCJpbmRleE9mIiwiX3JlYnVpbGRWaWV3cG9ydHNGcm9tVmlld3MiLCJwYXJhbWV0ZXJzIiwiX3NldEV2ZW50SGFuZGxpbmdQYXJhbWV0ZXJzIiwic2V0TGF5ZXJzIiwic2V0TmVlZHNSZWRyYXciLCJkcmF3UGlja2luZ0NvbG9ycyIsIkJvb2xlYW4iLCJtYXAiLCJfZGlmZlZpZXdzIiwibmV3TGF5ZXJzIiwiX3VwZGF0ZUxheWVycyIsIm9sZExheWVycyIsImVycm9yIiwiZ2VuZXJhdGVkTGF5ZXJzIiwicGFzcyIsInJlZHJhd1JlYXNvbiIsImdldFZpZXdwb3J0cyIsIm9uVmlld3BvcnRBY3RpdmUiLCJfYWN0aXZhdGVWaWV3cG9ydCIsIngiLCJ5IiwibW9kZSIsInJhZGl1cyIsImdldExheWVycyIsIl9nZXRQaWNraW5nQnVmZmVyIiwiZGVwcmVjYXRlZCIsInJlZHJhdyIsImxheWVyTmVlZHNSZWRyYXciLCJnZXROZWVkc1JlZHJhdyIsIm5ld1ZpZXdwb3J0cyIsInZpZXdEZXNjcmlwdG9yIiwiX21ha2VWaWV3cG9ydEZyb21WaWV3RGVzY3JpcHRvciIsIlZpZXdwb3J0VHlwZSIsInR5cGUiLCJ2aWV3U3RhdGUiLCJ2aWV3cG9ydERpbWVuc2lvbnMiLCJfZ2V0Vmlld0RpbWVuc2lvbnMiLCJuZXdWaWV3cyIsIm9sZFZpZXdzIiwibGVuZ3RoIiwic29tZSIsIl8iLCJpIiwiX2RpZmZWaWV3IiwibmV3VmlldyIsIm9sZFZpZXciLCJlcXVhbHMiLCJwYXJzZVBlcmNlbnQiLCJ2YWx1ZSIsIm1heCIsIm9uIiwiY2xpY2siLCJwb2ludGVybW92ZSIsInBvaW50ZXJsZWF2ZSIsInBpY2tpbmdSYWRpdXMiLCJvbkxheWVyQ2xpY2siLCJvbkxheWVySG92ZXIiLCJpc05hTiIsIl92YWxpZGF0ZUV2ZW50SGFuZGxpbmciLCJzZXRDaGFuZ2VGbGFncyIsIl91cGRhdGVMYXllciIsInJlc2l6ZSIsImNhbnZhcyIsIm9sZExheWVyTWFwIiwib2xkTGF5ZXIiLCJ3YXJuIiwiX3VwZGF0ZVN1YmxheWVyc1JlY3Vyc2l2ZWx5IiwiZXJyb3IyIiwiX2ZpbmFsaXplT2xkTGF5ZXJzIiwiZmlyc3RFcnJvciIsIm5ld0xheWVyIiwic3VibGF5ZXJzIiwiX2luaXRpYWxpemVMYXllciIsIl90cmFuc2ZlckxheWVyU3RhdGUiLCJwdXNoIiwiaXNDb21wb3NpdGUiLCJnZXRTdWJMYXllcnMiLCJlcnIiLCJfZmluYWxpemVMYXllciIsInN0YXRlIiwiX2luaXRpYWxpemUiLCJsaWZlY3ljbGUiLCJJTklUSUFMSVpFRCIsImdldE1vZGVscyIsIm1vZGVsIiwidXNlckRhdGEiLCJNQVRDSEVEIiwiQVdBSVRJTkdfR0MiLCJfdHJhbnNmZXJTdGF0ZSIsIm9sZFByb3BzIiwicHJvcHMiLCJwcmludENoYW5nZUZsYWdzIiwiX3VwZGF0ZSIsIkFXQUlUSU5HX0ZJTkFMSVpBVElPTiIsIl9maW5hbGl6ZSIsIkZJTkFMSVpFRCIsInBpY2thYmxlIiwiZXZlbnQiLCJvZmZzZXRDZW50ZXIiLCJjYWxsYmFjayIsImlzRG93biIsIm9wdGlvbnMiLCJwb3MiLCJzZWxlY3RlZEluZm9zIiwiZmlyc3RJbmZvIiwiaW5mbyIsInNyY0V2ZW50IiwiZm9yRWFjaCIsInBheWxvYWQiLCJ2YWx1ZVBhdGgiLCJpdGVtS2V5Iiwic2xpY2UiLCJjb25zdHJ1Y3RvciIsInVwZGF0ZUxheWVycyJdLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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RDtBQUNEOztBQUVENUssdUJBQWlCMkssUUFBUUUsT0FBekIsRUFBa0NGLFFBQVFDLFNBQVIsQ0FBa0JFLEtBQWxCLENBQXdCLENBQXhCLENBQWxDLEVBQThESCxRQUFRNUQsS0FBdEU7QUFDQSxVQUFNdkMsWUFBWSxLQUFLL0MsTUFBTCxDQUFZNkMsR0FBWixDQUFnQjtBQUFBLGVBQVMsSUFBSW5ELE1BQU00SixXQUFWLENBQXNCNUosTUFBTXNJLEtBQTVCLENBQVQ7QUFBQSxPQUFoQixDQUFsQjtBQUNBLFdBQUt1QixZQUFMLENBQWtCLEVBQUN4RyxvQkFBRCxFQUFsQjtBQUNEOzs7Ozs7ZUExc0JrQnBELFkiLCJmaWxlIjoibGF5ZXItbWFuYWdlci5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgMjAxNSAtIDIwMTcgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuLy8gVEhFIFNPRlRXQVJFLlxuXG5pbXBvcnQgYXNzZXJ0IGZyb20gJ2Fzc2VydCc7XG5pbXBvcnQge0ZyYW1lYnVmZmVyLCBTaGFkZXJDYWNoZX0gZnJvbSAnbHVtYS5nbCc7XG5pbXBvcnQgc2VlciBmcm9tICdzZWVyJztcbmltcG9ydCBMYXllciBmcm9tICcuL2xheWVyJztcbmltcG9ydCB7ZHJhd0xheWVyc30gZnJvbSAnLi9kcmF3LWxheWVycyc7XG5pbXBvcnQge3BpY2tPYmplY3QsIHBpY2tWaXNpYmxlT2JqZWN0c30gZnJvbSAnLi9waWNrLWxheWVycyc7XG5pbXBvcnQge0xJRkVDWUNMRX0gZnJvbSAnLi9jb25zdGFudHMnO1xuaW1wb3J0IFZpZXdwb3J0IGZyb20gJy4uL3ZpZXdwb3J0cy92aWV3cG9ydCc7XG4vLyBUT0RPIC0gcmVtb3ZlLCBqdXN0IGZvciBkdW1teSBpbml0aWFsaXphdGlvblxuaW1wb3J0IFdlYk1lcmNhdG9yVmlld3BvcnQgZnJvbSAnLi4vdmlld3BvcnRzL3dlYi1tZXJjYXRvci12aWV3cG9ydCc7XG5pbXBvcnQgbG9nIGZyb20gJy4uL3V0aWxzL2xvZyc7XG5pbXBvcnQge2ZsYXR0ZW59IGZyb20gJy4uL3V0aWxzL2ZsYXR0ZW4nO1xuXG5pbXBvcnQge1xuICBzZXRQcm9wT3ZlcnJpZGVzLFxuICBsYXllckVkaXRMaXN0ZW5lcixcbiAgc2VlckluaXRMaXN0ZW5lcixcbiAgaW5pdExheWVySW5TZWVyLFxuICB1cGRhdGVMYXllckluU2VlclxufSBmcm9tICcuL3NlZXItaW50ZWdyYXRpb24nO1xuXG5jb25zdCBMT0dfUFJJT1JJVFlfTElGRUNZQ0xFID0gMjtcbmNvbnN0IExPR19QUklPUklUWV9MSUZFQ1lDTEVfTUlOT1IgPSA0O1xuXG5jb25zdCBpbml0aWFsQ29udGV4dCA9IHtcbiAgdW5pZm9ybXM6IHt9LFxuICB2aWV3cG9ydHM6IFtdLFxuICB2aWV3cG9ydDogbnVsbCxcbiAgbGF5ZXJGaWx0ZXI6IG51bGwsXG4gIHZpZXdwb3J0Q2hhbmdlZDogdHJ1ZSxcbiAgcGlja2luZ0ZCTzogbnVsbCxcbiAgdXNlRGV2aWNlUGl4ZWxzOiB0cnVlLFxuICBsYXN0UGlja2VkSW5mbzoge1xuICAgIGluZGV4OiAtMSxcbiAgICBsYXllcklkOiBudWxsXG4gIH1cbn07XG5cbmNvbnN0IGxheWVyTmFtZSA9IGxheWVyID0+IChsYXllciBpbnN0YW5jZW9mIExheWVyID8gYCR7bGF5ZXJ9YCA6ICFsYXllciA/ICdudWxsJyA6ICdpbnZhbGlkJyk7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExheWVyTWFuYWdlciB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICBjb25zdHJ1Y3RvcihnbCwge2V2ZW50TWFuYWdlcn0gPSB7fSkge1xuICAgIC8vIEN1cnJlbnRseSBkZWNrLmdsIGV4cGVjdHMgdGhlIERlY2tHTC5sYXllcnMgYXJyYXkgdG8gYmUgZGlmZmVyZW50XG4gICAgLy8gd2hlbmV2ZXIgUmVhY3QgcmVyZW5kZXJzLiBJZiB0aGUgc2FtZSBsYXllcnMgYXJyYXkgaXMgdXNlZCwgdGhlXG4gICAgLy8gTGF5ZXJNYW5hZ2VyJ3MgZGlmZmluZyBhbGdvcml0aG0gd2lsbCBnZW5lcmF0ZSBhIGZhdGFsIGVycm9yIGFuZFxuICAgIC8vIGJyZWFrIHRoZSByZW5kZXJpbmcuXG5cbiAgICAvLyBgdGhpcy5sYXN0UmVuZGVyZWRMYXllcnNgIHN0b3JlcyB0aGUgVU5GSUxURVJFRCBsYXllcnMgc2VudFxuICAgIC8vIGRvd24gdG8gTGF5ZXJNYW5hZ2VyLCBzbyB0aGF0IGBsYXllcnNgIHJlZmVyZW5jZSBjYW4gYmUgY29tcGFyZWQuXG4gICAgLy8gSWYgaXQncyB0aGUgc2FtZSBhY3Jvc3MgdHdvIFJlYWN0IHJlbmRlciBjYWxscywgdGhlIGRpZmZpbmcgbG9naWNcbiAgICAvLyB3aWxsIGJlIHNraXBwZWQuXG4gICAgdGhpcy5sYXN0UmVuZGVyZWRMYXllcnMgPSBbXTtcbiAgICB0aGlzLnByZXZMYXllcnMgPSBbXTtcbiAgICB0aGlzLmxheWVycyA9IFtdO1xuXG4gICAgdGhpcy5vbGRDb250ZXh0ID0ge307XG4gICAgdGhpcy5jb250ZXh0ID0gT2JqZWN0LmFzc2lnbih7fSwgaW5pdGlhbENvbnRleHQsIHtcbiAgICAgIGdsLFxuICAgICAgLy8gRW5hYmxpbmcgbHVtYS5nbCBQcm9ncmFtIGNhY2hpbmcgdXNpbmcgcHJpdmF0ZSBBUEkgKF9jYWNoZVByb2dyYW1zKVxuICAgICAgc2hhZGVyQ2FjaGU6IG5ldyBTaGFkZXJDYWNoZSh7Z2wsIF9jYWNoZVByb2dyYW1zOiB0cnVlfSlcbiAgICB9KTtcblxuICAgIC8vIExpc3Qgb2YgdmlldyBkZXNjcmlwdG9ycywgZ2V0cyByZS1ldmFsdWF0ZWQgd2hlbiB3aWR0aC9oZWlnaHQgY2hhbmdlc1xuICAgIHRoaXMud2lkdGggPSAxMDA7XG4gICAgdGhpcy5oZWlnaHQgPSAxMDA7XG4gICAgdGhpcy52aWV3RGVzY3JpcHRvcnMgPSBbXTtcbiAgICB0aGlzLnZpZXdEZXNjcmlwdG9yc0NoYW5nZWQgPSB0cnVlO1xuICAgIHRoaXMudmlld3BvcnRzID0gW107IC8vIEdlbmVyYXRlZCB2aWV3cG9ydHNcbiAgICB0aGlzLl9uZWVkc1JlZHJhdyA9ICdJbml0aWFsIHJlbmRlcic7XG5cbiAgICAvLyBFdmVudCBoYW5kbGluZ1xuICAgIHRoaXMuX3BpY2tpbmdSYWRpdXMgPSAwO1xuXG4gICAgdGhpcy5fZXZlbnRNYW5hZ2VyID0gbnVsbDtcbiAgICB0aGlzLl9vbkxheWVyQ2xpY2sgPSBudWxsO1xuICAgIHRoaXMuX29uTGF5ZXJIb3ZlciA9IG51bGw7XG4gICAgdGhpcy5fb25DbGljayA9IHRoaXMuX29uQ2xpY2suYmluZCh0aGlzKTtcbiAgICB0aGlzLl9vblBvaW50ZXJNb3ZlID0gdGhpcy5fb25Qb2ludGVyTW92ZS5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX29uUG9pbnRlckxlYXZlID0gdGhpcy5fb25Qb2ludGVyTGVhdmUuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9waWNrQW5kQ2FsbGJhY2sgPSB0aGlzLl9waWNrQW5kQ2FsbGJhY2suYmluZCh0aGlzKTtcblxuICAgIC8vIFNlZXIgaW50ZWdyYXRpb25cbiAgICB0aGlzLl9pbml0U2VlciA9IHRoaXMuX2luaXRTZWVyLmJpbmQodGhpcyk7XG4gICAgdGhpcy5fZWRpdFNlZXIgPSB0aGlzLl9lZGl0U2Vlci5iaW5kKHRoaXMpO1xuICAgIHNlZXJJbml0TGlzdGVuZXIodGhpcy5faW5pdFNlZXIpO1xuICAgIGxheWVyRWRpdExpc3RlbmVyKHRoaXMuX2VkaXRTZWVyKTtcblxuICAgIE9iamVjdC5zZWFsKHRoaXMpO1xuXG4gICAgaWYgKGV2ZW50TWFuYWdlcikge1xuICAgICAgdGhpcy5faW5pdEV2ZW50SGFuZGxpbmcoZXZlbnRNYW5hZ2VyKTtcbiAgICB9XG5cbiAgICAvLyBJbml0IHdpdGggZHVtbXkgdmlld3BvcnRcbiAgICB0aGlzLnNldFZpZXdwb3J0cyhbXG4gICAgICBuZXcgV2ViTWVyY2F0b3JWaWV3cG9ydCh7d2lkdGg6IDEsIGhlaWdodDogMSwgbGF0aXR1ZGU6IDAsIGxvbmdpdHVkZTogMCwgem9vbTogMX0pXG4gICAgXSk7XG4gIH1cblxuICAvKipcbiAgICogTWV0aG9kIHRvIGNhbGwgd2hlbiB0aGUgbGF5ZXIgbWFuYWdlciBpcyBub3QgbmVlZGVkIGFueW1vcmUuXG4gICAqXG4gICAqIEN1cnJlbnRseSB1c2VkIGluIHRoZSA8RGVja0dMPiBjb21wb25lbnRXaWxsVW5tb3VudCBsaWZlY3ljbGUgdG8gdW5iaW5kIFNlZXIgbGlzdGVuZXJzLlxuICAgKi9cbiAgZmluYWxpemUoKSB7XG4gICAgc2Vlci5yZW1vdmVMaXN0ZW5lcih0aGlzLl9pbml0U2Vlcik7XG4gICAgc2Vlci5yZW1vdmVMaXN0ZW5lcih0aGlzLl9lZGl0U2Vlcik7XG4gIH1cblxuICBuZWVkc1JlZHJhdyh7Y2xlYXJSZWRyYXdGbGFncyA9IHRydWV9ID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5fY2hlY2tJZk5lZWRzUmVkcmF3KGNsZWFyUmVkcmF3RmxhZ3MpO1xuICB9XG5cbiAgLy8gTm9ybWFsbHkgbm90IGNhbGxlZCBieSBhcHBcbiAgc2V0TmVlZHNSZWRyYXcocmVhc29uKSB7XG4gICAgdGhpcy5fbmVlZHNSZWRyYXcgPSB0aGlzLl9uZWVkc1JlZHJhdyB8fCByZWFzb247XG4gIH1cblxuICAvLyBHZXRzIGFuIChvcHRpb25hbGx5KSBmaWx0ZXJlZCBsaXN0IG9mIGxheWVyc1xuICBnZXRMYXllcnMoe2xheWVySWRzID0gbnVsbH0gPSB7fSkge1xuICAgIC8vIEZpbHRlcmluZyBieSBsYXllcklkIGNvbXBhcmVzIGJlZ2lubmluZyBvZiBzdHJpbmdzLCBzbyB0aGF0IHN1YmxheWVycyB3aWxsIGJlIGluY2x1ZGVkXG4gICAgLy8gRGVwZW5kZXMgb24gdGhlIGNvbnZlbnRpb24gb2YgYWRkaW5nIHN1ZmZpeGVzIHRvIHRoZSBwYXJlbnQncyBsYXllciBuYW1lXG4gICAgcmV0dXJuIGxheWVySWRzXG4gICAgICA/IHRoaXMubGF5ZXJzLmZpbHRlcihsYXllciA9PiBsYXllcklkcy5maW5kKGxheWVySWQgPT4gbGF5ZXIuaWQuaW5kZXhPZihsYXllcklkKSA9PT0gMCkpXG4gICAgICA6IHRoaXMubGF5ZXJzO1xuICB9XG5cbiAgLy8gR2V0IGEgc2V0IG9mIHZpZXdwb3J0cyBmb3IgYSBnaXZlbiB3aWR0aCBhbmQgaGVpZ2h0XG4gIC8vIFRPRE8gLSBJbnRlbnRpb24gaXMgZm9yIGRlY2suZ2wgdG8gYXV0b2RlZHVjZSB3aWR0aCBhbmQgaGVpZ2h0IGFuZCBkcm9wIHRoZSBuZWVkIGZvciBwcm9wc1xuICBnZXRWaWV3cG9ydHMoe3dpZHRoLCBoZWlnaHR9ID0ge30pIHtcbiAgICBpZiAod2lkdGggIT09IHRoaXMud2lkdGggfHwgaGVpZ2h0ICE9PSB0aGlzLmhlaWdodCB8fCB0aGlzLnZpZXdEZXNjcmlwdG9yc0NoYW5nZWQpIHtcbiAgICAgIHRoaXMuX3JlYnVpbGRWaWV3cG9ydHNGcm9tVmlld3Moe3ZpZXdEZXNjcmlwdG9yczogdGhpcy52aWV3RGVzY3JpcHRvcnMsIHdpZHRoLCBoZWlnaHR9KTtcbiAgICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy52aWV3cG9ydHM7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHBhcmFtZXRlcnMgbmVlZGVkIGZvciBsYXllciByZW5kZXJpbmcgYW5kIHBpY2tpbmcuXG4gICAqIFBhcmFtZXRlcnMgYXJlIHRvIGJlIHBhc3NlZCBhcyBhIHNpbmdsZSBvYmplY3QsIHdpdGggdGhlIGZvbGxvd2luZyB2YWx1ZXM6XG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gdXNlRGV2aWNlUGl4ZWxzXG4gICAqL1xuICBzZXRQYXJhbWV0ZXJzKHBhcmFtZXRlcnMpIHtcbiAgICBpZiAoJ2V2ZW50TWFuYWdlcicgaW4gcGFyYW1ldGVycykge1xuICAgICAgdGhpcy5faW5pdEV2ZW50SGFuZGxpbmcocGFyYW1ldGVycy5ldmVudE1hbmFnZXIpO1xuICAgIH1cblxuICAgIGlmIChcbiAgICAgICdwaWNraW5nUmFkaXVzJyBpbiBwYXJhbWV0ZXJzIHx8XG4gICAgICAnb25MYXllckNsaWNrJyBpbiBwYXJhbWV0ZXJzIHx8XG4gICAgICAnb25MYXllckhvdmVyJyBpbiBwYXJhbWV0ZXJzXG4gICAgKSB7XG4gICAgICB0aGlzLl9zZXRFdmVudEhhbmRsaW5nUGFyYW1ldGVycyhwYXJhbWV0ZXJzKTtcbiAgICB9XG5cbiAgICAvLyBUT0RPIC0gRm9yIG5vdyB3ZSBzZXQgbGF5ZXJzIGJlZm9yZSB2aWV3cG9ydHMgdG8gcHJlc2VydmVuY2hhbmdlRmxhZ3NcbiAgICBpZiAoJ2xheWVycycgaW4gcGFyYW1ldGVycykge1xuICAgICAgdGhpcy5zZXRMYXllcnMocGFyYW1ldGVycy5sYXllcnMpO1xuICAgIH1cblxuICAgIGlmICgndmlld3BvcnRzJyBpbiBwYXJhbWV0ZXJzKSB7XG4gICAgICB0aGlzLnNldFZpZXdwb3J0cyhwYXJhbWV0ZXJzLnZpZXdwb3J0cyk7XG4gICAgfVxuXG4gICAgaWYgKCdsYXllckZpbHRlcicgaW4gcGFyYW1ldGVycykge1xuICAgICAgdGhpcy5jb250ZXh0LmxheWVyRmlsdGVyID0gcGFyYW1ldGVycy5sYXllckZpbHRlcjtcbiAgICAgIGlmICh0aGlzLmNvbnRleHQubGF5ZXJGaWx0ZXIgIT09IHBhcmFtZXRlcnMubGF5ZXJGaWx0ZXIpIHtcbiAgICAgICAgdGhpcy5zZXROZWVkc1JlZHJhdygnbGF5ZXJGaWx0ZXIgY2hhbmdlZCcpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICgnZHJhd1BpY2tpbmdDb2xvcnMnIGluIHBhcmFtZXRlcnMpIHtcbiAgICAgIGlmICh0aGlzLmNvbnRleHQuZHJhd1BpY2tpbmdDb2xvcnMgIT09IHBhcmFtZXRlcnMuZHJhd1BpY2tpbmdDb2xvcnMpIHtcbiAgICAgICAgdGhpcy5zZXROZWVkc1JlZHJhdygnZHJhd1BpY2tpbmdDb2xvcnMgY2hhbmdlZCcpO1xuICAgICAgfVxuICAgIH1cblxuICAgIE9iamVjdC5hc3NpZ24odGhpcy5jb250ZXh0LCBwYXJhbWV0ZXJzKTtcbiAgfVxuXG4gIC8vIFVwZGF0ZSB0aGUgdmlldyBkZXNjcmlwdG9yIGxpc3QgYW5kIHNldCBjaGFuZ2UgZmxhZyBpZiBuZWVkZWRcbiAgc2V0Vmlld3BvcnRzKHZpZXdwb3J0cykge1xuICAgIC8vIEVuc3VyZSB2aWV3cG9ydHMgYXJlIHdyYXBwZWQgaW4gZGVzY3JpcHRvcnNcbiAgICBjb25zdCB2aWV3RGVzY3JpcHRvcnMgPSBmbGF0dGVuKHZpZXdwb3J0cywge2ZpbHRlcjogQm9vbGVhbn0pLm1hcChcbiAgICAgIHZpZXdwb3J0ID0+ICh2aWV3cG9ydCBpbnN0YW5jZW9mIFZpZXdwb3J0ID8ge3ZpZXdwb3J0fSA6IHZpZXdwb3J0KVxuICAgICk7XG5cbiAgICB0aGlzLnZpZXdEZXNjcmlwdG9yc0NoYW5nZWQgPVxuICAgICAgdGhpcy52aWV3RGVzY3JpcHRvcnNDaGFuZ2VkIHx8IHRoaXMuX2RpZmZWaWV3cyh2aWV3RGVzY3JpcHRvcnMsIHRoaXMudmlld0Rlc2NyaXB0b3JzKTtcblxuICAgIC8vIFRyeSB0byBub3QgYWN0dWFsbHkgcmVidWlsZCB0aGUgdmlld3BvcnRzIHVudGlsIGBnZXRWaWV3cG9ydHNgIGlzIGNhbGxlZFxuICAgIGlmICh0aGlzLnZpZXdEZXNjcmlwdG9yc0NoYW5nZWQpIHtcbiAgICAgIHRoaXMudmlld0Rlc2NyaXB0b3JzID0gdmlld0Rlc2NyaXB0b3JzO1xuICAgICAgdGhpcy5fcmVidWlsZFZpZXdwb3J0c0Zyb21WaWV3cyh7dmlld0Rlc2NyaXB0b3JzOiB0aGlzLnZpZXdEZXNjcmlwdG9yc30pO1xuICAgICAgdGhpcy52aWV3RGVzY3JpcHRvcnNDaGFuZ2VkID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgLy8gU3VwcGx5IGEgbmV3IGxheWVyIGxpc3QsIGluaXRpYXRpbmcgc3VibGF5ZXIgZ2VuZXJhdGlvbiBhbmQgbGF5ZXIgbWF0Y2hpbmdcbiAgc2V0TGF5ZXJzKG5ld0xheWVycykge1xuICAgIGFzc2VydCh0aGlzLmNvbnRleHQudmlld3BvcnQsICdMYXllck1hbmFnZXIudXBkYXRlTGF5ZXJzOiB2aWV3cG9ydCBub3Qgc2V0Jyk7XG5cbiAgICAvLyBUT0RPIC0gc29tZXRoaW5nIGlzIGdlbmVyYXRpbmcgc3RhdGUgdXBkYXRlcyB0aGF0IGNhdXNlIHJlcmVuZGVyIG9mIHRoZSBzYW1lXG4gICAgaWYgKG5ld0xheWVycyA9PT0gdGhpcy5sYXN0UmVuZGVyZWRMYXllcnMpIHtcbiAgICAgIGxvZy5sb2coMywgJ0lnbm9yaW5nIGxheWVyIHVwZGF0ZSBkdWUgdG8gbGF5ZXIgYXJyYXkgbm90IGNoYW5nZWQnKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB0aGlzLmxhc3RSZW5kZXJlZExheWVycyA9IG5ld0xheWVycztcblxuICAgIG5ld0xheWVycyA9IGZsYXR0ZW4obmV3TGF5ZXJzLCB7ZmlsdGVyOiBCb29sZWFufSk7XG5cbiAgICBmb3IgKGNvbnN0IGxheWVyIG9mIG5ld0xheWVycykge1xuICAgICAgbGF5ZXIuY29udGV4dCA9IHRoaXMuY29udGV4dDtcbiAgICB9XG5cbiAgICB0aGlzLnByZXZMYXllcnMgPSB0aGlzLmxheWVycztcbiAgICBjb25zdCB7ZXJyb3IsIGdlbmVyYXRlZExheWVyc30gPSB0aGlzLl91cGRhdGVMYXllcnMoe1xuICAgICAgb2xkTGF5ZXJzOiB0aGlzLnByZXZMYXllcnMsXG4gICAgICBuZXdMYXllcnNcbiAgICB9KTtcblxuICAgIHRoaXMubGF5ZXJzID0gZ2VuZXJhdGVkTGF5ZXJzO1xuICAgIC8vIFRocm93IGZpcnN0IGVycm9yIGZvdW5kLCBpZiBhbnlcbiAgICBpZiAoZXJyb3IpIHtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGRyYXdMYXllcnMoe3Bhc3MgPSAncmVuZGVyIHRvIHNjcmVlbicsIHJlZHJhd1JlYXNvbiA9ICd1bmtub3duIHJlYXNvbid9ID0ge30pIHtcbiAgICBjb25zdCB7Z2wsIHVzZURldmljZVBpeGVscywgZHJhd1BpY2tpbmdDb2xvcnN9ID0gdGhpcy5jb250ZXh0O1xuXG4gICAgLy8gcmVuZGVyIHRoaXMgdmlld3BvcnRcbiAgICBkcmF3TGF5ZXJzKGdsLCB7XG4gICAgICBsYXllcnM6IHRoaXMubGF5ZXJzLFxuICAgICAgdmlld3BvcnRzOiB0aGlzLmdldFZpZXdwb3J0cygpLFxuICAgICAgb25WaWV3cG9ydEFjdGl2ZTogdGhpcy5fYWN0aXZhdGVWaWV3cG9ydC5iaW5kKHRoaXMpLFxuICAgICAgdXNlRGV2aWNlUGl4ZWxzLFxuICAgICAgZHJhd1BpY2tpbmdDb2xvcnMsXG4gICAgICBwYXNzLFxuICAgICAgbGF5ZXJGaWx0ZXI6IHRoaXMuY29udGV4dC5sYXllckZpbHRlcixcbiAgICAgIHJlZHJhd1JlYXNvblxuICAgIH0pO1xuICB9XG5cbiAgLy8gUGljayB0aGUgY2xvc2VzdCBpbmZvIGF0IGdpdmVuIGNvb3JkaW5hdGVcbiAgcGlja09iamVjdCh7eCwgeSwgbW9kZSwgcmFkaXVzID0gMCwgbGF5ZXJJZHMsIGxheWVyRmlsdGVyfSkge1xuICAgIGNvbnN0IHtnbCwgdXNlRGV2aWNlUGl4ZWxzfSA9IHRoaXMuY29udGV4dDtcblxuICAgIGNvbnN0IGxheWVycyA9IHRoaXMuZ2V0TGF5ZXJzKHtsYXllcklkc30pO1xuXG4gICAgcmV0dXJuIHBpY2tPYmplY3QoZ2wsIHtcbiAgICAgIC8vIFVzZXIgcGFyYW1zXG4gICAgICB4LFxuICAgICAgeSxcbiAgICAgIHJhZGl1cyxcbiAgICAgIGxheWVycyxcbiAgICAgIG1vZGUsXG4gICAgICBsYXllckZpbHRlcixcbiAgICAgIC8vIEluamVjdGVkIHBhcmFtc1xuICAgICAgdmlld3BvcnRzOiB0aGlzLmdldFZpZXdwb3J0cygpLFxuICAgICAgb25WaWV3cG9ydEFjdGl2ZTogdGhpcy5fYWN0aXZhdGVWaWV3cG9ydC5iaW5kKHRoaXMpLFxuICAgICAgcGlja2luZ0ZCTzogdGhpcy5fZ2V0UGlja2luZ0J1ZmZlcigpLFxuICAgICAgbGFzdFBpY2tlZEluZm86IHRoaXMuY29udGV4dC5sYXN0UGlja2VkSW5mbyxcbiAgICAgIHVzZURldmljZVBpeGVsc1xuICAgIH0pO1xuICB9XG5cbiAgLy8gR2V0IGFsbCB1bmlxdWUgaW5mb3Mgd2l0aGluIGEgYm91bmRpbmcgYm94XG4gIHBpY2tPYmplY3RzKHt4LCB5LCB3aWR0aCwgaGVpZ2h0LCBsYXllcklkcywgbGF5ZXJGaWx0ZXJ9KSB7XG4gICAgY29uc3Qge2dsLCB1c2VEZXZpY2VQaXhlbHN9ID0gdGhpcy5jb250ZXh0O1xuXG4gICAgY29uc3QgbGF5ZXJzID0gdGhpcy5nZXRMYXllcnMoe2xheWVySWRzfSk7XG5cbiAgICByZXR1cm4gcGlja1Zpc2libGVPYmplY3RzKGdsLCB7XG4gICAgICB4LFxuICAgICAgeSxcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0LFxuICAgICAgbGF5ZXJzLFxuICAgICAgbGF5ZXJGaWx0ZXIsXG4gICAgICBtb2RlOiAncGlja09iamVjdHMnLFxuICAgICAgLy8gVE9ETyAtIGhvdyBkb2VzIHRoaXMgaW50ZXJhY3Qgd2l0aCBtdWx0aXBsZSB2aWV3cG9ydHM/XG4gICAgICB2aWV3cG9ydDogdGhpcy5jb250ZXh0LnZpZXdwb3J0LFxuICAgICAgdmlld3BvcnRzOiB0aGlzLmdldFZpZXdwb3J0cygpLFxuICAgICAgb25WaWV3cG9ydEFjdGl2ZTogdGhpcy5fYWN0aXZhdGVWaWV3cG9ydC5iaW5kKHRoaXMpLFxuICAgICAgcGlja2luZ0ZCTzogdGhpcy5fZ2V0UGlja2luZ0J1ZmZlcigpLFxuICAgICAgdXNlRGV2aWNlUGl4ZWxzXG4gICAgfSk7XG4gIH1cblxuICAvL1xuICAvLyBERVBSRUNBVEVEIE1FVEhPRFMgaW4gVjVcbiAgLy9cblxuICB1cGRhdGVMYXllcnMoe25ld0xheWVyc30pIHtcbiAgICBsb2cuZGVwcmVjYXRlZCgndXBkYXRlTGF5ZXJzJywgJ3NldExheWVycycpO1xuICAgIHRoaXMuc2V0TGF5ZXJzKG5ld0xheWVycyk7XG4gIH1cblxuICBzZXRWaWV3cG9ydCh2aWV3cG9ydCkge1xuICAgIGxvZy5kZXByZWNhdGVkKCdzZXRWaWV3cG9ydCcsICdzZXRWaWV3cG9ydHMnKTtcbiAgICB0aGlzLnNldFZpZXdwb3J0cyhbdmlld3BvcnRdKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vXG4gIC8vIFBSSVZBVEUgTUVUSE9EU1xuICAvL1xuXG4gIF9jaGVja0lmTmVlZHNSZWRyYXcoY2xlYXJSZWRyYXdGbGFncykge1xuICAgIGxldCByZWRyYXcgPSB0aGlzLl9uZWVkc1JlZHJhdztcbiAgICBpZiAoY2xlYXJSZWRyYXdGbGFncykge1xuICAgICAgdGhpcy5fbmVlZHNSZWRyYXcgPSBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBUaGlzIGxheWVycyBsaXN0IGRvZXNuJ3QgaW5jbHVkZSBzdWJsYXllcnMsIHJlbHlpbmcgb24gY29tcG9zaXRlIGxheWVyc1xuICAgIGZvciAoY29uc3QgbGF5ZXIgb2YgdGhpcy5sYXllcnMpIHtcbiAgICAgIC8vIENhbGwgZXZlcnkgbGF5ZXIgdG8gY2xlYXIgdGhlaXIgZmxhZ3NcbiAgICAgIGNvbnN0IGxheWVyTmVlZHNSZWRyYXcgPSBsYXllci5nZXROZWVkc1JlZHJhdyh7Y2xlYXJSZWRyYXdGbGFnc30pO1xuICAgICAgcmVkcmF3ID0gcmVkcmF3IHx8IGxheWVyTmVlZHNSZWRyYXc7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlZHJhdztcbiAgfVxuXG4gIC8vIFJlYnVpbGRzIHZpZXdwb3J0cyBmcm9tIGRlc2NyaXB0b3JzIHRvd2FyZHMgYSBjZXJ0YWluIHdpbmRvdyBzaXplXG4gIF9yZWJ1aWxkVmlld3BvcnRzRnJvbVZpZXdzKHt2aWV3RGVzY3JpcHRvcnMsIHdpZHRoLCBoZWlnaHR9KSB7XG4gICAgY29uc3QgbmV3Vmlld3BvcnRzID0gdmlld0Rlc2NyaXB0b3JzLm1hcChcbiAgICAgIHZpZXdEZXNjcmlwdG9yID0+XG4gICAgICAgIC8vIElmIGEgYFZpZXdwb3J0YCBpbnN0YW5jZSB3YXMgc3VwcGxpZWQsIHVzZSBpdCwgb3RoZXJ3aXNlIGJ1aWxkIGl0XG4gICAgICAgIHZpZXdEZXNjcmlwdG9yLnZpZXdwb3J0IGluc3RhbmNlb2YgVmlld3BvcnRcbiAgICAgICAgICA/IHZpZXdEZXNjcmlwdG9yLnZpZXdwb3J0XG4gICAgICAgICAgOiB0aGlzLl9tYWtlVmlld3BvcnRGcm9tVmlld0Rlc2NyaXB0b3Ioe3ZpZXdEZXNjcmlwdG9yLCB3aWR0aCwgaGVpZ2h0fSlcbiAgICApO1xuXG4gICAgdGhpcy5zZXROZWVkc1JlZHJhdygnVmlld3BvcnQocykgY2hhbmdlZCcpO1xuXG4gICAgLy8gRW5zdXJlIG9uZSB2aWV3cG9ydCBpcyBhY3RpdmF0ZWQsIGxheWVycyBtYXkgZXhwZWN0IGl0XG4gICAgLy8gVE9ETyAtIGhhbmRsZSBlbXB0eSB2aWV3cG9ydCBsaXN0ICh1c2luZyBkdW1teSB2aWV3cG9ydCksIG9yIGFzc2VydFxuICAgIC8vIGNvbnN0IG9sZFZpZXdwb3J0cyA9IHRoaXMuY29udGV4dC52aWV3cG9ydHM7XG4gICAgLy8gaWYgKHZpZXdwb3J0c0NoYW5nZWQpIHtcblxuICAgIGNvbnN0IHZpZXdwb3J0ID0gbmV3Vmlld3BvcnRzWzBdO1xuICAgIGFzc2VydCh2aWV3cG9ydCBpbnN0YW5jZW9mIFZpZXdwb3J0LCAnSW52YWxpZCB2aWV3cG9ydCcpO1xuXG4gICAgdGhpcy5jb250ZXh0LnZpZXdwb3J0cyA9IG5ld1ZpZXdwb3J0cztcbiAgICB0aGlzLl9hY3RpdmF0ZVZpZXdwb3J0KHZpZXdwb3J0KTtcbiAgICAvLyB9XG5cbiAgICAvLyBXZSd2ZSBqdXN0IHJlYnVpbHQgdGhlIHZpZXdwb3J0cyB0byBtYXRjaCB0aGUgZGVzY3JpcHRvcnMsIHNvIGNsZWFyIHRoZSBmbGFnXG4gICAgdGhpcy52aWV3cG9ydHMgPSBuZXdWaWV3cG9ydHM7XG4gICAgdGhpcy52aWV3RGVzY3JpcHRvcnNDaGFuZ2VkID0gZmFsc2U7XG4gIH1cblxuICAvLyBCdWlsZCBhIGBWaWV3cG9ydGAgZnJvbSBhIHZpZXcgZGVzY3JpcHRvclxuICAvLyBUT0RPIC0gYWRkIHN1cHBvcnQgZm9yIGF1dG9zaXppbmcgdmlld3BvcnRzIHVzaW5nIHdpZHRoIGFuZCBoZWlnaHRcbiAgX21ha2VWaWV3cG9ydEZyb21WaWV3RGVzY3JpcHRvcih7dmlld0Rlc2NyaXB0b3IsIHdpZHRoLCBoZWlnaHR9KSB7XG4gICAgLy8gR2V0IHRoZSB0eXBlIG9mIHRoZSB2aWV3cG9ydFxuICAgIC8vIFRPRE8gLSBkZWZhdWx0IHRvIFdlYk1lcmNhdG9yP1xuICAgIGNvbnN0IHt0eXBlOiBWaWV3cG9ydFR5cGUsIHZpZXdTdGF0ZX0gPSB2aWV3RGVzY3JpcHRvcjtcblxuICAgIC8vIFJlc29sdmUgcmVsYXRpdmUgdmlld3BvcnQgZGltZW5zaW9uc1xuICAgIC8vIFRPRE8gLSB3ZSBuZWVkIHRvIGhhdmUgd2lkdGggYW5kIGhlaWdodCBhdmFpbGFibGVcbiAgICBjb25zdCB2aWV3cG9ydERpbWVuc2lvbnMgPSB0aGlzLl9nZXRWaWV3RGltZW5zaW9ucyh7dmlld0Rlc2NyaXB0b3J9KTtcblxuICAgIC8vIENyZWF0ZSB0aGUgdmlld3BvcnQsIGdpdmluZyBwcmVmZXJlbmNlIHRvIHZpZXcgc3RhdGUgaW4gYHZpZXdTdGF0ZWBcbiAgICByZXR1cm4gbmV3IFZpZXdwb3J0VHlwZShcbiAgICAgIE9iamVjdC5hc3NpZ24oXG4gICAgICAgIHt9LFxuICAgICAgICB2aWV3RGVzY3JpcHRvcixcbiAgICAgICAgdmlld3BvcnREaW1lbnNpb25zLFxuICAgICAgICB2aWV3U3RhdGUgLy8gT2JqZWN0LmFzc2lnbiBoYW5kbGVzIHVuZGVmaW5lZFxuICAgICAgKVxuICAgICk7XG4gIH1cblxuICAvLyBDaGVjayBpZiB2aWV3cG9ydCBhcnJheSBoYXMgY2hhbmdlZCwgcmV0dXJucyB0cnVlIGlmIGFueSBjaGFuZ2VcbiAgLy8gTm90ZSB0aGF0IGRlc2NyaXB0b3JzIGNhbiBiZSB0aGUgc2FtZVxuICBfZGlmZlZpZXdzKG5ld1ZpZXdzLCBvbGRWaWV3cykge1xuICAgIGlmIChuZXdWaWV3cy5sZW5ndGggIT09IG9sZFZpZXdzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ld1ZpZXdzLnNvbWUoKF8sIGkpID0+IHRoaXMuX2RpZmZWaWV3KG5ld1ZpZXdzW2ldLCBvbGRWaWV3c1tpXSkpO1xuICB9XG5cbiAgX2RpZmZWaWV3KG5ld1ZpZXcsIG9sZFZpZXcpIHtcbiAgICAvLyBgVmlld2AgaGllYXJjaHkgc3VwcG9ydHMgYW4gYGVxdWFsc2AgbWV0aG9kXG4gICAgaWYgKG5ld1ZpZXcudmlld3BvcnQpIHtcbiAgICAgIHJldHVybiAhb2xkVmlldy52aWV3cG9ydCB8fCAhbmV3Vmlldy52aWV3cG9ydC5lcXVhbHMob2xkVmlldy52aWV3cG9ydCk7XG4gICAgfVxuICAgIC8vIFRPRE8gLSBpbXBsZW1lbnQgZGVlcCBlcXVhbCBvbiB2aWV3IGRlc2NyaXB0b3JzXG4gICAgcmV0dXJuIG5ld1ZpZXcgIT09IG9sZFZpZXc7XG4gIH1cblxuICAvLyBTdXBwb3J0IGZvciByZWxhdGl2ZSB2aWV3cG9ydCBkaW1lbnNpb25zIChlLmcge3k6ICc1MCUnLCBoZWlnaHQ6ICc1MCUnfSlcbiAgX2dldFZpZXdEaW1lbnNpb25zKHt2aWV3RGVzY3JpcHRvciwgd2lkdGgsIGhlaWdodH0pIHtcbiAgICBjb25zdCBwYXJzZVBlcmNlbnQgPSAodmFsdWUsIG1heCkgPT4gdmFsdWU7XG4gICAgLy8gVE9ETyAtIGVuYWJsZSB0byBzdXBwb3J0IHBlcmNlbnQgc2l6ZSBzcGVjaWZpZXJzXG4gICAgLy8gY29uc3QgcGFyc2VQZXJjZW50ID0gKHZhbHVlLCBtYXgpID0+IHZhbHVlID9cbiAgICAvLyAgIE1hdGgucm91bmQocGFyc2VGbG9hdCh2YWx1ZSkgLyAxMDAgKiBtYXgpIDpcbiAgICAvLyAgICh2YWx1ZSA9PT0gbnVsbCA/IG1heCA6IHZhbHVlKTtcblxuICAgIHJldHVybiB7XG4gICAgICB4OiBwYXJzZVBlcmNlbnQodmlld0Rlc2NyaXB0b3IueCwgd2lkdGgpLFxuICAgICAgeTogcGFyc2VQZXJjZW50KHZpZXdEZXNjcmlwdG9yLnksIGhlaWdodCksXG4gICAgICB3aWR0aDogcGFyc2VQZXJjZW50KHZpZXdEZXNjcmlwdG9yLndpZHRoLCB3aWR0aCksXG4gICAgICBoZWlnaHQ6IHBhcnNlUGVyY2VudCh2aWV3RGVzY3JpcHRvci5oZWlnaHQsIGhlaWdodClcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudE1hbmFnZXIgICBBIHNvdXJjZSBvZiBET00gaW5wdXQgZXZlbnRzXG4gICAqL1xuICBfaW5pdEV2ZW50SGFuZGxpbmcoZXZlbnRNYW5hZ2VyKSB7XG4gICAgdGhpcy5fZXZlbnRNYW5hZ2VyID0gZXZlbnRNYW5hZ2VyO1xuXG4gICAgLy8gVE9ETzogYWRkL3JlbW92ZSBoYW5kbGVycyBvbiBkZW1hbmQgYXQgcnVudGltZSwgbm90IGFsbCBhdCBvbmNlIG9uIGluaXQuXG4gICAgLy8gQ29uc2lkZXIgYm90aCB0b3AtbGV2ZWwgaGFuZGxlcnMgbGlrZSBvbkxheWVyQ2xpY2svSG92ZXJcbiAgICAvLyBhbmQgcGVyLWxheWVyIGhhbmRsZXJzIGF0dGFjaGVkIHRvIGluZGl2aWR1YWwgbGF5ZXJzLlxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS91YmVyL2RlY2suZ2wvaXNzdWVzLzYzNFxuICAgIHRoaXMuX2V2ZW50TWFuYWdlci5vbih7XG4gICAgICBjbGljazogdGhpcy5fb25DbGljayxcbiAgICAgIHBvaW50ZXJtb3ZlOiB0aGlzLl9vblBvaW50ZXJNb3ZlLFxuICAgICAgcG9pbnRlcmxlYXZlOiB0aGlzLl9vblBvaW50ZXJMZWF2ZVxuICAgIH0pO1xuICB9XG5cbiAgLy8gU2V0IHBhcmFtZXRlcnMgZm9yIGlucHV0IGV2ZW50IGhhbmRsaW5nLlxuICBfc2V0RXZlbnRIYW5kbGluZ1BhcmFtZXRlcnMoe3BpY2tpbmdSYWRpdXMsIG9uTGF5ZXJDbGljaywgb25MYXllckhvdmVyfSkge1xuICAgIGlmICghaXNOYU4ocGlja2luZ1JhZGl1cykpIHtcbiAgICAgIHRoaXMuX3BpY2tpbmdSYWRpdXMgPSBwaWNraW5nUmFkaXVzO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9uTGF5ZXJDbGljayAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRoaXMuX29uTGF5ZXJDbGljayA9IG9uTGF5ZXJDbGljaztcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvbkxheWVySG92ZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aGlzLl9vbkxheWVySG92ZXIgPSBvbkxheWVySG92ZXI7XG4gICAgfVxuICAgIHRoaXMuX3ZhbGlkYXRlRXZlbnRIYW5kbGluZygpO1xuICB9XG5cbiAgLy8gTWFrZSBhIHZpZXdwb3J0IFwiY3VycmVudFwiIGluIGxheWVyIGNvbnRleHQsIHByaW1lZCBmb3IgZHJhd1xuICBfYWN0aXZhdGVWaWV3cG9ydCh2aWV3cG9ydCkge1xuICAgIC8vIFRPRE8gLSB2aWV3cG9ydCBjaGFuZ2UgZGV0ZWN0aW9uIGJyZWFrcyBNRVRFUl9PRkZTRVRTIG1vZGVcbiAgICAvLyBjb25zdCBvbGRWaWV3cG9ydCA9IHRoaXMuY29udGV4dC52aWV3cG9ydDtcbiAgICAvLyBjb25zdCB2aWV3cG9ydENoYW5nZWQgPSAhb2xkVmlld3BvcnQgfHwgIXZpZXdwb3J0LmVxdWFscyhvbGRWaWV3cG9ydCk7XG4gICAgY29uc3Qgdmlld3BvcnRDaGFuZ2VkID0gdHJ1ZTtcblxuICAgIGlmICh2aWV3cG9ydENoYW5nZWQpIHtcbiAgICAgIE9iamVjdC5hc3NpZ24odGhpcy5vbGRDb250ZXh0LCB0aGlzLmNvbnRleHQpO1xuICAgICAgdGhpcy5jb250ZXh0LnZpZXdwb3J0ID0gdmlld3BvcnQ7XG4gICAgICB0aGlzLmNvbnRleHQudmlld3BvcnRDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgIHRoaXMuY29udGV4dC51bmlmb3JtcyA9IHt9O1xuICAgICAgbG9nKDQsIHZpZXdwb3J0KTtcblxuICAgICAgLy8gVXBkYXRlIGxheWVycyBzdGF0ZXNcbiAgICAgIC8vIExldCBzY3JlZW4gc3BhY2UgbGF5ZXJzIHVwZGF0ZSB0aGVpciBzdGF0ZSBiYXNlZCBvbiB2aWV3cG9ydFxuICAgICAgLy8gVE9ETyAtIHJlaW1wbGVtZW50IHZpZXdwb3J0IGNoYW5nZSBkZXRlY3Rpb24gKHNpbmdsZSB2aWV3cG9ydCBvcHRpbWl6YXRpb24pXG4gICAgICAvLyBUT0RPIC0gZG9uJ3Qgc2V0IHZpZXdwb3J0Q2hhbmdlZCBkdXJpbmcgc2V0Vmlld3BvcnRzP1xuICAgICAgaWYgKHRoaXMuY29udGV4dC52aWV3cG9ydENoYW5nZWQpIHtcbiAgICAgICAgZm9yIChjb25zdCBsYXllciBvZiB0aGlzLmxheWVycykge1xuICAgICAgICAgIGxheWVyLnNldENoYW5nZUZsYWdzKHt2aWV3cG9ydENoYW5nZWQ6ICdWaWV3cG9ydCBjaGFuZ2VkJ30pO1xuICAgICAgICAgIHRoaXMuX3VwZGF0ZUxheWVyKGxheWVyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGFzc2VydCh0aGlzLmNvbnRleHQudmlld3BvcnQsICdMYXllck1hbmFnZXI6IHZpZXdwb3J0IG5vdCBzZXQnKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgX2dldFBpY2tpbmdCdWZmZXIoKSB7XG4gICAgY29uc3Qge2dsfSA9IHRoaXMuY29udGV4dDtcbiAgICAvLyBDcmVhdGUgYSBmcmFtZSBidWZmZXIgaWYgbm90IGFscmVhZHkgYXZhaWxhYmxlXG4gICAgdGhpcy5jb250ZXh0LnBpY2tpbmdGQk8gPSB0aGlzLmNvbnRleHQucGlja2luZ0ZCTyB8fCBuZXcgRnJhbWVidWZmZXIoZ2wpO1xuICAgIC8vIFJlc2l6ZSBpdCB0byBjdXJyZW50IGNhbnZhcyBzaXplICh0aGlzIGlzIGEgbm9vcCBpZiBzaXplIGhhc24ndCBjaGFuZ2VkKVxuICAgIHRoaXMuY29udGV4dC5waWNraW5nRkJPLnJlc2l6ZSh7d2lkdGg6IGdsLmNhbnZhcy53aWR0aCwgaGVpZ2h0OiBnbC5jYW52YXMuaGVpZ2h0fSk7XG4gICAgcmV0dXJuIHRoaXMuY29udGV4dC5waWNraW5nRkJPO1xuICB9XG5cbiAgLy8gTWF0Y2ggYWxsIGxheWVycywgY2hlY2tpbmcgZm9yIGNhdWdodCBlcnJvcnNcbiAgLy8gVG8gYXZvaWQgaGF2aW5nIGFuIGV4Y2VwdGlvbiBpbiBvbmUgbGF5ZXIgZGlzcnVwdCBvdGhlciBsYXllcnNcbiAgLy8gVE9ETyAtIG1hcmsgbGF5ZXJzIHdpdGggZXhjZXB0aW9ucyBhcyBiYWQgYW5kIHJlbW92ZSBmcm9tIHJlbmRlcmluZyBjeWNsZT9cbiAgX3VwZGF0ZUxheWVycyh7b2xkTGF5ZXJzLCBuZXdMYXllcnN9KSB7XG4gICAgLy8gQ3JlYXRlIG9sZCBsYXllciBtYXBcbiAgICBjb25zdCBvbGRMYXllck1hcCA9IHt9O1xuICAgIGZvciAoY29uc3Qgb2xkTGF5ZXIgb2Ygb2xkTGF5ZXJzKSB7XG4gICAgICBpZiAob2xkTGF5ZXJNYXBbb2xkTGF5ZXIuaWRdKSB7XG4gICAgICAgIGxvZy53YXJuKGBNdWx0aXBsZSBvbGQgbGF5ZXJzIHdpdGggc2FtZSBpZCAke2xheWVyTmFtZShvbGRMYXllcil9YCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvbGRMYXllck1hcFtvbGRMYXllci5pZF0gPSBvbGRMYXllcjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBBbGxvY2F0ZSBhcnJheSBmb3IgZ2VuZXJhdGVkIGxheWVyc1xuICAgIGNvbnN0IGdlbmVyYXRlZExheWVycyA9IFtdO1xuXG4gICAgLy8gTWF0Y2ggc3VibGF5ZXJzXG4gICAgY29uc3QgZXJyb3IgPSB0aGlzLl91cGRhdGVTdWJsYXllcnNSZWN1cnNpdmVseSh7XG4gICAgICBuZXdMYXllcnMsXG4gICAgICBvbGRMYXllck1hcCxcbiAgICAgIGdlbmVyYXRlZExheWVyc1xuICAgIH0pO1xuXG4gICAgLy8gRmluYWxpemUgdW5tYXRjaGVkIGxheWVyc1xuICAgIGNvbnN0IGVycm9yMiA9IHRoaXMuX2ZpbmFsaXplT2xkTGF5ZXJzKG9sZExheWVyTWFwKTtcblxuICAgIGNvbnN0IGZpcnN0RXJyb3IgPSBlcnJvciB8fCBlcnJvcjI7XG4gICAgcmV0dXJuIHtlcnJvcjogZmlyc3RFcnJvciwgZ2VuZXJhdGVkTGF5ZXJzfTtcbiAgfVxuXG4gIC8vIE5vdGU6IGFkZHMgZ2VuZXJhdGVkIGxheWVycyB0byBgZ2VuZXJhdGVkTGF5ZXJzYCBhcnJheSBwYXJhbWV0ZXJcbiAgX3VwZGF0ZVN1YmxheWVyc1JlY3Vyc2l2ZWx5KHtuZXdMYXllcnMsIG9sZExheWVyTWFwLCBnZW5lcmF0ZWRMYXllcnN9KSB7XG4gICAgbGV0IGVycm9yID0gbnVsbDtcblxuICAgIGZvciAoY29uc3QgbmV3TGF5ZXIgb2YgbmV3TGF5ZXJzKSB7XG4gICAgICBuZXdMYXllci5jb250ZXh0ID0gdGhpcy5jb250ZXh0O1xuXG4gICAgICAvLyBHaXZlbiBhIG5ldyBjb21pbmcgbGF5ZXIsIGZpbmQgaXRzIG1hdGNoaW5nIG9sZCBsYXllciAoaWYgYW55KVxuICAgICAgY29uc3Qgb2xkTGF5ZXIgPSBvbGRMYXllck1hcFtuZXdMYXllci5pZF07XG4gICAgICBpZiAob2xkTGF5ZXIgPT09IG51bGwpIHtcbiAgICAgICAgLy8gbnVsbCwgcmF0aGVyIHRoYW4gdW5kZWZpbmVkLCBtZWFucyB0aGlzIGlkIHdhcyBvcmlnaW5hbGx5IHRoZXJlXG4gICAgICAgIGxvZy53YXJuKGBNdWx0aXBsZSBuZXcgbGF5ZXJzIHdpdGggc2FtZSBpZCAke2xheWVyTmFtZShuZXdMYXllcil9YCk7XG4gICAgICB9XG4gICAgICAvLyBSZW1vdmUgdGhlIG9sZCBsYXllciBmcm9tIGNhbmRpZGF0ZXMsIGFzIGl0IGhhcyBiZWVuIG1hdGNoZWQgd2l0aCB0aGlzIGxheWVyXG4gICAgICBvbGRMYXllck1hcFtuZXdMYXllci5pZF0gPSBudWxsO1xuXG4gICAgICBsZXQgc3VibGF5ZXJzID0gbnVsbDtcblxuICAgICAgLy8gV2UgbXVzdCBub3QgZ2VuZXJhdGUgZXhjZXB0aW9ucyB1bnRpbCBhZnRlciBsYXllciBtYXRjaGluZyBpcyBjb21wbGV0ZVxuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKCFvbGRMYXllcikge1xuICAgICAgICAgIHRoaXMuX2luaXRpYWxpemVMYXllcihuZXdMYXllcik7XG4gICAgICAgICAgaW5pdExheWVySW5TZWVyKG5ld0xheWVyKTsgLy8gSW5pdGlhbGl6ZXMgbGF5ZXIgaW4gc2VlciBjaHJvbWUgZXh0ZW5zaW9uIChpZiBjb25uZWN0ZWQpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5fdHJhbnNmZXJMYXllclN0YXRlKG9sZExheWVyLCBuZXdMYXllcik7XG4gICAgICAgICAgdGhpcy5fdXBkYXRlTGF5ZXIobmV3TGF5ZXIpO1xuICAgICAgICAgIHVwZGF0ZUxheWVySW5TZWVyKG5ld0xheWVyKTsgLy8gVXBkYXRlcyBsYXllciBpbiBzZWVyIGNocm9tZSBleHRlbnNpb24gKGlmIGNvbm5lY3RlZClcbiAgICAgICAgfVxuICAgICAgICBnZW5lcmF0ZWRMYXllcnMucHVzaChuZXdMYXllcik7XG5cbiAgICAgICAgLy8gQ2FsbCBsYXllciBsaWZlY3ljbGUgbWV0aG9kOiByZW5kZXIgc3VibGF5ZXJzXG4gICAgICAgIHN1YmxheWVycyA9IG5ld0xheWVyLmlzQ29tcG9zaXRlICYmIG5ld0xheWVyLmdldFN1YkxheWVycygpO1xuICAgICAgICAvLyBFbmQgbGF5ZXIgbGlmZWN5Y2xlIG1ldGhvZDogcmVuZGVyIHN1YmxheWVyc1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGxvZy53YXJuKGBlcnJvciBkdXJpbmcgbWF0Y2hpbmcgb2YgJHtsYXllck5hbWUobmV3TGF5ZXIpfWAsIGVycik7XG4gICAgICAgIGVycm9yID0gZXJyb3IgfHwgZXJyOyAvLyBSZWNvcmQgZmlyc3QgZXhjZXB0aW9uXG4gICAgICB9XG5cbiAgICAgIGlmIChzdWJsYXllcnMpIHtcbiAgICAgICAgdGhpcy5fdXBkYXRlU3VibGF5ZXJzUmVjdXJzaXZlbHkoe1xuICAgICAgICAgIG5ld0xheWVyczogc3VibGF5ZXJzLFxuICAgICAgICAgIG9sZExheWVyTWFwLFxuICAgICAgICAgIGdlbmVyYXRlZExheWVyc1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZXJyb3I7XG4gIH1cblxuICAvLyBGaW5hbGl6ZSBhbnkgb2xkIGxheWVycyB0aGF0IHdlcmUgbm90IG1hdGNoZWRcbiAgX2ZpbmFsaXplT2xkTGF5ZXJzKG9sZExheWVyTWFwKSB7XG4gICAgbGV0IGVycm9yID0gbnVsbDtcbiAgICBmb3IgKGNvbnN0IGxheWVySWQgaW4gb2xkTGF5ZXJNYXApIHtcbiAgICAgIGNvbnN0IGxheWVyID0gb2xkTGF5ZXJNYXBbbGF5ZXJJZF07XG4gICAgICBpZiAobGF5ZXIpIHtcbiAgICAgICAgZXJyb3IgPSBlcnJvciB8fCB0aGlzLl9maW5hbGl6ZUxheWVyKGxheWVyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGVycm9yO1xuICB9XG5cbiAgLy8gSW5pdGlhbGl6ZXMgYSBzaW5nbGUgbGF5ZXIsIGNhbGxpbmcgbGF5ZXIgbWV0aG9kc1xuICBfaW5pdGlhbGl6ZUxheWVyKGxheWVyKSB7XG4gICAgYXNzZXJ0KCFsYXllci5zdGF0ZSk7XG4gICAgbG9nKExPR19QUklPUklUWV9MSUZFQ1lDTEUsIGBpbml0aWFsaXppbmcgJHtsYXllck5hbWUobGF5ZXIpfWApO1xuXG4gICAgbGV0IGVycm9yID0gbnVsbDtcbiAgICB0cnkge1xuICAgICAgbGF5ZXIuX2luaXRpYWxpemUoKTtcbiAgICAgIGxheWVyLmxpZmVjeWNsZSA9IExJRkVDWUNMRS5JTklUSUFMSVpFRDtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGxvZy53YXJuKGBlcnJvciB3aGlsZSBpbml0aWFsaXppbmcgJHtsYXllck5hbWUobGF5ZXIpfVxcbmAsIGVycik7XG4gICAgICBlcnJvciA9IGVycm9yIHx8IGVycjtcbiAgICAgIC8vIFRPRE8gLSB3aGF0IHNob3VsZCB0aGUgbGlmZWN5Y2xlIHN0YXRlIGJlIGhlcmU/IExJRkVDWUNMRS5JTklUSUFMSVpBVElPTl9GQUlMRUQ/XG4gICAgfVxuXG4gICAgYXNzZXJ0KGxheWVyLnN0YXRlKTtcblxuICAgIC8vIFNldCBiYWNrIHBvaW50ZXIgKHVzZWQgaW4gcGlja2luZylcbiAgICBsYXllci5zdGF0ZS5sYXllciA9IGxheWVyO1xuXG4gICAgLy8gU2F2ZSBsYXllciBvbiBtb2RlbCBmb3IgcGlja2luZyBwdXJwb3Nlc1xuICAgIC8vIHN0b3JlIG9uIG1vZGVsLnVzZXJEYXRhIHJhdGhlciB0aGFuIGRpcmVjdGx5IG9uIG1vZGVsXG4gICAgZm9yIChjb25zdCBtb2RlbCBvZiBsYXllci5nZXRNb2RlbHMoKSkge1xuICAgICAgbW9kZWwudXNlckRhdGEubGF5ZXIgPSBsYXllcjtcbiAgICB9XG5cbiAgICByZXR1cm4gZXJyb3I7XG4gIH1cblxuICBfdHJhbnNmZXJMYXllclN0YXRlKG9sZExheWVyLCBuZXdMYXllcikge1xuICAgIGlmIChuZXdMYXllciAhPT0gb2xkTGF5ZXIpIHtcbiAgICAgIGxvZyhMT0dfUFJJT1JJVFlfTElGRUNZQ0xFX01JTk9SLCBgbWF0Y2hlZCAke2xheWVyTmFtZShuZXdMYXllcil9YCwgb2xkTGF5ZXIsICctPicsIG5ld0xheWVyKTtcbiAgICAgIG5ld0xheWVyLmxpZmVjeWNsZSA9IExJRkVDWUNMRS5NQVRDSEVEO1xuICAgICAgb2xkTGF5ZXIubGlmZWN5Y2xlID0gTElGRUNZQ0xFLkFXQUlUSU5HX0dDO1xuICAgICAgbmV3TGF5ZXIuX3RyYW5zZmVyU3RhdGUob2xkTGF5ZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsb2cubG9nKExPR19QUklPUklUWV9MSUZFQ1lDTEVfTUlOT1IsIGBNYXRjaGluZyBsYXllciBpcyB1bmNoYW5nZWQgJHtuZXdMYXllci5pZH1gKTtcbiAgICAgIG5ld0xheWVyLmxpZmVjeWNsZSA9IExJRkVDWUNMRS5NQVRDSEVEO1xuICAgICAgbmV3TGF5ZXIub2xkUHJvcHMgPSBuZXdMYXllci5wcm9wcztcbiAgICB9XG4gIH1cblxuICAvLyBVcGRhdGVzIGEgc2luZ2xlIGxheWVyLCBjbGVhbmluZyBhbGwgZmxhZ3NcbiAgX3VwZGF0ZUxheWVyKGxheWVyKSB7XG4gICAgbG9nLmxvZyhMT0dfUFJJT1JJVFlfTElGRUNZQ0xFX01JTk9SLCBgdXBkYXRpbmcgJHtsYXllcn0gYmVjYXVzZTogJHtsYXllci5wcmludENoYW5nZUZsYWdzKCl9YCk7XG4gICAgbGV0IGVycm9yID0gbnVsbDtcbiAgICB0cnkge1xuICAgICAgbGF5ZXIuX3VwZGF0ZSgpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgbG9nLndhcm4oYGVycm9yIGR1cmluZyB1cGRhdGUgb2YgJHtsYXllck5hbWUobGF5ZXIpfWAsIGVycik7XG4gICAgICAvLyBTYXZlIGZpcnN0IGVycm9yXG4gICAgICBlcnJvciA9IGVycjtcbiAgICB9XG4gICAgcmV0dXJuIGVycm9yO1xuICB9XG5cbiAgLy8gRmluYWxpemVzIGEgc2luZ2xlIGxheWVyXG4gIF9maW5hbGl6ZUxheWVyKGxheWVyKSB7XG4gICAgYXNzZXJ0KGxheWVyLnN0YXRlKTtcbiAgICBhc3NlcnQobGF5ZXIubGlmZWN5Y2xlICE9PSBMSUZFQ1lDTEUuQVdBSVRJTkdfRklOQUxJWkFUSU9OKTtcbiAgICBsYXllci5saWZlY3ljbGUgPSBMSUZFQ1lDTEUuQVdBSVRJTkdfRklOQUxJWkFUSU9OO1xuICAgIGxldCBlcnJvciA9IG51bGw7XG4gICAgdGhpcy5zZXROZWVkc1JlZHJhdyhgZmluYWxpemVkICR7bGF5ZXJOYW1lKGxheWVyKX1gKTtcbiAgICB0cnkge1xuICAgICAgbGF5ZXIuX2ZpbmFsaXplKCk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBsb2cud2FybihgZXJyb3IgZHVyaW5nIGZpbmFsaXphdGlvbiBvZiAke2xheWVyTmFtZShsYXllcil9YCwgZXJyKTtcbiAgICAgIGVycm9yID0gZXJyO1xuICAgIH1cbiAgICBsYXllci5saWZlY3ljbGUgPSBMSUZFQ1lDTEUuRklOQUxJWkVEO1xuICAgIGxvZyhMT0dfUFJJT1JJVFlfTElGRUNZQ0xFLCBgZmluYWxpemluZyAke2xheWVyTmFtZShsYXllcil9YCk7XG4gICAgcmV0dXJuIGVycm9yO1xuICB9XG5cbiAgLyoqXG4gICAqIFdhcm4gaWYgYSBkZWNrLWxldmVsIG1vdXNlIGV2ZW50IGhhcyBiZWVuIHNwZWNpZmllZCxcbiAgICogYnV0IG5vIGxheWVycyBhcmUgYHBpY2thYmxlYC5cbiAgICovXG4gIF92YWxpZGF0ZUV2ZW50SGFuZGxpbmcoKSB7XG4gICAgaWYgKHRoaXMub25MYXllckNsaWNrIHx8IHRoaXMub25MYXllckhvdmVyKSB7XG4gICAgICBpZiAodGhpcy5sYXllcnMubGVuZ3RoICYmICF0aGlzLmxheWVycy5zb21lKGxheWVyID0+IGxheWVyLnByb3BzLnBpY2thYmxlKSkge1xuICAgICAgICBsb2cud2FybihcbiAgICAgICAgICAnWW91IGhhdmUgc3VwcGxpZWQgYSB0b3AtbGV2ZWwgaW5wdXQgZXZlbnQgaGFuZGxlciAoZS5nLiBgb25MYXllckNsaWNrYCksICcgK1xuICAgICAgICAgICAgJ2J1dCBub25lIG9mIHlvdXIgbGF5ZXJzIGhhdmUgc2V0IHRoZSBgcGlja2FibGVgIGZsYWcuJ1xuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSb3V0ZSBjbGljayBldmVudHMgdG8gbGF5ZXJzLlxuICAgKiBgcGlja0xheWVyYCB3aWxsIGNhbGwgdGhlIGBvbkNsaWNrYCBwcm9wIG9mIGFueSBwaWNrZWQgbGF5ZXIsXG4gICAqIGFuZCBgb25MYXllckNsaWNrYCBpcyBjYWxsZWQgZGlyZWN0bHkgZnJvbSBoZXJlXG4gICAqIHdpdGggYW55IHBpY2tpbmcgaW5mbyBnZW5lcmF0ZWQgYnkgYHBpY2tMYXllcmAuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAgQW4gb2JqZWN0IGVuY2Fwc3VsYXRpbmcgYW4gaW5wdXQgZXZlbnQsXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgd2l0aCB0aGUgZm9sbG93aW5nIHNoYXBlOlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgIHtPYmplY3Q6IHt4LCB5fX0gb2Zmc2V0Q2VudGVyOiBjZW50ZXIgb2YgdGhlIGV2ZW50XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAge09iamVjdH0gc3JjRXZlbnQ6ICAgICAgICAgICAgIG5hdGl2ZSBKUyBFdmVudCBvYmplY3RcbiAgICovXG4gIF9vbkNsaWNrKGV2ZW50KSB7XG4gICAgaWYgKCFldmVudC5vZmZzZXRDZW50ZXIpIHtcbiAgICAgIC8vIERvIG5vdCB0cmlnZ2VyIG9uSG92ZXIgY2FsbGJhY2tzIHdoZW4gY2xpY2sgcG9zaXRpb24gaXMgaW52YWxpZC5cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fcGlja0FuZENhbGxiYWNrKHtcbiAgICAgIGNhbGxiYWNrOiB0aGlzLl9vbkxheWVyQ2xpY2ssXG4gICAgICBldmVudCxcbiAgICAgIG1vZGU6ICdjbGljaydcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSb3V0ZSBjbGljayBldmVudHMgdG8gbGF5ZXJzLlxuICAgKiBgcGlja0xheWVyYCB3aWxsIGNhbGwgdGhlIGBvbkhvdmVyYCBwcm9wIG9mIGFueSBwaWNrZWQgbGF5ZXIsXG4gICAqIGFuZCBgb25MYXllckhvdmVyYCBpcyBjYWxsZWQgZGlyZWN0bHkgZnJvbSBoZXJlXG4gICAqIHdpdGggYW55IHBpY2tpbmcgaW5mbyBnZW5lcmF0ZWQgYnkgYHBpY2tMYXllcmAuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAgQW4gb2JqZWN0IGVuY2Fwc3VsYXRpbmcgYW4gaW5wdXQgZXZlbnQsXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgd2l0aCB0aGUgZm9sbG93aW5nIHNoYXBlOlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgIHtPYmplY3Q6IHt4LCB5fX0gb2Zmc2V0Q2VudGVyOiBjZW50ZXIgb2YgdGhlIGV2ZW50XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAge09iamVjdH0gc3JjRXZlbnQ6ICAgICAgICAgICAgIG5hdGl2ZSBKUyBFdmVudCBvYmplY3RcbiAgICovXG4gIF9vblBvaW50ZXJNb3ZlKGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LmlzRG93bikge1xuICAgICAgLy8gRG8gbm90IHRyaWdnZXIgb25Ib3ZlciBjYWxsYmFja3MgaWYgbW91c2UgYnV0dG9uIGlzIGRvd24uXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX3BpY2tBbmRDYWxsYmFjayh7XG4gICAgICBjYWxsYmFjazogdGhpcy5fb25MYXllckhvdmVyLFxuICAgICAgZXZlbnQsXG4gICAgICBtb2RlOiAnaG92ZXInXG4gICAgfSk7XG4gIH1cblxuICBfb25Qb2ludGVyTGVhdmUoZXZlbnQpIHtcbiAgICB0aGlzLnBpY2tPYmplY3Qoe1xuICAgICAgeDogLTEsXG4gICAgICB5OiAtMSxcbiAgICAgIHJhZGl1czogdGhpcy5fcGlja2luZ1JhZGl1cyxcbiAgICAgIG1vZGU6ICdob3ZlcidcbiAgICB9KTtcbiAgfVxuXG4gIF9waWNrQW5kQ2FsbGJhY2sob3B0aW9ucykge1xuICAgIGNvbnN0IHBvcyA9IG9wdGlvbnMuZXZlbnQub2Zmc2V0Q2VudGVyO1xuICAgIGNvbnN0IHJhZGl1cyA9IHRoaXMuX3BpY2tpbmdSYWRpdXM7XG4gICAgY29uc3Qgc2VsZWN0ZWRJbmZvcyA9IHRoaXMucGlja09iamVjdCh7eDogcG9zLngsIHk6IHBvcy55LCByYWRpdXMsIG1vZGU6IG9wdGlvbnMubW9kZX0pO1xuICAgIGlmIChvcHRpb25zLmNhbGxiYWNrKSB7XG4gICAgICBjb25zdCBmaXJzdEluZm8gPSBzZWxlY3RlZEluZm9zLmZpbmQoaW5mbyA9PiBpbmZvLmluZGV4ID49IDApIHx8IG51bGw7XG4gICAgICAvLyBBcyBwZXIgZG9jdW1lbnRhdGlvbiwgc2VuZCBudWxsIHZhbHVlIHdoZW4gbm8gdmFsaWQgb2JqZWN0IGlzIHBpY2tlZC5cbiAgICAgIG9wdGlvbnMuY2FsbGJhY2soZmlyc3RJbmZvLCBzZWxlY3RlZEluZm9zLCBvcHRpb25zLmV2ZW50LnNyY0V2ZW50KTtcbiAgICB9XG4gIH1cblxuICAvLyBTRUVSIElOVEVHUkFUSU9OXG5cbiAgLyoqXG4gICAqIENhbGxlZCB1cG9uIFNlZXIgaW5pdGlhbGl6YXRpb24sIG1hbnVhbGx5IHNlbmRzIGxheWVycyBkYXRhLlxuICAgKi9cbiAgX2luaXRTZWVyKCkge1xuICAgIHRoaXMubGF5ZXJzLmZvckVhY2gobGF5ZXIgPT4ge1xuICAgICAgaW5pdExheWVySW5TZWVyKGxheWVyKTtcbiAgICAgIHVwZGF0ZUxheWVySW5TZWVyKGxheWVyKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBPbiBTZWVyIHByb3BlcnR5IGVkaXRpb24sIHNldCBvdmVycmlkZSBhbmQgdXBkYXRlIGxheWVycy5cbiAgICovXG4gIF9lZGl0U2VlcihwYXlsb2FkKSB7XG4gICAgaWYgKHBheWxvYWQudHlwZSAhPT0gJ2VkaXQnIHx8IHBheWxvYWQudmFsdWVQYXRoWzBdICE9PSAncHJvcHMnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgc2V0UHJvcE92ZXJyaWRlcyhwYXlsb2FkLml0ZW1LZXksIHBheWxvYWQudmFsdWVQYXRoLnNsaWNlKDEpLCBwYXlsb2FkLnZhbHVlKTtcbiAgICBjb25zdCBuZXdMYXllcnMgPSB0aGlzLmxheWVycy5tYXAobGF5ZXIgPT4gbmV3IGxheWVyLmNvbnN0cnVjdG9yKGxheWVyLnByb3BzKSk7XG4gICAgdGhpcy51cGRhdGVMYXllcnMoe25ld0xheWVyc30pO1xuICB9XG59XG4iXX0=