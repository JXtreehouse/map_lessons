var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

/* global window */
import { COORDINATE_SYSTEM, LIFECYCLE } from './constants';
import AttributeManager from './attribute-manager';
import Stats from './stats';
import { getDefaultProps, diffProps as _diffProps } from './props';
import { count } from '../utils/count';
import log from '../utils/log';
import { applyPropOverrides, removeLayerInSeer } from './seer-integration';
import { GL, withParameters } from 'luma.gl';
import assert from 'assert';

var LOG_PRIORITY_UPDATE = 1;

var EMPTY_ARRAY = [];
var EMPTY_PROPS = {};
Object.freeze(EMPTY_PROPS);
var noop = function noop() {};

var defaultProps = {
  // data: Special handling for null, see below
  dataComparator: null,
  updateTriggers: {}, // Update triggers: a core change detection mechanism in deck.gl
  numInstances: undefined,

  visible: true,
  pickable: false,
  opacity: 0.8,

  onHover: noop,
  onClick: noop,

  coordinateSystem: COORDINATE_SYSTEM.LNGLAT,
  coordinateOrigin: [0, 0, 0],

  parameters: {},
  uniforms: {},
  framebuffer: null,

  animation: null, // Passed prop animation functions to evaluate props

  // Offset depth based on layer index to avoid z-fighting.
  // Negative values pull layer towards the camera
  // https://www.opengl.org/archives/resources/faq/technical/polygonoffset.htm
  getPolygonOffset: function getPolygonOffset(_ref) {
    var layerIndex = _ref.layerIndex;
    return [0, -layerIndex * 100];
  },

  // Selection/Highlighting
  highlightedObjectIndex: null,
  autoHighlight: false,
  highlightColor: [0, 0, 128, 128]
};

var counter = 0;

var Layer = function () {
  function Layer(props) {
    _classCallCheck(this, Layer);

    // Call a helper function to merge the incoming props with defaults and freeze them.
    this.props = this._normalizeProps(props);

    // Define all members before layer is sealed
    this.id = this.props.id; // The layer's id, used for matching with layers from last render cycle
    this.oldProps = EMPTY_PROPS; // Props from last render used for change detection
    this.count = counter++; // Keep track of how many layer instances you are generating
    this.lifecycle = LIFECYCLE.NO_STATE; // Helps track and debug the life cycle of the layers
    this.state = null; // Will be set to the shared layer state object during layer matching
    this.context = null; // Will reference layer manager's context, contains state shared by layers
    this.parentLayer = null; // reference to the composite layer parent that rendered this layer

    // CompositeLayer members, need to be defined here because of the `Object.seal`
    this.internalState = null;

    // Seal the layer
    Object.seal(this);
  }

  _createClass(Layer, [{
    key: 'toString',
    value: function toString() {
      var className = this.constructor.layerName || this.constructor.name;
      return className + '({id: \'' + this.props.id + '\'})';
    }
  }, {
    key: 'needsUpdate',
    value: function needsUpdate() {
      // Call subclass lifecycle method
      return this.shouldUpdateState(this._getUpdateParams());
      // End lifecycle method
    }

    // Checks state of attributes and model

  }, {
    key: 'getNeedsRedraw',
    value: function getNeedsRedraw() {
      var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref2$clearRedrawFlag = _ref2.clearRedrawFlags,
          clearRedrawFlags = _ref2$clearRedrawFlag === undefined ? false : _ref2$clearRedrawFlag;

      return this._getNeedsRedraw(clearRedrawFlags);
    }

    // //////////////////////////////////////////////////
    // LIFECYCLE METHODS, overridden by the layer subclasses

    // Called once to set up the initial state
    // App can create WebGL resources

  }, {
    key: 'initializeState',
    value: function initializeState() {
      throw new Error('Layer ' + this + ' has not defined initializeState');
    }

    // Let's layer control if updateState should be called

  }, {
    key: 'shouldUpdateState',
    value: function shouldUpdateState(_ref3) {
      var oldProps = _ref3.oldProps,
          props = _ref3.props,
          oldContext = _ref3.oldContext,
          context = _ref3.context,
          changeFlags = _ref3.changeFlags;

      return changeFlags.propsOrDataChanged;
    }

    // Default implementation, all attributes will be invalidated and updated
    // when data changes

  }, {
    key: 'updateState',
    value: function updateState(_ref4) {
      var oldProps = _ref4.oldProps,
          props = _ref4.props,
          oldContext = _ref4.oldContext,
          context = _ref4.context,
          changeFlags = _ref4.changeFlags;
      var attributeManager = this.state.attributeManager;

      if (changeFlags.dataChanged && attributeManager) {
        attributeManager.invalidateAll();
      }
    }

    // Called once when layer is no longer matched and state will be discarded
    // App can destroy WebGL resources here

  }, {
    key: 'finalizeState',
    value: function finalizeState() {}

    // If state has a model, draw it with supplied uniforms

  }, {
    key: 'draw',
    value: function draw(opts) {
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = this.getModels()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var model = _step.value;

          model.draw(opts);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }

    // called to populate the info object that is passed to the event handler
    // @return null to cancel event

  }, {
    key: 'getPickingInfo',
    value: function getPickingInfo(_ref5) {
      var info = _ref5.info,
          mode = _ref5.mode;
      var index = info.index;


      if (index >= 0) {
        // If props.data is an indexable array, get the object
        if (Array.isArray(this.props.data)) {
          info.object = this.props.data[index];
        }
      }

      return info;
    }

    // END LIFECYCLE METHODS
    // //////////////////////////////////////////////////

    // Returns true if the layer is pickable and visible.

  }, {
    key: 'isPickable',
    value: function isPickable() {
      return this.props.pickable && this.props.visible;
    }

    // Default implementation of attribute invalidation, can be redefined

  }, {
    key: 'invalidateAttribute',
    value: function invalidateAttribute() {
      var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'all';
      var diffReason = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
      var attributeManager = this.state.attributeManager;

      if (!attributeManager) {
        return;
      }

      if (name === 'all') {
        log.log(LOG_PRIORITY_UPDATE, 'updateTriggers invalidating all attributes: ' + diffReason);
        attributeManager.invalidateAll();
      } else {
        log.log(LOG_PRIORITY_UPDATE, 'updateTriggers invalidating attribute ' + name + ': ' + diffReason);
        attributeManager.invalidate(name);
      }
    }

    // Calls attribute manager to update any WebGL attributes, can be redefined

  }, {
    key: 'updateAttributes',
    value: function updateAttributes(props) {
      var attributeManager = this.state.attributeManager;

      if (!attributeManager) {
        return;
      }

      // Figure out data length
      var numInstances = this.getNumInstances(props);

      attributeManager.update({
        data: props.data,
        numInstances: numInstances,
        props: props,
        buffers: props,
        context: this,
        // Don't worry about non-attribute props
        ignoreUnknownAttributes: true
      });

      // TODO - Use getModels?
      var model = this.state.model;

      if (model) {
        var changedAttributes = attributeManager.getChangedAttributes({ clearChangedFlags: true });
        model.setAttributes(changedAttributes);
      }
    }

    // Public API

    // Updates selected state members and marks the object for redraw

  }, {
    key: 'setState',
    value: function setState(updateObject) {
      Object.assign(this.state, updateObject);
      this.state.needsRedraw = true;
    }

    // Sets the redraw flag for this layer, will trigger a redraw next animation frame

  }, {
    key: 'setNeedsRedraw',
    value: function setNeedsRedraw() {
      var redraw = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

      if (this.state) {
        this.state.needsRedraw = redraw;
      }
    }

    // Return an array of models used by this layer, can be overriden by layer subclass

  }, {
    key: 'getModels',
    value: function getModels() {
      return this.state.models || (this.state.model ? [this.state.model] : []);
    }

    // PROJECTION METHODS

    /**
     * Projects a point with current map state (lat, lon, zoom, pitch, bearing)
     *
     * Note: Position conversion is done in shader, so in many cases there is no need
     * for this function
     * @param {Array|TypedArray} lngLat - long and lat values
     * @return {Array|TypedArray} - x, y coordinates
     */

  }, {
    key: 'project',
    value: function project(lngLat) {
      var viewport = this.context.viewport;

      assert(Array.isArray(lngLat), 'Layer.project needs [lng,lat]');
      return viewport.project(lngLat);
    }
  }, {
    key: 'unproject',
    value: function unproject(xy) {
      var viewport = this.context.viewport;

      assert(Array.isArray(xy), 'Layer.unproject needs [x,y]');
      return viewport.unproject(xy);
    }
  }, {
    key: 'projectFlat',
    value: function projectFlat(lngLat) {
      var viewport = this.context.viewport;

      assert(Array.isArray(lngLat), 'Layer.project needs [lng,lat]');
      return viewport.projectFlat(lngLat);
    }
  }, {
    key: 'unprojectFlat',
    value: function unprojectFlat(xy) {
      var viewport = this.context.viewport;

      assert(Array.isArray(xy), 'Layer.unproject needs [x,y]');
      return viewport.unprojectFlat(xy);
    }

    // TODO - needs to refer to context

  }, {
    key: 'screenToDevicePixels',
    value: function screenToDevicePixels(screenPixels) {
      log.deprecated('screenToDevicePixels', 'DeckGL prop useDevicePixels for conversion');
      var devicePixelRatio = typeof window !== 'undefined' ? window.devicePixelRatio : 1;
      return screenPixels * devicePixelRatio;
    }

    /**
     * Returns the picking color that doesn't match any subfeature
     * Use if some graphics do not belong to any pickable subfeature
     * @return {Array} - a black color
     */

  }, {
    key: 'nullPickingColor',
    value: function nullPickingColor() {
      return [0, 0, 0];
    }

    /**
     * Returns the picking color that doesn't match any subfeature
     * Use if some graphics do not belong to any pickable subfeature
     * @param {int} i - index to be decoded
     * @return {Array} - the decoded color
     */

  }, {
    key: 'encodePickingColor',
    value: function encodePickingColor(i) {
      assert((i + 1 >> 24 & 255) === 0, 'index out of picking color range');
      return [i + 1 & 255, i + 1 >> 8 & 255, i + 1 >> 8 >> 8 & 255];
    }

    /**
     * Returns the picking color that doesn't match any subfeature
     * Use if some graphics do not belong to any pickable subfeature
     * @param {Uint8Array} color - color array to be decoded
     * @return {Array} - the decoded picking color
     */

  }, {
    key: 'decodePickingColor',
    value: function decodePickingColor(color) {
      assert(color instanceof Uint8Array);

      var _color = _slicedToArray(color, 3),
          i1 = _color[0],
          i2 = _color[1],
          i3 = _color[2];
      // 1 was added to seperate from no selection


      var index = i1 + i2 * 256 + i3 * 65536 - 1;
      return index;
    }
  }, {
    key: 'calculateInstancePickingColors',
    value: function calculateInstancePickingColors(attribute, _ref6) {
      var numInstances = _ref6.numInstances;
      var value = attribute.value,
          size = attribute.size;
      // add 1 to index to seperate from no selection

      for (var i = 0; i < numInstances; i++) {
        var pickingColor = this.encodePickingColor(i);
        value[i * size + 0] = pickingColor[0];
        value[i * size + 1] = pickingColor[1];
        value[i * size + 2] = pickingColor[2];
      }
    }

    // DATA ACCESS API
    // Data can use iterators and may not be random access

    // Use iteration (the only required capability on data) to get first element

  }, {
    key: 'getFirstObject',
    value: function getFirstObject() {
      var data = this.props.data;
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = data[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var object = _step2.value;

          return object;
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      return null;
    }

    // INTERNAL METHODS

    // Deduces numer of instances. Intention is to support:
    // - Explicit setting of numInstances
    // - Auto-deduction for ES6 containers that define a size member
    // - Auto-deduction for Classic Arrays via the built-in length attribute
    // - Auto-deduction via arrays

  }, {
    key: 'getNumInstances',
    value: function getNumInstances(props) {
      props = props || this.props;

      // First check if the layer has set its own value
      if (this.state && this.state.numInstances !== undefined) {
        return this.state.numInstances;
      }

      // Check if app has provided an explicit value
      if (props.numInstances !== undefined) {
        return props.numInstances;
      }

      // Use container library to get a count for any ES6 container or object
      var _props = props,
          data = _props.data;

      return count(data);
    }

    // clone this layer with modified props

  }, {
    key: 'clone',
    value: function clone(newProps) {
      return new this.constructor(Object.assign({}, this.props, newProps));
    }

    // LAYER MANAGER API
    // Should only be called by the deck.gl LayerManager class

    // Called by layer manager when a new layer is found
    /* eslint-disable max-statements */

  }, {
    key: '_initialize',
    value: function _initialize() {
      assert(arguments.length === 0);
      assert(this.context.gl);
      assert(!this.state);

      var attributeManager = new AttributeManager({ id: this.props.id });
      // All instanced layers get instancePickingColors attribute by default
      // Their shaders can use it to render a picking scene
      // TODO - this slightly slows down non instanced layers
      attributeManager.addInstanced({
        instancePickingColors: {
          type: GL.UNSIGNED_BYTE,
          size: 3,
          update: this.calculateInstancePickingColors
        }
      });

      this.internalState = {
        subLayers: null, // reference to sublayers rendered in a previous cycle
        stats: new Stats({ id: 'draw' })
        // animatedProps: null, // Computing animated props requires layer manager state
        // TODO - move these fields here (risks breaking layers)
        // attributeManager,
        // needsRedraw: true,
      };

      this.state = {
        attributeManager: attributeManager,
        model: null,
        needsRedraw: true
      };

      // Call subclass lifecycle methods
      this.initializeState(this.context);
      // End subclass lifecycle methods

      // initializeState callback tends to clear state
      this.setChangeFlags({ dataChanged: true, propsChanged: true, viewportChanged: true });

      this._updateState(this._getUpdateParams());

      if (this.isComposite) {
        this._renderLayers(true);
      }

      var model = this.state.model;

      if (model) {
        model.id = this.props.id;
        model.program.id = this.props.id + '-program';
        model.geometry.id = this.props.id + '-geometry';
        model.setAttributes(attributeManager.getAttributes());
      }

      // Last but not least, update any sublayers
      if (this.isComposite) {
        this._renderLayers();
      }

      this.clearChangeFlags();
    }

    // Called by layer manager
    // if this layer is new (not matched with an existing layer) oldProps will be empty object

  }, {
    key: '_update',
    value: function _update() {
      assert(arguments.length === 0);

      // Call subclass lifecycle method
      var stateNeedsUpdate = this.needsUpdate();
      // End lifecycle method

      var updateParams = {
        props: this.props,
        oldProps: this.oldProps,
        context: this.context,
        oldContext: this.oldContext,
        changeFlags: this.internalState.changeFlags
      };

      if (stateNeedsUpdate) {
        this._updateState(updateParams);
      }

      // Render or update previously rendered sublayers
      if (this.isComposite) {
        this._renderLayers(stateNeedsUpdate);
      }

      this.clearChangeFlags();
    }
    /* eslint-enable max-statements */

  }, {
    key: '_updateState',
    value: function _updateState(updateParams) {
      // Call subclass lifecycle methods
      this.updateState(updateParams);
      // End subclass lifecycle methods

      // Add any subclass attributes
      this.updateAttributes(this.props);
      this._updateBaseUniforms();
      this._updateModuleSettings();

      // Note: Automatic instance count update only works for single layers
      if (this.state.model) {
        this.state.model.setInstanceCount(this.getNumInstances());
      }
    }

    // Called by manager when layer is about to be disposed
    // Note: not guaranteed to be called on application shutdown

  }, {
    key: '_finalize',
    value: function _finalize() {
      assert(arguments.length === 0);
      // Call subclass lifecycle method
      this.finalizeState(this.context);
      // End lifecycle method
      removeLayerInSeer(this.id);
    }

    // Calculates uniforms

  }, {
    key: 'drawLayer',
    value: function drawLayer(_ref7) {
      var _this = this;

      var _ref7$moduleParameter = _ref7.moduleParameters,
          moduleParameters = _ref7$moduleParameter === undefined ? null : _ref7$moduleParameter,
          _ref7$uniforms = _ref7.uniforms,
          uniforms = _ref7$uniforms === undefined ? {} : _ref7$uniforms,
          _ref7$parameters = _ref7.parameters,
          parameters = _ref7$parameters === undefined ? {} : _ref7$parameters;

      // TODO/ib - hack move to luma Model.draw
      if (moduleParameters) {
        var _iteratorNormalCompletion3 = true;
        var _didIteratorError3 = false;
        var _iteratorError3 = undefined;

        try {
          for (var _iterator3 = this.getModels()[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
            var model = _step3.value;

            model.updateModuleSettings(moduleParameters);
          }
        } catch (err) {
          _didIteratorError3 = true;
          _iteratorError3 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion3 && _iterator3.return) {
              _iterator3.return();
            }
          } finally {
            if (_didIteratorError3) {
              throw _iteratorError3;
            }
          }
        }
      }

      // Apply polygon offset to avoid z-fighting
      // TODO - move to draw-layers
      var getPolygonOffset = this.props.getPolygonOffset;

      var offsets = getPolygonOffset && getPolygonOffset(uniforms) || [0, 0];
      parameters.polygonOffset = offsets;

      // Call subclass lifecycle method
      withParameters(this.context.gl, parameters, function () {
        _this.draw({ moduleParameters: moduleParameters, uniforms: uniforms, parameters: parameters, context: _this.context });
      });
      // End lifecycle method
    }

    // {uniforms = {}, ...opts}

  }, {
    key: 'pickLayer',
    value: function pickLayer(opts) {
      // Call subclass lifecycle method
      return this.getPickingInfo(opts);
      // End lifecycle method
    }

    // Helper methods

  }, {
    key: 'getChangeFlags',
    value: function getChangeFlags() {
      return this.internalState.changeFlags;
    }

    // Dirty some change flags, will be handled by updateLayer
    /* eslint-disable complexity */

  }, {
    key: 'setChangeFlags',
    value: function setChangeFlags(flags) {
      var _this2 = this;

      this.internalState.changeFlags = this.internalState.changeFlags || {};
      var changeFlags = this.internalState.changeFlags;

      // Update primary flags
      if (flags.dataChanged && !changeFlags.dataChanged) {
        changeFlags.dataChanged = flags.dataChanged;
        log.log(LOG_PRIORITY_UPDATE + 1, function () {
          return 'dataChanged: ' + flags.dataChanged + ' in ' + _this2.id;
        });
      }
      if (flags.updateTriggersChanged && !changeFlags.updateTriggersChanged) {
        changeFlags.updateTriggersChanged = changeFlags.updateTriggersChanged && flags.updateTriggersChanged ? Object.assign({}, flags.updateTriggersChanged, changeFlags.updateTriggersChanged) : flags.updateTriggersChanged || changeFlags.updateTriggersChanged;
        log.log(LOG_PRIORITY_UPDATE + 1, function () {
          return 'updateTriggersChanged: ' + (Object.keys(flags.updateTriggersChanged).join(', ') + ' in ' + _this2.id);
        });
      }
      if (flags.propsChanged && !changeFlags.propsChanged) {
        changeFlags.propsChanged = flags.propsChanged;
        log.log(LOG_PRIORITY_UPDATE + 1, function () {
          return 'propsChanged: ' + flags.propsChanged + ' in ' + _this2.id;
        });
      }
      if (flags.viewportChanged && !changeFlags.viewportChanged) {
        changeFlags.viewportChanged = flags.viewportChanged;
        log.log(LOG_PRIORITY_UPDATE + 2, function () {
          return 'viewportChanged: ' + flags.viewportChanged + ' in ' + _this2.id;
        });
      }

      // Update composite flags
      var propsOrDataChanged = flags.dataChanged || flags.updateTriggersChanged || flags.propsChanged;
      changeFlags.propsOrDataChanged = changeFlags.propsOrDataChanged || propsOrDataChanged;
      changeFlags.somethingChanged = changeFlags.somethingChanged || propsOrDataChanged || flags.viewportChanged;
    }
    /* eslint-enable complexity */

    // Clear all changeFlags, typically after an update

  }, {
    key: 'clearChangeFlags',
    value: function clearChangeFlags() {
      this.internalState.changeFlags = {
        // Primary changeFlags, can be strings stating reason for change
        dataChanged: false,
        propsChanged: false,
        updateTriggersChanged: false,
        viewportChanged: false,

        // Derived changeFlags
        propsOrDataChanged: false,
        somethingChanged: false
      };
    }
  }, {
    key: 'printChangeFlags',
    value: function printChangeFlags() {
      var flags = this.internalState.changeFlags;
      return '' + (flags.dataChanged ? 'data ' : '') + (flags.propsChanged ? 'props ' : '') + (flags.updateTriggersChanged ? 'triggers ' : '') + (flags.viewportChanged ? 'viewport' : '');
    }

    // Compares the layers props with old props from a matched older layer
    // and extracts change flags that describe what has change so that state
    // can be update correctly with minimal effort
    // TODO - arguments for testing only

  }, {
    key: 'diffProps',
    value: function diffProps() {
      var newProps = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;
      var oldProps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.oldProps;

      var changeFlags = _diffProps(newProps, oldProps);

      // iterate over changedTriggers
      if (changeFlags.updateTriggersChanged) {
        for (var key in changeFlags.updateTriggersChanged) {
          if (changeFlags.updateTriggersChanged[key]) {
            this._activeUpdateTrigger(key);
          }
        }
      }

      return this.setChangeFlags(changeFlags);
    }

    // PRIVATE METHODS

  }, {
    key: '_getUpdateParams',
    value: function _getUpdateParams() {
      return {
        props: this.props,
        oldProps: this.oldProps,
        context: this.context,
        oldContext: this.oldContext || {},
        changeFlags: this.internalState.changeFlags
      };
    }

    // Checks state of attributes and model

  }, {
    key: '_getNeedsRedraw',
    value: function _getNeedsRedraw(clearRedrawFlags) {
      // this method may be called by the render loop as soon a the layer
      // has been created, so guard against uninitialized state
      if (!this.state) {
        return false;
      }

      var redraw = false;
      redraw = redraw || this.state.needsRedraw && this.id;
      this.state.needsRedraw = this.state.needsRedraw && !clearRedrawFlags;

      // TODO - is attribute manager needed? - Model should be enough.
      var attributeManager = this.state.attributeManager;

      var attributeManagerNeedsRedraw = attributeManager && attributeManager.getNeedsRedraw({ clearRedrawFlags: clearRedrawFlags });
      redraw = redraw || attributeManagerNeedsRedraw;

      var _iteratorNormalCompletion4 = true;
      var _didIteratorError4 = false;
      var _iteratorError4 = undefined;

      try {
        for (var _iterator4 = this.getModels()[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
          var model = _step4.value;

          var modelNeedsRedraw = model.getNeedsRedraw({ clearRedrawFlags: clearRedrawFlags });
          if (modelNeedsRedraw && typeof modelNeedsRedraw !== 'string') {
            modelNeedsRedraw = 'model ' + model.id;
          }
          redraw = redraw || modelNeedsRedraw;
        }
      } catch (err) {
        _didIteratorError4 = true;
        _iteratorError4 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion4 && _iterator4.return) {
            _iterator4.return();
          }
        } finally {
          if (_didIteratorError4) {
            throw _iteratorError4;
          }
        }
      }

      return redraw;
    }

    // Helper for constructor, merges props with default props and freezes them

  }, {
    key: '_normalizeProps',
    value: function _normalizeProps(props) {
      // If sublayer has static defaultProps member, getDefaultProps will return it
      var mergedDefaultProps = getDefaultProps(this);
      // Merge supplied props with pre-merged default props
      props = Object.assign({}, mergedDefaultProps, props);
      // Accept null as data - otherwise apps and layers need to add ugly checks
      // Use constant fallback so that data change is not triggered
      props.data = props.data || EMPTY_ARRAY;
      // Apply any overrides from the seer debug extension if it is active
      applyPropOverrides(props);
      // Props are immutable
      Object.freeze(props);
      return props;
    }

    // Called by layer manager to transfer state from an old layer

  }, {
    key: '_transferState',
    value: function _transferState(oldLayer) {
      var state = oldLayer.state,
          internalState = oldLayer.internalState,
          props = oldLayer.props;

      assert(state && internalState);

      // Move state
      state.layer = this;
      this.state = state;
      this.internalState = internalState;
      // Note: We keep the state ref on old layers to support async actions
      // oldLayer.state = null;

      // Keep a temporary ref to the old props, for prop comparison
      this.oldProps = props;

      // Update model layer reference
      var _iteratorNormalCompletion5 = true;
      var _didIteratorError5 = false;
      var _iteratorError5 = undefined;

      try {
        for (var _iterator5 = this.getModels()[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
          var model = _step5.value;

          model.userData.layer = this;
        }
      } catch (err) {
        _didIteratorError5 = true;
        _iteratorError5 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion5 && _iterator5.return) {
            _iterator5.return();
          }
        } finally {
          if (_didIteratorError5) {
            throw _iteratorError5;
          }
        }
      }

      this.diffProps();
    }

    // Operate on each changed triggers, will be called when an updateTrigger changes

  }, {
    key: '_activeUpdateTrigger',
    value: function _activeUpdateTrigger(propName) {
      this.invalidateAttribute(propName);
    }

    //  Helper to check that required props are supplied

  }, {
    key: '_checkRequiredProp',
    value: function _checkRequiredProp(propertyName, condition) {
      var value = this.props[propertyName];
      if (value === undefined) {
        throw new Error('Property ' + propertyName + ' undefined in layer ' + this);
      }
      if (condition && !condition(value)) {
        throw new Error('Bad property ' + propertyName + ' in layer ' + this);
      }
    }
  }, {
    key: '_updateBaseUniforms',
    value: function _updateBaseUniforms() {
      var uniforms = {
        // apply gamma to opacity to make it visually "linear"
        opacity: Math.pow(this.props.opacity, 1 / 2.2),
        ONE: 1.0
      };
      var _iteratorNormalCompletion6 = true;
      var _didIteratorError6 = false;
      var _iteratorError6 = undefined;

      try {
        for (var _iterator6 = this.getModels()[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
          var model = _step6.value;

          model.setUniforms(uniforms);
        }

        // TODO - set needsRedraw on the model(s)?
      } catch (err) {
        _didIteratorError6 = true;
        _iteratorError6 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion6 && _iterator6.return) {
            _iterator6.return();
          }
        } finally {
          if (_didIteratorError6) {
            throw _iteratorError6;
          }
        }
      }

      this.state.needsRedraw = true;
    }
  }, {
    key: '_updateModuleSettings',
    value: function _updateModuleSettings() {
      var settings = {
        pickingHighlightColor: this.props.highlightColor
      };
      var _iteratorNormalCompletion7 = true;
      var _didIteratorError7 = false;
      var _iteratorError7 = undefined;

      try {
        for (var _iterator7 = this.getModels()[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
          var model = _step7.value;

          model.updateModuleSettings(settings);
        }
      } catch (err) {
        _didIteratorError7 = true;
        _iteratorError7 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion7 && _iterator7.return) {
            _iterator7.return();
          }
        } finally {
          if (_didIteratorError7) {
            throw _iteratorError7;
          }
        }
      }
    }

    // DEPRECATED METHODS

    // Updates selected state members and marks the object for redraw

  }, {
    key: 'setUniforms',
    value: function setUniforms(uniformMap) {
      var _iteratorNormalCompletion8 = true;
      var _didIteratorError8 = false;
      var _iteratorError8 = undefined;

      try {
        for (var _iterator8 = this.getModels()[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
          var model = _step8.value;

          model.setUniforms(uniformMap);
        }

        // TODO - set needsRedraw on the model(s)?
      } catch (err) {
        _didIteratorError8 = true;
        _iteratorError8 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion8 && _iterator8.return) {
            _iterator8.return();
          }
        } finally {
          if (_didIteratorError8) {
            throw _iteratorError8;
          }
        }
      }

      this.state.needsRedraw = true;
      log.deprecated('layer.setUniforms', 'model.setUniforms');
    }
  }, {
    key: 'stats',
    get: function get() {
      return this.internalState.stats;
    }
  }]);

  return Layer;
}();

export default Layer;


Layer.layerName = 'Layer';
Layer.propTypes = defaultProps;
Layer.defaultProps = defaultProps;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9jb3JlL2xpYi9sYXllci5qcyJdLCJuYW1lcyI6WyJDT09SRElOQVRFX1NZU1RFTSIsIkxJRkVDWUNMRSIsIkF0dHJpYnV0ZU1hbmFnZXIiLCJTdGF0cyIsImdldERlZmF1bHRQcm9wcyIsImRpZmZQcm9wcyIsImNvdW50IiwibG9nIiwiYXBwbHlQcm9wT3ZlcnJpZGVzIiwicmVtb3ZlTGF5ZXJJblNlZXIiLCJHTCIsIndpdGhQYXJhbWV0ZXJzIiwiYXNzZXJ0IiwiTE9HX1BSSU9SSVRZX1VQREFURSIsIkVNUFRZX0FSUkFZIiwiRU1QVFlfUFJPUFMiLCJPYmplY3QiLCJmcmVlemUiLCJub29wIiwiZGVmYXVsdFByb3BzIiwiZGF0YUNvbXBhcmF0b3IiLCJ1cGRhdGVUcmlnZ2VycyIsIm51bUluc3RhbmNlcyIsInVuZGVmaW5lZCIsInZpc2libGUiLCJwaWNrYWJsZSIsIm9wYWNpdHkiLCJvbkhvdmVyIiwib25DbGljayIsImNvb3JkaW5hdGVTeXN0ZW0iLCJMTkdMQVQiLCJjb29yZGluYXRlT3JpZ2luIiwicGFyYW1ldGVycyIsInVuaWZvcm1zIiwiZnJhbWVidWZmZXIiLCJhbmltYXRpb24iLCJnZXRQb2x5Z29uT2Zmc2V0IiwibGF5ZXJJbmRleCIsImhpZ2hsaWdodGVkT2JqZWN0SW5kZXgiLCJhdXRvSGlnaGxpZ2h0IiwiaGlnaGxpZ2h0Q29sb3IiLCJjb3VudGVyIiwiTGF5ZXIiLCJwcm9wcyIsIl9ub3JtYWxpemVQcm9wcyIsImlkIiwib2xkUHJvcHMiLCJsaWZlY3ljbGUiLCJOT19TVEFURSIsInN0YXRlIiwiY29udGV4dCIsInBhcmVudExheWVyIiwiaW50ZXJuYWxTdGF0ZSIsInNlYWwiLCJjbGFzc05hbWUiLCJjb25zdHJ1Y3RvciIsImxheWVyTmFtZSIsIm5hbWUiLCJzaG91bGRVcGRhdGVTdGF0ZSIsIl9nZXRVcGRhdGVQYXJhbXMiLCJjbGVhclJlZHJhd0ZsYWdzIiwiX2dldE5lZWRzUmVkcmF3IiwiRXJyb3IiLCJvbGRDb250ZXh0IiwiY2hhbmdlRmxhZ3MiLCJwcm9wc09yRGF0YUNoYW5nZWQiLCJhdHRyaWJ1dGVNYW5hZ2VyIiwiZGF0YUNoYW5nZWQiLCJpbnZhbGlkYXRlQWxsIiwib3B0cyIsImdldE1vZGVscyIsIm1vZGVsIiwiZHJhdyIsImluZm8iLCJtb2RlIiwiaW5kZXgiLCJBcnJheSIsImlzQXJyYXkiLCJkYXRhIiwib2JqZWN0IiwiZGlmZlJlYXNvbiIsImludmFsaWRhdGUiLCJnZXROdW1JbnN0YW5jZXMiLCJ1cGRhdGUiLCJidWZmZXJzIiwiaWdub3JlVW5rbm93bkF0dHJpYnV0ZXMiLCJjaGFuZ2VkQXR0cmlidXRlcyIsImdldENoYW5nZWRBdHRyaWJ1dGVzIiwiY2xlYXJDaGFuZ2VkRmxhZ3MiLCJzZXRBdHRyaWJ1dGVzIiwidXBkYXRlT2JqZWN0IiwiYXNzaWduIiwibmVlZHNSZWRyYXciLCJyZWRyYXciLCJtb2RlbHMiLCJsbmdMYXQiLCJ2aWV3cG9ydCIsInByb2plY3QiLCJ4eSIsInVucHJvamVjdCIsInByb2plY3RGbGF0IiwidW5wcm9qZWN0RmxhdCIsInNjcmVlblBpeGVscyIsImRlcHJlY2F0ZWQiLCJkZXZpY2VQaXhlbFJhdGlvIiwid2luZG93IiwiaSIsImNvbG9yIiwiVWludDhBcnJheSIsImkxIiwiaTIiLCJpMyIsImF0dHJpYnV0ZSIsInZhbHVlIiwic2l6ZSIsInBpY2tpbmdDb2xvciIsImVuY29kZVBpY2tpbmdDb2xvciIsIm5ld1Byb3BzIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwiZ2wiLCJhZGRJbnN0YW5jZWQiLCJpbnN0YW5jZVBpY2tpbmdDb2xvcnMiLCJ0eXBlIiwiVU5TSUdORURfQllURSIsImNhbGN1bGF0ZUluc3RhbmNlUGlja2luZ0NvbG9ycyIsInN1YkxheWVycyIsInN0YXRzIiwiaW5pdGlhbGl6ZVN0YXRlIiwic2V0Q2hhbmdlRmxhZ3MiLCJwcm9wc0NoYW5nZWQiLCJ2aWV3cG9ydENoYW5nZWQiLCJfdXBkYXRlU3RhdGUiLCJpc0NvbXBvc2l0ZSIsIl9yZW5kZXJMYXllcnMiLCJwcm9ncmFtIiwiZ2VvbWV0cnkiLCJnZXRBdHRyaWJ1dGVzIiwiY2xlYXJDaGFuZ2VGbGFncyIsInN0YXRlTmVlZHNVcGRhdGUiLCJuZWVkc1VwZGF0ZSIsInVwZGF0ZVBhcmFtcyIsInVwZGF0ZVN0YXRlIiwidXBkYXRlQXR0cmlidXRlcyIsIl91cGRhdGVCYXNlVW5pZm9ybXMiLCJfdXBkYXRlTW9kdWxlU2V0dGluZ3MiLCJzZXRJbnN0YW5jZUNvdW50IiwiZmluYWxpemVTdGF0ZSIsIm1vZHVsZVBhcmFtZXRlcnMiLCJ1cGRhdGVNb2R1bGVTZXR0aW5ncyIsIm9mZnNldHMiLCJwb2x5Z29uT2Zmc2V0IiwiZ2V0UGlja2luZ0luZm8iLCJmbGFncyIsInVwZGF0ZVRyaWdnZXJzQ2hhbmdlZCIsImtleXMiLCJqb2luIiwic29tZXRoaW5nQ2hhbmdlZCIsImtleSIsIl9hY3RpdmVVcGRhdGVUcmlnZ2VyIiwiYXR0cmlidXRlTWFuYWdlck5lZWRzUmVkcmF3IiwiZ2V0TmVlZHNSZWRyYXciLCJtb2RlbE5lZWRzUmVkcmF3IiwibWVyZ2VkRGVmYXVsdFByb3BzIiwib2xkTGF5ZXIiLCJsYXllciIsInVzZXJEYXRhIiwicHJvcE5hbWUiLCJpbnZhbGlkYXRlQXR0cmlidXRlIiwicHJvcGVydHlOYW1lIiwiY29uZGl0aW9uIiwiTWF0aCIsInBvdyIsIk9ORSIsInNldFVuaWZvcm1zIiwic2V0dGluZ3MiLCJwaWNraW5nSGlnaGxpZ2h0Q29sb3IiLCJ1bmlmb3JtTWFwIiwicHJvcFR5cGVzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVFBLGlCQUFSLEVBQTJCQyxTQUEzQixRQUEyQyxhQUEzQztBQUNBLE9BQU9DLGdCQUFQLE1BQTZCLHFCQUE3QjtBQUNBLE9BQU9DLEtBQVAsTUFBa0IsU0FBbEI7QUFD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LElBQXpCO0FBQ0Q7Ozs0Q0FFdUI7QUFDdEIsVUFBTW1GLFdBQVc7QUFDZkMsK0JBQXVCLEtBQUtySSxLQUFMLENBQVdIO0FBRG5CLE9BQWpCO0FBRHNCO0FBQUE7QUFBQTs7QUFBQTtBQUl0Qiw4QkFBb0IsS0FBSzhCLFNBQUwsRUFBcEIsbUlBQXNDO0FBQUEsY0FBM0JDLEtBQTJCOztBQUNwQ0EsZ0JBQU04RSxvQkFBTixDQUEyQjBCLFFBQTNCO0FBQ0Q7QUFOcUI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQU92Qjs7QUFFRDs7QUFFQTs7OztnQ0FDWUUsVSxFQUFZO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQ3RCLDhCQUFvQixLQUFLM0csU0FBTCxFQUFwQixtSUFBc0M7QUFBQSxjQUEzQkMsS0FBMkI7O0FBQ3BDQSxnQkFBTXVHLFdBQU4sQ0FBa0JHLFVBQWxCO0FBQ0Q7O0FBRUQ7QUFMc0I7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFNdEIsV0FBS2hJLEtBQUwsQ0FBVzJDLFdBQVgsR0FBeUIsSUFBekI7QUFDQXJGLFVBQUlnRyxVQUFKLENBQWUsbUJBQWYsRUFBb0MsbUJBQXBDO0FBQ0Q7Ozt3QkE5bkJXO0FBQ1YsYUFBTyxLQUFLbkQsYUFBTCxDQUFtQjJFLEtBQTFCO0FBQ0Q7Ozs7OztlQTVCa0JyRixLOzs7QUEycEJyQkEsTUFBTWMsU0FBTixHQUFrQixPQUFsQjtBQUNBZCxNQUFNd0ksU0FBTixHQUFrQi9KLFlBQWxCO0FBQ0F1QixNQUFNdkIsWUFBTixHQUFxQkEsWUFBckIiLCJmaWxlIjoibGF5ZXIuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIDIwMTUgLSAyMDE3IFViZXIgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbi8vIFRIRSBTT0ZUV0FSRS5cblxuLyogZ2xvYmFsIHdpbmRvdyAqL1xuaW1wb3J0IHtDT09SRElOQVRFX1NZU1RFTSwgTElGRUNZQ0xFfSBmcm9tICcuL2NvbnN0YW50cyc7XG5pbXBvcnQgQXR0cmlidXRlTWFuYWdlciBmcm9tICcuL2F0dHJpYnV0ZS1tYW5hZ2VyJztcbmltcG9ydCBTdGF0cyBmcm9tICcuL3N0YXRzJztcbmltcG9ydCB7Z2V0RGVmYXVsdFByb3BzLCBkaWZmUHJvcHN9IGZyb20gJy4vcHJvcHMnO1xuaW1wb3J0IHtjb3VudH0gZnJvbSAnLi4vdXRpbHMvY291bnQnO1xuaW1wb3J0IGxvZyBmcm9tICcuLi91dGlscy9sb2cnO1xuaW1wb3J0IHthcHBseVByb3BPdmVycmlkZXMsIHJlbW92ZUxheWVySW5TZWVyfSBmcm9tICcuL3NlZXItaW50ZWdyYXRpb24nO1xuaW1wb3J0IHtHTCwgd2l0aFBhcmFtZXRlcnN9IGZyb20gJ2x1bWEuZ2wnO1xuaW1wb3J0IGFzc2VydCBmcm9tICdhc3NlcnQnO1xuXG5jb25zdCBMT0dfUFJJT1JJVFlfVVBEQVRFID0gMTtcblxuY29uc3QgRU1QVFlfQVJSQVkgPSBbXTtcbmNvbnN0IEVNUFRZX1BST1BTID0ge307XG5PYmplY3QuZnJlZXplKEVNUFRZX1BST1BTKTtcbmNvbnN0IG5vb3AgPSAoKSA9PiB7fTtcblxuY29uc3QgZGVmYXVsdFByb3BzID0ge1xuICAvLyBkYXRhOiBTcGVjaWFsIGhhbmRsaW5nIGZvciBudWxsLCBzZWUgYmVsb3dcbiAgZGF0YUNvbXBhcmF0b3I6IG51bGwsXG4gIHVwZGF0ZVRyaWdnZXJzOiB7fSwgLy8gVXBkYXRlIHRyaWdnZXJzOiBhIGNvcmUgY2hhbmdlIGRldGVjdGlvbiBtZWNoYW5pc20gaW4gZGVjay5nbFxuICBudW1JbnN0YW5jZXM6IHVuZGVmaW5lZCxcblxuICB2aXNpYmxlOiB0cnVlLFxuICBwaWNrYWJsZTogZmFsc2UsXG4gIG9wYWNpdHk6IDAuOCxcblxuICBvbkhvdmVyOiBub29wLFxuICBvbkNsaWNrOiBub29wLFxuXG4gIGNvb3JkaW5hdGVTeXN0ZW06IENPT1JESU5BVEVfU1lTVEVNLkxOR0xBVCxcbiAgY29vcmRpbmF0ZU9yaWdpbjogWzAsIDAsIDBdLFxuXG4gIHBhcmFtZXRlcnM6IHt9LFxuICB1bmlmb3Jtczoge30sXG4gIGZyYW1lYnVmZmVyOiBudWxsLFxuXG4gIGFuaW1hdGlvbjogbnVsbCwgLy8gUGFzc2VkIHByb3AgYW5pbWF0aW9uIGZ1bmN0aW9ucyB0byBldmFsdWF0ZSBwcm9wc1xuXG4gIC8vIE9mZnNldCBkZXB0aCBiYXNlZCBvbiBsYXllciBpbmRleCB0byBhdm9pZCB6LWZpZ2h0aW5nLlxuICAvLyBOZWdhdGl2ZSB2YWx1ZXMgcHVsbCBsYXllciB0b3dhcmRzIHRoZSBjYW1lcmFcbiAgLy8gaHR0cHM6Ly93d3cub3BlbmdsLm9yZy9hcmNoaXZlcy9yZXNvdXJjZXMvZmFxL3RlY2huaWNhbC9wb2x5Z29ub2Zmc2V0Lmh0bVxuICBnZXRQb2x5Z29uT2Zmc2V0OiAoe2xheWVySW5kZXh9KSA9PiBbMCwgLWxheWVySW5kZXggKiAxMDBdLFxuXG4gIC8vIFNlbGVjdGlvbi9IaWdobGlnaHRpbmdcbiAgaGlnaGxpZ2h0ZWRPYmplY3RJbmRleDogbnVsbCxcbiAgYXV0b0hpZ2hsaWdodDogZmFsc2UsXG4gIGhpZ2hsaWdodENvbG9yOiBbMCwgMCwgMTI4LCAxMjhdXG59O1xuXG5sZXQgY291bnRlciA9IDA7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExheWVyIHtcbiAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICAvLyBDYWxsIGEgaGVscGVyIGZ1bmN0aW9uIHRvIG1lcmdlIHRoZSBpbmNvbWluZyBwcm9wcyB3aXRoIGRlZmF1bHRzIGFuZCBmcmVlemUgdGhlbS5cbiAgICB0aGlzLnByb3BzID0gdGhpcy5fbm9ybWFsaXplUHJvcHMocHJvcHMpO1xuXG4gICAgLy8gRGVmaW5lIGFsbCBtZW1iZXJzIGJlZm9yZSBsYXllciBpcyBzZWFsZWRcbiAgICB0aGlzLmlkID0gdGhpcy5wcm9wcy5pZDsgLy8gVGhlIGxheWVyJ3MgaWQsIHVzZWQgZm9yIG1hdGNoaW5nIHdpdGggbGF5ZXJzIGZyb20gbGFzdCByZW5kZXIgY3ljbGVcbiAgICB0aGlzLm9sZFByb3BzID0gRU1QVFlfUFJPUFM7IC8vIFByb3BzIGZyb20gbGFzdCByZW5kZXIgdXNlZCBmb3IgY2hhbmdlIGRldGVjdGlvblxuICAgIHRoaXMuY291bnQgPSBjb3VudGVyKys7IC8vIEtlZXAgdHJhY2sgb2YgaG93IG1hbnkgbGF5ZXIgaW5zdGFuY2VzIHlvdSBhcmUgZ2VuZXJhdGluZ1xuICAgIHRoaXMubGlmZWN5Y2xlID0gTElGRUNZQ0xFLk5PX1NUQVRFOyAvLyBIZWxwcyB0cmFjayBhbmQgZGVidWcgdGhlIGxpZmUgY3ljbGUgb2YgdGhlIGxheWVyc1xuICAgIHRoaXMuc3RhdGUgPSBudWxsOyAvLyBXaWxsIGJlIHNldCB0byB0aGUgc2hhcmVkIGxheWVyIHN0YXRlIG9iamVjdCBkdXJpbmcgbGF5ZXIgbWF0Y2hpbmdcbiAgICB0aGlzLmNvbnRleHQgPSBudWxsOyAvLyBXaWxsIHJlZmVyZW5jZSBsYXllciBtYW5hZ2VyJ3MgY29udGV4dCwgY29udGFpbnMgc3RhdGUgc2hhcmVkIGJ5IGxheWVyc1xuICAgIHRoaXMucGFyZW50TGF5ZXIgPSBudWxsOyAvLyByZWZlcmVuY2UgdG8gdGhlIGNvbXBvc2l0ZSBsYXllciBwYXJlbnQgdGhhdCByZW5kZXJlZCB0aGlzIGxheWVyXG5cbiAgICAvLyBDb21wb3NpdGVMYXllciBtZW1iZXJzLCBuZWVkIHRvIGJlIGRlZmluZWQgaGVyZSBiZWNhdXNlIG9mIHRoZSBgT2JqZWN0LnNlYWxgXG4gICAgdGhpcy5pbnRlcm5hbFN0YXRlID0gbnVsbDtcblxuICAgIC8vIFNlYWwgdGhlIGxheWVyXG4gICAgT2JqZWN0LnNlYWwodGhpcyk7XG4gIH1cblxuICB0b1N0cmluZygpIHtcbiAgICBjb25zdCBjbGFzc05hbWUgPSB0aGlzLmNvbnN0cnVjdG9yLmxheWVyTmFtZSB8fCB0aGlzLmNvbnN0cnVjdG9yLm5hbWU7XG4gICAgcmV0dXJuIGAke2NsYXNzTmFtZX0oe2lkOiAnJHt0aGlzLnByb3BzLmlkfSd9KWA7XG4gIH1cblxuICBnZXQgc3RhdHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW50ZXJuYWxTdGF0ZS5zdGF0cztcbiAgfVxuXG4gIG5lZWRzVXBkYXRlKCkge1xuICAgIC8vIENhbGwgc3ViY2xhc3MgbGlmZWN5Y2xlIG1ldGhvZFxuICAgIHJldHVybiB0aGlzLnNob3VsZFVwZGF0ZVN0YXRlKHRoaXMuX2dldFVwZGF0ZVBhcmFtcygpKTtcbiAgICAvLyBFbmQgbGlmZWN5Y2xlIG1ldGhvZFxuICB9XG5cbiAgLy8gQ2hlY2tzIHN0YXRlIG9mIGF0dHJpYnV0ZXMgYW5kIG1vZGVsXG4gIGdldE5lZWRzUmVkcmF3KHtjbGVhclJlZHJhd0ZsYWdzID0gZmFsc2V9ID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0TmVlZHNSZWRyYXcoY2xlYXJSZWRyYXdGbGFncyk7XG4gIH1cblxuICAvLyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAvLyBMSUZFQ1lDTEUgTUVUSE9EUywgb3ZlcnJpZGRlbiBieSB0aGUgbGF5ZXIgc3ViY2xhc3Nlc1xuXG4gIC8vIENhbGxlZCBvbmNlIHRvIHNldCB1cCB0aGUgaW5pdGlhbCBzdGF0ZVxuICAvLyBBcHAgY2FuIGNyZWF0ZSBXZWJHTCByZXNvdXJjZXNcbiAgaW5pdGlhbGl6ZVN0YXRlKCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgTGF5ZXIgJHt0aGlzfSBoYXMgbm90IGRlZmluZWQgaW5pdGlhbGl6ZVN0YXRlYCk7XG4gIH1cblxuICAvLyBMZXQncyBsYXllciBjb250cm9sIGlmIHVwZGF0ZVN0YXRlIHNob3VsZCBiZSBjYWxsZWRcbiAgc2hvdWxkVXBkYXRlU3RhdGUoe29sZFByb3BzLCBwcm9wcywgb2xkQ29udGV4dCwgY29udGV4dCwgY2hhbmdlRmxhZ3N9KSB7XG4gICAgcmV0dXJuIGNoYW5nZUZsYWdzLnByb3BzT3JEYXRhQ2hhbmdlZDtcbiAgfVxuXG4gIC8vIERlZmF1bHQgaW1wbGVtZW50YXRpb24sIGFsbCBhdHRyaWJ1dGVzIHdpbGwgYmUgaW52YWxpZGF0ZWQgYW5kIHVwZGF0ZWRcbiAgLy8gd2hlbiBkYXRhIGNoYW5nZXNcbiAgdXBkYXRlU3RhdGUoe29sZFByb3BzLCBwcm9wcywgb2xkQ29udGV4dCwgY29udGV4dCwgY2hhbmdlRmxhZ3N9KSB7XG4gICAgY29uc3Qge2F0dHJpYnV0ZU1hbmFnZXJ9ID0gdGhpcy5zdGF0ZTtcbiAgICBpZiAoY2hhbmdlRmxhZ3MuZGF0YUNoYW5nZWQgJiYgYXR0cmlidXRlTWFuYWdlcikge1xuICAgICAgYXR0cmlidXRlTWFuYWdlci5pbnZhbGlkYXRlQWxsKCk7XG4gICAgfVxuICB9XG5cbiAgLy8gQ2FsbGVkIG9uY2Ugd2hlbiBsYXllciBpcyBubyBsb25nZXIgbWF0Y2hlZCBhbmQgc3RhdGUgd2lsbCBiZSBkaXNjYXJkZWRcbiAgLy8gQXBwIGNhbiBkZXN0cm95IFdlYkdMIHJlc291cmNlcyBoZXJlXG4gIGZpbmFsaXplU3RhdGUoKSB7fVxuXG4gIC8vIElmIHN0YXRlIGhhcyBhIG1vZGVsLCBkcmF3IGl0IHdpdGggc3VwcGxpZWQgdW5pZm9ybXNcbiAgZHJhdyhvcHRzKSB7XG4gICAgZm9yIChjb25zdCBtb2RlbCBvZiB0aGlzLmdldE1vZGVscygpKSB7XG4gICAgICBtb2RlbC5kcmF3KG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIC8vIGNhbGxlZCB0byBwb3B1bGF0ZSB0aGUgaW5mbyBvYmplY3QgdGhhdCBpcyBwYXNzZWQgdG8gdGhlIGV2ZW50IGhhbmRsZXJcbiAgLy8gQHJldHVybiBudWxsIHRvIGNhbmNlbCBldmVudFxuICBnZXRQaWNraW5nSW5mbyh7aW5mbywgbW9kZX0pIHtcbiAgICBjb25zdCB7aW5kZXh9ID0gaW5mbztcblxuICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICAvLyBJZiBwcm9wcy5kYXRhIGlzIGFuIGluZGV4YWJsZSBhcnJheSwgZ2V0IHRoZSBvYmplY3RcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHRoaXMucHJvcHMuZGF0YSkpIHtcbiAgICAgICAgaW5mby5vYmplY3QgPSB0aGlzLnByb3BzLmRhdGFbaW5kZXhdO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBpbmZvO1xuICB9XG5cbiAgLy8gRU5EIExJRkVDWUNMRSBNRVRIT0RTXG4gIC8vIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbiAgLy8gUmV0dXJucyB0cnVlIGlmIHRoZSBsYXllciBpcyBwaWNrYWJsZSBhbmQgdmlzaWJsZS5cbiAgaXNQaWNrYWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5wcm9wcy5waWNrYWJsZSAmJiB0aGlzLnByb3BzLnZpc2libGU7XG4gIH1cblxuICAvLyBEZWZhdWx0IGltcGxlbWVudGF0aW9uIG9mIGF0dHJpYnV0ZSBpbnZhbGlkYXRpb24sIGNhbiBiZSByZWRlZmluZWRcbiAgaW52YWxpZGF0ZUF0dHJpYnV0ZShuYW1lID0gJ2FsbCcsIGRpZmZSZWFzb24gPSAnJykge1xuICAgIGNvbnN0IHthdHRyaWJ1dGVNYW5hZ2VyfSA9IHRoaXMuc3RhdGU7XG4gICAgaWYgKCFhdHRyaWJ1dGVNYW5hZ2VyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKG5hbWUgPT09ICdhbGwnKSB7XG4gICAgICBsb2cubG9nKExPR19QUklPUklUWV9VUERBVEUsIGB1cGRhdGVUcmlnZ2VycyBpbnZhbGlkYXRpbmcgYWxsIGF0dHJpYnV0ZXM6ICR7ZGlmZlJlYXNvbn1gKTtcbiAgICAgIGF0dHJpYnV0ZU1hbmFnZXIuaW52YWxpZGF0ZUFsbCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsb2cubG9nKExPR19QUklPUklUWV9VUERBVEUsIGB1cGRhdGVUcmlnZ2VycyBpbnZhbGlkYXRpbmcgYXR0cmlidXRlICR7bmFtZX06ICR7ZGlmZlJlYXNvbn1gKTtcbiAgICAgIGF0dHJpYnV0ZU1hbmFnZXIuaW52YWxpZGF0ZShuYW1lKTtcbiAgICB9XG4gIH1cblxuICAvLyBDYWxscyBhdHRyaWJ1dGUgbWFuYWdlciB0byB1cGRhdGUgYW55IFdlYkdMIGF0dHJpYnV0ZXMsIGNhbiBiZSByZWRlZmluZWRcbiAgdXBkYXRlQXR0cmlidXRlcyhwcm9wcykge1xuICAgIGNvbnN0IHthdHRyaWJ1dGVNYW5hZ2VyfSA9IHRoaXMuc3RhdGU7XG4gICAgaWYgKCFhdHRyaWJ1dGVNYW5hZ2VyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gRmlndXJlIG91dCBkYXRhIGxlbmd0aFxuICAgIGNvbnN0IG51bUluc3RhbmNlcyA9IHRoaXMuZ2V0TnVtSW5zdGFuY2VzKHByb3BzKTtcblxuICAgIGF0dHJpYnV0ZU1hbmFnZXIudXBkYXRlKHtcbiAgICAgIGRhdGE6IHByb3BzLmRhdGEsXG4gICAgICBudW1JbnN0YW5jZXMsXG4gICAgICBwcm9wcyxcbiAgICAgIGJ1ZmZlcnM6IHByb3BzLFxuICAgICAgY29udGV4dDogdGhpcyxcbiAgICAgIC8vIERvbid0IHdvcnJ5IGFib3V0IG5vbi1hdHRyaWJ1dGUgcHJvcHNcbiAgICAgIGlnbm9yZVVua25vd25BdHRyaWJ1dGVzOiB0cnVlXG4gICAgfSk7XG5cbiAgICAvLyBUT0RPIC0gVXNlIGdldE1vZGVscz9cbiAgICBjb25zdCB7bW9kZWx9ID0gdGhpcy5zdGF0ZTtcbiAgICBpZiAobW9kZWwpIHtcbiAgICAgIGNvbnN0IGNoYW5nZWRBdHRyaWJ1dGVzID0gYXR0cmlidXRlTWFuYWdlci5nZXRDaGFuZ2VkQXR0cmlidXRlcyh7Y2xlYXJDaGFuZ2VkRmxhZ3M6IHRydWV9KTtcbiAgICAgIG1vZGVsLnNldEF0dHJpYnV0ZXMoY2hhbmdlZEF0dHJpYnV0ZXMpO1xuICAgIH1cbiAgfVxuXG4gIC8vIFB1YmxpYyBBUElcblxuICAvLyBVcGRhdGVzIHNlbGVjdGVkIHN0YXRlIG1lbWJlcnMgYW5kIG1hcmtzIHRoZSBvYmplY3QgZm9yIHJlZHJhd1xuICBzZXRTdGF0ZSh1cGRhdGVPYmplY3QpIHtcbiAgICBPYmplY3QuYXNzaWduKHRoaXMuc3RhdGUsIHVwZGF0ZU9iamVjdCk7XG4gICAgdGhpcy5zdGF0ZS5uZWVkc1JlZHJhdyA9IHRydWU7XG4gIH1cblxuICAvLyBTZXRzIHRoZSByZWRyYXcgZmxhZyBmb3IgdGhpcyBsYXllciwgd2lsbCB0cmlnZ2VyIGEgcmVkcmF3IG5leHQgYW5pbWF0aW9uIGZyYW1lXG4gIHNldE5lZWRzUmVkcmF3KHJlZHJhdyA9IHRydWUpIHtcbiAgICBpZiAodGhpcy5zdGF0ZSkge1xuICAgICAgdGhpcy5zdGF0ZS5uZWVkc1JlZHJhdyA9IHJlZHJhdztcbiAgICB9XG4gIH1cblxuICAvLyBSZXR1cm4gYW4gYXJyYXkgb2YgbW9kZWxzIHVzZWQgYnkgdGhpcyBsYXllciwgY2FuIGJlIG92ZXJyaWRlbiBieSBsYXllciBzdWJjbGFzc1xuICBnZXRNb2RlbHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGUubW9kZWxzIHx8ICh0aGlzLnN0YXRlLm1vZGVsID8gW3RoaXMuc3RhdGUubW9kZWxdIDogW10pO1xuICB9XG5cbiAgLy8gUFJPSkVDVElPTiBNRVRIT0RTXG5cbiAgLyoqXG4gICAqIFByb2plY3RzIGEgcG9pbnQgd2l0aCBjdXJyZW50IG1hcCBzdGF0ZSAobGF0LCBsb24sIHpvb20sIHBpdGNoLCBiZWFyaW5nKVxuICAgKlxuICAgKiBOb3RlOiBQb3NpdGlvbiBjb252ZXJzaW9uIGlzIGRvbmUgaW4gc2hhZGVyLCBzbyBpbiBtYW55IGNhc2VzIHRoZXJlIGlzIG5vIG5lZWRcbiAgICogZm9yIHRoaXMgZnVuY3Rpb25cbiAgICogQHBhcmFtIHtBcnJheXxUeXBlZEFycmF5fSBsbmdMYXQgLSBsb25nIGFuZCBsYXQgdmFsdWVzXG4gICAqIEByZXR1cm4ge0FycmF5fFR5cGVkQXJyYXl9IC0geCwgeSBjb29yZGluYXRlc1xuICAgKi9cbiAgcHJvamVjdChsbmdMYXQpIHtcbiAgICBjb25zdCB7dmlld3BvcnR9ID0gdGhpcy5jb250ZXh0O1xuICAgIGFzc2VydChBcnJheS5pc0FycmF5KGxuZ0xhdCksICdMYXllci5wcm9qZWN0IG5lZWRzIFtsbmcsbGF0XScpO1xuICAgIHJldHVybiB2aWV3cG9ydC5wcm9qZWN0KGxuZ0xhdCk7XG4gIH1cblxuICB1bnByb2plY3QoeHkpIHtcbiAgICBjb25zdCB7dmlld3BvcnR9ID0gdGhpcy5jb250ZXh0O1xuICAgIGFzc2VydChBcnJheS5pc0FycmF5KHh5KSwgJ0xheWVyLnVucHJvamVjdCBuZWVkcyBbeCx5XScpO1xuICAgIHJldHVybiB2aWV3cG9ydC51bnByb2plY3QoeHkpO1xuICB9XG5cbiAgcHJvamVjdEZsYXQobG5nTGF0KSB7XG4gICAgY29uc3Qge3ZpZXdwb3J0fSA9IHRoaXMuY29udGV4dDtcbiAgICBhc3NlcnQoQXJyYXkuaXNBcnJheShsbmdMYXQpLCAnTGF5ZXIucHJvamVjdCBuZWVkcyBbbG5nLGxhdF0nKTtcbiAgICByZXR1cm4gdmlld3BvcnQucHJvamVjdEZsYXQobG5nTGF0KTtcbiAgfVxuXG4gIHVucHJvamVjdEZsYXQoeHkpIHtcbiAgICBjb25zdCB7dmlld3BvcnR9ID0gdGhpcy5jb250ZXh0O1xuICAgIGFzc2VydChBcnJheS5pc0FycmF5KHh5KSwgJ0xheWVyLnVucHJvamVjdCBuZWVkcyBbeCx5XScpO1xuICAgIHJldHVybiB2aWV3cG9ydC51bnByb2plY3RGbGF0KHh5KTtcbiAgfVxuXG4gIC8vIFRPRE8gLSBuZWVkcyB0byByZWZlciB0byBjb250ZXh0XG4gIHNjcmVlblRvRGV2aWNlUGl4ZWxzKHNjcmVlblBpeGVscykge1xuICAgIGxvZy5kZXByZWNhdGVkKCdzY3JlZW5Ub0RldmljZVBpeGVscycsICdEZWNrR0wgcHJvcCB1c2VEZXZpY2VQaXhlbHMgZm9yIGNvbnZlcnNpb24nKTtcbiAgICBjb25zdCBkZXZpY2VQaXhlbFJhdGlvID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyA6IDE7XG4gICAgcmV0dXJuIHNjcmVlblBpeGVscyAqIGRldmljZVBpeGVsUmF0aW87XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgcGlja2luZyBjb2xvciB0aGF0IGRvZXNuJ3QgbWF0Y2ggYW55IHN1YmZlYXR1cmVcbiAgICogVXNlIGlmIHNvbWUgZ3JhcGhpY3MgZG8gbm90IGJlbG9uZyB0byBhbnkgcGlja2FibGUgc3ViZmVhdHVyZVxuICAgKiBAcmV0dXJuIHtBcnJheX0gLSBhIGJsYWNrIGNvbG9yXG4gICAqL1xuICBudWxsUGlja2luZ0NvbG9yKCkge1xuICAgIHJldHVybiBbMCwgMCwgMF07XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgcGlja2luZyBjb2xvciB0aGF0IGRvZXNuJ3QgbWF0Y2ggYW55IHN1YmZlYXR1cmVcbiAgICogVXNlIGlmIHNvbWUgZ3JhcGhpY3MgZG8gbm90IGJlbG9uZyB0byBhbnkgcGlja2FibGUgc3ViZmVhdHVyZVxuICAgKiBAcGFyYW0ge2ludH0gaSAtIGluZGV4IHRvIGJlIGRlY29kZWRcbiAgICogQHJldHVybiB7QXJyYXl9IC0gdGhlIGRlY29kZWQgY29sb3JcbiAgICovXG4gIGVuY29kZVBpY2tpbmdDb2xvcihpKSB7XG4gICAgYXNzZXJ0KCgoKGkgKyAxKSA+PiAyNCkgJiAyNTUpID09PSAwLCAnaW5kZXggb3V0IG9mIHBpY2tpbmcgY29sb3IgcmFuZ2UnKTtcbiAgICByZXR1cm4gWyhpICsgMSkgJiAyNTUsICgoaSArIDEpID4+IDgpICYgMjU1LCAoKChpICsgMSkgPj4gOCkgPj4gOCkgJiAyNTVdO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHBpY2tpbmcgY29sb3IgdGhhdCBkb2Vzbid0IG1hdGNoIGFueSBzdWJmZWF0dXJlXG4gICAqIFVzZSBpZiBzb21lIGdyYXBoaWNzIGRvIG5vdCBiZWxvbmcgdG8gYW55IHBpY2thYmxlIHN1YmZlYXR1cmVcbiAgICogQHBhcmFtIHtVaW50OEFycmF5fSBjb2xvciAtIGNvbG9yIGFycmF5IHRvIGJlIGRlY29kZWRcbiAgICogQHJldHVybiB7QXJyYXl9IC0gdGhlIGRlY29kZWQgcGlja2luZyBjb2xvclxuICAgKi9cbiAgZGVjb2RlUGlja2luZ0NvbG9yKGNvbG9yKSB7XG4gICAgYXNzZXJ0KGNvbG9yIGluc3RhbmNlb2YgVWludDhBcnJheSk7XG4gICAgY29uc3QgW2kxLCBpMiwgaTNdID0gY29sb3I7XG4gICAgLy8gMSB3YXMgYWRkZWQgdG8gc2VwZXJhdGUgZnJvbSBubyBzZWxlY3Rpb25cbiAgICBjb25zdCBpbmRleCA9IGkxICsgaTIgKiAyNTYgKyBpMyAqIDY1NTM2IC0gMTtcbiAgICByZXR1cm4gaW5kZXg7XG4gIH1cblxuICBjYWxjdWxhdGVJbnN0YW5jZVBpY2tpbmdDb2xvcnMoYXR0cmlidXRlLCB7bnVtSW5zdGFuY2VzfSkge1xuICAgIGNvbnN0IHt2YWx1ZSwgc2l6ZX0gPSBhdHRyaWJ1dGU7XG4gICAgLy8gYWRkIDEgdG8gaW5kZXggdG8gc2VwZXJhdGUgZnJvbSBubyBzZWxlY3Rpb25cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bUluc3RhbmNlczsgaSsrKSB7XG4gICAgICBjb25zdCBwaWNraW5nQ29sb3IgPSB0aGlzLmVuY29kZVBpY2tpbmdDb2xvcihpKTtcbiAgICAgIHZhbHVlW2kgKiBzaXplICsgMF0gPSBwaWNraW5nQ29sb3JbMF07XG4gICAgICB2YWx1ZVtpICogc2l6ZSArIDFdID0gcGlja2luZ0NvbG9yWzFdO1xuICAgICAgdmFsdWVbaSAqIHNpemUgKyAyXSA9IHBpY2tpbmdDb2xvclsyXTtcbiAgICB9XG4gIH1cblxuICAvLyBEQVRBIEFDQ0VTUyBBUElcbiAgLy8gRGF0YSBjYW4gdXNlIGl0ZXJhdG9ycyBhbmQgbWF5IG5vdCBiZSByYW5kb20gYWNjZXNzXG5cbiAgLy8gVXNlIGl0ZXJhdGlvbiAodGhlIG9ubHkgcmVxdWlyZWQgY2FwYWJpbGl0eSBvbiBkYXRhKSB0byBnZXQgZmlyc3QgZWxlbWVudFxuICBnZXRGaXJzdE9iamVjdCgpIHtcbiAgICBjb25zdCB7ZGF0YX0gPSB0aGlzLnByb3BzO1xuICAgIGZvciAoY29uc3Qgb2JqZWN0IG9mIGRhdGEpIHtcbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gSU5URVJOQUwgTUVUSE9EU1xuXG4gIC8vIERlZHVjZXMgbnVtZXIgb2YgaW5zdGFuY2VzLiBJbnRlbnRpb24gaXMgdG8gc3VwcG9ydDpcbiAgLy8gLSBFeHBsaWNpdCBzZXR0aW5nIG9mIG51bUluc3RhbmNlc1xuICAvLyAtIEF1dG8tZGVkdWN0aW9uIGZvciBFUzYgY29udGFpbmVycyB0aGF0IGRlZmluZSBhIHNpemUgbWVtYmVyXG4gIC8vIC0gQXV0by1kZWR1Y3Rpb24gZm9yIENsYXNzaWMgQXJyYXlzIHZpYSB0aGUgYnVpbHQtaW4gbGVuZ3RoIGF0dHJpYnV0ZVxuICAvLyAtIEF1dG8tZGVkdWN0aW9uIHZpYSBhcnJheXNcbiAgZ2V0TnVtSW5zdGFuY2VzKHByb3BzKSB7XG4gICAgcHJvcHMgPSBwcm9wcyB8fCB0aGlzLnByb3BzO1xuXG4gICAgLy8gRmlyc3QgY2hlY2sgaWYgdGhlIGxheWVyIGhhcyBzZXQgaXRzIG93biB2YWx1ZVxuICAgIGlmICh0aGlzLnN0YXRlICYmIHRoaXMuc3RhdGUubnVtSW5zdGFuY2VzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLnN0YXRlLm51bUluc3RhbmNlcztcbiAgICB9XG5cbiAgICAvLyBDaGVjayBpZiBhcHAgaGFzIHByb3ZpZGVkIGFuIGV4cGxpY2l0IHZhbHVlXG4gICAgaWYgKHByb3BzLm51bUluc3RhbmNlcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gcHJvcHMubnVtSW5zdGFuY2VzO1xuICAgIH1cblxuICAgIC8vIFVzZSBjb250YWluZXIgbGlicmFyeSB0byBnZXQgYSBjb3VudCBmb3IgYW55IEVTNiBjb250YWluZXIgb3Igb2JqZWN0XG4gICAgY29uc3Qge2RhdGF9ID0gcHJvcHM7XG4gICAgcmV0dXJuIGNvdW50KGRhdGEpO1xuICB9XG5cbiAgLy8gY2xvbmUgdGhpcyBsYXllciB3aXRoIG1vZGlmaWVkIHByb3BzXG4gIGNsb25lKG5ld1Byb3BzKSB7XG4gICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKE9iamVjdC5hc3NpZ24oe30sIHRoaXMucHJvcHMsIG5ld1Byb3BzKSk7XG4gIH1cblxuICAvLyBMQVlFUiBNQU5BR0VSIEFQSVxuICAvLyBTaG91bGQgb25seSBiZSBjYWxsZWQgYnkgdGhlIGRlY2suZ2wgTGF5ZXJNYW5hZ2VyIGNsYXNzXG5cbiAgLy8gQ2FsbGVkIGJ5IGxheWVyIG1hbmFnZXIgd2hlbiBhIG5ldyBsYXllciBpcyBmb3VuZFxuICAvKiBlc2xpbnQtZGlzYWJsZSBtYXgtc3RhdGVtZW50cyAqL1xuICBfaW5pdGlhbGl6ZSgpIHtcbiAgICBhc3NlcnQoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCk7XG4gICAgYXNzZXJ0KHRoaXMuY29udGV4dC5nbCk7XG4gICAgYXNzZXJ0KCF0aGlzLnN0YXRlKTtcblxuICAgIGNvbnN0IGF0dHJpYnV0ZU1hbmFnZXIgPSBuZXcgQXR0cmlidXRlTWFuYWdlcih7aWQ6IHRoaXMucHJvcHMuaWR9KTtcbiAgICAvLyBBbGwgaW5zdGFuY2VkIGxheWVycyBnZXQgaW5zdGFuY2VQaWNraW5nQ29sb3JzIGF0dHJpYnV0ZSBieSBkZWZhdWx0XG4gICAgLy8gVGhlaXIgc2hhZGVycyBjYW4gdXNlIGl0IHRvIHJlbmRlciBhIHBpY2tpbmcgc2NlbmVcbiAgICAvLyBUT0RPIC0gdGhpcyBzbGlnaHRseSBzbG93cyBkb3duIG5vbiBpbnN0YW5jZWQgbGF5ZXJzXG4gICAgYXR0cmlidXRlTWFuYWdlci5hZGRJbnN0YW5jZWQoe1xuICAgICAgaW5zdGFuY2VQaWNraW5nQ29sb3JzOiB7XG4gICAgICAgIHR5cGU6IEdMLlVOU0lHTkVEX0JZVEUsXG4gICAgICAgIHNpemU6IDMsXG4gICAgICAgIHVwZGF0ZTogdGhpcy5jYWxjdWxhdGVJbnN0YW5jZVBpY2tpbmdDb2xvcnNcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHRoaXMuaW50ZXJuYWxTdGF0ZSA9IHtcbiAgICAgIHN1YkxheWVyczogbnVsbCwgLy8gcmVmZXJlbmNlIHRvIHN1YmxheWVycyByZW5kZXJlZCBpbiBhIHByZXZpb3VzIGN5Y2xlXG4gICAgICBzdGF0czogbmV3IFN0YXRzKHtpZDogJ2RyYXcnfSlcbiAgICAgIC8vIGFuaW1hdGVkUHJvcHM6IG51bGwsIC8vIENvbXB1dGluZyBhbmltYXRlZCBwcm9wcyByZXF1aXJlcyBsYXllciBtYW5hZ2VyIHN0YXRlXG4gICAgICAvLyBUT0RPIC0gbW92ZSB0aGVzZSBmaWVsZHMgaGVyZSAocmlza3MgYnJlYWtpbmcgbGF5ZXJzKVxuICAgICAgLy8gYXR0cmlidXRlTWFuYWdlcixcbiAgICAgIC8vIG5lZWRzUmVkcmF3OiB0cnVlLFxuICAgIH07XG5cbiAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgYXR0cmlidXRlTWFuYWdlcixcbiAgICAgIG1vZGVsOiBudWxsLFxuICAgICAgbmVlZHNSZWRyYXc6IHRydWVcbiAgICB9O1xuXG4gICAgLy8gQ2FsbCBzdWJjbGFzcyBsaWZlY3ljbGUgbWV0aG9kc1xuICAgIHRoaXMuaW5pdGlhbGl6ZVN0YXRlKHRoaXMuY29udGV4dCk7XG4gICAgLy8gRW5kIHN1YmNsYXNzIGxpZmVjeWNsZSBtZXRob2RzXG5cbiAgICAvLyBpbml0aWFsaXplU3RhdGUgY2FsbGJhY2sgdGVuZHMgdG8gY2xlYXIgc3RhdGVcbiAgICB0aGlzLnNldENoYW5nZUZsYWdzKHtkYXRhQ2hhbmdlZDogdHJ1ZSwgcHJvcHNDaGFuZ2VkOiB0cnVlLCB2aWV3cG9ydENoYW5nZWQ6IHRydWV9KTtcblxuICAgIHRoaXMuX3VwZGF0ZVN0YXRlKHRoaXMuX2dldFVwZGF0ZVBhcmFtcygpKTtcblxuICAgIGlmICh0aGlzLmlzQ29tcG9zaXRlKSB7XG4gICAgICB0aGlzLl9yZW5kZXJMYXllcnModHJ1ZSk7XG4gICAgfVxuXG4gICAgY29uc3Qge21vZGVsfSA9IHRoaXMuc3RhdGU7XG4gICAgaWYgKG1vZGVsKSB7XG4gICAgICBtb2RlbC5pZCA9IHRoaXMucHJvcHMuaWQ7XG4gICAgICBtb2RlbC5wcm9ncmFtLmlkID0gYCR7dGhpcy5wcm9wcy5pZH0tcHJvZ3JhbWA7XG4gICAgICBtb2RlbC5nZW9tZXRyeS5pZCA9IGAke3RoaXMucHJvcHMuaWR9LWdlb21ldHJ5YDtcbiAgICAgIG1vZGVsLnNldEF0dHJpYnV0ZXMoYXR0cmlidXRlTWFuYWdlci5nZXRBdHRyaWJ1dGVzKCkpO1xuICAgIH1cblxuICAgIC8vIExhc3QgYnV0IG5vdCBsZWFzdCwgdXBkYXRlIGFueSBzdWJsYXllcnNcbiAgICBpZiAodGhpcy5pc0NvbXBvc2l0ZSkge1xuICAgICAgdGhpcy5fcmVuZGVyTGF5ZXJzKCk7XG4gICAgfVxuXG4gICAgdGhpcy5jbGVhckNoYW5nZUZsYWdzKCk7XG4gIH1cblxuICAvLyBDYWxsZWQgYnkgbGF5ZXIgbWFuYWdlclxuICAvLyBpZiB0aGlzIGxheWVyIGlzIG5ldyAobm90IG1hdGNoZWQgd2l0aCBhbiBleGlzdGluZyBsYXllcikgb2xkUHJvcHMgd2lsbCBiZSBlbXB0eSBvYmplY3RcbiAgX3VwZGF0ZSgpIHtcbiAgICBhc3NlcnQoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCk7XG5cbiAgICAvLyBDYWxsIHN1YmNsYXNzIGxpZmVjeWNsZSBtZXRob2RcbiAgICBjb25zdCBzdGF0ZU5lZWRzVXBkYXRlID0gdGhpcy5uZWVkc1VwZGF0ZSgpO1xuICAgIC8vIEVuZCBsaWZlY3ljbGUgbWV0aG9kXG5cbiAgICBjb25zdCB1cGRhdGVQYXJhbXMgPSB7XG4gICAgICBwcm9wczogdGhpcy5wcm9wcyxcbiAgICAgIG9sZFByb3BzOiB0aGlzLm9sZFByb3BzLFxuICAgICAgY29udGV4dDogdGhpcy5jb250ZXh0LFxuICAgICAgb2xkQ29udGV4dDogdGhpcy5vbGRDb250ZXh0LFxuICAgICAgY2hhbmdlRmxhZ3M6IHRoaXMuaW50ZXJuYWxTdGF0ZS5jaGFuZ2VGbGFnc1xuICAgIH07XG5cbiAgICBpZiAoc3RhdGVOZWVkc1VwZGF0ZSkge1xuICAgICAgdGhpcy5fdXBkYXRlU3RhdGUodXBkYXRlUGFyYW1zKTtcbiAgICB9XG5cbiAgICAvLyBSZW5kZXIgb3IgdXBkYXRlIHByZXZpb3VzbHkgcmVuZGVyZWQgc3VibGF5ZXJzXG4gICAgaWYgKHRoaXMuaXNDb21wb3NpdGUpIHtcbiAgICAgIHRoaXMuX3JlbmRlckxheWVycyhzdGF0ZU5lZWRzVXBkYXRlKTtcbiAgICB9XG5cbiAgICB0aGlzLmNsZWFyQ2hhbmdlRmxhZ3MoKTtcbiAgfVxuICAvKiBlc2xpbnQtZW5hYmxlIG1heC1zdGF0ZW1lbnRzICovXG5cbiAgX3VwZGF0ZVN0YXRlKHVwZGF0ZVBhcmFtcykge1xuICAgIC8vIENhbGwgc3ViY2xhc3MgbGlmZWN5Y2xlIG1ldGhvZHNcbiAgICB0aGlzLnVwZGF0ZVN0YXRlKHVwZGF0ZVBhcmFtcyk7XG4gICAgLy8gRW5kIHN1YmNsYXNzIGxpZmVjeWNsZSBtZXRob2RzXG5cbiAgICAvLyBBZGQgYW55IHN1YmNsYXNzIGF0dHJpYnV0ZXNcbiAgICB0aGlzLnVwZGF0ZUF0dHJpYnV0ZXModGhpcy5wcm9wcyk7XG4gICAgdGhpcy5fdXBkYXRlQmFzZVVuaWZvcm1zKCk7XG4gICAgdGhpcy5fdXBkYXRlTW9kdWxlU2V0dGluZ3MoKTtcblxuICAgIC8vIE5vdGU6IEF1dG9tYXRpYyBpbnN0YW5jZSBjb3VudCB1cGRhdGUgb25seSB3b3JrcyBmb3Igc2luZ2xlIGxheWVyc1xuICAgIGlmICh0aGlzLnN0YXRlLm1vZGVsKSB7XG4gICAgICB0aGlzLnN0YXRlLm1vZGVsLnNldEluc3RhbmNlQ291bnQodGhpcy5nZXROdW1JbnN0YW5jZXMoKSk7XG4gICAgfVxuICB9XG5cbiAgLy8gQ2FsbGVkIGJ5IG1hbmFnZXIgd2hlbiBsYXllciBpcyBhYm91dCB0byBiZSBkaXNwb3NlZFxuICAvLyBOb3RlOiBub3QgZ3VhcmFudGVlZCB0byBiZSBjYWxsZWQgb24gYXBwbGljYXRpb24gc2h1dGRvd25cbiAgX2ZpbmFsaXplKCkge1xuICAgIGFzc2VydChhcmd1bWVudHMubGVuZ3RoID09PSAwKTtcbiAgICAvLyBDYWxsIHN1YmNsYXNzIGxpZmVjeWNsZSBtZXRob2RcbiAgICB0aGlzLmZpbmFsaXplU3RhdGUodGhpcy5jb250ZXh0KTtcbiAgICAvLyBFbmQgbGlmZWN5Y2xlIG1ldGhvZFxuICAgIHJlbW92ZUxheWVySW5TZWVyKHRoaXMuaWQpO1xuICB9XG5cbiAgLy8gQ2FsY3VsYXRlcyB1bmlmb3Jtc1xuICBkcmF3TGF5ZXIoe21vZHVsZVBhcmFtZXRlcnMgPSBudWxsLCB1bmlmb3JtcyA9IHt9LCBwYXJhbWV0ZXJzID0ge319KSB7XG4gICAgLy8gVE9ETy9pYiAtIGhhY2sgbW92ZSB0byBsdW1hIE1vZGVsLmRyYXdcbiAgICBpZiAobW9kdWxlUGFyYW1ldGVycykge1xuICAgICAgZm9yIChjb25zdCBtb2RlbCBvZiB0aGlzLmdldE1vZGVscygpKSB7XG4gICAgICAgIG1vZGVsLnVwZGF0ZU1vZHVsZVNldHRpbmdzKG1vZHVsZVBhcmFtZXRlcnMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEFwcGx5IHBvbHlnb24gb2Zmc2V0IHRvIGF2b2lkIHotZmlnaHRpbmdcbiAgICAvLyBUT0RPIC0gbW92ZSB0byBkcmF3LWxheWVyc1xuICAgIGNvbnN0IHtnZXRQb2x5Z29uT2Zmc2V0fSA9IHRoaXMucHJvcHM7XG4gICAgY29uc3Qgb2Zmc2V0cyA9IChnZXRQb2x5Z29uT2Zmc2V0ICYmIGdldFBvbHlnb25PZmZzZXQodW5pZm9ybXMpKSB8fCBbMCwgMF07XG4gICAgcGFyYW1ldGVycy5wb2x5Z29uT2Zmc2V0ID0gb2Zmc2V0cztcblxuICAgIC8vIENhbGwgc3ViY2xhc3MgbGlmZWN5Y2xlIG1ldGhvZFxuICAgIHdpdGhQYXJhbWV0ZXJzKHRoaXMuY29udGV4dC5nbCwgcGFyYW1ldGVycywgKCkgPT4ge1xuICAgICAgdGhpcy5kcmF3KHttb2R1bGVQYXJhbWV0ZXJzLCB1bmlmb3JtcywgcGFyYW1ldGVycywgY29udGV4dDogdGhpcy5jb250ZXh0fSk7XG4gICAgfSk7XG4gICAgLy8gRW5kIGxpZmVjeWNsZSBtZXRob2RcbiAgfVxuXG4gIC8vIHt1bmlmb3JtcyA9IHt9LCAuLi5vcHRzfVxuICBwaWNrTGF5ZXIob3B0cykge1xuICAgIC8vIENhbGwgc3ViY2xhc3MgbGlmZWN5Y2xlIG1ldGhvZFxuICAgIHJldHVybiB0aGlzLmdldFBpY2tpbmdJbmZvKG9wdHMpO1xuICAgIC8vIEVuZCBsaWZlY3ljbGUgbWV0aG9kXG4gIH1cblxuICAvLyBIZWxwZXIgbWV0aG9kc1xuICBnZXRDaGFuZ2VGbGFncygpIHtcbiAgICByZXR1cm4gdGhpcy5pbnRlcm5hbFN0YXRlLmNoYW5nZUZsYWdzO1xuICB9XG5cbiAgLy8gRGlydHkgc29tZSBjaGFuZ2UgZmxhZ3MsIHdpbGwgYmUgaGFuZGxlZCBieSB1cGRhdGVMYXllclxuICAvKiBlc2xpbnQtZGlzYWJsZSBjb21wbGV4aXR5ICovXG4gIHNldENoYW5nZUZsYWdzKGZsYWdzKSB7XG4gICAgdGhpcy5pbnRlcm5hbFN0YXRlLmNoYW5nZUZsYWdzID0gdGhpcy5pbnRlcm5hbFN0YXRlLmNoYW5nZUZsYWdzIHx8IHt9O1xuICAgIGNvbnN0IGNoYW5nZUZsYWdzID0gdGhpcy5pbnRlcm5hbFN0YXRlLmNoYW5nZUZsYWdzO1xuXG4gICAgLy8gVXBkYXRlIHByaW1hcnkgZmxhZ3NcbiAgICBpZiAoZmxhZ3MuZGF0YUNoYW5nZWQgJiYgIWNoYW5nZUZsYWdzLmRhdGFDaGFuZ2VkKSB7XG4gICAgICBjaGFuZ2VGbGFncy5kYXRhQ2hhbmdlZCA9IGZsYWdzLmRhdGFDaGFuZ2VkO1xuICAgICAgbG9nLmxvZyhMT0dfUFJJT1JJVFlfVVBEQVRFICsgMSwgKCkgPT4gYGRhdGFDaGFuZ2VkOiAke2ZsYWdzLmRhdGFDaGFuZ2VkfSBpbiAke3RoaXMuaWR9YCk7XG4gICAgfVxuICAgIGlmIChmbGFncy51cGRhdGVUcmlnZ2Vyc0NoYW5nZWQgJiYgIWNoYW5nZUZsYWdzLnVwZGF0ZVRyaWdnZXJzQ2hhbmdlZCkge1xuICAgICAgY2hhbmdlRmxhZ3MudXBkYXRlVHJpZ2dlcnNDaGFuZ2VkID1cbiAgICAgICAgY2hhbmdlRmxhZ3MudXBkYXRlVHJpZ2dlcnNDaGFuZ2VkICYmIGZsYWdzLnVwZGF0ZVRyaWdnZXJzQ2hhbmdlZFxuICAgICAgICAgID8gT2JqZWN0LmFzc2lnbih7fSwgZmxhZ3MudXBkYXRlVHJpZ2dlcnNDaGFuZ2VkLCBjaGFuZ2VGbGFncy51cGRhdGVUcmlnZ2Vyc0NoYW5nZWQpXG4gICAgICAgICAgOiBmbGFncy51cGRhdGVUcmlnZ2Vyc0NoYW5nZWQgfHwgY2hhbmdlRmxhZ3MudXBkYXRlVHJpZ2dlcnNDaGFuZ2VkO1xuICAgICAgbG9nLmxvZyhcbiAgICAgICAgTE9HX1BSSU9SSVRZX1VQREFURSArIDEsXG4gICAgICAgICgpID0+XG4gICAgICAgICAgJ3VwZGF0ZVRyaWdnZXJzQ2hhbmdlZDogJyArXG4gICAgICAgICAgYCR7T2JqZWN0LmtleXMoZmxhZ3MudXBkYXRlVHJpZ2dlcnNDaGFuZ2VkKS5qb2luKCcsICcpfSBpbiAke3RoaXMuaWR9YFxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKGZsYWdzLnByb3BzQ2hhbmdlZCAmJiAhY2hhbmdlRmxhZ3MucHJvcHNDaGFuZ2VkKSB7XG4gICAgICBjaGFuZ2VGbGFncy5wcm9wc0NoYW5nZWQgPSBmbGFncy5wcm9wc0NoYW5nZWQ7XG4gICAgICBsb2cubG9nKExPR19QUklPUklUWV9VUERBVEUgKyAxLCAoKSA9PiBgcHJvcHNDaGFuZ2VkOiAke2ZsYWdzLnByb3BzQ2hhbmdlZH0gaW4gJHt0aGlzLmlkfWApO1xuICAgIH1cbiAgICBpZiAoZmxhZ3Mudmlld3BvcnRDaGFuZ2VkICYmICFjaGFuZ2VGbGFncy52aWV3cG9ydENoYW5nZWQpIHtcbiAgICAgIGNoYW5nZUZsYWdzLnZpZXdwb3J0Q2hhbmdlZCA9IGZsYWdzLnZpZXdwb3J0Q2hhbmdlZDtcbiAgICAgIGxvZy5sb2coXG4gICAgICAgIExPR19QUklPUklUWV9VUERBVEUgKyAyLFxuICAgICAgICAoKSA9PiBgdmlld3BvcnRDaGFuZ2VkOiAke2ZsYWdzLnZpZXdwb3J0Q2hhbmdlZH0gaW4gJHt0aGlzLmlkfWBcbiAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gVXBkYXRlIGNvbXBvc2l0ZSBmbGFnc1xuICAgIGNvbnN0IHByb3BzT3JEYXRhQ2hhbmdlZCA9XG4gICAgICBmbGFncy5kYXRhQ2hhbmdlZCB8fCBmbGFncy51cGRhdGVUcmlnZ2Vyc0NoYW5nZWQgfHwgZmxhZ3MucHJvcHNDaGFuZ2VkO1xuICAgIGNoYW5nZUZsYWdzLnByb3BzT3JEYXRhQ2hhbmdlZCA9IGNoYW5nZUZsYWdzLnByb3BzT3JEYXRhQ2hhbmdlZCB8fCBwcm9wc09yRGF0YUNoYW5nZWQ7XG4gICAgY2hhbmdlRmxhZ3Muc29tZXRoaW5nQ2hhbmdlZCA9XG4gICAgICBjaGFuZ2VGbGFncy5zb21ldGhpbmdDaGFuZ2VkIHx8IHByb3BzT3JEYXRhQ2hhbmdlZCB8fCBmbGFncy52aWV3cG9ydENoYW5nZWQ7XG4gIH1cbiAgLyogZXNsaW50LWVuYWJsZSBjb21wbGV4aXR5ICovXG5cbiAgLy8gQ2xlYXIgYWxsIGNoYW5nZUZsYWdzLCB0eXBpY2FsbHkgYWZ0ZXIgYW4gdXBkYXRlXG4gIGNsZWFyQ2hhbmdlRmxhZ3MoKSB7XG4gICAgdGhpcy5pbnRlcm5hbFN0YXRlLmNoYW5nZUZsYWdzID0ge1xuICAgICAgLy8gUHJpbWFyeSBjaGFuZ2VGbGFncywgY2FuIGJlIHN0cmluZ3Mgc3RhdGluZyByZWFzb24gZm9yIGNoYW5nZVxuICAgICAgZGF0YUNoYW5nZWQ6IGZhbHNlLFxuICAgICAgcHJvcHNDaGFuZ2VkOiBmYWxzZSxcbiAgICAgIHVwZGF0ZVRyaWdnZXJzQ2hhbmdlZDogZmFsc2UsXG4gICAgICB2aWV3cG9ydENoYW5nZWQ6IGZhbHNlLFxuXG4gICAgICAvLyBEZXJpdmVkIGNoYW5nZUZsYWdzXG4gICAgICBwcm9wc09yRGF0YUNoYW5nZWQ6IGZhbHNlLFxuICAgICAgc29tZXRoaW5nQ2hhbmdlZDogZmFsc2VcbiAgICB9O1xuICB9XG5cbiAgcHJpbnRDaGFuZ2VGbGFncygpIHtcbiAgICBjb25zdCBmbGFncyA9IHRoaXMuaW50ZXJuYWxTdGF0ZS5jaGFuZ2VGbGFncztcbiAgICByZXR1cm4gYFxcXG4ke2ZsYWdzLmRhdGFDaGFuZ2VkID8gJ2RhdGEgJyA6ICcnfVxcXG4ke2ZsYWdzLnByb3BzQ2hhbmdlZCA/ICdwcm9wcyAnIDogJyd9XFxcbiR7ZmxhZ3MudXBkYXRlVHJpZ2dlcnNDaGFuZ2VkID8gJ3RyaWdnZXJzICcgOiAnJ31cXFxuJHtmbGFncy52aWV3cG9ydENoYW5nZWQgPyAndmlld3BvcnQnIDogJyd9XFxcbmA7XG4gIH1cblxuICAvLyBDb21wYXJlcyB0aGUgbGF5ZXJzIHByb3BzIHdpdGggb2xkIHByb3BzIGZyb20gYSBtYXRjaGVkIG9sZGVyIGxheWVyXG4gIC8vIGFuZCBleHRyYWN0cyBjaGFuZ2UgZmxhZ3MgdGhhdCBkZXNjcmliZSB3aGF0IGhhcyBjaGFuZ2Ugc28gdGhhdCBzdGF0ZVxuICAvLyBjYW4gYmUgdXBkYXRlIGNvcnJlY3RseSB3aXRoIG1pbmltYWwgZWZmb3J0XG4gIC8vIFRPRE8gLSBhcmd1bWVudHMgZm9yIHRlc3Rpbmcgb25seVxuICBkaWZmUHJvcHMobmV3UHJvcHMgPSB0aGlzLnByb3BzLCBvbGRQcm9wcyA9IHRoaXMub2xkUHJvcHMpIHtcbiAgICBjb25zdCBjaGFuZ2VGbGFncyA9IGRpZmZQcm9wcyhuZXdQcm9wcywgb2xkUHJvcHMpO1xuXG4gICAgLy8gaXRlcmF0ZSBvdmVyIGNoYW5nZWRUcmlnZ2Vyc1xuICAgIGlmIChjaGFuZ2VGbGFncy51cGRhdGVUcmlnZ2Vyc0NoYW5nZWQpIHtcbiAgICAgIGZvciAoY29uc3Qga2V5IGluIGNoYW5nZUZsYWdzLnVwZGF0ZVRyaWdnZXJzQ2hhbmdlZCkge1xuICAgICAgICBpZiAoY2hhbmdlRmxhZ3MudXBkYXRlVHJpZ2dlcnNDaGFuZ2VkW2tleV0pIHtcbiAgICAgICAgICB0aGlzLl9hY3RpdmVVcGRhdGVUcmlnZ2VyKGtleSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5zZXRDaGFuZ2VGbGFncyhjaGFuZ2VGbGFncyk7XG4gIH1cblxuICAvLyBQUklWQVRFIE1FVEhPRFNcblxuICBfZ2V0VXBkYXRlUGFyYW1zKCkge1xuICAgIHJldHVybiB7XG4gICAgICBwcm9wczogdGhpcy5wcm9wcyxcbiAgICAgIG9sZFByb3BzOiB0aGlzLm9sZFByb3BzLFxuICAgICAgY29udGV4dDogdGhpcy5jb250ZXh0LFxuICAgICAgb2xkQ29udGV4dDogdGhpcy5vbGRDb250ZXh0IHx8IHt9LFxuICAgICAgY2hhbmdlRmxhZ3M6IHRoaXMuaW50ZXJuYWxTdGF0ZS5jaGFuZ2VGbGFnc1xuICAgIH07XG4gIH1cblxuICAvLyBDaGVja3Mgc3RhdGUgb2YgYXR0cmlidXRlcyBhbmQgbW9kZWxcbiAgX2dldE5lZWRzUmVkcmF3KGNsZWFyUmVkcmF3RmxhZ3MpIHtcbiAgICAvLyB0aGlzIG1ldGhvZCBtYXkgYmUgY2FsbGVkIGJ5IHRoZSByZW5kZXIgbG9vcCBhcyBzb29uIGEgdGhlIGxheWVyXG4gICAgLy8gaGFzIGJlZW4gY3JlYXRlZCwgc28gZ3VhcmQgYWdhaW5zdCB1bmluaXRpYWxpemVkIHN0YXRlXG4gICAgaWYgKCF0aGlzLnN0YXRlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgbGV0IHJlZHJhdyA9IGZhbHNlO1xuICAgIHJlZHJhdyA9IHJlZHJhdyB8fCAodGhpcy5zdGF0ZS5uZWVkc1JlZHJhdyAmJiB0aGlzLmlkKTtcbiAgICB0aGlzLnN0YXRlLm5lZWRzUmVkcmF3ID0gdGhpcy5zdGF0ZS5uZWVkc1JlZHJhdyAmJiAhY2xlYXJSZWRyYXdGbGFncztcblxuICAgIC8vIFRPRE8gLSBpcyBhdHRyaWJ1dGUgbWFuYWdlciBuZWVkZWQ/IC0gTW9kZWwgc2hvdWxkIGJlIGVub3VnaC5cbiAgICBjb25zdCB7YXR0cmlidXRlTWFuYWdlcn0gPSB0aGlzLnN0YXRlO1xuICAgIGNvbnN0IGF0dHJpYnV0ZU1hbmFnZXJOZWVkc1JlZHJhdyA9XG4gICAgICBhdHRyaWJ1dGVNYW5hZ2VyICYmIGF0dHJpYnV0ZU1hbmFnZXIuZ2V0TmVlZHNSZWRyYXcoe2NsZWFyUmVkcmF3RmxhZ3N9KTtcbiAgICByZWRyYXcgPSByZWRyYXcgfHwgYXR0cmlidXRlTWFuYWdlck5lZWRzUmVkcmF3O1xuXG4gICAgZm9yIChjb25zdCBtb2RlbCBvZiB0aGlzLmdldE1vZGVscygpKSB7XG4gICAgICBsZXQgbW9kZWxOZWVkc1JlZHJhdyA9IG1vZGVsLmdldE5lZWRzUmVkcmF3KHtjbGVhclJlZHJhd0ZsYWdzfSk7XG4gICAgICBpZiAobW9kZWxOZWVkc1JlZHJhdyAmJiB0eXBlb2YgbW9kZWxOZWVkc1JlZHJhdyAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgbW9kZWxOZWVkc1JlZHJhdyA9IGBtb2RlbCAke21vZGVsLmlkfWA7XG4gICAgICB9XG4gICAgICByZWRyYXcgPSByZWRyYXcgfHwgbW9kZWxOZWVkc1JlZHJhdztcbiAgICB9XG5cbiAgICByZXR1cm4gcmVkcmF3O1xuICB9XG5cbiAgLy8gSGVscGVyIGZvciBjb25zdHJ1Y3RvciwgbWVyZ2VzIHByb3BzIHdpdGggZGVmYXVsdCBwcm9wcyBhbmQgZnJlZXplcyB0aGVtXG4gIF9ub3JtYWxpemVQcm9wcyhwcm9wcykge1xuICAgIC8vIElmIHN1YmxheWVyIGhhcyBzdGF0aWMgZGVmYXVsdFByb3BzIG1lbWJlciwgZ2V0RGVmYXVsdFByb3BzIHdpbGwgcmV0dXJuIGl0XG4gICAgY29uc3QgbWVyZ2VkRGVmYXVsdFByb3BzID0gZ2V0RGVmYXVsdFByb3BzKHRoaXMpO1xuICAgIC8vIE1lcmdlIHN1cHBsaWVkIHByb3BzIHdpdGggcHJlLW1lcmdlZCBkZWZhdWx0IHByb3BzXG4gICAgcHJvcHMgPSBPYmplY3QuYXNzaWduKHt9LCBtZXJnZWREZWZhdWx0UHJvcHMsIHByb3BzKTtcbiAgICAvLyBBY2NlcHQgbnVsbCBhcyBkYXRhIC0gb3RoZXJ3aXNlIGFwcHMgYW5kIGxheWVycyBuZWVkIHRvIGFkZCB1Z2x5IGNoZWNrc1xuICAgIC8vIFVzZSBjb25zdGFudCBmYWxsYmFjayBzbyB0aGF0IGRhdGEgY2hhbmdlIGlzIG5vdCB0cmlnZ2VyZWRcbiAgICBwcm9wcy5kYXRhID0gcHJvcHMuZGF0YSB8fCBFTVBUWV9BUlJBWTtcbiAgICAvLyBBcHBseSBhbnkgb3ZlcnJpZGVzIGZyb20gdGhlIHNlZXIgZGVidWcgZXh0ZW5zaW9uIGlmIGl0IGlzIGFjdGl2ZVxuICAgIGFwcGx5UHJvcE92ZXJyaWRlcyhwcm9wcyk7XG4gICAgLy8gUHJvcHMgYXJlIGltbXV0YWJsZVxuICAgIE9iamVjdC5mcmVlemUocHJvcHMpO1xuICAgIHJldHVybiBwcm9wcztcbiAgfVxuXG4gIC8vIENhbGxlZCBieSBsYXllciBtYW5hZ2VyIHRvIHRyYW5zZmVyIHN0YXRlIGZyb20gYW4gb2xkIGxheWVyXG4gIF90cmFuc2ZlclN0YXRlKG9sZExheWVyKSB7XG4gICAgY29uc3Qge3N0YXRlLCBpbnRlcm5hbFN0YXRlLCBwcm9wc30gPSBvbGRMYXllcjtcbiAgICBhc3NlcnQoc3RhdGUgJiYgaW50ZXJuYWxTdGF0ZSk7XG5cbiAgICAvLyBNb3ZlIHN0YXRlXG4gICAgc3RhdGUubGF5ZXIgPSB0aGlzO1xuICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgICB0aGlzLmludGVybmFsU3RhdGUgPSBpbnRlcm5hbFN0YXRlO1xuICAgIC8vIE5vdGU6IFdlIGtlZXAgdGhlIHN0YXRlIHJlZiBvbiBvbGQgbGF5ZXJzIHRvIHN1cHBvcnQgYXN5bmMgYWN0aW9uc1xuICAgIC8vIG9sZExheWVyLnN0YXRlID0gbnVsbDtcblxuICAgIC8vIEtlZXAgYSB0ZW1wb3JhcnkgcmVmIHRvIHRoZSBvbGQgcHJvcHMsIGZvciBwcm9wIGNvbXBhcmlzb25cbiAgICB0aGlzLm9sZFByb3BzID0gcHJvcHM7XG5cbiAgICAvLyBVcGRhdGUgbW9kZWwgbGF5ZXIgcmVmZXJlbmNlXG4gICAgZm9yIChjb25zdCBtb2RlbCBvZiB0aGlzLmdldE1vZGVscygpKSB7XG4gICAgICBtb2RlbC51c2VyRGF0YS5sYXllciA9IHRoaXM7XG4gICAgfVxuXG4gICAgdGhpcy5kaWZmUHJvcHMoKTtcbiAgfVxuXG4gIC8vIE9wZXJhdGUgb24gZWFjaCBjaGFuZ2VkIHRyaWdnZXJzLCB3aWxsIGJlIGNhbGxlZCB3aGVuIGFuIHVwZGF0ZVRyaWdnZXIgY2hhbmdlc1xuICBfYWN0aXZlVXBkYXRlVHJpZ2dlcihwcm9wTmFtZSkge1xuICAgIHRoaXMuaW52YWxpZGF0ZUF0dHJpYnV0ZShwcm9wTmFtZSk7XG4gIH1cblxuICAvLyAgSGVscGVyIHRvIGNoZWNrIHRoYXQgcmVxdWlyZWQgcHJvcHMgYXJlIHN1cHBsaWVkXG4gIF9jaGVja1JlcXVpcmVkUHJvcChwcm9wZXJ0eU5hbWUsIGNvbmRpdGlvbikge1xuICAgIGNvbnN0IHZhbHVlID0gdGhpcy5wcm9wc1twcm9wZXJ0eU5hbWVdO1xuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFByb3BlcnR5ICR7cHJvcGVydHlOYW1lfSB1bmRlZmluZWQgaW4gbGF5ZXIgJHt0aGlzfWApO1xuICAgIH1cbiAgICBpZiAoY29uZGl0aW9uICYmICFjb25kaXRpb24odmFsdWUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEJhZCBwcm9wZXJ0eSAke3Byb3BlcnR5TmFtZX0gaW4gbGF5ZXIgJHt0aGlzfWApO1xuICAgIH1cbiAgfVxuXG4gIF91cGRhdGVCYXNlVW5pZm9ybXMoKSB7XG4gICAgY29uc3QgdW5pZm9ybXMgPSB7XG4gICAgICAvLyBhcHBseSBnYW1tYSB0byBvcGFjaXR5IHRvIG1ha2UgaXQgdmlzdWFsbHkgXCJsaW5lYXJcIlxuICAgICAgb3BhY2l0eTogTWF0aC5wb3codGhpcy5wcm9wcy5vcGFjaXR5LCAxIC8gMi4yKSxcbiAgICAgIE9ORTogMS4wXG4gICAgfTtcbiAgICBmb3IgKGNvbnN0IG1vZGVsIG9mIHRoaXMuZ2V0TW9kZWxzKCkpIHtcbiAgICAgIG1vZGVsLnNldFVuaWZvcm1zKHVuaWZvcm1zKTtcbiAgICB9XG5cbiAgICAvLyBUT0RPIC0gc2V0IG5lZWRzUmVkcmF3IG9uIHRoZSBtb2RlbChzKT9cbiAgICB0aGlzLnN0YXRlLm5lZWRzUmVkcmF3ID0gdHJ1ZTtcbiAgfVxuXG4gIF91cGRhdGVNb2R1bGVTZXR0aW5ncygpIHtcbiAgICBjb25zdCBzZXR0aW5ncyA9IHtcbiAgICAgIHBpY2tpbmdIaWdobGlnaHRDb2xvcjogdGhpcy5wcm9wcy5oaWdobGlnaHRDb2xvclxuICAgIH07XG4gICAgZm9yIChjb25zdCBtb2RlbCBvZiB0aGlzLmdldE1vZGVscygpKSB7XG4gICAgICBtb2RlbC51cGRhdGVNb2R1bGVTZXR0aW5ncyhzZXR0aW5ncyk7XG4gICAgfVxuICB9XG5cbiAgLy8gREVQUkVDQVRFRCBNRVRIT0RTXG5cbiAgLy8gVXBkYXRlcyBzZWxlY3RlZCBzdGF0ZSBtZW1iZXJzIGFuZCBtYXJrcyB0aGUgb2JqZWN0IGZvciByZWRyYXdcbiAgc2V0VW5pZm9ybXModW5pZm9ybU1hcCkge1xuICAgIGZvciAoY29uc3QgbW9kZWwgb2YgdGhpcy5nZXRNb2RlbHMoKSkge1xuICAgICAgbW9kZWwuc2V0VW5pZm9ybXModW5pZm9ybU1hcCk7XG4gICAgfVxuXG4gICAgLy8gVE9ETyAtIHNldCBuZWVkc1JlZHJhdyBvbiB0aGUgbW9kZWwocyk/XG4gICAgdGhpcy5zdGF0ZS5uZWVkc1JlZHJhdyA9IHRydWU7XG4gICAgbG9nLmRlcHJlY2F0ZWQoJ2xheWVyLnNldFVuaWZvcm1zJywgJ21vZGVsLnNldFVuaWZvcm1zJyk7XG4gIH1cbn1cblxuTGF5ZXIubGF5ZXJOYW1lID0gJ0xheWVyJztcbkxheWVyLnByb3BUeXBlcyA9IGRlZmF1bHRQcm9wcztcbkxheWVyLmRlZmF1bHRQcm9wcyA9IGRlZmF1bHRQcm9wcztcbiJdfQ==