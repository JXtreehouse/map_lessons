var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

import { PureComponent, createElement } from 'react';
import PropTypes from 'prop-types';

import { EventManager } from 'mjolnir.js';
import { experimental } from '../core';
var ViewportControls = experimental.ViewportControls,
    TransitionManager = experimental.TransitionManager;


import CURSOR from './utils/cursors';

var propTypes = {
  viewportState: PropTypes.func,
  state: PropTypes.object,

  /** Viewport props */
  /** The width of the map. */
  width: PropTypes.number.isRequired,
  /** The height of the map. */
  height: PropTypes.number.isRequired,
  /** The longitude of the center of the map. */
  longitude: PropTypes.number.isRequired,
  /** The latitude of the center of the map. */
  latitude: PropTypes.number.isRequired,
  /** The tile zoom level of the map. */
  zoom: PropTypes.number.isRequired,
  /** Specify the bearing of the viewport */
  bearing: PropTypes.number,
  /** Specify the pitch of the viewport */
  pitch: PropTypes.number,
  /** Altitude of the viewport camera. Default 1.5 "screen heights" */
  // Note: Non-public API, see https://github.com/mapbox/mapbox-gl-js/issues/1137
  altitude: PropTypes.number,
  // Camera position for FirstPersonViewport
  position: PropTypes.array,

  /** Viewport constraints */
  // Max zoom level
  maxZoom: PropTypes.number,
  // Min zoom level
  minZoom: PropTypes.number,
  // Max pitch in degrees
  maxPitch: PropTypes.number,
  // Min pitch in degrees
  minPitch: PropTypes.number,

  /**
   * `onViewportChange` callback is fired when the user interacted with the
   * map. The object passed to the callback contains viewport properties
   * such as `longitude`, `latitude`, `zoom` etc.
   */
  onViewportChange: PropTypes.func,

  /** Viewport transition **/
  // transition duration for viewport change
  transitionDuration: PropTypes.number,
  // an instance of ViewportTransitionInterpolator, can be used to perform custom transitions.
  transitionInterpolator: PropTypes.object,
  // type of interruption of current transition on update.
  transitionInterruption: PropTypes.number,
  // easing function
  transitionEasing: PropTypes.func,
  // transition status update functions
  onTransitionStart: PropTypes.func,
  onTransitionInterrupt: PropTypes.func,
  onTransitionEnd: PropTypes.func,

  /** Enables control event handling */
  // Scroll to zoom
  scrollZoom: PropTypes.bool,
  // Drag to pan
  dragPan: PropTypes.bool,
  // Drag to rotate
  dragRotate: PropTypes.bool,
  // Double click to zoom
  doubleClickZoom: PropTypes.bool,
  // Pinch to zoom / rotate
  touchZoomRotate: PropTypes.bool,

  /** Accessor that returns a cursor style to show interactive state */
  getCursor: PropTypes.func,

  // A map control instance to replace the default map controls
  // The object must expose one property: `events` as an array of subscribed
  // event names; and two methods: `setState(state)` and `handle(event)`
  controls: PropTypes.shape({
    events: PropTypes.arrayOf(PropTypes.string),
    handleEvent: PropTypes.func
  })
};

var getDefaultCursor = function getDefaultCursor(_ref) {
  var isDragging = _ref.isDragging;
  return isDragging ? CURSOR.GRABBING : CURSOR.GRAB;
};

var defaultProps = Object.assign({}, TransitionManager.defaultProps, {
  onViewportChange: null,

  scrollZoom: true,
  dragPan: true,
  dragRotate: true,
  doubleClickZoom: true,
  touchZoomRotate: true,

  getCursor: getDefaultCursor
});

var ViewportController = function (_PureComponent) {
  _inherits(ViewportController, _PureComponent);

  function ViewportController(props) {
    _classCallCheck(this, ViewportController);

    var _this = _possibleConstructorReturn(this, (ViewportController.__proto__ || Object.getPrototypeOf(ViewportController)).call(this, props));

    _this.state = {
      isDragging: false // Whether the cursor is down
    };
    return _this;
  }

  _createClass(ViewportController, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      this._eventManager = new EventManager(this.eventCanvas);

      // If props.controls is not provided, fallback to default MapControls instance
      // Cannot use defaultProps here because it needs to be per map instance
      this._controls = this.props.controls || new ViewportControls(this.props.viewportState);

      this._controls.setOptions(Object.assign({}, this.props, {
        onStateChange: this._onInteractiveStateChange.bind(this),
        eventManager: this._eventManager
      }));

      this._transitionManger = new TransitionManager(this.props);
    }
  }, {
    key: 'shouldComponentUpdate',
    value: function shouldComponentUpdate(nextProps, nextState) {
      if (this._transitionManger) {
        var transitionTriggered = this._transitionManger.processViewportChange(nextProps);
        // Skip this render to avoid jump during viewport transitions.
        return !transitionTriggered;
      }
      return true;
    }
  }, {
    key: 'componentWillUpdate',
    value: function componentWillUpdate(nextProps) {
      if (this._controls) {
        this._controls.setOptions(nextProps);
      }
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      this._eventManager.destroy();
    }
  }, {
    key: '_onInteractiveStateChange',
    value: function _onInteractiveStateChange(_ref2) {
      var _ref2$isDragging = _ref2.isDragging,
          isDragging = _ref2$isDragging === undefined ? false : _ref2$isDragging;

      if (isDragging !== this.state.isDragging) {
        this.setState({ isDragging: isDragging });
      }
    }
  }, {
    key: 'render',
    value: function render() {
      var _this2 = this;

      var _props = this.props,
          width = _props.width,
          height = _props.height,
          getCursor = _props.getCursor;


      var eventCanvasStyle = {
        width: width,
        height: height,
        position: 'relative',
        cursor: getCursor(this.state)
      };

      return createElement('div', {
        key: 'map-controls',
        ref: function ref(c) {
          return _this2.eventCanvas = c;
        },
        style: eventCanvasStyle
      }, this.props.children);
    }
  }]);

  return ViewportController;
}(PureComponent);

export default ViewportController;


ViewportController.displayName = 'ViewportController';
ViewportController.propTypes = propTypes;
ViewportController.defaultProps = defaultProps;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9yZWFjdC92aWV3cG9ydC1jb250cm9sbGVyLmpzIl0sIm5hbWVzIjpbIlB1cmVDb21wb25lbnQiLCJjcmVhdGVFbGVtZW50IiwiUHJvcFR5cGVzIiwiRXZlbnRNYW5hZ2VyIiwiZXhwZXJpbWVudGFsIiwiVmlld3BvcnRDb250cm9scyIsIlRyYW5zaXRpb25NYW5hZ2VyIiwiQ1VSU09SIiwicHJvcFR5cGVzIiwidmlld3BvcnRTdGF0ZSIsImZ1bmMiLCJzdGF0ZSIsIm9iamVjdCIsIndpZHRoIiwibnVtYmVyIiwiaXNSZXF1aXJlZCIsImhlaWdodCIsImxvbmdpdHVkZSIsImxhdGl0dWRlIiwiem9vbSIsImJlYXJpbmciLCJwaXRjaCIsImFsdGl0dWRlIiwicG9zaXRpb24iLCJhcnJheSIsIm1heFpvb20iLCJtaW5ab29tIiwibWF4UGl0Y2giLCJtaW5QaXRjaCIsIm9uVmlld3BvcnRDaGFuZ2UiLCJ0cmFuc2l0aW9uRHVyYXRpb24iLCJ0cmFuc2l0aW9uSW50ZXJwb2xhdG9yIiwidHJhbnNpdGlvbkludGVycnVwdGlvbiIsInRyYW5zaXRpb25FYXNpbmciLCJvblRyYW5zaXRpb25TdGFydCIsIm9uVHJhbnNpdGlvbkludGVycnVwdCIsIm9uVHJhbnNpdGlvbkVuZCIsInNjcm9sbFpvb20iLCJib29sIiwiZHJhZ1BhbiIsImRyYWdSb3RhdGUiLCJkb3VibGVDbGlja1pvb20iLCJ0b3VjaFpvb21Sb3RhdGUiLCJnZXRDdXJzb3IiLCJjb250cm9scyIsInNoYXBlIiwiZXZlbnRzIiwiYXJyYXlPZiIsInN0cmluZyIsImhhbmRsZUV2ZW50IiwiZ2V0RGVmYXVsdEN1cnNvciIsImlzRHJhZ2dpbmciLCJHUkFCQklORyIsIkdSQUIiLCJkZWZhdWx0UHJvcHMiLCJPYmplY3QiLCJhc3NpZ24iLCJWaWV3cG9ydENvbnRyb2xsZXIiLCJwcm9wcyIsIl9ldmVudE1hbmFnZXIiLCJldmVudENhbnZhcyIsIl9jb250cm9scyIsInNldE9wdGlvbnMiLCJvblN0YXRlQ2hhbmdlIiwiX29uSW50ZXJhY3RpdmVTdGF0ZUNoYW5nZSIsImJpbmQiLCJldmVudE1hbmFnZXIiLCJfdHJhbnNpdGlvbk1hbmdlciIsIm5leHRQcm9wcyIsIm5leHRTdGF0ZSIsInRyYW5zaXRpb25UcmlnZ2VyZWQiLCJwcm9jZXNzVmlld3BvcnRDaGFuZ2UiLCJkZXN0cm95Iiwic2V0U3RhdGUiLCJldmVudENhbnZhc1N0eWxlIiwiY3Vyc29yIiwia2V5IiwicmVmIiwiYyIsInN0eWxlIiwiY2hpbGRyZW4iLCJkaXNwbGF5TmFtZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQSxTQUFRQSxhQUFSLEVBQXVCQyxhQUF2QixRQUEyQyxPQUEzQztBQUNBLE9BQU9DLFNBQVAsTUFBc0IsWUFBdEI7O0FBRUEsU0FBUUMsWUFBUixRQUEyQixZQUEzQjtBQUNBLFNBQVFDLFlBQVIsUUFBMkIsU0FBM0I7SUFDT0MsZ0IsR0FBdUNELFksQ0FBdkNDLGdCO0lBQWtCQyxpQixHQUFxQkYsWSxDQUFyQkUsaUI7OztBQUV6QixPQUFPQyxNQUFQLE1BQW1CLGlCQUFuQjs7QUFFQSxJQUFNQyxZQUFZO0FBQ2hCQyxpQkFBZVAsVUFBVVEsSUFEVDtBQUVoQkMsU0FBT1QsVUFBVVUsTUFGRDs7QUFJaEI7QUFDQTtBQUNBQyxTQUFPWCxVQUFVWSxNQUFWLENBQWlCQyxVQU5SO0FBT2hCO0FBQ0FDLFVBQVFkLFVBQVVZLE1BQVYsQ0FBaUJDLFVBUlQ7QUFTaEI7QUFDQUUsYUFBV2YsVUFBVVksTUFBVixDQUFpQkMsVUFWWjtBQVdoQjtBQUNBRyxZQUFVaEIsVUFBVVksTUFBVixDQUFpQkMsVUFaWDtBQWFoQjtBQUNBSSxRQUFNakIsVUFBVVksTUFBVixDQUFpQkMsVUFkUDtBQWVoQjtBQUNBSyxXQUFTbEIsVUFBVVksTUFoQkg7QUFpQmhCO0FBQ0FPLFNBQU9uQixVQUFVWSxNQWxCRDtBQW1CaEI7QUFDQTtBQUNBUSxZQUFVcEIsVUFBVVksTUFyQko7QUFzQmhCO0FBQ0FTLFlBQVVyQixVQUFVc0IsS0F2Qko7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Q29udGVudCI6WyJpbXBvcnQge1B1cmVDb21wb25lbnQsIGNyZWF0ZUVsZW1lbnR9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5cbmltcG9ydCB7RXZlbnRNYW5hZ2VyfSBmcm9tICdtam9sbmlyLmpzJztcbmltcG9ydCB7ZXhwZXJpbWVudGFsfSBmcm9tICcuLi9jb3JlJztcbmNvbnN0IHtWaWV3cG9ydENvbnRyb2xzLCBUcmFuc2l0aW9uTWFuYWdlcn0gPSBleHBlcmltZW50YWw7XG5cbmltcG9ydCBDVVJTT1IgZnJvbSAnLi91dGlscy9jdXJzb3JzJztcblxuY29uc3QgcHJvcFR5cGVzID0ge1xuICB2aWV3cG9ydFN0YXRlOiBQcm9wVHlwZXMuZnVuYyxcbiAgc3RhdGU6IFByb3BUeXBlcy5vYmplY3QsXG5cbiAgLyoqIFZpZXdwb3J0IHByb3BzICovXG4gIC8qKiBUaGUgd2lkdGggb2YgdGhlIG1hcC4gKi9cbiAgd2lkdGg6IFByb3BUeXBlcy5udW1iZXIuaXNSZXF1aXJlZCxcbiAgLyoqIFRoZSBoZWlnaHQgb2YgdGhlIG1hcC4gKi9cbiAgaGVpZ2h0OiBQcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWQsXG4gIC8qKiBUaGUgbG9uZ2l0dWRlIG9mIHRoZSBjZW50ZXIgb2YgdGhlIG1hcC4gKi9cbiAgbG9uZ2l0dWRlOiBQcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWQsXG4gIC8qKiBUaGUgbGF0aXR1ZGUgb2YgdGhlIGNlbnRlciBvZiB0aGUgbWFwLiAqL1xuICBsYXRpdHVkZTogUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkLFxuICAvKiogVGhlIHRpbGUgem9vbSBsZXZlbCBvZiB0aGUgbWFwLiAqL1xuICB6b29tOiBQcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWQsXG4gIC8qKiBTcGVjaWZ5IHRoZSBiZWFyaW5nIG9mIHRoZSB2aWV3cG9ydCAqL1xuICBiZWFyaW5nOiBQcm9wVHlwZXMubnVtYmVyLFxuICAvKiogU3BlY2lmeSB0aGUgcGl0Y2ggb2YgdGhlIHZpZXdwb3J0ICovXG4gIHBpdGNoOiBQcm9wVHlwZXMubnVtYmVyLFxuICAvKiogQWx0aXR1ZGUgb2YgdGhlIHZpZXdwb3J0IGNhbWVyYS4gRGVmYXVsdCAxLjUgXCJzY3JlZW4gaGVpZ2h0c1wiICovXG4gIC8vIE5vdGU6IE5vbi1wdWJsaWMgQVBJLCBzZWUgaHR0cHM6Ly9naXRodWIuY29tL21hcGJveC9tYXBib3gtZ2wtanMvaXNzdWVzLzExMzdcbiAgYWx0aXR1ZGU6IFByb3BUeXBlcy5udW1iZXIsXG4gIC8vIENhbWVyYSBwb3NpdGlvbiBmb3IgRmlyc3RQZXJzb25WaWV3cG9ydFxuICBwb3NpdGlvbjogUHJvcFR5cGVzLmFycmF5LFxuXG4gIC8qKiBWaWV3cG9ydCBjb25zdHJhaW50cyAqL1xuICAvLyBNYXggem9vbSBsZXZlbFxuICBtYXhab29tOiBQcm9wVHlwZXMubnVtYmVyLFxuICAvLyBNaW4gem9vbSBsZXZlbFxuICBtaW5ab29tOiBQcm9wVHlwZXMubnVtYmVyLFxuICAvLyBNYXggcGl0Y2ggaW4gZGVncmVlc1xuICBtYXhQaXRjaDogUHJvcFR5cGVzLm51bWJlcixcbiAgLy8gTWluIHBpdGNoIGluIGRlZ3JlZXNcbiAgbWluUGl0Y2g6IFByb3BUeXBlcy5udW1iZXIsXG5cbiAgLyoqXG4gICAqIGBvblZpZXdwb3J0Q2hhbmdlYCBjYWxsYmFjayBpcyBmaXJlZCB3aGVuIHRoZSB1c2VyIGludGVyYWN0ZWQgd2l0aCB0aGVcbiAgICogbWFwLiBUaGUgb2JqZWN0IHBhc3NlZCB0byB0aGUgY2FsbGJhY2sgY29udGFpbnMgdmlld3BvcnQgcHJvcGVydGllc1xuICAgKiBzdWNoIGFzIGBsb25naXR1ZGVgLCBgbGF0aXR1ZGVgLCBgem9vbWAgZXRjLlxuICAgKi9cbiAgb25WaWV3cG9ydENoYW5nZTogUHJvcFR5cGVzLmZ1bmMsXG5cbiAgLyoqIFZpZXdwb3J0IHRyYW5zaXRpb24gKiovXG4gIC8vIHRyYW5zaXRpb24gZHVyYXRpb24gZm9yIHZpZXdwb3J0IGNoYW5nZVxuICB0cmFuc2l0aW9uRHVyYXRpb246IFByb3BUeXBlcy5udW1iZXIsXG4gIC8vIGFuIGluc3RhbmNlIG9mIFZpZXdwb3J0VHJhbnNpdGlvbkludGVycG9sYXRvciwgY2FuIGJlIHVzZWQgdG8gcGVyZm9ybSBjdXN0b20gdHJhbnNpdGlvbnMuXG4gIHRyYW5zaXRpb25JbnRlcnBvbGF0b3I6IFByb3BUeXBlcy5vYmplY3QsXG4gIC8vIHR5cGUgb2YgaW50ZXJydXB0aW9uIG9mIGN1cnJlbnQgdHJhbnNpdGlvbiBvbiB1cGRhdGUuXG4gIHRyYW5zaXRpb25JbnRlcnJ1cHRpb246IFByb3BUeXBlcy5udW1iZXIsXG4gIC8vIGVhc2luZyBmdW5jdGlvblxuICB0cmFuc2l0aW9uRWFzaW5nOiBQcm9wVHlwZXMuZnVuYyxcbiAgLy8gdHJhbnNpdGlvbiBzdGF0dXMgdXBkYXRlIGZ1bmN0aW9uc1xuICBvblRyYW5zaXRpb25TdGFydDogUHJvcFR5cGVzLmZ1bmMsXG4gIG9uVHJhbnNpdGlvbkludGVycnVwdDogUHJvcFR5cGVzLmZ1bmMsXG4gIG9uVHJhbnNpdGlvbkVuZDogUHJvcFR5cGVzLmZ1bmMsXG5cbiAgLyoqIEVuYWJsZXMgY29udHJvbCBldmVudCBoYW5kbGluZyAqL1xuICAvLyBTY3JvbGwgdG8gem9vbVxuICBzY3JvbGxab29tOiBQcm9wVHlwZXMuYm9vbCxcbiAgLy8gRHJhZyB0byBwYW5cbiAgZHJhZ1BhbjogUHJvcFR5cGVzLmJvb2wsXG4gIC8vIERyYWcgdG8gcm90YXRlXG4gIGRyYWdSb3RhdGU6IFByb3BUeXBlcy5ib29sLFxuICAvLyBEb3VibGUgY2xpY2sgdG8gem9vbVxuICBkb3VibGVDbGlja1pvb206IFByb3BUeXBlcy5ib29sLFxuICAvLyBQaW5jaCB0byB6b29tIC8gcm90YXRlXG4gIHRvdWNoWm9vbVJvdGF0ZTogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqIEFjY2Vzc29yIHRoYXQgcmV0dXJucyBhIGN1cnNvciBzdHlsZSB0byBzaG93IGludGVyYWN0aXZlIHN0YXRlICovXG4gIGdldEN1cnNvcjogUHJvcFR5cGVzLmZ1bmMsXG5cbiAgLy8gQSBtYXAgY29udHJvbCBpbnN0YW5jZSB0byByZXBsYWNlIHRoZSBkZWZhdWx0IG1hcCBjb250cm9sc1xuICAvLyBUaGUgb2JqZWN0IG11c3QgZXhwb3NlIG9uZSBwcm9wZXJ0eTogYGV2ZW50c2AgYXMgYW4gYXJyYXkgb2Ygc3Vic2NyaWJlZFxuICAvLyBldmVudCBuYW1lczsgYW5kIHR3byBtZXRob2RzOiBgc2V0U3RhdGUoc3RhdGUpYCBhbmQgYGhhbmRsZShldmVudClgXG4gIGNvbnRyb2xzOiBQcm9wVHlwZXMuc2hhcGUoe1xuICAgIGV2ZW50czogUHJvcFR5cGVzLmFycmF5T2YoUHJvcFR5cGVzLnN0cmluZyksXG4gICAgaGFuZGxlRXZlbnQ6IFByb3BUeXBlcy5mdW5jXG4gIH0pXG59O1xuXG5jb25zdCBnZXREZWZhdWx0Q3Vyc29yID0gKHtpc0RyYWdnaW5nfSkgPT4gKGlzRHJhZ2dpbmcgPyBDVVJTT1IuR1JBQkJJTkcgOiBDVVJTT1IuR1JBQik7XG5cbmNvbnN0IGRlZmF1bHRQcm9wcyA9IE9iamVjdC5hc3NpZ24oe30sIFRyYW5zaXRpb25NYW5hZ2VyLmRlZmF1bHRQcm9wcywge1xuICBvblZpZXdwb3J0Q2hhbmdlOiBudWxsLFxuXG4gIHNjcm9sbFpvb206IHRydWUsXG4gIGRyYWdQYW46IHRydWUsXG4gIGRyYWdSb3RhdGU6IHRydWUsXG4gIGRvdWJsZUNsaWNrWm9vbTogdHJ1ZSxcbiAgdG91Y2hab29tUm90YXRlOiB0cnVlLFxuXG4gIGdldEN1cnNvcjogZ2V0RGVmYXVsdEN1cnNvclxufSk7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFZpZXdwb3J0Q29udHJvbGxlciBleHRlbmRzIFB1cmVDb21wb25lbnQge1xuICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgIHN1cGVyKHByb3BzKTtcblxuICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICBpc0RyYWdnaW5nOiBmYWxzZSAvLyBXaGV0aGVyIHRoZSBjdXJzb3IgaXMgZG93blxuICAgIH07XG4gIH1cblxuICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICB0aGlzLl9ldmVudE1hbmFnZXIgPSBuZXcgRXZlbnRNYW5hZ2VyKHRoaXMuZXZlbnRDYW52YXMpO1xuXG4gICAgLy8gSWYgcHJvcHMuY29udHJvbHMgaXMgbm90IHByb3ZpZGVkLCBmYWxsYmFjayB0byBkZWZhdWx0IE1hcENvbnRyb2xzIGluc3RhbmNlXG4gICAgLy8gQ2Fubm90IHVzZSBkZWZhdWx0UHJvcHMgaGVyZSBiZWNhdXNlIGl0IG5lZWRzIHRvIGJlIHBlciBtYXAgaW5zdGFuY2VcbiAgICB0aGlzLl9jb250cm9scyA9IHRoaXMucHJvcHMuY29udHJvbHMgfHwgbmV3IFZpZXdwb3J0Q29udHJvbHModGhpcy5wcm9wcy52aWV3cG9ydFN0YXRlKTtcblxuICAgIHRoaXMuX2NvbnRyb2xzLnNldE9wdGlvbnMoXG4gICAgICBPYmplY3QuYXNzaWduKHt9LCB0aGlzLnByb3BzLCB7XG4gICAgICAgIG9uU3RhdGVDaGFuZ2U6IHRoaXMuX29uSW50ZXJhY3RpdmVTdGF0ZUNoYW5nZS5iaW5kKHRoaXMpLFxuICAgICAgICBldmVudE1hbmFnZXI6IHRoaXMuX2V2ZW50TWFuYWdlclxuICAgICAgfSlcbiAgICApO1xuXG4gICAgdGhpcy5fdHJhbnNpdGlvbk1hbmdlciA9IG5ldyBUcmFuc2l0aW9uTWFuYWdlcih0aGlzLnByb3BzKTtcbiAgfVxuXG4gIHNob3VsZENvbXBvbmVudFVwZGF0ZShuZXh0UHJvcHMsIG5leHRTdGF0ZSkge1xuICAgIGlmICh0aGlzLl90cmFuc2l0aW9uTWFuZ2VyKSB7XG4gICAgICBjb25zdCB0cmFuc2l0aW9uVHJpZ2dlcmVkID0gdGhpcy5fdHJhbnNpdGlvbk1hbmdlci5wcm9jZXNzVmlld3BvcnRDaGFuZ2UobmV4dFByb3BzKTtcbiAgICAgIC8vIFNraXAgdGhpcyByZW5kZXIgdG8gYXZvaWQganVtcCBkdXJpbmcgdmlld3BvcnQgdHJhbnNpdGlvbnMuXG4gICAgICByZXR1cm4gIXRyYW5zaXRpb25UcmlnZ2VyZWQ7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgY29tcG9uZW50V2lsbFVwZGF0ZShuZXh0UHJvcHMpIHtcbiAgICBpZiAodGhpcy5fY29udHJvbHMpIHtcbiAgICAgIHRoaXMuX2NvbnRyb2xzLnNldE9wdGlvbnMobmV4dFByb3BzKTtcbiAgICB9XG4gIH1cblxuICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICB0aGlzLl9ldmVudE1hbmFnZXIuZGVzdHJveSgpO1xuICB9XG5cbiAgX29uSW50ZXJhY3RpdmVTdGF0ZUNoYW5nZSh7aXNEcmFnZ2luZyA9IGZhbHNlfSkge1xuICAgIGlmIChpc0RyYWdnaW5nICE9PSB0aGlzLnN0YXRlLmlzRHJhZ2dpbmcpIHtcbiAgICAgIHRoaXMuc2V0U3RhdGUoe2lzRHJhZ2dpbmd9KTtcbiAgICB9XG4gIH1cblxuICByZW5kZXIoKSB7XG4gICAgY29uc3Qge3dpZHRoLCBoZWlnaHQsIGdldEN1cnNvcn0gPSB0aGlzLnByb3BzO1xuXG4gICAgY29uc3QgZXZlbnRDYW52YXNTdHlsZSA9IHtcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0LFxuICAgICAgcG9zaXRpb246ICdyZWxhdGl2ZScsXG4gICAgICBjdXJzb3I6IGdldEN1cnNvcih0aGlzLnN0YXRlKVxuICAgIH07XG5cbiAgICByZXR1cm4gY3JlYXRlRWxlbWVudChcbiAgICAgICdkaXYnLFxuICAgICAge1xuICAgICAgICBrZXk6ICdtYXAtY29udHJvbHMnLFxuICAgICAgICByZWY6IGMgPT4gKHRoaXMuZXZlbnRDYW52YXMgPSBjKSxcbiAgICAgICAgc3R5bGU6IGV2ZW50Q2FudmFzU3R5bGVcbiAgICAgIH0sXG4gICAgICB0aGlzLnByb3BzLmNoaWxkcmVuXG4gICAgKTtcbiAgfVxufVxuXG5WaWV3cG9ydENvbnRyb2xsZXIuZGlzcGxheU5hbWUgPSAnVmlld3BvcnRDb250cm9sbGVyJztcblZpZXdwb3J0Q29udHJvbGxlci5wcm9wVHlwZXMgPSBwcm9wVHlwZXM7XG5WaWV3cG9ydENvbnRyb2xsZXIuZGVmYXVsdFByb3BzID0gZGVmYXVsdFByb3BzO1xuIl19