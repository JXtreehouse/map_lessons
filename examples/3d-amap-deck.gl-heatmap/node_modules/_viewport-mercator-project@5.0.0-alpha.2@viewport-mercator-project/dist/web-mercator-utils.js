'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }(); // TODO - THE UTILITIES IN THIS FILE SHOULD BE IMPORTED FROM WEB-MERCATOR-VIEWPORT MODULE

exports.projectFlat = projectFlat;
exports.unprojectFlat = unprojectFlat;
exports.getMeterZoom = getMeterZoom;
exports.getDistanceScales = getDistanceScales;
exports.getWorldPosition = getWorldPosition;
exports.getUncenteredViewMatrix = getUncenteredViewMatrix;
exports.getViewMatrix = getViewMatrix;
exports.getProjectionMatrix = getProjectionMatrix;

var _math = require('math.gl');

var _mathUtils = require('./math-utils');

var _perspective = require('gl-mat4/perspective');

var _perspective2 = _interopRequireDefault(_perspective);

var _scale = require('gl-mat4/scale');

var _scale2 = _interopRequireDefault(_scale);

var _translate = require('gl-mat4/translate');

var _translate2 = _interopRequireDefault(_translate);

var _rotateX = require('gl-mat4/rotateX');

var _rotateX2 = _interopRequireDefault(_rotateX);

var _rotateZ = require('gl-mat4/rotateZ');

var _rotateZ2 = _interopRequireDefault(_rotateZ);

var _assert = require('assert');

var _assert2 = _interopRequireDefault(_assert);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// CONSTANTS
var PI = Math.PI;
var PI_4 = PI / 4;
var DEGREES_TO_RADIANS = PI / 180;
var RADIANS_TO_DEGREES = 180 / PI;
var TILE_SIZE = 512;
// Average circumference (40075 km equatorial, 40007 km meridional)
var EARTH_CIRCUMFERENCE = 40.03e6;

/**
 * Project [lng,lat] on sphere onto [x,y] on 512*512 Mercator Zoom 0 tile.
 * Performs the nonlinear part of the web mercator projection.
 * Remaining projection is done with 4x4 matrices which also handles
 * perspective.
 *
 * @param {Array} lngLat - [lng, lat] coordinates
 *   Specifies a point on the sphere to project onto the map.
 * @return {Array} [x,y] coordinates.
 */
function projectFlat(_ref, scale) {
  var _ref2 = _slicedToArray(_ref, 2),
      lng = _ref2[0],
      lat = _ref2[1];

  scale *= TILE_SIZE;
  var lambda2 = lng * DEGREES_TO_RADIANS;
  var phi2 = lat * DEGREES_TO_RADIANS;
  var x = scale * (lambda2 + PI) / (2 * PI);
  var y = scale * (PI - Math.log(Math.tan(PI_4 + phi2 * 0.5))) / (2 * PI);
  return [x, y];
}

/**
 * Unproject world point [x,y] on map onto {lat, lon} on sphere
 *
 * @param {object|Vector} xy - object with {x,y} members
 *  representing point on projected map plane
 * @return {GeoCoordinates} - object with {lat,lon} of point on sphere.
 *   Has toArray method if you need a GeoJSON Array.
 *   Per cartographic tradition, lat and lon are specified as degrees.
 */
function unprojectFlat(_ref3, scale) {
  var _ref4 = _slicedToArray(_ref3, 2),
      x = _ref4[0],
      y = _ref4[1];

  scale *= TILE_SIZE;
  var lambda2 = x / scale * (2 * PI) - PI;
  var phi2 = 2 * (Math.atan(Math.exp(PI - y / scale * (2 * PI))) - PI_4);
  return [lambda2 * RADIANS_TO_DEGREES, phi2 * RADIANS_TO_DEGREES];
}

// Returns the zoom level that gives a 1 meter pixel at a certain latitude
// S=C*cos(y)/2^(z+8)
function getMeterZoom(_ref5) {
  var latitude = _ref5.latitude;

  (0, _assert2.default)(latitude);
  var latCosine = Math.cos(latitude * DEGREES_TO_RADIANS);
  return Math.log2(EARTH_CIRCUMFERENCE * latCosine) - 8;
}

/**
 * Calculate distance scales in meters around current lat/lon, both for
 * degrees and pixels.
 * In mercator projection mode, the distance scales vary significantly
 * with latitude.
 */
function getDistanceScales(_ref6) {
  var latitude = _ref6.latitude,
      longitude = _ref6.longitude,
      zoom = _ref6.zoom,
      scale = _ref6.scale,
      _ref6$highPrecision = _ref6.highPrecision,
      highPrecision = _ref6$highPrecision === undefined ? false : _ref6$highPrecision;

  // Calculate scale from zoom if not provided
  scale = scale !== undefined ? scale : Math.pow(2, zoom);

  (0, _assert2.default)(isFinite(latitude) && isFinite(longitude) && isFinite(scale));

  var result = {};
  var worldSize = TILE_SIZE * scale;
  var latCosine = Math.cos(latitude * DEGREES_TO_RADIANS);

  /**
   * Number of pixels occupied by one degree longitude around current lat/lon:
     pixelsPerDegreeX = d(projectFlat([lng, lat])[0])/d(lng)
       = scale * TILE_SIZE * DEGREES_TO_RADIANS / (2 * PI)
     pixelsPerDegreeY = d(projectFlat([lng, lat])[1])/d(lat)
       = -scale * TILE_SIZE * DEGREES_TO_RADIANS / cos(lat * DEGREES_TO_RADIANS)  / (2 * PI)
   */
  var pixelsPerDegreeX = worldSize / 360;
  var pixelsPerDegreeY = pixelsPerDegreeX / latCosine;

  /**
   * Number of pixels occupied by one meter around current lat/lon:
   */
  var altPixelsPerMeter = worldSize / EARTH_CIRCUMFERENCE / latCosine;

  result.pixelsPerMeter = [altPixelsPerMeter, altPixelsPerMeter, altPixelsPerMeter];
  result.metersPerPixel = [1 / altPixelsPerMeter, 1 / altPixelsPerMeter, 1 / altPixelsPerMeter];

  result.pixelsPerDegree = [pixelsPerDegreeX, pixelsPerDegreeY, altPixelsPerMeter];
  result.degreesPerPixel = [1 / pixelsPerDegreeX, 1 / pixelsPerDegreeY, 1 / altPixelsPerMeter];

  /**
   * Taylor series 2nd order for 1/latCosine
     f'(a) * (x - a)
       = d(1/cos(lat * DEGREES_TO_RADIANS))/d(lat) * dLat
       = DEGREES_TO_RADIANS * tan(lat * DEGREES_TO_RADIANS) / cos(lat * DEGREES_TO_RADIANS) * dLat
   */
  if (highPrecision) {
    var latCosine2 = DEGREES_TO_RADIANS * Math.tan(latitude * DEGREES_TO_RADIANS) / latCosine;
    var pixelsPerDegreeY2 = pixelsPerDegreeX * latCosine2 / 2;
    var altPixelsPerDegree2 = worldSize / EARTH_CIRCUMFERENCE * latCosine2;
    var altPixelsPerMeter2 = altPixelsPerDegree2 / pixelsPerDegreeY * altPixelsPerMeter;

    result.pixelsPerDegree2 = [0, pixelsPerDegreeY2, altPixelsPerDegree2];
    result.pixelsPerMeter2 = [altPixelsPerMeter2, 0, altPixelsPerMeter2];
  }

  // Main results, used for converting meters to latlng deltas and scaling offsets
  return result;
}

/**
 * Calculates a mercator world position ("pixels" in given zoom level)
 * from a lng/lat and meterOffset
 */
function getWorldPosition(_ref7) {
  var longitude = _ref7.longitude,
      latitude = _ref7.latitude,
      zoom = _ref7.zoom,
      meterOffset = _ref7.meterOffset,
      _ref7$distanceScales = _ref7.distanceScales,
      distanceScales = _ref7$distanceScales === undefined ? null : _ref7$distanceScales;

  var scale = Math.pow(2, zoom);

  // Make a centered version of the matrix for projection modes without an offset
  var center2d = projectFlat([longitude, latitude], scale);
  var center = new _math.Vector3(center2d[0], center2d[1], 0);

  if (meterOffset) {
    // Calculate distance scales if lng/lat/zoom are provided
    distanceScales = distanceScales || getDistanceScales({ latitude: latitude, longitude: longitude, scale: scale });

    var pixelPosition = new _math.Vector3(meterOffset)
    // Convert to pixels in current zoom
    .scale(distanceScales.pixelsPerMeter)
    // We want positive Y to represent an offset towards north,
    // but web mercator world coordinates is top-left
    .scale([1, -1, 1]);
    center.add(pixelPosition);
  }

  return center;
}

// ATTRIBUTION:
// view and projection matrix creation is intentionally kept compatible with
// mapbox-gl's implementation to ensure that seamless interoperation
// with mapbox and react-map-gl. See: https://github.com/mapbox/mapbox-gl-js

// Variable fov (in radians)
function getFov(_ref8) {
  var height = _ref8.height,
      altitude = _ref8.altitude;

  return 2 * Math.atan(height / 2 / altitude);
}

function getClippingPlanes(_ref9) {
  var altitude = _ref9.altitude,
      pitch = _ref9.pitch;

  // Find the distance from the center point to the center top
  // in altitude units using law of sines.
  var pitchRadians = pitch * DEGREES_TO_RADIANS;
  var halfFov = Math.atan(0.5 / altitude);
  var topHalfSurfaceDistance = Math.sin(halfFov) * altitude / Math.sin(Math.PI / 2 - pitchRadians - halfFov);

  // Calculate z value of the farthest fragment that should be rendered.
  var farZ = Math.cos(Math.PI / 2 - pitchRadians) * topHalfSurfaceDistance + altitude;

  return { farZ: farZ, nearZ: 0.1 };
}

// TODO - rename this matrix
function getUncenteredViewMatrix(_ref10) {
  var height = _ref10.height,
      pitch = _ref10.pitch,
      bearing = _ref10.bearing,
      altitude = _ref10.altitude;

  // VIEW MATRIX: PROJECTS MERCATOR WORLD COORDINATES
  // Note that mercator world coordinates typically need to be flipped
  //
  // Note: As usual, matrix operation orders should be read in reverse
  // since vectors will be multiplied from the right during transformation
  var vm = (0, _mathUtils.createMat4)();

  // Move camera to altitude (along the pitch & bearing direction)
  (0, _translate2.default)(vm, vm, [0, 0, -altitude]);

  // After the rotateX, z values are in pixel units. Convert them to
  // altitude units. 1 altitude unit = the screen height.
  (0, _scale2.default)(vm, vm, [1, 1, 1 / height]);

  // Rotate by bearing, and then by pitch (which tilts the view)
  (0, _rotateX2.default)(vm, vm, -pitch * DEGREES_TO_RADIANS);
  (0, _rotateZ2.default)(vm, vm, bearing * DEGREES_TO_RADIANS);

  return vm;
}

function getViewMatrix(_ref11) {
  var width = _ref11.width,
      height = _ref11.height,
      longitude = _ref11.longitude,
      latitude = _ref11.latitude,
      zoom = _ref11.zoom,
      pitch = _ref11.pitch,
      bearing = _ref11.bearing,
      altitude = _ref11.altitude,
      _ref11$distanceScales = _ref11.distanceScales,
      distanceScales = _ref11$distanceScales === undefined ? null : _ref11$distanceScales,
      _ref11$center = _ref11.center,
      center = _ref11$center === undefined ? null : _ref11$center,
      _ref11$viewMatrixUnce = _ref11.viewMatrixUncentered,
      viewMatrixUncentered = _ref11$viewMatrixUnce === undefined ? null : _ref11$viewMatrixUnce,
      _ref11$meterOffset = _ref11.meterOffset,
      meterOffset = _ref11$meterOffset === undefined ? null : _ref11$meterOffset,
      _ref11$flipY = _ref11.flipY,
      flipY = _ref11$flipY === undefined ? true : _ref11$flipY;

  if (!center) {
    center = getWorldPosition({ longitude: longitude, latitude: latitude, zoom: zoom, distanceScales: distanceScales, meterOffset: meterOffset });
  }

  // VIEW MATRIX: PROJECTS FROM VIRTUAL PIXELS TO CAMERA SPACE
  // Note: As usual, matrix operation orders should be read in reverse
  // since vectors will be multiplied from the right during transformation
  if (!viewMatrixUncentered) {
    viewMatrixUncentered = getUncenteredViewMatrix({ height: height, pitch: pitch, bearing: bearing, altitude: altitude });
  }

  var vm = (0, _mathUtils.createMat4)();

  if (flipY) {
    (0, _scale2.default)(vm, viewMatrixUncentered, [1, -1, 1]);
  }

  var viewMatrixCentered = (0, _translate2.default)(vm, vm, new _math.Vector3(center).negate());

  return viewMatrixCentered;
}

// PROJECTION MATRIX: PROJECTS FROM CAMERA (VIEW) SPACE TO CLIPSPACE
// This is a "Mapbox" projection matrix - matches mapbox exactly if farZMultiplier === 1
function getProjectionMatrix(_ref12) {
  var width = _ref12.width,
      height = _ref12.height,
      pitch = _ref12.pitch,
      altitude = _ref12.altitude,
      _ref12$farZMultiplier = _ref12.farZMultiplier,
      farZMultiplier = _ref12$farZMultiplier === undefined ? 10 : _ref12$farZMultiplier;

  var _getClippingPlanes = getClippingPlanes({ altitude: altitude, pitch: pitch }),
      nearZ = _getClippingPlanes.nearZ,
      farZ = _getClippingPlanes.farZ;

  var fov = getFov({ height: height, altitude: altitude });

  var projectionMatrix = (0, _perspective2.default)([], fov, // fov in radians
  width / height, // aspect ratio
  nearZ, // near plane
  farZ * farZMultiplier // far plane
  );

  return projectionMatrix;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy93ZWItbWVyY2F0b3ItdXRpbHMuanMiXSwibmFtZXMiOlsicHJvamVjdEZsYXQiLCJ1bnByb2plY3RGbGF0IiwiZ2V0TWV0ZXJab29tIiwiZ2V0RGlzdGFuY2VTY2FsZXMiLCJnZXRXb3JsZFBvc2l0aW9uIiwiZ2V0VW5jZW50ZXJlZFZpZXdNYXRyaXgiLCJnZXRWaWV3TWF0cml4IiwiZ2V0UHJvamVjdGlvbk1hdHJpeCIsIlBJIiwiTWF0aCIsIlBJXzQiLCJERUdSRUVTX1RPX1JBRElBTlMiLCJSQURJQU5TX1RPX0RFR1JFRVMiLCJUSUxFX1NJWkUiLCJFQVJUSF9DSVJDVU1GRVJFTkNFIiwic2NhbGUiLCJsbmciLCJsYXQiLCJsYW1iZGEyIiwicGhpMiIsIngiLCJ5IiwibG9nIiwidGFuIiwiYXRhbiIsImV4cCIsImxhdGl0dWRlIiwibGF0Q29zaW5lIiwiY29zIiwibG9nMiIsImxvbmdpdHVkZSIsInpvb20iLCJoaWdoUHJlY2lzaW9uIiwidW5kZWZpbmVkIiwicG93IiwiaXNGaW5pdGUiLCJyZXN1bHQiLCJ3b3JsZFNpemUiLCJwaXhlbHNQZXJEZWdyZWVYIiwicGl4ZWxzUGVyRGVncmVlWSIsImFsdFBpeGVsc1Blck1ldGVyIiwicGl4ZWxzUGVyTWV0ZXIiLCJtZXRlcnNQZXJQaXhlbCIsInBpeGVsc1BlckRlZ3JlZSIsImRlZ3JlZXNQZXJQaXhlbCIsImxhdENvc2luZTIiLCJwaXhlbHNQZXJEZWdyZWVZMiIsImFsdFBpeGVsc1BlckRlZ3JlZTIiLCJhbHRQaXhlbHNQZXJNZXRlcjIiLCJwaXhlbHNQZXJEZWdyZWUyIiwicGl4ZWxzUGVyTWV0ZXIyIiwibWV0ZXJPZmZzZXQiLCJkaXN0YW5jZVNjYWxlcyIsImNlbnRlcjJkIiwiY2VudGVyIiwicGl4ZWxQb3NpdGlvbiIsImFkZCIsImdldEZvdiIsImhlaWdodCIsImFsdGl0dWRlIiwiZ2V0Q2xpcHBpbmdQbGFuZXMiLCJwaXRjaCIsInBpdGNoUmFkaWFucyIsImhhbGZGb3YiLCJ0b3BIYWxmU3VyZmFjZURpc3RhbmNlIiwic2luIiwiZmFyWiIsIm5lYXJaIiwiYmVhcmluZyIsInZtIiwid2lkdGgiLCJ2aWV3TWF0cml4VW5jZW50ZXJlZCIsImZsaXBZIiwidmlld01hdHJpeENlbnRlcmVkIiwibmVnYXRlIiwiZmFyWk11bHRpcGxpZXIiLCJmb3YiLCJwcm9qZWN0aW9uTWF0cml4Il0sIm1hcHBpbmdzIjoiOzs7Ozs7eXBCQUFBOztRQStCZ0JBLFcsR0FBQUEsVztRQWtCQUMsYSxHQUFBQSxhO1FBU0FDLFksR0FBQUEsWTtRQVlBQyxpQixHQUFBQSxpQjtRQXVEQUMsZ0IsR0FBQUEsZ0I7UUFzREFDLHVCLEdBQUFBLHVCO1FBMkJBQyxhLEdBQUFBLGE7UUEwQ0FDLG1CLEdBQUFBLG1COztBQXRQaEI7O0FBQ0E7O0FBRUE7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7Ozs7QUFFQTtBQUNBLElBQU1DLEtBQUtDLEtBQUtELEVBQWhCO0FBQ0EsSUFBTUUsT0FBT0YsS0FBSyxDQUFsQjtBQUNBLElBQU1HLHFCQUFxQkgsS0FBSyxHQUFoQztBQUNBLElBQU1JLHFCQUFxQixNQUFNSixFQUFqQztBQUNBLElBQU1LLFlBQVksR0FBbEI7QUFDQTtBQUNBLElBQU1DLHNCQUFzQixPQUE1Qjs7QUFFQTs7Ozs7Ozs7OztBQVVPLFNBQVNkLFdBQVQsT0FBaUNlLEtBQWpDLEVBQXdDO0FBQUE7QUFBQSxNQUFsQkMsR0FBa0I7QUFBQSxNQUFiQyxHQUFhOztBQUM3Q0YsV0FBU0YsU0FBVDtBQUNBLE1BQU1LLFVBQVVGLE1BQU1MLGtCQUF0QjtBQUNBLE1BQU1RLE9BQU9GLE1BQU1OLGtCQUFuQjtBQUNBLE1BQU1TLElBQUlMLFNBQVNHLFVBQVVWLEVBQW5CLEtBQTBCLElBQUlBLEVBQTlCLENBQVY7QUFDQSxNQUFNYSxJQUFJTixTQUFTUCxLQUFLQyxLQUFLYSxHQUFMLENBQVNiLEtBQUtjLEdBQUwsQ0FBU2IsT0FBT1MsT0FBTyxHQUF2QixDQUFULENBQWQsS0FBd0QsSUFB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RUFBeUJULGtCQUF6QixFQUF4QixDQUF2QjtBQUNEOztBQUVELE1BQU1VLEtBQUssNEJBQVg7O0FBRUEsTUFBSUcsS0FBSixFQUFXO0FBQ1QseUJBQVdILEVBQVgsRUFBZUUsb0JBQWYsRUFBcUMsQ0FBQyxDQUFELEVBQUksQ0FBQyxDQUFMLEVBQVEsQ0FBUixDQUFyQztBQUNEOztBQUVELE1BQU1FLHFCQUFxQix5QkFBZUosRUFBZixFQUFtQkEsRUFBbkIsRUFBdUIsa0JBQVlmLE1BQVosRUFBb0JvQixNQUFwQixFQUF2QixDQUEzQjs7QUFFQSxTQUFPRCxrQkFBUDtBQUNEOztBQUVEO0FBQ0E7QUFDTyxTQUFTbEUsbUJBQVQsU0FNSjtBQUFBLE1BTEQrRCxLQUtDLFVBTERBLEtBS0M7QUFBQSxNQUpEWixNQUlDLFVBSkRBLE1BSUM7QUFBQSxNQUhERyxLQUdDLFVBSERBLEtBR0M7QUFBQSxNQUZERixRQUVDLFVBRkRBLFFBRUM7QUFBQSxxQ0FERGdCLGNBQ0M7QUFBQSxNQUREQSxjQUNDLHlDQURnQixFQUNoQjs7QUFBQSwyQkFDcUJmLGtCQUFrQixFQUFDRCxrQkFBRCxFQUFXRSxZQUFYLEVBQWxCLENBRHJCO0FBQUEsTUFDTU0sS0FETixzQkFDTUEsS0FETjtBQUFBLE1BQ2FELElBRGIsc0JBQ2FBLElBRGI7O0FBRUQsTUFBTVUsTUFBTW5CLE9BQU8sRUFBQ0MsY0FBRCxFQUFTQyxrQkFBVCxFQUFQLENBQVo7O0FBRUEsTUFBTWtCLG1CQUFtQiwyQkFDdkIsRUFEdUIsRUFFdkJELEdBRnVCLEVBRUw7QUFDbEJOLFVBQVFaLE1BSGUsRUFHTDtBQUNsQlMsT0FKdUIsRUFJTDtBQUNsQkQsU0FBT1MsY0FMZ0IsQ0FLRDtBQUxDLEdBQXpCOztBQVFBLFNBQU9FLGdCQUFQO0FBQ0QiLCJmaWxlIjoid2ViLW1lcmNhdG9yLXV0aWxzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gVE9ETyAtIFRIRSBVVElMSVRJRVMgSU4gVEhJUyBGSUxFIFNIT1VMRCBCRSBJTVBPUlRFRCBGUk9NIFdFQi1NRVJDQVRPUi1WSUVXUE9SVCBNT0RVTEVcblxuaW1wb3J0IHtWZWN0b3IzfSBmcm9tICdtYXRoLmdsJztcbmltcG9ydCB7Y3JlYXRlTWF0NH0gZnJvbSAnLi9tYXRoLXV0aWxzJztcblxuaW1wb3J0IG1hdDRfcGVyc3BlY3RpdmUgZnJvbSAnZ2wtbWF0NC9wZXJzcGVjdGl2ZSc7XG5pbXBvcnQgbWF0NF9zY2FsZSBmcm9tICdnbC1tYXQ0L3NjYWxlJztcbmltcG9ydCBtYXQ0X3RyYW5zbGF0ZSBmcm9tICdnbC1tYXQ0L3RyYW5zbGF0ZSc7XG5pbXBvcnQgbWF0NF9yb3RhdGVYIGZyb20gJ2dsLW1hdDQvcm90YXRlWCc7XG5pbXBvcnQgbWF0NF9yb3RhdGVaIGZyb20gJ2dsLW1hdDQvcm90YXRlWic7XG5pbXBvcnQgYXNzZXJ0IGZyb20gJ2Fzc2VydCc7XG5cbi8vIENPTlNUQU5UU1xuY29uc3QgUEkgPSBNYXRoLlBJO1xuY29uc3QgUElfNCA9IFBJIC8gNDtcbmNvbnN0IERFR1JFRVNfVE9fUkFESUFOUyA9IFBJIC8gMTgwO1xuY29uc3QgUkFESUFOU19UT19ERUdSRUVTID0gMTgwIC8gUEk7XG5jb25zdCBUSUxFX1NJWkUgPSA1MTI7XG4vLyBBdmVyYWdlIGNpcmN1bWZlcmVuY2UgKDQwMDc1IGttIGVxdWF0b3JpYWwsIDQwMDA3IGttIG1lcmlkaW9uYWwpXG5jb25zdCBFQVJUSF9DSVJDVU1GRVJFTkNFID0gNDAuMDNlNjtcblxuLyoqXG4gKiBQcm9qZWN0IFtsbmcsbGF0XSBvbiBzcGhlcmUgb250byBbeCx5XSBvbiA1MTIqNTEyIE1lcmNhdG9yIFpvb20gMCB0aWxlLlxuICogUGVyZm9ybXMgdGhlIG5vbmxpbmVhciBwYXJ0IG9mIHRoZSB3ZWIgbWVyY2F0b3IgcHJvamVjdGlvbi5cbiAqIFJlbWFpbmluZyBwcm9qZWN0aW9uIGlzIGRvbmUgd2l0aCA0eDQgbWF0cmljZXMgd2hpY2ggYWxzbyBoYW5kbGVzXG4gKiBwZXJzcGVjdGl2ZS5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBsbmdMYXQgLSBbbG5nLCBsYXRdIGNvb3JkaW5hdGVzXG4gKiAgIFNwZWNpZmllcyBhIHBvaW50IG9uIHRoZSBzcGhlcmUgdG8gcHJvamVjdCBvbnRvIHRoZSBtYXAuXG4gKiBAcmV0dXJuIHtBcnJheX0gW3gseV0gY29vcmRpbmF0ZXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwcm9qZWN0RmxhdChbbG5nLCBsYXRdLCBzY2FsZSkge1xuICBzY2FsZSAqPSBUSUxFX1NJWkU7XG4gIGNvbnN0IGxhbWJkYTIgPSBsbmcgKiBERUdSRUVTX1RPX1JBRElBTlM7XG4gIGNvbnN0IHBoaTIgPSBsYXQgKiBERUdSRUVTX1RPX1JBRElBTlM7XG4gIGNvbnN0IHggPSBzY2FsZSAqIChsYW1iZGEyICsgUEkpIC8gKDIgKiBQSSk7XG4gIGNvbnN0IHkgPSBzY2FsZSAqIChQSSAtIE1hdGgubG9nKE1hdGgudGFuKFBJXzQgKyBwaGkyICogMC41KSkpIC8gKDIgKiBQSSk7XG4gIHJldHVybiBbeCwgeV07XG59XG5cbi8qKlxuICogVW5wcm9qZWN0IHdvcmxkIHBvaW50IFt4LHldIG9uIG1hcCBvbnRvIHtsYXQsIGxvbn0gb24gc3BoZXJlXG4gKlxuICogQHBhcmFtIHtvYmplY3R8VmVjdG9yfSB4eSAtIG9iamVjdCB3aXRoIHt4LHl9IG1lbWJlcnNcbiAqICByZXByZXNlbnRpbmcgcG9pbnQgb24gcHJvamVjdGVkIG1hcCBwbGFuZVxuICogQHJldHVybiB7R2VvQ29vcmRpbmF0ZXN9IC0gb2JqZWN0IHdpdGgge2xhdCxsb259IG9mIHBvaW50IG9uIHNwaGVyZS5cbiAqICAgSGFzIHRvQXJyYXkgbWV0aG9kIGlmIHlvdSBuZWVkIGEgR2VvSlNPTiBBcnJheS5cbiAqICAgUGVyIGNhcnRvZ3JhcGhpYyB0cmFkaXRpb24sIGxhdCBhbmQgbG9uIGFyZSBzcGVjaWZpZWQgYXMgZGVncmVlcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVucHJvamVjdEZsYXQoW3gsIHldLCBzY2FsZSkge1xuICBzY2FsZSAqPSBUSUxFX1NJWkU7XG4gIGNvbnN0IGxhbWJkYTIgPSAoeCAvIHNjYWxlKSAqICgyICogUEkpIC0gUEk7XG4gIGNvbnN0IHBoaTIgPSAyICogKE1hdGguYXRhbihNYXRoLmV4cChQSSAtICh5IC8gc2NhbGUpICogKDIgKiBQSSkpKSAtIFBJXzQpO1xuICByZXR1cm4gW2xhbWJkYTIgKiBSQURJQU5TX1RPX0RFR1JFRVMsIHBoaTIgKiBSQURJQU5TX1RPX0RFR1JFRVNdO1xufVxuXG4vLyBSZXR1cm5zIHRoZSB6b29tIGxldmVsIHRoYXQgZ2l2ZXMgYSAxIG1ldGVyIHBpeGVsIGF0IGEgY2VydGFpbiBsYXRpdHVkZVxuLy8gUz1DKmNvcyh5KS8yXih6KzgpXG5leHBvcnQgZnVuY3Rpb24gZ2V0TWV0ZXJab29tKHtsYXRpdHVkZX0pIHtcbiAgYXNzZXJ0KGxhdGl0dWRlKTtcbiAgY29uc3QgbGF0Q29zaW5lID0gTWF0aC5jb3MobGF0aXR1ZGUgKiBERUdSRUVTX1RPX1JBRElBTlMpO1xuICByZXR1cm4gTWF0aC5sb2cyKEVBUlRIX0NJUkNVTUZFUkVOQ0UgKiBsYXRDb3NpbmUpIC0gODtcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGUgZGlzdGFuY2Ugc2NhbGVzIGluIG1ldGVycyBhcm91bmQgY3VycmVudCBsYXQvbG9uLCBib3RoIGZvclxuICogZGVncmVlcyBhbmQgcGl4ZWxzLlxuICogSW4gbWVyY2F0b3IgcHJvamVjdGlvbiBtb2RlLCB0aGUgZGlzdGFuY2Ugc2NhbGVzIHZhcnkgc2lnbmlmaWNhbnRseVxuICogd2l0aCBsYXRpdHVkZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldERpc3RhbmNlU2NhbGVzKHtsYXRpdHVkZSwgbG9uZ2l0dWRlLCB6b29tLCBzY2FsZSwgaGlnaFByZWNpc2lvbiA9IGZhbHNlfSkge1xuICAvLyBDYWxjdWxhdGUgc2NhbGUgZnJvbSB6b29tIGlmIG5vdCBwcm92aWRlZFxuICBzY2FsZSA9IHNjYWxlICE9PSB1bmRlZmluZWQgPyBzY2FsZSA6IE1hdGgucG93KDIsIHpvb20pO1xuXG4gIGFzc2VydChpc0Zpbml0ZShsYXRpdHVkZSkgJiYgaXNGaW5pdGUobG9uZ2l0dWRlKSAmJiBpc0Zpbml0ZShzY2FsZSkpO1xuXG4gIGNvbnN0IHJlc3VsdCA9IHt9O1xuICBjb25zdCB3b3JsZFNpemUgPSBUSUxFX1NJWkUgKiBzY2FsZTtcbiAgY29uc3QgbGF0Q29zaW5lID0gTWF0aC5jb3MobGF0aXR1ZGUgKiBERUdSRUVTX1RPX1JBRElBTlMpO1xuXG4gIC8qKlxuICAgKiBOdW1iZXIgb2YgcGl4ZWxzIG9jY3VwaWVkIGJ5IG9uZSBkZWdyZWUgbG9uZ2l0dWRlIGFyb3VuZCBjdXJyZW50IGxhdC9sb246XG4gICAgIHBpeGVsc1BlckRlZ3JlZVggPSBkKHByb2plY3RGbGF0KFtsbmcsIGxhdF0pWzBdKS9kKGxuZylcbiAgICAgICA9IHNjYWxlICogVElMRV9TSVpFICogREVHUkVFU19UT19SQURJQU5TIC8gKDIgKiBQSSlcbiAgICAgcGl4ZWxzUGVyRGVncmVlWSA9IGQocHJvamVjdEZsYXQoW2xuZywgbGF0XSlbMV0pL2QobGF0KVxuICAgICAgID0gLXNjYWxlICogVElMRV9TSVpFICogREVHUkVFU19UT19SQURJQU5TIC8gY29zKGxhdCAqIERFR1JFRVNfVE9fUkFESUFOUykgIC8gKDIgKiBQSSlcbiAgICovXG4gIGNvbnN0IHBpeGVsc1BlckRlZ3JlZVggPSB3b3JsZFNpemUgLyAzNjA7XG4gIGNvbnN0IHBpeGVsc1BlckRlZ3JlZVkgPSBwaXhlbHNQZXJEZWdyZWVYIC8gbGF0Q29zaW5lO1xuXG4gIC8qKlxuICAgKiBOdW1iZXIgb2YgcGl4ZWxzIG9jY3VwaWVkIGJ5IG9uZSBtZXRlciBhcm91bmQgY3VycmVudCBsYXQvbG9uOlxuICAgKi9cbiAgY29uc3QgYWx0UGl4ZWxzUGVyTWV0ZXIgPSB3b3JsZFNpemUgLyBFQVJUSF9DSVJDVU1GRVJFTkNFIC8gbGF0Q29zaW5lO1xuXG4gIHJlc3VsdC5waXhlbHNQZXJNZXRlciA9IFthbHRQaXhlbHNQZXJNZXRlciwgYWx0UGl4ZWxzUGVyTWV0ZXIsIGFsdFBpeGVsc1Blck1ldGVyXTtcbiAgcmVzdWx0Lm1ldGVyc1BlclBpeGVsID0gWzEgLyBhbHRQaXhlbHNQZXJNZXRlciwgMSAvIGFsdFBpeGVsc1Blck1ldGVyLCAxIC8gYWx0UGl4ZWxzUGVyTWV0ZXJdO1xuXG4gIHJlc3VsdC5waXhlbHNQZXJEZWdyZWUgPSBbcGl4ZWxzUGVyRGVncmVlWCwgcGl4ZWxzUGVyRGVncmVlWSwgYWx0UGl4ZWxzUGVyTWV0ZXJdO1xuICByZXN1bHQuZGVncmVlc1BlclBpeGVsID0gWzEgLyBwaXhlbHNQZXJEZWdyZWVYLCAxIC8gcGl4ZWxzUGVyRGVncmVlWSwgMSAvIGFsdFBpeGVsc1Blck1ldGVyXTtcblxuICAvKipcbiAgICogVGF5bG9yIHNlcmllcyAybmQgb3JkZXIgZm9yIDEvbGF0Q29zaW5lXG4gICAgIGYnKGEpICogKHggLSBhKVxuICAgICAgID0gZCgxL2NvcyhsYXQgKiBERUdSRUVTX1RPX1JBRElBTlMpKS9kKGxhdCkgKiBkTGF0XG4gICAgICAgPSBERUdSRUVTX1RPX1JBRElBTlMgKiB0YW4obGF0ICogREVHUkVFU19UT19SQURJQU5TKSAvIGNvcyhsYXQgKiBERUdSRUVTX1RPX1JBRElBTlMpICogZExhdFxuICAgKi9cbiAgaWYgKGhpZ2hQcmVjaXNpb24pIHtcbiAgICBjb25zdCBsYXRDb3NpbmUyID0gREVHUkVFU19UT19SQURJQU5TICogTWF0aC50YW4obGF0aXR1ZGUgKiBERUdSRUVTX1RPX1JBRElBTlMpIC8gbGF0Q29zaW5lO1xuICAgIGNvbnN0IHBpeGVsc1BlckRlZ3JlZVkyID0gcGl4ZWxzUGVyRGVncmVlWCAqIGxhdENvc2luZTIgLyAyO1xuICAgIGNvbnN0IGFsdFBpeGVsc1BlckRlZ3JlZTIgPSB3b3JsZFNpemUgLyBFQVJUSF9DSVJDVU1GRVJFTkNFICogbGF0Q29zaW5lMjtcbiAgICBjb25zdCBhbHRQaXhlbHNQZXJNZXRlcjIgPSBhbHRQaXhlbHNQZXJEZWdyZWUyIC8gcGl4ZWxzUGVyRGVncmVlWSAqIGFsdFBpeGVsc1Blck1ldGVyO1xuXG4gICAgcmVzdWx0LnBpeGVsc1BlckRlZ3JlZTIgPSBbMCwgcGl4ZWxzUGVyRGVncmVlWTIsIGFsdFBpeGVsc1BlckRlZ3JlZTJdO1xuICAgIHJlc3VsdC5waXhlbHNQZXJNZXRlcjIgPSBbYWx0UGl4ZWxzUGVyTWV0ZXIyLCAwLCBhbHRQaXhlbHNQZXJNZXRlcjJdO1xuICB9XG5cbiAgLy8gTWFpbiByZXN1bHRzLCB1c2VkIGZvciBjb252ZXJ0aW5nIG1ldGVycyB0byBsYXRsbmcgZGVsdGFzIGFuZCBzY2FsaW5nIG9mZnNldHNcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGVzIGEgbWVyY2F0b3Igd29ybGQgcG9zaXRpb24gKFwicGl4ZWxzXCIgaW4gZ2l2ZW4gem9vbSBsZXZlbClcbiAqIGZyb20gYSBsbmcvbGF0IGFuZCBtZXRlck9mZnNldFxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0V29ybGRQb3NpdGlvbih7XG4gIGxvbmdpdHVkZSxcbiAgbGF0aXR1ZGUsXG4gIHpvb20sXG4gIG1ldGVyT2Zmc2V0LFxuICBkaXN0YW5jZVNjYWxlcyA9IG51bGxcbn0pIHtcbiAgY29uc3Qgc2NhbGUgPSBNYXRoLnBvdygyLCB6b29tKTtcblxuICAvLyBNYWtlIGEgY2VudGVyZWQgdmVyc2lvbiBvZiB0aGUgbWF0cml4IGZvciBwcm9qZWN0aW9uIG1vZGVzIHdpdGhvdXQgYW4gb2Zmc2V0XG4gIGNvbnN0IGNlbnRlcjJkID0gcHJvamVjdEZsYXQoW2xvbmdpdHVkZSwgbGF0aXR1ZGVdLCBzY2FsZSk7XG4gIGNvbnN0IGNlbnRlciA9IG5ldyBWZWN0b3IzKGNlbnRlcjJkWzBdLCBjZW50ZXIyZFsxXSwgMCk7XG5cbiAgaWYgKG1ldGVyT2Zmc2V0KSB7XG4gICAgLy8gQ2FsY3VsYXRlIGRpc3RhbmNlIHNjYWxlcyBpZiBsbmcvbGF0L3pvb20gYXJlIHByb3ZpZGVkXG4gICAgZGlzdGFuY2VTY2FsZXMgPSBkaXN0YW5jZVNjYWxlcyB8fCBnZXREaXN0YW5jZVNjYWxlcyh7bGF0aXR1ZGUsIGxvbmdpdHVkZSwgc2NhbGV9KTtcblxuICAgIGNvbnN0IHBpeGVsUG9zaXRpb24gPSBuZXcgVmVjdG9yMyhtZXRlck9mZnNldClcbiAgICAgIC8vIENvbnZlcnQgdG8gcGl4ZWxzIGluIGN1cnJlbnQgem9vbVxuICAgICAgLnNjYWxlKGRpc3RhbmNlU2NhbGVzLnBpeGVsc1Blck1ldGVyKVxuICAgICAgLy8gV2Ugd2FudCBwb3NpdGl2ZSBZIHRvIHJlcHJlc2VudCBhbiBvZmZzZXQgdG93YXJkcyBub3J0aCxcbiAgICAgIC8vIGJ1dCB3ZWIgbWVyY2F0b3Igd29ybGQgY29vcmRpbmF0ZXMgaXMgdG9wLWxlZnRcbiAgICAgIC5zY2FsZShbMSwgLTEsIDFdKTtcbiAgICBjZW50ZXIuYWRkKHBpeGVsUG9zaXRpb24pO1xuICB9XG5cbiAgcmV0dXJuIGNlbnRlcjtcbn1cblxuLy8gQVRUUklCVVRJT046XG4vLyB2aWV3IGFuZCBwcm9qZWN0aW9uIG1hdHJpeCBjcmVhdGlvbiBpcyBpbnRlbnRpb25hbGx5IGtlcHQgY29tcGF0aWJsZSB3aXRoXG4vLyBtYXBib3gtZ2wncyBpbXBsZW1lbnRhdGlvbiB0byBlbnN1cmUgdGhhdCBzZWFtbGVzcyBpbnRlcm9wZXJhdGlvblxuLy8gd2l0aCBtYXBib3ggYW5kIHJlYWN0LW1hcC1nbC4gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vbWFwYm94L21hcGJveC1nbC1qc1xuXG4vLyBWYXJpYWJsZSBmb3YgKGluIHJhZGlhbnMpXG5mdW5jdGlvbiBnZXRGb3Yoe2hlaWdodCwgYWx0aXR1ZGV9KSB7XG4gIHJldHVybiAyICogTWF0aC5hdGFuKChoZWlnaHQgLyAyKSAvIGFsdGl0dWRlKTtcbn1cblxuZnVuY3Rpb24gZ2V0Q2xpcHBpbmdQbGFuZXMoe2FsdGl0dWRlLCBwaXRjaH0pIHtcbiAgLy8gRmluZCB0aGUgZGlzdGFuY2UgZnJvbSB0aGUgY2VudGVyIHBvaW50IHRvIHRoZSBjZW50ZXIgdG9wXG4gIC8vIGluIGFsdGl0dWRlIHVuaXRzIHVzaW5nIGxhdyBvZiBzaW5lcy5cbiAgY29uc3QgcGl0Y2hSYWRpYW5zID0gcGl0Y2ggKiBERUdSRUVTX1RPX1JBRElBTlM7XG4gIGNvbnN0IGhhbGZGb3YgPSBNYXRoLmF0YW4oMC41IC8gYWx0aXR1ZGUpO1xuICBjb25zdCB0b3BIYWxmU3VyZmFjZURpc3RhbmNlID1cbiAgICBNYXRoLnNpbihoYWxmRm92KSAqIGFsdGl0dWRlIC8gTWF0aC5zaW4oTWF0aC5QSSAvIDIgLSBwaXRjaFJhZGlhbnMgLSBoYWxmRm92KTtcblxuICAvLyBDYWxjdWxhdGUgeiB2YWx1ZSBvZiB0aGUgZmFydGhlc3QgZnJhZ21lbnQgdGhhdCBzaG91bGQgYmUgcmVuZGVyZWQuXG4gIGNvbnN0IGZhclogPSBNYXRoLmNvcyhNYXRoLlBJIC8gMiAtIHBpdGNoUmFkaWFucykgKiB0b3BIYWxmU3VyZmFjZURpc3RhbmNlICsgYWx0aXR1ZGU7XG5cbiAgcmV0dXJuIHtmYXJaLCBuZWFyWjogMC4xfTtcbn1cblxuLy8gVE9ETyAtIHJlbmFtZSB0aGlzIG1hdHJpeFxuZXhwb3J0IGZ1bmN0aW9uIGdldFVuY2VudGVyZWRWaWV3TWF0cml4KHtcbiAgaGVpZ2h0LFxuICBwaXRjaCxcbiAgYmVhcmluZyxcbiAgYWx0aXR1ZGVcbn0pIHtcbiAgLy8gVklFVyBNQVRSSVg6IFBST0pFQ1RTIE1FUkNBVE9SIFdPUkxEIENPT1JESU5BVEVTXG4gIC8vIE5vdGUgdGhhdCBtZXJjYXRvciB3b3JsZCBjb29yZGluYXRlcyB0eXBpY2FsbHkgbmVlZCB0byBiZSBmbGlwcGVkXG4gIC8vXG4gIC8vIE5vdGU6IEFzIHVzdWFsLCBtYXRyaXggb3BlcmF0aW9uIG9yZGVycyBzaG91bGQgYmUgcmVhZCBpbiByZXZlcnNlXG4gIC8vIHNpbmNlIHZlY3RvcnMgd2lsbCBiZSBtdWx0aXBsaWVkIGZyb20gdGhlIHJpZ2h0IGR1cmluZyB0cmFuc2Zvcm1hdGlvblxuICBjb25zdCB2bSA9IGNyZWF0ZU1hdDQoKTtcblxuICAvLyBNb3ZlIGNhbWVyYSB0byBhbHRpdHVkZSAoYWxvbmcgdGhlIHBpdGNoICYgYmVhcmluZyBkaXJlY3Rpb24pXG4gIG1hdDRfdHJhbnNsYXRlKHZtLCB2bSwgWzAsIDAsIC1hbHRpdHVkZV0pO1xuXG4gIC8vIEFmdGVyIHRoZSByb3RhdGVYLCB6IHZhbHVlcyBhcmUgaW4gcGl4ZWwgdW5pdHMuIENvbnZlcnQgdGhlbSB0b1xuICAvLyBhbHRpdHVkZSB1bml0cy4gMSBhbHRpdHVkZSB1bml0ID0gdGhlIHNjcmVlbiBoZWlnaHQuXG4gIG1hdDRfc2NhbGUodm0sIHZtLCBbMSwgMSwgMSAvIGhlaWdodF0pO1xuXG4gIC8vIFJvdGF0ZSBieSBiZWFyaW5nLCBhbmQgdGhlbiBieSBwaXRjaCAod2hpY2ggdGlsdHMgdGhlIHZpZXcpXG4gIG1hdDRfcm90YXRlWCh2bSwgdm0sIC1waXRjaCAqIERFR1JFRVNfVE9fUkFESUFOUyk7XG4gIG1hdDRfcm90YXRlWih2bSwgdm0sIGJlYXJpbmcgKiBERUdSRUVTX1RPX1JBRElBTlMpO1xuXG4gIHJldHVybiB2bTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFZpZXdNYXRyaXgoe1xuICAvLyBWaWV3cG9ydCBwcm9wc1xuICB3aWR0aCxcbiAgaGVpZ2h0LFxuICBsb25naXR1ZGUsXG4gIGxhdGl0dWRlLFxuICB6b29tLFxuICBwaXRjaCxcbiAgYmVhcmluZyxcbiAgYWx0aXR1ZGUsXG4gIC8vIFByZS1jYWxjdWxhdGVkIHBhcmFtZXRlcnNcbiAgZGlzdGFuY2VTY2FsZXMgPSBudWxsLFxuICBjZW50ZXIgPSBudWxsLFxuICB2aWV3TWF0cml4VW5jZW50ZXJlZCA9IG51bGwsXG4gIC8vIE9wdGlvbnNcbiAgbWV0ZXJPZmZzZXQgPSBudWxsLFxuICBmbGlwWSA9IHRydWVcbn0pIHtcbiAgaWYgKCFjZW50ZXIpIHtcbiAgICBjZW50ZXIgPSBnZXRXb3JsZFBvc2l0aW9uKHtsb25naXR1ZGUsIGxhdGl0dWRlLCB6b29tLCBkaXN0YW5jZVNjYWxlcywgbWV0ZXJPZmZzZXR9KTtcbiAgfVxuXG4gIC8vIFZJRVcgTUFUUklYOiBQUk9KRUNUUyBGUk9NIFZJUlRVQUwgUElYRUxTIFRPIENBTUVSQSBTUEFDRVxuICAvLyBOb3RlOiBBcyB1c3VhbCwgbWF0cml4IG9wZXJhdGlvbiBvcmRlcnMgc2hvdWxkIGJlIHJlYWQgaW4gcmV2ZXJzZVxuICAvLyBzaW5jZSB2ZWN0b3JzIHdpbGwgYmUgbXVsdGlwbGllZCBmcm9tIHRoZSByaWdodCBkdXJpbmcgdHJhbnNmb3JtYXRpb25cbiAgaWYgKCF2aWV3TWF0cml4VW5jZW50ZXJlZCkge1xuICAgIHZpZXdNYXRyaXhVbmNlbnRlcmVkID0gZ2V0VW5jZW50ZXJlZFZpZXdNYXRyaXgoe2hlaWdodCwgcGl0Y2gsIGJlYXJpbmcsIGFsdGl0dWRlfSk7XG4gIH1cblxuICBjb25zdCB2bSA9IGNyZWF0ZU1hdDQoKTtcblxuICBpZiAoZmxpcFkpIHtcbiAgICBtYXQ0X3NjYWxlKHZtLCB2aWV3TWF0cml4VW5jZW50ZXJlZCwgWzEsIC0xLCAxXSk7XG4gIH1cblxuICBjb25zdCB2aWV3TWF0cml4Q2VudGVyZWQgPSBtYXQ0X3RyYW5zbGF0ZSh2bSwgdm0sIG5ldyBWZWN0b3IzKGNlbnRlcikubmVnYXRlKCkpO1xuXG4gIHJldHVybiB2aWV3TWF0cml4Q2VudGVyZWQ7XG59XG5cbi8vIFBST0pFQ1RJT04gTUFUUklYOiBQUk9KRUNUUyBGUk9NIENBTUVSQSAoVklFVykgU1BBQ0UgVE8gQ0xJUFNQQUNFXG4vLyBUaGlzIGlzIGEgXCJNYXBib3hcIiBwcm9qZWN0aW9uIG1hdHJpeCAtIG1hdGNoZXMgbWFwYm94IGV4YWN0bHkgaWYgZmFyWk11bHRpcGxpZXIgPT09IDFcbmV4cG9ydCBmdW5jdGlvbiBnZXRQcm9qZWN0aW9uTWF0cml4KHtcbiAgd2lkdGgsXG4gIGhlaWdodCxcbiAgcGl0Y2gsXG4gIGFsdGl0dWRlLFxuICBmYXJaTXVsdGlwbGllciA9IDEwXG59KSB7XG4gIGNvbnN0IHtuZWFyWiwgZmFyWn0gPSBnZXRDbGlwcGluZ1BsYW5lcyh7YWx0aXR1ZGUsIHBpdGNofSk7XG4gIGNvbnN0IGZvdiA9IGdldEZvdih7aGVpZ2h0LCBhbHRpdHVkZX0pO1xuXG4gIGNvbnN0IHByb2plY3Rpb25NYXRyaXggPSBtYXQ0X3BlcnNwZWN0aXZlKFxuICAgIFtdLFxuICAgIGZvdiwgICAgICAgICAgICAgIC8vIGZvdiBpbiByYWRpYW5zXG4gICAgd2lkdGggLyBoZWlnaHQsICAgLy8gYXNwZWN0IHJhdGlvXG4gICAgbmVhclosICAgICAgICAgICAgLy8gbmVhciBwbGFuZVxuICAgIGZhclogKiBmYXJaTXVsdGlwbGllciAvLyBmYXIgcGxhbmVcbiAgKTtcblxuICByZXR1cm4gcHJvamVjdGlvbk1hdHJpeDtcbn1cbiJdfQ==