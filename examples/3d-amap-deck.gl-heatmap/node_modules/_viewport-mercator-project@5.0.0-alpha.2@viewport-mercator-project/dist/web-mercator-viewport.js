'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.fitBounds = undefined;

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _viewport = require('./viewport');

var _viewport2 = _interopRequireDefault(_viewport);

var _webMercatorUtils = require('./web-mercator-utils');

var _add = require('gl-vec2/add');

var _add2 = _interopRequireDefault(_add);

var _negate = require('gl-vec2/negate');

var _negate2 = _interopRequireDefault(_negate);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // View and Projection Matrix calculations for mapbox-js style map view properties


/* eslint-disable camelcase */


var WebMercatorViewport = function (_Viewport) {
  _inherits(WebMercatorViewport, _Viewport);

  /**
   * @classdesc
   * Creates view/projection matrices from mercator params
   * Note: The Viewport is immutable in the sense that it only has accessors.
   * A new viewport instance should be created if any parameters have changed.
   *
   * @class
   * @param {Object} opt - options
   *
   * @param {Number} opt.width=1 - Width of "viewport" or window
   * @param {Number} opt.height=1 - Height of "viewport" or window
   * @param {Number} opt.scale=1 - Either use scale or zoom
   * @param {Number} opt.pitch=0 - Camera angle in degrees (0 is straight down)
   * @param {Number} opt.bearing=0 - Map rotation in degrees (0 means north is up)
   * @param {Number} opt.altitude= - Altitude of camera in screen units
   *
   * Web mercator projection short-hand parameters
   * @param {Number} opt.latitude - Center of viewport on map (alternative to opt.center)
   * @param {Number} opt.longitude - Center of viewport on map (alternative to opt.center)
   * @param {Number} opt.zoom - Scale = Math.pow(2,zoom) on map (alternative to opt.scale)
    * Notes:
   *  - Only one of center or [latitude, longitude] can be specified
   *  - [latitude, longitude] can only be specified when "mercator" is true
   *  - Altitude has a default value that matches assumptions in mapbox-gl
   *  - width and height are forced to 1 if supplied as 0, to avoid
   *    division by zero. This is intended to reduce the burden of apps to
   *    to check values before instantiating a Viewport.
   */
  /* eslint-disable complexity */
  function WebMercatorViewport() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        width = _ref.width,
        height = _ref.height,
        _ref$latitude = _ref.latitude,
        latitude = _ref$latitude === undefined ? 0 : _ref$latitude,
        _ref$longitude = _ref.longitude,
        longitude = _ref$longitude === undefined ? 0 : _ref$longitude,
        _ref$zoom = _ref.zoom,
        zoom = _ref$zoom === undefined ? 0 : _ref$zoom,
        _ref$pitch = _ref.pitch,
        pitch = _ref$pitch === undefined ? 0 : _ref$pitch,
        _ref$bearing = _ref.bearing,
        bearing = _ref$bearing === undefined ? 0 : _ref$bearing,
        _ref$altitude = _ref.altitude,
        altitude = _ref$altitude === undefined ? 1.5 : _ref$altitude,
        _ref$farZMultiplier = _ref.farZMultiplier,
        farZMultiplier = _ref$farZMultiplier === undefined ? 10 : _ref$farZMultiplier;

    _classCallCheck(this, WebMercatorViewport);

    // Silently allow apps to send in 0,0 to facilitate isomorphic render etc
    width = width || 1;
    height = height || 1;

    var scale = Math.pow(2, zoom);
    // Altitude - prevent division by 0
    // TODO - just throw an Error instead?
    altitude = Math.max(0.75, altitude);

    var center = (0, _webMercatorUtils.projectFlat)([longitude, latitude], scale);

    var projectionMatrix = (0, _webMercatorUtils.getProjectionMatrix)({
      width: width,
      height: height,
      pitch: pitch,
      bearing: bearing,
      altitude: altitude,
      farZMultiplier: farZMultiplier
    });

    var viewMatrix = (0, _webMercatorUtils.getViewMatrix)({
      width: width,
      height: height,
      longitude: longitude,
      latitude: latitude,
      zoom: zoom,
      pitch: pitch,
      bearing: bearing,
      altitude: altitude
    });

    // Save parameters
    var _this = _possibleConstructorReturn(this, (WebMercatorViewport.__proto__ || Object.getPrototypeOf(WebMercatorViewport)).call(this, { width: width, height: height, viewMatrix: viewMatrix, projectionMatrix: projectionMatrix }));

    _this.latitude = latitude;
    _this.longitude = longitude;
    _this.zoom = zoom;
    _this.pitch = pitch;
    _this.bearing = bearing;
    _this.altitude = altitude;

    _this.scale = scale;
    _this.center = center;

    Object.freeze(_this);
    return _this;
  }
  /* eslint-enable complexity */

  /**
   * Project [lng,lat] on sphere onto [x,y] on 512*512 Mercator Zoom 0 tile.
   * Performs the nonlinear part of the web mercator projection.
   * Remaining projection is done with 4x4 matrices which also handles
   * perspective.
   *
   * @param {Array} lngLat - [lng, lat] coordinates
   *   Specifies a point on the sphere to project onto the map.
   * @return {Array} [x,y] coordinates.
   */


  _createClass(WebMercatorViewport, [{
    key: 'projectFlat',
    value: function projectFlat(lngLat) {
      var scale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.scale;

      return (0, _webMercatorUtils.projectFlat)(lngLat, scale);
    }

    /**
     * Unproject world point [x,y] on map onto {lat, lon} on sphere
     *
     * @param {object|Vector} xy - object with {x,y} members
     *  representing point on projected map plane
     * @return {GeoCoordinates} - object with {lat,lon} of point on sphere.
     *   Has toArray method if you need a GeoJSON Array.
     *   Per cartographic tradition, lat and lon are specified as degrees.
     */

  }, {
    key: 'unprojectFlat',
    value: function unprojectFlat(xy) {
      var scale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.scale;

      return (0, _webMercatorUtils.unprojectFlat)(xy, scale);
    }

    /**
     * Get the map center that place a given [lng, lat] coordinate at screen
     * point [x, y]
     *
     * @param {Array} lngLat - [lng,lat] coordinates
     *   Specifies a point on the sphere.
     * @param {Array} pos - [x,y] coordinates
     *   Specifies a point on the screen.
     * @return {Array} [lng,lat] new map center.
     */

  }, {
    key: 'getLocationAtPoint',
    value: function getLocationAtPoint(_ref2) {
      var lngLat = _ref2.lngLat,
          pos = _ref2.pos;

      var fromLocation = this.projectFlat(this.unproject(pos));
      var toLocation = this.projectFlat(lngLat);

      var center = this.projectFlat([this.longitude, this.latitude]);

      var translate = (0, _add2.default)([], toLocation, (0, _negate2.default)([], fromLocation));
      var newCenter = (0, _add2.default)([], center, translate);
      return this.unprojectFlat(newCenter);
    }

    /**
     * Returns a new viewport that fit around the given rectangle.
     * Only supports non-perspective mode.
     * @param {Array} bounds - [[lon, lat], [lon, lat]]
     * @param {Number} [options.padding] - The amount of padding in pixels to add to the given bounds.
     * @param {Array} [options.offset] - The center of the given bounds relative to the map's center,
     *    [x, y] measured in pixels.
     * @returns {WebMercatorViewport}
     */

  }, {
    key: 'fitBounds',
    value: function fitBounds(bounds) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var width = this.width,
          height = this.height;

      var _fitBounds2 = _fitBounds(Object.assign({ width: width, height: height, bounds: bounds }, options)),
          longitude = _fitBounds2.longitude,
          latitude = _fitBounds2.latitude,
          zoom = _fitBounds2.zoom;

      return new WebMercatorViewport({ width: width, height: height, longitude: longitude, latitude: latitude, zoom: zoom });
    }
  }]);

  return WebMercatorViewport;
}(_viewport2.default);

/**
 * Returns map settings {latitude, longitude, zoom}
 * that will contain the provided corners within the provided width.
 * Only supports non-perspective mode.
 * @param {Number} width - viewport width
 * @param {Number} height - viewport height
 * @param {Array} bounds - [[lon, lat], [lon, lat]]
 * @param {Number} [padding] - The amount of padding in pixels to add to the given bounds.
 * @param {Array} [offset] - The center of the given bounds relative to the map's center,
 *    [x, y] measured in pixels.
 * @returns {Object} - latitude, longitude and zoom
 */


exports.default = WebMercatorViewport;
function _fitBounds(_ref3) {
  var width = _ref3.width,
      height = _ref3.height,
      bounds = _ref3.bounds,
      _ref3$padding = _ref3.padding,
      padding = _ref3$padding === undefined ? 0 : _ref3$padding,
      _ref3$offset = _ref3.offset,
      offset = _ref3$offset === undefined ? [0, 0] : _ref3$offset;

  var _bounds = _slicedToArray(bounds, 2),
      _bounds$ = _slicedToArray(_bounds[0], 2),
      west = _bounds$[0],
      south = _bounds$[1],
      _bounds$2 = _slicedToArray(_bounds[1], 2),
      east = _bounds$2[0],
      north = _bounds$2[1];

  var viewport = new WebMercatorViewport({
    width: width,
    height: height,
    longitude: 0,
    latitude: 0,
    zoom: 0
  });

  var nw = viewport.project([west, north]);
  var se = viewport.project([east, south]);
  var size = [Math.abs(se[0] - nw[0]), Math.abs(se[1] - nw[1])];
  var center = [(se[0] + nw[0]) / 2, (se[1] + nw[1]) / 2];

  var scaleX = (width - padding * 2 - Math.abs(offset[0]) * 2) / size[0];
  var scaleY = (height - padding * 2 - Math.abs(offset[1]) * 2) / size[1];

  var centerLngLat = viewport.unproject(center);
  var zoom = viewport.zoom + Math.log2(Math.abs(Math.min(scaleX, scaleY)));

  return {
    longitude: centerLngLat[0],
    latitude: centerLngLat[1],
    zoom: zoom
  };
}
exports.fitBounds = _fitBounds;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy93ZWItbWVyY2F0b3Itdmlld3BvcnQuanMiXSwibmFtZXMiOlsiV2ViTWVyY2F0b3JWaWV3cG9ydCIsIndpZHRoIiwiaGVpZ2h0IiwibGF0aXR1ZGUiLCJsb25naXR1ZGUiLCJ6b29tIiwicGl0Y2giLCJiZWFyaW5nIiwiYWx0aXR1ZGUiLCJmYXJaTXVsdGlwbGllciIsInNjYWxlIiwiTWF0aCIsInBvdyIsIm1heCIsImNlbnRlciIsInByb2plY3Rpb25NYXRyaXgiLCJ2aWV3TWF0cml4IiwiT2JqZWN0IiwiZnJlZXplIiwibG5nTGF0IiwieHkiLCJwb3MiLCJmcm9tTG9jYXRpb24iLCJwcm9qZWN0RmxhdCIsInVucHJvamVjdCIsInRvTG9jYXRpb24iLCJ0cmFuc2xhdGUiLCJuZXdDZW50ZXIiLCJ1bnByb2plY3RGbGF0IiwiYm91bmRzIiwib3B0aW9ucyIsImZpdEJvdW5kcyIsImFzc2lnbiIsInBhZGRpbmciLCJvZmZzZXQiLCJ3ZXN0Iiwic291dGgiLCJlYXN0Iiwibm9ydGgiLCJ2aWV3cG9ydCIsIm53IiwicHJvamVjdCIsInNlIiwic2l6ZSIsImFicyIsInNjYWxlWCIsInNjYWxlWSIsImNlbnRlckxuZ0xhdCIsImxvZzIiLCJtaW4iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQ0E7Ozs7QUFFQTs7QUFRQTs7OztBQUNBOzs7Ozs7Ozs7OytlQVpBOzs7QUFVQTs7O0lBSXFCQSxtQjs7O0FBQ25COzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBNkJBO0FBQ0EsaUNBV1E7QUFBQSxtRkFBSixFQUFJO0FBQUEsUUFUTkMsS0FTTSxRQVROQSxLQVNNO0FBQUEsUUFSTkMsTUFRTSxRQVJOQSxNQVFNO0FBQUEsNkJBUE5DLFFBT007QUFBQSxRQVBOQSxRQU9NLGlDQVBLLENBT0w7QUFBQSw4QkFOTkMsU0FNTTtBQUFBLFFBTk5BLFNBTU0sa0NBTk0sQ0FNTjtBQUFBLHlCQUxOQyxJQUtNO0FBQUEsUUFMTkEsSUFLTSw2QkFMQyxDQUtE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amVjdGlvbiBNYXRyaXggY2FsY3VsYXRpb25zIGZvciBtYXBib3gtanMgc3R5bGUgbWFwIHZpZXcgcHJvcGVydGllc1xuaW1wb3J0IFZpZXdwb3J0IGZyb20gJy4vdmlld3BvcnQnO1xuXG5pbXBvcnQge1xuICBwcm9qZWN0RmxhdCxcbiAgdW5wcm9qZWN0RmxhdCxcbiAgZ2V0UHJvamVjdGlvbk1hdHJpeCxcbiAgZ2V0Vmlld01hdHJpeFxufSBmcm9tICcuL3dlYi1tZXJjYXRvci11dGlscyc7XG5cbi8qIGVzbGludC1kaXNhYmxlIGNhbWVsY2FzZSAqL1xuaW1wb3J0IHZlYzJfYWRkIGZyb20gJ2dsLXZlYzIvYWRkJztcbmltcG9ydCB2ZWMyX25lZ2F0ZSBmcm9tICdnbC12ZWMyL25lZ2F0ZSc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFdlYk1lcmNhdG9yVmlld3BvcnQgZXh0ZW5kcyBWaWV3cG9ydCB7XG4gIC8qKlxuICAgKiBAY2xhc3NkZXNjXG4gICAqIENyZWF0ZXMgdmlldy9wcm9qZWN0aW9uIG1hdHJpY2VzIGZyb20gbWVyY2F0b3IgcGFyYW1zXG4gICAqIE5vdGU6IFRoZSBWaWV3cG9ydCBpcyBpbW11dGFibGUgaW4gdGhlIHNlbnNlIHRoYXQgaXQgb25seSBoYXMgYWNjZXNzb3JzLlxuICAgKiBBIG5ldyB2aWV3cG9ydCBpbnN0YW5jZSBzaG91bGQgYmUgY3JlYXRlZCBpZiBhbnkgcGFyYW1ldGVycyBoYXZlIGNoYW5nZWQuXG4gICAqXG4gICAqIEBjbGFzc1xuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0IC0gb3B0aW9uc1xuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gb3B0LndpZHRoPTEgLSBXaWR0aCBvZiBcInZpZXdwb3J0XCIgb3Igd2luZG93XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvcHQuaGVpZ2h0PTEgLSBIZWlnaHQgb2YgXCJ2aWV3cG9ydFwiIG9yIHdpbmRvd1xuICAgKiBAcGFyYW0ge051bWJlcn0gb3B0LnNjYWxlPTEgLSBFaXRoZXIgdXNlIHNjYWxlIG9yIHpvb21cbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdC5waXRjaD0wIC0gQ2FtZXJhIGFuZ2xlIGluIGRlZ3JlZXMgKDAgaXMgc3RyYWlnaHQgZG93bilcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdC5iZWFyaW5nPTAgLSBNYXAgcm90YXRpb24gaW4gZGVncmVlcyAoMCBtZWFucyBub3J0aCBpcyB1cClcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdC5hbHRpdHVkZT0gLSBBbHRpdHVkZSBvZiBjYW1lcmEgaW4gc2NyZWVuIHVuaXRzXG4gICAqXG4gICAqIFdlYiBtZXJjYXRvciBwcm9qZWN0aW9uIHNob3J0LWhhbmQgcGFyYW1ldGVyc1xuICAgKiBAcGFyYW0ge051bWJlcn0gb3B0LmxhdGl0dWRlIC0gQ2VudGVyIG9mIHZpZXdwb3J0IG9uIG1hcCAoYWx0ZXJuYXRpdmUgdG8gb3B0LmNlbnRlcilcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdC5sb25naXR1ZGUgLSBDZW50ZXIgb2Ygdmlld3BvcnQgb24gbWFwIChhbHRlcm5hdGl2ZSB0byBvcHQuY2VudGVyKVxuICAgKiBAcGFyYW0ge051bWJlcn0gb3B0Lnpvb20gLSBTY2FsZSA9IE1hdGgucG93KDIsem9vbSkgb24gbWFwIChhbHRlcm5hdGl2ZSB0byBvcHQuc2NhbGUpXG5cbiAgICogTm90ZXM6XG4gICAqICAtIE9ubHkgb25lIG9mIGNlbnRlciBvciBbbGF0aXR1ZGUsIGxvbmdpdHVkZV0gY2FuIGJlIHNwZWNpZmllZFxuICAgKiAgLSBbbGF0aXR1ZGUsIGxvbmdpdHVkZV0gY2FuIG9ubHkgYmUgc3BlY2lmaWVkIHdoZW4gXCJtZXJjYXRvclwiIGlzIHRydWVcbiAgICogIC0gQWx0aXR1ZGUgaGFzIGEgZGVmYXVsdCB2YWx1ZSB0aGF0IG1hdGNoZXMgYXNzdW1wdGlvbnMgaW4gbWFwYm94LWdsXG4gICAqICAtIHdpZHRoIGFuZCBoZWlnaHQgYXJlIGZvcmNlZCB0byAxIGlmIHN1cHBsaWVkIGFzIDAsIHRvIGF2b2lkXG4gICAqICAgIGRpdmlzaW9uIGJ5IHplcm8uIFRoaXMgaXMgaW50ZW5kZWQgdG8gcmVkdWNlIHRoZSBidXJkZW4gb2YgYXBwcyB0b1xuICAgKiAgICB0byBjaGVjayB2YWx1ZXMgYmVmb3JlIGluc3RhbnRpYXRpbmcgYSBWaWV3cG9ydC5cbiAgICovXG4gIC8qIGVzbGludC1kaXNhYmxlIGNvbXBsZXhpdHkgKi9cbiAgY29uc3RydWN0b3Ioe1xuICAgIC8vIE1hcCBzdGF0ZVxuICAgIHdpZHRoLFxuICAgIGhlaWdodCxcbiAgICBsYXRpdHVkZSA9IDAsXG4gICAgbG9uZ2l0dWRlID0gMCxcbiAgICB6b29tID0gMCxcbiAgICBwaXRjaCA9IDAsXG4gICAgYmVhcmluZyA9IDAsXG4gICAgYWx0aXR1ZGUgPSAxLjUsXG4gICAgZmFyWk11bHRpcGxpZXIgPSAxMFxuICB9ID0ge30pIHtcbiAgICAvLyBTaWxlbnRseSBhbGxvdyBhcHBzIHRvIHNlbmQgaW4gMCwwIHRvIGZhY2lsaXRhdGUgaXNvbW9ycGhpYyByZW5kZXIgZXRjXG4gICAgd2lkdGggPSB3aWR0aCB8fCAxO1xuICAgIGhlaWdodCA9IGhlaWdodCB8fCAxO1xuXG4gICAgY29uc3Qgc2NhbGUgPSBNYXRoLnBvdygyLCB6b29tKTtcbiAgICAvLyBBbHRpdHVkZSAtIHByZXZlbnQgZGl2aXNpb24gYnkgMFxuICAgIC8vIFRPRE8gLSBqdXN0IHRocm93IGFuIEVycm9yIGluc3RlYWQ/XG4gICAgYWx0aXR1ZGUgPSBNYXRoLm1heCgwLjc1LCBhbHRpdHVkZSk7XG5cbiAgICBjb25zdCBjZW50ZXIgPSBwcm9qZWN0RmxhdChbbG9uZ2l0dWRlLCBsYXRpdHVkZV0sIHNjYWxlKTtcblxuICAgIGNvbnN0IHByb2plY3Rpb25NYXRyaXggPSBnZXRQcm9qZWN0aW9uTWF0cml4KHtcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0LFxuICAgICAgcGl0Y2gsXG4gICAgICBiZWFyaW5nLFxuICAgICAgYWx0aXR1ZGUsXG4gICAgICBmYXJaTXVsdGlwbGllclxuICAgIH0pO1xuXG4gICAgY29uc3Qgdmlld01hdHJpeCA9IGdldFZpZXdNYXRyaXgoe1xuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHQsXG4gICAgICBsb25naXR1ZGUsXG4gICAgICBsYXRpdHVkZSxcbiAgICAgIHpvb20sXG4gICAgICBwaXRjaCxcbiAgICAgIGJlYXJpbmcsXG4gICAgICBhbHRpdHVkZVxuICAgIH0pO1xuXG4gICAgc3VwZXIoe3dpZHRoLCBoZWlnaHQsIHZpZXdNYXRyaXgsIHByb2plY3Rpb25NYXRyaXh9KTtcblxuICAgIC8vIFNhdmUgcGFyYW1ldGVyc1xuICAgIHRoaXMubGF0aXR1ZGUgPSBsYXRpdHVkZTtcbiAgICB0aGlzLmxvbmdpdHVkZSA9IGxvbmdpdHVkZTtcbiAgICB0aGlzLnpvb20gPSB6b29tO1xuICAgIHRoaXMucGl0Y2ggPSBwaXRjaDtcbiAgICB0aGlzLmJlYXJpbmcgPSBiZWFyaW5nO1xuICAgIHRoaXMuYWx0aXR1ZGUgPSBhbHRpdHVkZTtcblxuICAgIHRoaXMuc2NhbGUgPSBzY2FsZTtcbiAgICB0aGlzLmNlbnRlciA9IGNlbnRlcjtcblxuICAgIE9iamVjdC5mcmVlemUodGhpcyk7XG4gIH1cbiAgLyogZXNsaW50LWVuYWJsZSBjb21wbGV4aXR5ICovXG5cbiAgLyoqXG4gICAqIFByb2plY3QgW2xuZyxsYXRdIG9uIHNwaGVyZSBvbnRvIFt4LHldIG9uIDUxMio1MTIgTWVyY2F0b3IgWm9vbSAwIHRpbGUuXG4gICAqIFBlcmZvcm1zIHRoZSBub25saW5lYXIgcGFydCBvZiB0aGUgd2ViIG1lcmNhdG9yIHByb2plY3Rpb24uXG4gICAqIFJlbWFpbmluZyBwcm9qZWN0aW9uIGlzIGRvbmUgd2l0aCA0eDQgbWF0cmljZXMgd2hpY2ggYWxzbyBoYW5kbGVzXG4gICAqIHBlcnNwZWN0aXZlLlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fSBsbmdMYXQgLSBbbG5nLCBsYXRdIGNvb3JkaW5hdGVzXG4gICAqICAgU3BlY2lmaWVzIGEgcG9pbnQgb24gdGhlIHNwaGVyZSB0byBwcm9qZWN0IG9udG8gdGhlIG1hcC5cbiAgICogQHJldHVybiB7QXJyYXl9IFt4LHldIGNvb3JkaW5hdGVzLlxuICAgKi9cbiAgcHJvamVjdEZsYXQobG5nTGF0LCBzY2FsZSA9IHRoaXMuc2NhbGUpIHtcbiAgICByZXR1cm4gcHJvamVjdEZsYXQobG5nTGF0LCBzY2FsZSk7XG4gIH1cblxuICAvKipcbiAgICogVW5wcm9qZWN0IHdvcmxkIHBvaW50IFt4LHldIG9uIG1hcCBvbnRvIHtsYXQsIGxvbn0gb24gc3BoZXJlXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fFZlY3Rvcn0geHkgLSBvYmplY3Qgd2l0aCB7eCx5fSBtZW1iZXJzXG4gICAqICByZXByZXNlbnRpbmcgcG9pbnQgb24gcHJvamVjdGVkIG1hcCBwbGFuZVxuICAgKiBAcmV0dXJuIHtHZW9Db29yZGluYXRlc30gLSBvYmplY3Qgd2l0aCB7bGF0LGxvbn0gb2YgcG9pbnQgb24gc3BoZXJlLlxuICAgKiAgIEhhcyB0b0FycmF5IG1ldGhvZCBpZiB5b3UgbmVlZCBhIEdlb0pTT04gQXJyYXkuXG4gICAqICAgUGVyIGNhcnRvZ3JhcGhpYyB0cmFkaXRpb24sIGxhdCBhbmQgbG9uIGFyZSBzcGVjaWZpZWQgYXMgZGVncmVlcy5cbiAgICovXG4gIHVucHJvamVjdEZsYXQoeHksIHNjYWxlID0gdGhpcy5zY2FsZSkge1xuICAgIHJldHVybiB1bnByb2plY3RGbGF0KHh5LCBzY2FsZSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBtYXAgY2VudGVyIHRoYXQgcGxhY2UgYSBnaXZlbiBbbG5nLCBsYXRdIGNvb3JkaW5hdGUgYXQgc2NyZWVuXG4gICAqIHBvaW50IFt4LCB5XVxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fSBsbmdMYXQgLSBbbG5nLGxhdF0gY29vcmRpbmF0ZXNcbiAgICogICBTcGVjaWZpZXMgYSBwb2ludCBvbiB0aGUgc3BoZXJlLlxuICAgKiBAcGFyYW0ge0FycmF5fSBwb3MgLSBbeCx5XSBjb29yZGluYXRlc1xuICAgKiAgIFNwZWNpZmllcyBhIHBvaW50IG9uIHRoZSBzY3JlZW4uXG4gICAqIEByZXR1cm4ge0FycmF5fSBbbG5nLGxhdF0gbmV3IG1hcCBjZW50ZXIuXG4gICAqL1xuICBnZXRMb2NhdGlvbkF0UG9pbnQoe2xuZ0xhdCwgcG9zfSkge1xuICAgIGNvbnN0IGZyb21Mb2NhdGlvbiA9IHRoaXMucHJvamVjdEZsYXQodGhpcy51bnByb2plY3QocG9zKSk7XG4gICAgY29uc3QgdG9Mb2NhdGlvbiA9IHRoaXMucHJvamVjdEZsYXQobG5nTGF0KTtcblxuICAgIGNvbnN0IGNlbnRlciA9IHRoaXMucHJvamVjdEZsYXQoW3RoaXMubG9uZ2l0dWRlLCB0aGlzLmxhdGl0dWRlXSk7XG5cbiAgICBjb25zdCB0cmFuc2xhdGUgPSB2ZWMyX2FkZChbXSwgdG9Mb2NhdGlvbiwgdmVjMl9uZWdhdGUoW10sIGZyb21Mb2NhdGlvbikpO1xuICAgIGNvbnN0IG5ld0NlbnRlciA9IHZlYzJfYWRkKFtdLCBjZW50ZXIsIHRyYW5zbGF0ZSk7XG4gICAgcmV0dXJuIHRoaXMudW5wcm9qZWN0RmxhdChuZXdDZW50ZXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBuZXcgdmlld3BvcnQgdGhhdCBmaXQgYXJvdW5kIHRoZSBnaXZlbiByZWN0YW5nbGUuXG4gICAqIE9ubHkgc3VwcG9ydHMgbm9uLXBlcnNwZWN0aXZlIG1vZGUuXG4gICAqIEBwYXJhbSB7QXJyYXl9IGJvdW5kcyAtIFtbbG9uLCBsYXRdLCBbbG9uLCBsYXRdXVxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucGFkZGluZ10gLSBUaGUgYW1vdW50IG9mIHBhZGRpbmcgaW4gcGl4ZWxzIHRvIGFkZCB0byB0aGUgZ2l2ZW4gYm91bmRzLlxuICAgKiBAcGFyYW0ge0FycmF5fSBbb3B0aW9ucy5vZmZzZXRdIC0gVGhlIGNlbnRlciBvZiB0aGUgZ2l2ZW4gYm91bmRzIHJlbGF0aXZlIHRvIHRoZSBtYXAncyBjZW50ZXIsXG4gICAqICAgIFt4LCB5XSBtZWFzdXJlZCBpbiBwaXhlbHMuXG4gICAqIEByZXR1cm5zIHtXZWJNZXJjYXRvclZpZXdwb3J0fVxuICAgKi9cbiAgZml0Qm91bmRzKGJvdW5kcywgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3Qge3dpZHRoLCBoZWlnaHR9ID0gdGhpcztcbiAgICBjb25zdCB7bG9uZ2l0dWRlLCBsYXRpdHVkZSwgem9vbX0gPSBmaXRCb3VuZHMoT2JqZWN0LmFzc2lnbih7d2lkdGgsIGhlaWdodCwgYm91bmRzfSwgb3B0aW9ucykpO1xuICAgIHJldHVybiBuZXcgV2ViTWVyY2F0b3JWaWV3cG9ydCh7d2lkdGgsIGhlaWdodCwgbG9uZ2l0dWRlLCBsYXRpdHVkZSwgem9vbX0pO1xuICB9XG5cbn1cblxuLyoqXG4gKiBSZXR1cm5zIG1hcCBzZXR0aW5ncyB7bGF0aXR1ZGUsIGxvbmdpdHVkZSwgem9vbX1cbiAqIHRoYXQgd2lsbCBjb250YWluIHRoZSBwcm92aWRlZCBjb3JuZXJzIHdpdGhpbiB0aGUgcHJvdmlkZWQgd2lkdGguXG4gKiBPbmx5IHN1cHBvcnRzIG5vbi1wZXJzcGVjdGl2ZSBtb2RlLlxuICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoIC0gdmlld3BvcnQgd2lkdGhcbiAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHQgLSB2aWV3cG9ydCBoZWlnaHRcbiAqIEBwYXJhbSB7QXJyYXl9IGJvdW5kcyAtIFtbbG9uLCBsYXRdLCBbbG9uLCBsYXRdXVxuICogQHBhcmFtIHtOdW1iZXJ9IFtwYWRkaW5nXSAtIFRoZSBhbW91bnQgb2YgcGFkZGluZyBpbiBwaXhlbHMgdG8gYWRkIHRvIHRoZSBnaXZlbiBib3VuZHMuXG4gKiBAcGFyYW0ge0FycmF5fSBbb2Zmc2V0XSAtIFRoZSBjZW50ZXIgb2YgdGhlIGdpdmVuIGJvdW5kcyByZWxhdGl2ZSB0byB0aGUgbWFwJ3MgY2VudGVyLFxuICogICAgW3gsIHldIG1lYXN1cmVkIGluIHBpeGVscy5cbiAqIEByZXR1cm5zIHtPYmplY3R9IC0gbGF0aXR1ZGUsIGxvbmdpdHVkZSBhbmQgem9vbVxuICovXG5leHBvcnQgZnVuY3Rpb24gZml0Qm91bmRzKHtcbiAgd2lkdGgsXG4gIGhlaWdodCxcbiAgYm91bmRzLFxuICAvLyBvcHRpb25zXG4gIHBhZGRpbmcgPSAwLFxuICBvZmZzZXQgPSBbMCwgMF1cbn0pIHtcbiAgY29uc3QgW1t3ZXN0LCBzb3V0aF0sIFtlYXN0LCBub3J0aF1dID0gYm91bmRzO1xuXG4gIGNvbnN0IHZpZXdwb3J0ID0gbmV3IFdlYk1lcmNhdG9yVmlld3BvcnQoe1xuICAgIHdpZHRoLFxuICAgIGhlaWdodCxcbiAgICBsb25naXR1ZGU6IDAsXG4gICAgbGF0aXR1ZGU6IDAsXG4gICAgem9vbTogMFxuICB9KTtcblxuICBjb25zdCBudyA9IHZpZXdwb3J0LnByb2plY3QoW3dlc3QsIG5vcnRoXSk7XG4gIGNvbnN0IHNlID0gdmlld3BvcnQucHJvamVjdChbZWFzdCwgc291dGhdKTtcbiAgY29uc3Qgc2l6ZSA9IFtcbiAgICBNYXRoLmFicyhzZVswXSAtIG53WzBdKSxcbiAgICBNYXRoLmFicyhzZVsxXSAtIG53WzFdKVxuICBdO1xuICBjb25zdCBjZW50ZXIgPSBbXG4gICAgKHNlWzBdICsgbndbMF0pIC8gMixcbiAgICAoc2VbMV0gKyBud1sxXSkgLyAyXG4gIF07XG5cbiAgY29uc3Qgc2NhbGVYID0gKHdpZHRoIC0gcGFkZGluZyAqIDIgLSBNYXRoLmFicyhvZmZzZXRbMF0pICogMikgLyBzaXplWzBdO1xuICBjb25zdCBzY2FsZVkgPSAoaGVpZ2h0IC0gcGFkZGluZyAqIDIgLSBNYXRoLmFicyhvZmZzZXRbMV0pICogMikgLyBzaXplWzFdO1xuXG4gIGNvbnN0IGNlbnRlckxuZ0xhdCA9IHZpZXdwb3J0LnVucHJvamVjdChjZW50ZXIpO1xuICBjb25zdCB6b29tID0gdmlld3BvcnQuem9vbSArIE1hdGgubG9nMihNYXRoLmFicyhNYXRoLm1pbihzY2FsZVgsIHNjYWxlWSkpKTtcblxuICByZXR1cm4ge1xuICAgIGxvbmdpdHVkZTogY2VudGVyTG5nTGF0WzBdLFxuICAgIGxhdGl0dWRlOiBjZW50ZXJMbmdMYXRbMV0sXG4gICAgem9vbVxuICB9O1xufVxuIl19