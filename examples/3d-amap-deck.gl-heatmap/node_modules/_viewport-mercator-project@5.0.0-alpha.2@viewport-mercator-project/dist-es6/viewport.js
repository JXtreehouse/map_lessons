var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// View and Projection Matrix management

/* eslint-disable camelcase */
import { equals as _equals } from 'math.gl';
import { createMat4, transformVector } from './math-utils';

import mat4_scale from 'gl-mat4/scale';
import mat4_translate from 'gl-mat4/translate';
import mat4_multiply from 'gl-mat4/multiply';
import mat4_invert from 'gl-mat4/invert';
import vec2_lerp from 'gl-vec2/lerp';

import assert from 'assert';

var IDENTITY = createMat4();

var ERR_ARGUMENT = 'Illegal argument to Viewport';

var Viewport = function () {
  /**
   * @classdesc
   * Manages coordinate system transformations for deck.gl.
   *
   * Note: The Viewport is immutable in the sense that it only has accessors.
   * A new viewport instance should be created if any parameters have changed.
   *
   * @class
   * @param {Object} opt - options
   * @param {Boolean} mercator=true - Whether to use mercator projection
   *
   * @param {Number} opt.width=1 - Width of "viewport" or window
   * @param {Number} opt.height=1 - Height of "viewport" or window
   * @param {Array} opt.center=[0, 0] - Center of viewport
   *   [longitude, latitude] or [x, y]
   * @param {Number} opt.scale=1 - Either use scale or zoom
   * @param {Number} opt.pitch=0 - Camera angle in degrees (0 is straight down)
   * @param {Number} opt.bearing=0 - Map rotation in degrees (0 means north is up)
   * @param {Number} opt.altitude= - Altitude of camera in screen units
   *
   * Web mercator projection short-hand parameters
   * @param {Number} opt.latitude - Center of viewport on map (alternative to opt.center)
   * @param {Number} opt.longitude - Center of viewport on map (alternative to opt.center)
   * @param {Number} opt.zoom - Scale = Math.pow(2,zoom) on map (alternative to opt.scale)
   */
  /* eslint-disable complexity */
  function Viewport() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        width = _ref.width,
        height = _ref.height,
        _ref$viewMatrix = _ref.viewMatrix,
        viewMatrix = _ref$viewMatrix === undefined ? IDENTITY : _ref$viewMatrix,
        _ref$projectionMatrix = _ref.projectionMatrix,
        projectionMatrix = _ref$projectionMatrix === undefined ? IDENTITY : _ref$projectionMatrix;

    _classCallCheck(this, Viewport);

    // Silently allow apps to send in 0,0
    this.width = width || 1;
    this.height = height || 1;
    this.scale = 1;

    this.viewMatrix = viewMatrix;
    this.projectionMatrix = projectionMatrix;

    // Note: As usual, matrix operations should be applied in "reverse" order
    // since vectors will be multiplied in from the right during transformation
    var vpm = createMat4();
    mat4_multiply(vpm, vpm, this.projectionMatrix);
    mat4_multiply(vpm, vpm, this.viewMatrix);
    this.viewProjectionMatrix = vpm;

    // Calculate matrices and scales needed for projection
    /**
     * Builds matrices that converts preprojected lngLats to screen pixels
     * and vice versa.
     * Note: Currently returns bottom-left coordinates!
     * Note: Starts with the GL projection matrix and adds steps to the
     *       scale and translate that matrix onto the window.
     * Note: WebGL controls clip space to screen projection with gl.viewport
     *       and does not need this step.
     */
    var m = createMat4();

    // matrix for conversion from location to screen coordinates
    mat4_scale(m, m, [this.width / 2, -this.height / 2, 1]);
    mat4_translate(m, m, [1, -1, 0]);

    mat4_multiply(m, m, this.viewProjectionMatrix);

    var mInverse = mat4_invert(createMat4(), m);
    if (!mInverse) {
      throw new Error('Pixel project matrix not invertible');
    }

    this.pixelProjectionMatrix = m;
    this.pixelUnprojectionMatrix = mInverse;

    // Bind methods for easy access
    this.equals = this.equals.bind(this);
    this.project = this.project.bind(this);
    this.unproject = this.unproject.bind(this);
    this.projectFlat = this.projectFlat.bind(this);
    this.unprojectFlat = this.unprojectFlat.bind(this);
  }
  /* eslint-enable complexity */

  // Two viewports are equal if width and height are identical, and if
  // their view and projection matrices are (approximately) equal.


  _createClass(Viewport, [{
    key: 'equals',
    value: function equals(viewport) {
      if (!(viewport instanceof Viewport)) {
        return false;
      }

      return viewport.width === this.width && viewport.height === this.height && _equals(viewport.projectionMatrix, this.projectionMatrix) && _equals(viewport.viewMatrix, this.viewMatrix);
    }

    /**
     * Projects xyz (possibly latitude and longitude) to pixel coordinates in window
     * using viewport projection parameters
     * - [longitude, latitude] to [x, y]
     * - [longitude, latitude, Z] => [x, y, z]
     * Note: By default, returns top-left coordinates for canvas/SVG type render
     *
     * @param {Array} lngLatZ - [lng, lat] or [lng, lat, Z]
     * @param {Object} opts - options
     * @param {Object} opts.topLeft=true - Whether projected coords are top left
     * @return {Array} - screen coordinates [x, y] or [x, y, z], z as pixel depth
     */

  }, {
    key: 'project',
    value: function project(xyz) {
      var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
          _ref2$topLeft = _ref2.topLeft,
          topLeft = _ref2$topLeft === undefined ? true : _ref2$topLeft;

      var _xyz = _slicedToArray(xyz, 3),
          x0 = _xyz[0],
          y0 = _xyz[1],
          _xyz$ = _xyz[2],
          z0 = _xyz$ === undefined ? 0 : _xyz$;

      assert(Number.isFinite(x0) && Number.isFinite(y0) && Number.isFinite(z0), ERR_ARGUMENT);

      var _projectFlat = this.projectFlat([x0, y0]),
          _projectFlat2 = _slicedToArray(_projectFlat, 2),
          X = _projectFlat2[0],
          Y = _projectFlat2[1];

      var coord = transformVector(this.pixelProjectionMatrix, [X, Y, z0, 1]);

      var _coord = _slicedToArray(coord, 2),
          x = _coord[0],
          y = _coord[1];

      var y2 = topLeft ? y : this.height - y;
      return xyz.length === 2 ? [x, y2] : [x, y2, coord[2]];
    }

    /**
     * Unproject pixel coordinates on screen onto world coordinates,
     * (possibly [lon, lat]) on map.
     * - [x, y] => [lng, lat]
     * - [x, y, z] => [lng, lat, Z]
     * @param {Array} xyz - screen coordinates, z as pixel depth
     * @param {Object} opts - options
     * @param {Object} opts.topLeft=true - Whether projected coords are top left
     * @param {Object} opts.targetZ=0 - If pixel depth is unknown, targetZ is used as
     *   the elevation plane to unproject onto
     * @return {Array} - [lng, lat, Z] or [X, Y, Z]
     */

  }, {
    key: 'unproject',
    value: function unproject(xyz) {
      var _ref3 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
          _ref3$topLeft = _ref3.topLeft,
          topLeft = _ref3$topLeft === undefined ? true : _ref3$topLeft,
          targetZ = _ref3.targetZ;

      var _xyz2 = _slicedToArray(xyz, 3),
          x = _xyz2[0],
          y = _xyz2[1],
          z = _xyz2[2];

      var y2 = topLeft ? y : this.height - y;

      if (Number.isFinite(z)) {
        // Has depth component
        var coord = transformVector(this.pixelUnprojectionMatrix, [x, y2, z, 1]);
        var Z = coord[2];
        var _vUnprojected = this.unprojectFlat(coord);
        return [_vUnprojected[0], _vUnprojected[1], Z];
      }

      // since we don't know the correct projected z value for the point,
      // unproject two points to get a line and then find the point on that line with z=0
      var coord0 = transformVector(this.pixelUnprojectionMatrix, [x, y2, 0, 1]);
      var coord1 = transformVector(this.pixelUnprojectionMatrix, [x, y2, 1, 1]);

      var z0 = coord0[2];
      var z1 = coord1[2];

      var t = z0 === z1 ? 0 : ((targetZ || 0) - z0) / (z1 - z0);
      var v = vec2_lerp([], coord0, coord1, t);

      var vUnprojected = this.unprojectFlat(v);
      return Number.isFinite(targetZ) ? [vUnprojected[0], vUnprojected[1], targetZ] : vUnprojected;
    }

    // NON_LINEAR PROJECTION HOOKS
    // Used for web meractor projection

    /**
     * Project map coordinates to world coordinates.
     * This should be overridden by each viewport that implements a specific
     * geographic projection.
     * @param {Array} xyz - map coordinates
     * @return {Array} [x,y,z] world coordinates.
     */

  }, {
    key: 'projectFlat',
    value: function projectFlat(xyz) {
      var scale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.scale;

      return xyz;
    }

    /**
     * Project world coordinates to map coordinates.
     * This should be overridden by each viewport that implements a specific
     * geographic projection.
     * @param {Array} xyz - world coordinates
     * @return {Array} [x,y,z] map coordinates.
     */

  }, {
    key: 'unprojectFlat',
    value: function unprojectFlat(xyz) {
      var scale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.scale;

      return xyz;
    }
  }]);

  return Viewport;
}();

export default Viewport;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy92aWV3cG9ydC5qcyJdLCJuYW1lcyI6WyJlcXVhbHMiLCJjcmVhdGVNYXQ0IiwidHJhbnNmb3JtVmVjdG9yIiwibWF0NF9zY2FsZSIsIm1hdDRfdHJhbnNsYXRlIiwibWF0NF9tdWx0aXBseSIsIm1hdDRfaW52ZXJ0IiwidmVjMl9sZXJwIiwiYXNzZXJ0IiwiSURFTlRJVFkiLCJFUlJfQVJHVU1FTlQiLCJWaWV3cG9ydCIsIndpZHRoIiwiaGVpZ2h0Iiwidmlld01hdHJpeCIsInByb2plY3Rpb25NYXRyaXgiLCJzY2FsZSIsInZwbSIsInZpZXdQcm9qZWN0aW9uTWF0cml4IiwibSIsIm1JbnZlcnNlIiwiRXJyb3IiLCJwaXhlbFByb2plY3Rpb25NYXRyaXgiLCJwaXhlbFVucHJvamVjdGlvbk1hdHJpeCIsImJpbmQiLCJwcm9qZWN0IiwidW5wcm9qZWN0IiwicHJvamVjdEZsYXQiLCJ1bnByb2plY3RGbGF0Iiwidmlld3BvcnQiLCJ4eXoiLCJ0b3BMZWZ0IiwieDAiLCJ5MCIsInowIiwiTnVtYmVyIiwiaXNGaW5pdGUiLCJYIiwiWSIsImNvb3JkIiwieCIsInkiLCJ5MiIsImxlbmd0aCIsInRhcmdldFoiLCJ6IiwiWiIsInZVbnByb2plY3RlZCIsImNvb3JkMCIsImNvb3JkMSIsInoxIiwidCIsInYiXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBOztBQUVBO0FBQ0EsU0FBUUEsaUJBQVIsUUFBcUIsU0FBckI7QUFDQSxTQUFRQyxVQUFSLEVBQW9CQyxlQUFwQixRQUEwQyxjQUExQzs7QUFFQSxPQUFPQyxVQUFQLE1BQXVCLGVBQXZCO0FBQ0EsT0FBT0MsY0FBUCxNQUEyQixtQkFBM0I7QUFDQSxPQUFPQyxhQUFQLE1BQTBCLGtCQUExQjtBQUNBLE9BQU9DLFdBQVAsTUFBd0IsZ0JBQXhCO0FBQ0EsT0FBT0MsU0FBUCxNQUFzQixjQUF0Qjs7QUFFQSxPQUFPQyxNQUFQLE1BQW1CLFFBQW5COztBQUVBLElBQU1DLFdBQVdSLFlBQWpCOztBQUVBLElB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QUVEO0FBQ0E7O0FBRUE7Ozs7Ozs7Ozs7Z0NBT1lqQixHLEVBQXlCO0FBQUEsVUFBcEJkLEtBQW9CLHVFQUFaLEtBQUtBLEtBQU87O0FBQ25DLGFBQU9jLEdBQVA7QUFDRDs7QUFFRDs7Ozs7Ozs7OztrQ0FPY0EsRyxFQUF5QjtBQUFBLFVBQXBCZCxLQUFvQix1RUFBWixLQUFLQSxLQUFPOztBQUNyQyxhQUFPYyxHQUFQO0FBQ0Q7Ozs7OztlQXpMa0JuQixRIiwiZmlsZSI6InZpZXdwb3J0LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gVmlldyBhbmQgUHJvamVjdGlvbiBNYXRyaXggbWFuYWdlbWVudFxuXG4vKiBlc2xpbnQtZGlzYWJsZSBjYW1lbGNhc2UgKi9cbmltcG9ydCB7ZXF1YWxzfSBmcm9tICdtYXRoLmdsJztcbmltcG9ydCB7Y3JlYXRlTWF0NCwgdHJhbnNmb3JtVmVjdG9yfSBmcm9tICcuL21hdGgtdXRpbHMnO1xuXG5pbXBvcnQgbWF0NF9zY2FsZSBmcm9tICdnbC1tYXQ0L3NjYWxlJztcbmltcG9ydCBtYXQ0X3RyYW5zbGF0ZSBmcm9tICdnbC1tYXQ0L3RyYW5zbGF0ZSc7XG5pbXBvcnQgbWF0NF9tdWx0aXBseSBmcm9tICdnbC1tYXQ0L211bHRpcGx5JztcbmltcG9ydCBtYXQ0X2ludmVydCBmcm9tICdnbC1tYXQ0L2ludmVydCc7XG5pbXBvcnQgdmVjMl9sZXJwIGZyb20gJ2dsLXZlYzIvbGVycCc7XG5cbmltcG9ydCBhc3NlcnQgZnJvbSAnYXNzZXJ0JztcblxuY29uc3QgSURFTlRJVFkgPSBjcmVhdGVNYXQ0KCk7XG5cbmNvbnN0IEVSUl9BUkdVTUVOVCA9ICdJbGxlZ2FsIGFyZ3VtZW50IHRvIFZpZXdwb3J0JztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVmlld3BvcnQge1xuICAvKipcbiAgICogQGNsYXNzZGVzY1xuICAgKiBNYW5hZ2VzIGNvb3JkaW5hdGUgc3lzdGVtIHRyYW5zZm9ybWF0aW9ucyBmb3IgZGVjay5nbC5cbiAgICpcbiAgICogTm90ZTogVGhlIFZpZXdwb3J0IGlzIGltbXV0YWJsZSBpbiB0aGUgc2Vuc2UgdGhhdCBpdCBvbmx5IGhhcyBhY2Nlc3NvcnMuXG4gICAqIEEgbmV3IHZpZXdwb3J0IGluc3RhbmNlIHNob3VsZCBiZSBjcmVhdGVkIGlmIGFueSBwYXJhbWV0ZXJzIGhhdmUgY2hhbmdlZC5cbiAgICpcbiAgICogQGNsYXNzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHQgLSBvcHRpb25zXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gbWVyY2F0b3I9dHJ1ZSAtIFdoZXRoZXIgdG8gdXNlIG1lcmNhdG9yIHByb2plY3Rpb25cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdC53aWR0aD0xIC0gV2lkdGggb2YgXCJ2aWV3cG9ydFwiIG9yIHdpbmRvd1xuICAgKiBAcGFyYW0ge051bWJlcn0gb3B0LmhlaWdodD0xIC0gSGVpZ2h0IG9mIFwidmlld3BvcnRcIiBvciB3aW5kb3dcbiAgICogQHBhcmFtIHtBcnJheX0gb3B0LmNlbnRlcj1bMCwgMF0gLSBDZW50ZXIgb2Ygdmlld3BvcnRcbiAgICogICBbbG9uZ2l0dWRlLCBsYXRpdHVkZV0gb3IgW3gsIHldXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvcHQuc2NhbGU9MSAtIEVpdGhlciB1c2Ugc2NhbGUgb3Igem9vbVxuICAgKiBAcGFyYW0ge051bWJlcn0gb3B0LnBpdGNoPTAgLSBDYW1lcmEgYW5nbGUgaW4gZGVncmVlcyAoMCBpcyBzdHJhaWdodCBkb3duKVxuICAgKiBAcGFyYW0ge051bWJlcn0gb3B0LmJlYXJpbmc9MCAtIE1hcCByb3RhdGlvbiBpbiBkZWdyZWVzICgwIG1lYW5zIG5vcnRoIGlzIHVwKVxuICAgKiBAcGFyYW0ge051bWJlcn0gb3B0LmFsdGl0dWRlPSAtIEFsdGl0dWRlIG9mIGNhbWVyYSBpbiBzY3JlZW4gdW5pdHNcbiAgICpcbiAgICogV2ViIG1lcmNhdG9yIHByb2plY3Rpb24gc2hvcnQtaGFuZCBwYXJhbWV0ZXJzXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvcHQubGF0aXR1ZGUgLSBDZW50ZXIgb2Ygdmlld3BvcnQgb24gbWFwIChhbHRlcm5hdGl2ZSB0byBvcHQuY2VudGVyKVxuICAgKiBAcGFyYW0ge051bWJlcn0gb3B0LmxvbmdpdHVkZSAtIENlbnRlciBvZiB2aWV3cG9ydCBvbiBtYXAgKGFsdGVybmF0aXZlIHRvIG9wdC5jZW50ZXIpXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvcHQuem9vbSAtIFNjYWxlID0gTWF0aC5wb3coMix6b29tKSBvbiBtYXAgKGFsdGVybmF0aXZlIHRvIG9wdC5zY2FsZSlcbiAgICovXG4gIC8qIGVzbGludC1kaXNhYmxlIGNvbXBsZXhpdHkgKi9cbiAgY29uc3RydWN0b3Ioe1xuICAgIC8vIFdpbmRvdyB3aWR0aC9oZWlnaHQgaW4gcGl4ZWxzIChmb3IgcGl4ZWwgcHJvamVjdGlvbilcbiAgICB3aWR0aCxcbiAgICBoZWlnaHQsXG4gICAgLy8gRGVzY1xuICAgIHZpZXdNYXRyaXggPSBJREVOVElUWSxcbiAgICBwcm9qZWN0aW9uTWF0cml4ID0gSURFTlRJVFlcbiAgfSA9IHt9KSB7XG4gICAgLy8gU2lsZW50bHkgYWxsb3cgYXBwcyB0byBzZW5kIGluIDAsMFxuICAgIHRoaXMud2lkdGggPSB3aWR0aCB8fCAxO1xuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0IHx8IDE7XG4gICAgdGhpcy5zY2FsZSA9IDE7XG5cbiAgICB0aGlzLnZpZXdNYXRyaXggPSB2aWV3TWF0cml4O1xuICAgIHRoaXMucHJvamVjdGlvbk1hdHJpeCA9IHByb2plY3Rpb25NYXRyaXg7XG5cbiAgICAvLyBOb3RlOiBBcyB1c3VhbCwgbWF0cml4IG9wZXJhdGlvbnMgc2hvdWxkIGJlIGFwcGxpZWQgaW4gXCJyZXZlcnNlXCIgb3JkZXJcbiAgICAvLyBzaW5jZSB2ZWN0b3JzIHdpbGwgYmUgbXVsdGlwbGllZCBpbiBmcm9tIHRoZSByaWdodCBkdXJpbmcgdHJhbnNmb3JtYXRpb25cbiAgICBjb25zdCB2cG0gPSBjcmVhdGVNYXQ0KCk7XG4gICAgbWF0NF9tdWx0aXBseSh2cG0sIHZwbSwgdGhpcy5wcm9qZWN0aW9uTWF0cml4KTtcbiAgICBtYXQ0X211bHRpcGx5KHZwbSwgdnBtLCB0aGlzLnZpZXdNYXRyaXgpO1xuICAgIHRoaXMudmlld1Byb2plY3Rpb25NYXRyaXggPSB2cG07XG5cbiAgICAvLyBDYWxjdWxhdGUgbWF0cmljZXMgYW5kIHNjYWxlcyBuZWVkZWQgZm9yIHByb2plY3Rpb25cbiAgICAvKipcbiAgICAgKiBCdWlsZHMgbWF0cmljZXMgdGhhdCBjb252ZXJ0cyBwcmVwcm9qZWN0ZWQgbG5nTGF0cyB0byBzY3JlZW4gcGl4ZWxzXG4gICAgICogYW5kIHZpY2UgdmVyc2EuXG4gICAgICogTm90ZTogQ3VycmVudGx5IHJldHVybnMgYm90dG9tLWxlZnQgY29vcmRpbmF0ZXMhXG4gICAgICogTm90ZTogU3RhcnRzIHdpdGggdGhlIEdMIHByb2plY3Rpb24gbWF0cml4IGFuZCBhZGRzIHN0ZXBzIHRvIHRoZVxuICAgICAqICAgICAgIHNjYWxlIGFuZCB0cmFuc2xhdGUgdGhhdCBtYXRyaXggb250byB0aGUgd2luZG93LlxuICAgICAqIE5vdGU6IFdlYkdMIGNvbnRyb2xzIGNsaXAgc3BhY2UgdG8gc2NyZWVuIHByb2plY3Rpb24gd2l0aCBnbC52aWV3cG9ydFxuICAgICAqICAgICAgIGFuZCBkb2VzIG5vdCBuZWVkIHRoaXMgc3RlcC5cbiAgICAgKi9cbiAgICBjb25zdCBtID0gY3JlYXRlTWF0NCgpO1xuXG4gICAgLy8gbWF0cml4IGZvciBjb252ZXJzaW9uIGZyb20gbG9jYXRpb24gdG8gc2NyZWVuIGNvb3JkaW5hdGVzXG4gICAgbWF0NF9zY2FsZShtLCBtLCBbdGhpcy53aWR0aCAvIDIsIC10aGlzLmhlaWdodCAvIDIsIDFdKTtcbiAgICBtYXQ0X3RyYW5zbGF0ZShtLCBtLCBbMSwgLTEsIDBdKTtcblxuICAgIG1hdDRfbXVsdGlwbHkobSwgbSwgdGhpcy52aWV3UHJvamVjdGlvbk1hdHJpeCk7XG5cbiAgICBjb25zdCBtSW52ZXJzZSA9IG1hdDRfaW52ZXJ0KGNyZWF0ZU1hdDQoKSwgbSk7XG4gICAgaWYgKCFtSW52ZXJzZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdQaXhlbCBwcm9qZWN0IG1hdHJpeCBub3QgaW52ZXJ0aWJsZScpO1xuICAgIH1cblxuICAgIHRoaXMucGl4ZWxQcm9qZWN0aW9uTWF0cml4ID0gbTtcbiAgICB0aGlzLnBpeGVsVW5wcm9qZWN0aW9uTWF0cml4ID0gbUludmVyc2U7XG5cbiAgICAvLyBCaW5kIG1ldGhvZHMgZm9yIGVhc3kgYWNjZXNzXG4gICAgdGhpcy5lcXVhbHMgPSB0aGlzLmVxdWFscy5iaW5kKHRoaXMpO1xuICAgIHRoaXMucHJvamVjdCA9IHRoaXMucHJvamVjdC5iaW5kKHRoaXMpO1xuICAgIHRoaXMudW5wcm9qZWN0ID0gdGhpcy51bnByb2plY3QuYmluZCh0aGlzKTtcbiAgICB0aGlzLnByb2plY3RGbGF0ID0gdGhpcy5wcm9qZWN0RmxhdC5iaW5kKHRoaXMpO1xuICAgIHRoaXMudW5wcm9qZWN0RmxhdCA9IHRoaXMudW5wcm9qZWN0RmxhdC5iaW5kKHRoaXMpO1xuICB9XG4gIC8qIGVzbGludC1lbmFibGUgY29tcGxleGl0eSAqL1xuXG4gIC8vIFR3byB2aWV3cG9ydHMgYXJlIGVxdWFsIGlmIHdpZHRoIGFuZCBoZWlnaHQgYXJlIGlkZW50aWNhbCwgYW5kIGlmXG4gIC8vIHRoZWlyIHZpZXcgYW5kIHByb2plY3Rpb24gbWF0cmljZXMgYXJlIChhcHByb3hpbWF0ZWx5KSBlcXVhbC5cbiAgZXF1YWxzKHZpZXdwb3J0KSB7XG4gICAgaWYgKCEodmlld3BvcnQgaW5zdGFuY2VvZiBWaWV3cG9ydCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmlld3BvcnQud2lkdGggPT09IHRoaXMud2lkdGggJiZcbiAgICAgIHZpZXdwb3J0LmhlaWdodCA9PT0gdGhpcy5oZWlnaHQgJiZcbiAgICAgIGVxdWFscyh2aWV3cG9ydC5wcm9qZWN0aW9uTWF0cml4LCB0aGlzLnByb2plY3Rpb25NYXRyaXgpICYmXG4gICAgICBlcXVhbHModmlld3BvcnQudmlld01hdHJpeCwgdGhpcy52aWV3TWF0cml4KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQcm9qZWN0cyB4eXogKHBvc3NpYmx5IGxhdGl0dWRlIGFuZCBsb25naXR1ZGUpIHRvIHBpeGVsIGNvb3JkaW5hdGVzIGluIHdpbmRvd1xuICAgKiB1c2luZyB2aWV3cG9ydCBwcm9qZWN0aW9uIHBhcmFtZXRlcnNcbiAgICogLSBbbG9uZ2l0dWRlLCBsYXRpdHVkZV0gdG8gW3gsIHldXG4gICAqIC0gW2xvbmdpdHVkZSwgbGF0aXR1ZGUsIFpdID0+IFt4LCB5LCB6XVxuICAgKiBOb3RlOiBCeSBkZWZhdWx0LCByZXR1cm5zIHRvcC1sZWZ0IGNvb3JkaW5hdGVzIGZvciBjYW52YXMvU1ZHIHR5cGUgcmVuZGVyXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXl9IGxuZ0xhdFogLSBbbG5nLCBsYXRdIG9yIFtsbmcsIGxhdCwgWl1cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzLnRvcExlZnQ9dHJ1ZSAtIFdoZXRoZXIgcHJvamVjdGVkIGNvb3JkcyBhcmUgdG9wIGxlZnRcbiAgICogQHJldHVybiB7QXJyYXl9IC0gc2NyZWVuIGNvb3JkaW5hdGVzIFt4LCB5XSBvciBbeCwgeSwgel0sIHogYXMgcGl4ZWwgZGVwdGhcbiAgICovXG4gIHByb2plY3QoeHl6LCB7dG9wTGVmdCA9IHRydWV9ID0ge30pIHtcbiAgICBjb25zdCBbeDAsIHkwLCB6MCA9IDBdID0geHl6O1xuICAgIGFzc2VydChOdW1iZXIuaXNGaW5pdGUoeDApICYmIE51bWJlci5pc0Zpbml0ZSh5MCkgJiYgTnVtYmVyLmlzRmluaXRlKHowKSwgRVJSX0FSR1VNRU5UKTtcblxuICAgIGNvbnN0IFtYLCBZXSA9IHRoaXMucHJvamVjdEZsYXQoW3gwLCB5MF0pO1xuICAgIGNvbnN0IGNvb3JkID0gdHJhbnNmb3JtVmVjdG9yKHRoaXMucGl4ZWxQcm9qZWN0aW9uTWF0cml4LCBbWCwgWSwgejAsIDFdKTtcblxuICAgIGNvbnN0IFt4LCB5XSA9IGNvb3JkO1xuICAgIGNvbnN0IHkyID0gdG9wTGVmdCA/IHkgOiB0aGlzLmhlaWdodCAtIHk7XG4gICAgcmV0dXJuIHh5ei5sZW5ndGggPT09IDIgPyBbeCwgeTJdIDogW3gsIHkyLCBjb29yZFsyXV07XG4gIH1cblxuICAvKipcbiAgICogVW5wcm9qZWN0IHBpeGVsIGNvb3JkaW5hdGVzIG9uIHNjcmVlbiBvbnRvIHdvcmxkIGNvb3JkaW5hdGVzLFxuICAgKiAocG9zc2libHkgW2xvbiwgbGF0XSkgb24gbWFwLlxuICAgKiAtIFt4LCB5XSA9PiBbbG5nLCBsYXRdXG4gICAqIC0gW3gsIHksIHpdID0+IFtsbmcsIGxhdCwgWl1cbiAgICogQHBhcmFtIHtBcnJheX0geHl6IC0gc2NyZWVuIGNvb3JkaW5hdGVzLCB6IGFzIHBpeGVsIGRlcHRoXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cy50b3BMZWZ0PXRydWUgLSBXaGV0aGVyIHByb2plY3RlZCBjb29yZHMgYXJlIHRvcCBsZWZ0XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzLnRhcmdldFo9MCAtIElmIHBpeGVsIGRlcHRoIGlzIHVua25vd24sIHRhcmdldFogaXMgdXNlZCBhc1xuICAgKiAgIHRoZSBlbGV2YXRpb24gcGxhbmUgdG8gdW5wcm9qZWN0IG9udG9cbiAgICogQHJldHVybiB7QXJyYXl9IC0gW2xuZywgbGF0LCBaXSBvciBbWCwgWSwgWl1cbiAgICovXG4gIHVucHJvamVjdCh4eXosIHt0b3BMZWZ0ID0gdHJ1ZSwgdGFyZ2V0Wn0gPSB7fSkge1xuICAgIGNvbnN0IFt4LCB5LCB6XSA9IHh5ejtcblxuICAgIGNvbnN0IHkyID0gdG9wTGVmdCA/IHkgOiB0aGlzLmhlaWdodCAtIHk7XG5cbiAgICBpZiAoTnVtYmVyLmlzRmluaXRlKHopKSB7XG4gICAgICAvLyBIYXMgZGVwdGggY29tcG9uZW50XG4gICAgICBjb25zdCBjb29yZCA9IHRyYW5zZm9ybVZlY3Rvcih0aGlzLnBpeGVsVW5wcm9qZWN0aW9uTWF0cml4LCBbeCwgeTIsIHosIDFdKTtcbiAgICAgIGNvbnN0IFogPSBjb29yZFsyXTtcbiAgICAgIGNvbnN0IHZVbnByb2plY3RlZCA9IHRoaXMudW5wcm9qZWN0RmxhdChjb29yZCk7XG4gICAgICByZXR1cm4gW3ZVbnByb2plY3RlZFswXSwgdlVucHJvamVjdGVkWzFdLCBaXTtcbiAgICB9XG5cbiAgICAvLyBzaW5jZSB3ZSBkb24ndCBrbm93IHRoZSBjb3JyZWN0IHByb2plY3RlZCB6IHZhbHVlIGZvciB0aGUgcG9pbnQsXG4gICAgLy8gdW5wcm9qZWN0IHR3byBwb2ludHMgdG8gZ2V0IGEgbGluZSBhbmQgdGhlbiBmaW5kIHRoZSBwb2ludCBvbiB0aGF0IGxpbmUgd2l0aCB6PTBcbiAgICBjb25zdCBjb29yZDAgPSB0cmFuc2Zvcm1WZWN0b3IodGhpcy5waXhlbFVucHJvamVjdGlvbk1hdHJpeCwgW3gsIHkyLCAwLCAxXSk7XG4gICAgY29uc3QgY29vcmQxID0gdHJhbnNmb3JtVmVjdG9yKHRoaXMucGl4ZWxVbnByb2plY3Rpb25NYXRyaXgsIFt4LCB5MiwgMSwgMV0pO1xuXG4gICAgY29uc3QgejAgPSBjb29yZDBbMl07XG4gICAgY29uc3QgejEgPSBjb29yZDFbMl07XG5cbiAgICBjb25zdCB0ID0gejAgPT09IHoxID8gMCA6ICgodGFyZ2V0WiB8fCAwKSAtIHowKSAvICh6MSAtIHowKTtcbiAgICBjb25zdCB2ID0gdmVjMl9sZXJwKFtdLCBjb29yZDAsIGNvb3JkMSwgdCk7XG5cbiAgICBjb25zdCB2VW5wcm9qZWN0ZWQgPSB0aGlzLnVucHJvamVjdEZsYXQodik7XG4gICAgcmV0dXJuIE51bWJlci5pc0Zpbml0ZSh0YXJnZXRaKSA/IFt2VW5wcm9qZWN0ZWRbMF0sIHZVbnByb2plY3RlZFsxXSwgdGFyZ2V0Wl0gOiB2VW5wcm9qZWN0ZWQ7XG4gIH1cblxuICAvLyBOT05fTElORUFSIFBST0pFQ1RJT04gSE9PS1NcbiAgLy8gVXNlZCBmb3Igd2ViIG1lcmFjdG9yIHByb2plY3Rpb25cblxuICAvKipcbiAgICogUHJvamVjdCBtYXAgY29vcmRpbmF0ZXMgdG8gd29ybGQgY29vcmRpbmF0ZXMuXG4gICAqIFRoaXMgc2hvdWxkIGJlIG92ZXJyaWRkZW4gYnkgZWFjaCB2aWV3cG9ydCB0aGF0IGltcGxlbWVudHMgYSBzcGVjaWZpY1xuICAgKiBnZW9ncmFwaGljIHByb2plY3Rpb24uXG4gICAqIEBwYXJhbSB7QXJyYXl9IHh5eiAtIG1hcCBjb29yZGluYXRlc1xuICAgKiBAcmV0dXJuIHtBcnJheX0gW3gseSx6XSB3b3JsZCBjb29yZGluYXRlcy5cbiAgICovXG4gIHByb2plY3RGbGF0KHh5eiwgc2NhbGUgPSB0aGlzLnNjYWxlKSB7XG4gICAgcmV0dXJuIHh5ejtcbiAgfVxuXG4gIC8qKlxuICAgKiBQcm9qZWN0IHdvcmxkIGNvb3JkaW5hdGVzIHRvIG1hcCBjb29yZGluYXRlcy5cbiAgICogVGhpcyBzaG91bGQgYmUgb3ZlcnJpZGRlbiBieSBlYWNoIHZpZXdwb3J0IHRoYXQgaW1wbGVtZW50cyBhIHNwZWNpZmljXG4gICAqIGdlb2dyYXBoaWMgcHJvamVjdGlvbi5cbiAgICogQHBhcmFtIHtBcnJheX0geHl6IC0gd29ybGQgY29vcmRpbmF0ZXNcbiAgICogQHJldHVybiB7QXJyYXl9IFt4LHksel0gbWFwIGNvb3JkaW5hdGVzLlxuICAgKi9cbiAgdW5wcm9qZWN0RmxhdCh4eXosIHNjYWxlID0gdGhpcy5zY2FsZSkge1xuICAgIHJldHVybiB4eXo7XG4gIH1cblxufVxuIl19