export { _fitBounds as fitBounds };

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

// View and Projection Matrix calculations for mapbox-js style map view properties
import Viewport from './viewport';

import { projectFlat as _projectFlat, unprojectFlat as _unprojectFlat, getProjectionMatrix, getViewMatrix } from './web-mercator-utils';

/* eslint-disable camelcase */
import vec2_add from 'gl-vec2/add';
import vec2_negate from 'gl-vec2/negate';

var WebMercatorViewport = function (_Viewport) {
  _inherits(WebMercatorViewport, _Viewport);

  /**
   * @classdesc
   * Creates view/projection matrices from mercator params
   * Note: The Viewport is immutable in the sense that it only has accessors.
   * A new viewport instance should be created if any parameters have changed.
   *
   * @class
   * @param {Object} opt - options
   *
   * @param {Number} opt.width=1 - Width of "viewport" or window
   * @param {Number} opt.height=1 - Height of "viewport" or window
   * @param {Number} opt.scale=1 - Either use scale or zoom
   * @param {Number} opt.pitch=0 - Camera angle in degrees (0 is straight down)
   * @param {Number} opt.bearing=0 - Map rotation in degrees (0 means north is up)
   * @param {Number} opt.altitude= - Altitude of camera in screen units
   *
   * Web mercator projection short-hand parameters
   * @param {Number} opt.latitude - Center of viewport on map (alternative to opt.center)
   * @param {Number} opt.longitude - Center of viewport on map (alternative to opt.center)
   * @param {Number} opt.zoom - Scale = Math.pow(2,zoom) on map (alternative to opt.scale)
    * Notes:
   *  - Only one of center or [latitude, longitude] can be specified
   *  - [latitude, longitude] can only be specified when "mercator" is true
   *  - Altitude has a default value that matches assumptions in mapbox-gl
   *  - width and height are forced to 1 if supplied as 0, to avoid
   *    division by zero. This is intended to reduce the burden of apps to
   *    to check values before instantiating a Viewport.
   */
  /* eslint-disable complexity */
  function WebMercatorViewport() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        width = _ref.width,
        height = _ref.height,
        _ref$latitude = _ref.latitude,
        latitude = _ref$latitude === undefined ? 0 : _ref$latitude,
        _ref$longitude = _ref.longitude,
        longitude = _ref$longitude === undefined ? 0 : _ref$longitude,
        _ref$zoom = _ref.zoom,
        zoom = _ref$zoom === undefined ? 0 : _ref$zoom,
        _ref$pitch = _ref.pitch,
        pitch = _ref$pitch === undefined ? 0 : _ref$pitch,
        _ref$bearing = _ref.bearing,
        bearing = _ref$bearing === undefined ? 0 : _ref$bearing,
        _ref$altitude = _ref.altitude,
        altitude = _ref$altitude === undefined ? 1.5 : _ref$altitude,
        _ref$farZMultiplier = _ref.farZMultiplier,
        farZMultiplier = _ref$farZMultiplier === undefined ? 10 : _ref$farZMultiplier;

    _classCallCheck(this, WebMercatorViewport);

    // Silently allow apps to send in 0,0 to facilitate isomorphic render etc
    width = width || 1;
    height = height || 1;

    var scale = Math.pow(2, zoom);
    // Altitude - prevent division by 0
    // TODO - just throw an Error instead?
    altitude = Math.max(0.75, altitude);

    var center = _projectFlat([longitude, latitude], scale);

    var projectionMatrix = getProjectionMatrix({
      width: width,
      height: height,
      pitch: pitch,
      bearing: bearing,
      altitude: altitude,
      farZMultiplier: farZMultiplier
    });

    var viewMatrix = getViewMatrix({
      width: width,
      height: height,
      longitude: longitude,
      latitude: latitude,
      zoom: zoom,
      pitch: pitch,
      bearing: bearing,
      altitude: altitude
    });

    // Save parameters
    var _this = _possibleConstructorReturn(this, (WebMercatorViewport.__proto__ || Object.getPrototypeOf(WebMercatorViewport)).call(this, { width: width, height: height, viewMatrix: viewMatrix, projectionMatrix: projectionMatrix }));

    _this.latitude = latitude;
    _this.longitude = longitude;
    _this.zoom = zoom;
    _this.pitch = pitch;
    _this.bearing = bearing;
    _this.altitude = altitude;

    _this.scale = scale;
    _this.center = center;

    Object.freeze(_this);
    return _this;
  }
  /* eslint-enable complexity */

  /**
   * Project [lng,lat] on sphere onto [x,y] on 512*512 Mercator Zoom 0 tile.
   * Performs the nonlinear part of the web mercator projection.
   * Remaining projection is done with 4x4 matrices which also handles
   * perspective.
   *
   * @param {Array} lngLat - [lng, lat] coordinates
   *   Specifies a point on the sphere to project onto the map.
   * @return {Array} [x,y] coordinates.
   */


  _createClass(WebMercatorViewport, [{
    key: 'projectFlat',
    value: function projectFlat(lngLat) {
      var scale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.scale;

      return _projectFlat(lngLat, scale);
    }

    /**
     * Unproject world point [x,y] on map onto {lat, lon} on sphere
     *
     * @param {object|Vector} xy - object with {x,y} members
     *  representing point on projected map plane
     * @return {GeoCoordinates} - object with {lat,lon} of point on sphere.
     *   Has toArray method if you need a GeoJSON Array.
     *   Per cartographic tradition, lat and lon are specified as degrees.
     */

  }, {
    key: 'unprojectFlat',
    value: function unprojectFlat(xy) {
      var scale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.scale;

      return _unprojectFlat(xy, scale);
    }

    /**
     * Get the map center that place a given [lng, lat] coordinate at screen
     * point [x, y]
     *
     * @param {Array} lngLat - [lng,lat] coordinates
     *   Specifies a point on the sphere.
     * @param {Array} pos - [x,y] coordinates
     *   Specifies a point on the screen.
     * @return {Array} [lng,lat] new map center.
     */

  }, {
    key: 'getLocationAtPoint',
    value: function getLocationAtPoint(_ref2) {
      var lngLat = _ref2.lngLat,
          pos = _ref2.pos;

      var fromLocation = this.projectFlat(this.unproject(pos));
      var toLocation = this.projectFlat(lngLat);

      var center = this.projectFlat([this.longitude, this.latitude]);

      var translate = vec2_add([], toLocation, vec2_negate([], fromLocation));
      var newCenter = vec2_add([], center, translate);
      return this.unprojectFlat(newCenter);
    }

    /**
     * Returns a new viewport that fit around the given rectangle.
     * Only supports non-perspective mode.
     * @param {Array} bounds - [[lon, lat], [lon, lat]]
     * @param {Number} [options.padding] - The amount of padding in pixels to add to the given bounds.
     * @param {Array} [options.offset] - The center of the given bounds relative to the map's center,
     *    [x, y] measured in pixels.
     * @returns {WebMercatorViewport}
     */

  }, {
    key: 'fitBounds',
    value: function fitBounds(bounds) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var width = this.width,
          height = this.height;

      var _fitBounds2 = _fitBounds(Object.assign({ width: width, height: height, bounds: bounds }, options)),
          longitude = _fitBounds2.longitude,
          latitude = _fitBounds2.latitude,
          zoom = _fitBounds2.zoom;

      return new WebMercatorViewport({ width: width, height: height, longitude: longitude, latitude: latitude, zoom: zoom });
    }
  }]);

  return WebMercatorViewport;
}(Viewport);

/**
 * Returns map settings {latitude, longitude, zoom}
 * that will contain the provided corners within the provided width.
 * Only supports non-perspective mode.
 * @param {Number} width - viewport width
 * @param {Number} height - viewport height
 * @param {Array} bounds - [[lon, lat], [lon, lat]]
 * @param {Number} [padding] - The amount of padding in pixels to add to the given bounds.
 * @param {Array} [offset] - The center of the given bounds relative to the map's center,
 *    [x, y] measured in pixels.
 * @returns {Object} - latitude, longitude and zoom
 */


export default WebMercatorViewport;
function _fitBounds(_ref3) {
  var width = _ref3.width,
      height = _ref3.height,
      bounds = _ref3.bounds,
      _ref3$padding = _ref3.padding,
      padding = _ref3$padding === undefined ? 0 : _ref3$padding,
      _ref3$offset = _ref3.offset,
      offset = _ref3$offset === undefined ? [0, 0] : _ref3$offset;

  var _bounds = _slicedToArray(bounds, 2),
      _bounds$ = _slicedToArray(_bounds[0], 2),
      west = _bounds$[0],
      south = _bounds$[1],
      _bounds$2 = _slicedToArray(_bounds[1], 2),
      east = _bounds$2[0],
      north = _bounds$2[1];

  var viewport = new WebMercatorViewport({
    width: width,
    height: height,
    longitude: 0,
    latitude: 0,
    zoom: 0
  });

  var nw = viewport.project([west, north]);
  var se = viewport.project([east, south]);
  var size = [Math.abs(se[0] - nw[0]), Math.abs(se[1] - nw[1])];
  var center = [(se[0] + nw[0]) / 2, (se[1] + nw[1]) / 2];

  var scaleX = (width - padding * 2 - Math.abs(offset[0]) * 2) / size[0];
  var scaleY = (height - padding * 2 - Math.abs(offset[1]) * 2) / size[1];

  var centerLngLat = viewport.unproject(center);
  var zoom = viewport.zoom + Math.log2(Math.abs(Math.min(scaleX, scaleY)));

  return {
    longitude: centerLngLat[0],
    latitude: centerLngLat[1],
    zoom: zoom
  };
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy93ZWItbWVyY2F0b3Itdmlld3BvcnQuanMiXSwibmFtZXMiOlsiVmlld3BvcnQiLCJwcm9qZWN0RmxhdCIsInVucHJvamVjdEZsYXQiLCJnZXRQcm9qZWN0aW9uTWF0cml4IiwiZ2V0Vmlld01hdHJpeCIsInZlYzJfYWRkIiwidmVjMl9uZWdhdGUiLCJXZWJNZXJjYXRvclZpZXdwb3J0Iiwid2lkdGgiLCJoZWlnaHQiLCJsYXRpdHVkZSIsImxvbmdpdHVkZSIsInpvb20iLCJwaXRjaCIsImJlYXJpbmciLCJhbHRpdHVkZSIsImZhclpNdWx0aXBsaWVyIiwic2NhbGUiLCJNYXRoIiwicG93IiwibWF4IiwiY2VudGVyIiwicHJvamVjdGlvbk1hdHJpeCIsInZpZXdNYXRyaXgiLCJPYmplY3QiLCJmcmVlemUiLCJsbmdMYXQiLCJ4eSIsInBvcyIsImZyb21Mb2NhdGlvbiIsInVucHJvamVjdCIsInRvTG9jYXRpb24iLCJ0cmFuc2xhdGUiLCJuZXdDZW50ZXIiLCJib3VuZHMiLCJvcHRpb25zIiwiZml0Qm91bmRzIiwiYXNzaWduIiwicGFkZGluZyIsIm9mZnNldCIsIndlc3QiLCJzb3V0aCIsImVhc3QiLCJub3J0aCIsInZpZXdwb3J0IiwibnciLCJwcm9qZWN0Iiwic2UiLCJzaXplIiwiYWJzIiwic2NhbGVYIiwic2NhbGVZIiwiY2VudGVyTG5nTGF0IiwibG9nMiIsIm1pbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQSxPQUFPQSxRQUFQLE1BQXFCLFlBQXJCOztBQUVBLFNBQ0VDLDJCQURGLEVBRUVDLCtCQUZGLEVBR0VDLG1CQUhGLEVBSUVDLGFBSkYsUUFLTyxzQkFMUDs7QUFPQTtBQUNBLE9BQU9DLFFBQVAsTUFBcUIsYUFBckI7QUFDQSxPQUFPQyxXQUFQLE1BQXdCLGdCQUF4Qjs7SUFFcUJDLG1COzs7QUFDbkI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUE2QkE7QUFDQSxpQ0FXUTtBQUFBLG1GQUFKLEVBQUk7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QixLQUFLb0MsR0FBTCxDQUFTSixNQUFULEVBQWlCQyxNQUFqQixDQUFULENBQVYsQ0FBN0I7O0FBRUEsU0FBTztBQUNMeEMsZUFBV3lDLGFBQWEsQ0FBYixDQUROO0FBRUwxQyxjQUFVMEMsYUFBYSxDQUFiLENBRkw7QUFHTHhDO0FBSEssR0FBUDtBQUtEIiwiZmlsZSI6IndlYi1tZXJjYXRvci12aWV3cG9ydC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIFZpZXcgYW5kIFByb2plY3Rpb24gTWF0cml4IGNhbGN1bGF0aW9ucyBmb3IgbWFwYm94LWpzIHN0eWxlIG1hcCB2aWV3IHByb3BlcnRpZXNcbmltcG9ydCBWaWV3cG9ydCBmcm9tICcuL3ZpZXdwb3J0JztcblxuaW1wb3J0IHtcbiAgcHJvamVjdEZsYXQsXG4gIHVucHJvamVjdEZsYXQsXG4gIGdldFByb2plY3Rpb25NYXRyaXgsXG4gIGdldFZpZXdNYXRyaXhcbn0gZnJvbSAnLi93ZWItbWVyY2F0b3ItdXRpbHMnO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBjYW1lbGNhc2UgKi9cbmltcG9ydCB2ZWMyX2FkZCBmcm9tICdnbC12ZWMyL2FkZCc7XG5pbXBvcnQgdmVjMl9uZWdhdGUgZnJvbSAnZ2wtdmVjMi9uZWdhdGUnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBXZWJNZXJjYXRvclZpZXdwb3J0IGV4dGVuZHMgVmlld3BvcnQge1xuICAvKipcbiAgICogQGNsYXNzZGVzY1xuICAgKiBDcmVhdGVzIHZpZXcvcHJvamVjdGlvbiBtYXRyaWNlcyBmcm9tIG1lcmNhdG9yIHBhcmFtc1xuICAgKiBOb3RlOiBUaGUgVmlld3BvcnQgaXMgaW1tdXRhYmxlIGluIHRoZSBzZW5zZSB0aGF0IGl0IG9ubHkgaGFzIGFjY2Vzc29ycy5cbiAgICogQSBuZXcgdmlld3BvcnQgaW5zdGFuY2Ugc2hvdWxkIGJlIGNyZWF0ZWQgaWYgYW55IHBhcmFtZXRlcnMgaGF2ZSBjaGFuZ2VkLlxuICAgKlxuICAgKiBAY2xhc3NcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdCAtIG9wdGlvbnNcbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdC53aWR0aD0xIC0gV2lkdGggb2YgXCJ2aWV3cG9ydFwiIG9yIHdpbmRvd1xuICAgKiBAcGFyYW0ge051bWJlcn0gb3B0LmhlaWdodD0xIC0gSGVpZ2h0IG9mIFwidmlld3BvcnRcIiBvciB3aW5kb3dcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdC5zY2FsZT0xIC0gRWl0aGVyIHVzZSBzY2FsZSBvciB6b29tXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvcHQucGl0Y2g9MCAtIENhbWVyYSBhbmdsZSBpbiBkZWdyZWVzICgwIGlzIHN0cmFpZ2h0IGRvd24pXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvcHQuYmVhcmluZz0wIC0gTWFwIHJvdGF0aW9uIGluIGRlZ3JlZXMgKDAgbWVhbnMgbm9ydGggaXMgdXApXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvcHQuYWx0aXR1ZGU9IC0gQWx0aXR1ZGUgb2YgY2FtZXJhIGluIHNjcmVlbiB1bml0c1xuICAgKlxuICAgKiBXZWIgbWVyY2F0b3IgcHJvamVjdGlvbiBzaG9ydC1oYW5kIHBhcmFtZXRlcnNcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdC5sYXRpdHVkZSAtIENlbnRlciBvZiB2aWV3cG9ydCBvbiBtYXAgKGFsdGVybmF0aXZlIHRvIG9wdC5jZW50ZXIpXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvcHQubG9uZ2l0dWRlIC0gQ2VudGVyIG9mIHZpZXdwb3J0IG9uIG1hcCAoYWx0ZXJuYXRpdmUgdG8gb3B0LmNlbnRlcilcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdC56b29tIC0gU2NhbGUgPSBNYXRoLnBvdygyLHpvb20pIG9uIG1hcCAoYWx0ZXJuYXRpdmUgdG8gb3B0LnNjYWxlKVxuXG4gICAqIE5vdGVzOlxuICAgKiAgLSBPbmx5IG9uZSBvZiBjZW50ZXIgb3IgW2xhdGl0dWRlLCBsb25naXR1ZGVdIGNhbiBiZSBzcGVjaWZpZWRcbiAgICogIC0gW2xhdGl0dWRlLCBsb25naXR1ZGVdIGNhbiBvbmx5IGJlIHNwZWNpZmllZCB3aGVuIFwibWVyY2F0b3JcIiBpcyB0cnVlXG4gICAqICAtIEFsdGl0dWRlIGhhcyBhIGRlZmF1bHQgdmFsdWUgdGhhdCBtYXRjaGVzIGFzc3VtcHRpb25zIGluIG1hcGJveC1nbFxuICAgKiAgLSB3aWR0aCBhbmQgaGVpZ2h0IGFyZSBmb3JjZWQgdG8gMSBpZiBzdXBwbGllZCBhcyAwLCB0byBhdm9pZFxuICAgKiAgICBkaXZpc2lvbiBieSB6ZXJvLiBUaGlzIGlzIGludGVuZGVkIHRvIHJlZHVjZSB0aGUgYnVyZGVuIG9mIGFwcHMgdG9cbiAgICogICAgdG8gY2hlY2sgdmFsdWVzIGJlZm9yZSBpbnN0YW50aWF0aW5nIGEgVmlld3BvcnQuXG4gICAqL1xuICAvKiBlc2xpbnQtZGlzYWJsZSBjb21wbGV4aXR5ICovXG4gIGNvbnN0cnVjdG9yKHtcbiAgICAvLyBNYXAgc3RhdGVcbiAgICB3aWR0aCxcbiAgICBoZWlnaHQsXG4gICAgbGF0aXR1ZGUgPSAwLFxuICAgIGxvbmdpdHVkZSA9IDAsXG4gICAgem9vbSA9IDAsXG4gICAgcGl0Y2ggPSAwLFxuICAgIGJlYXJpbmcgPSAwLFxuICAgIGFsdGl0dWRlID0gMS41LFxuICAgIGZhclpNdWx0aXBsaWVyID0gMTBcbiAgfSA9IHt9KSB7XG4gICAgLy8gU2lsZW50bHkgYWxsb3cgYXBwcyB0byBzZW5kIGluIDAsMCB0byBmYWNpbGl0YXRlIGlzb21vcnBoaWMgcmVuZGVyIGV0Y1xuICAgIHdpZHRoID0gd2lkdGggfHwgMTtcbiAgICBoZWlnaHQgPSBoZWlnaHQgfHwgMTtcblxuICAgIGNvbnN0IHNjYWxlID0gTWF0aC5wb3coMiwgem9vbSk7XG4gICAgLy8gQWx0aXR1ZGUgLSBwcmV2ZW50IGRpdmlzaW9uIGJ5IDBcbiAgICAvLyBUT0RPIC0ganVzdCB0aHJvdyBhbiBFcnJvciBpbnN0ZWFkP1xuICAgIGFsdGl0dWRlID0gTWF0aC5tYXgoMC43NSwgYWx0aXR1ZGUpO1xuXG4gICAgY29uc3QgY2VudGVyID0gcHJvamVjdEZsYXQoW2xvbmdpdHVkZSwgbGF0aXR1ZGVdLCBzY2FsZSk7XG5cbiAgICBjb25zdCBwcm9qZWN0aW9uTWF0cml4ID0gZ2V0UHJvamVjdGlvbk1hdHJpeCh7XG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodCxcbiAgICAgIHBpdGNoLFxuICAgICAgYmVhcmluZyxcbiAgICAgIGFsdGl0dWRlLFxuICAgICAgZmFyWk11bHRpcGxpZXJcbiAgICB9KTtcblxuICAgIGNvbnN0IHZpZXdNYXRyaXggPSBnZXRWaWV3TWF0cml4KHtcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0LFxuICAgICAgbG9uZ2l0dWRlLFxuICAgICAgbGF0aXR1ZGUsXG4gICAgICB6b29tLFxuICAgICAgcGl0Y2gsXG4gICAgICBiZWFyaW5nLFxuICAgICAgYWx0aXR1ZGVcbiAgICB9KTtcblxuICAgIHN1cGVyKHt3aWR0aCwgaGVpZ2h0LCB2aWV3TWF0cml4LCBwcm9qZWN0aW9uTWF0cml4fSk7XG5cbiAgICAvLyBTYXZlIHBhcmFtZXRlcnNcbiAgICB0aGlzLmxhdGl0dWRlID0gbGF0aXR1ZGU7XG4gICAgdGhpcy5sb25naXR1ZGUgPSBsb25naXR1ZGU7XG4gICAgdGhpcy56b29tID0gem9vbTtcbiAgICB0aGlzLnBpdGNoID0gcGl0Y2g7XG4gICAgdGhpcy5iZWFyaW5nID0gYmVhcmluZztcbiAgICB0aGlzLmFsdGl0dWRlID0gYWx0aXR1ZGU7XG5cbiAgICB0aGlzLnNjYWxlID0gc2NhbGU7XG4gICAgdGhpcy5jZW50ZXIgPSBjZW50ZXI7XG5cbiAgICBPYmplY3QuZnJlZXplKHRoaXMpO1xuICB9XG4gIC8qIGVzbGludC1lbmFibGUgY29tcGxleGl0eSAqL1xuXG4gIC8qKlxuICAgKiBQcm9qZWN0IFtsbmcsbGF0XSBvbiBzcGhlcmUgb250byBbeCx5XSBvbiA1MTIqNTEyIE1lcmNhdG9yIFpvb20gMCB0aWxlLlxuICAgKiBQZXJmb3JtcyB0aGUgbm9ubGluZWFyIHBhcnQgb2YgdGhlIHdlYiBtZXJjYXRvciBwcm9qZWN0aW9uLlxuICAgKiBSZW1haW5pbmcgcHJvamVjdGlvbiBpcyBkb25lIHdpdGggNHg0IG1hdHJpY2VzIHdoaWNoIGFsc28gaGFuZGxlc1xuICAgKiBwZXJzcGVjdGl2ZS5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheX0gbG5nTGF0IC0gW2xuZywgbGF0XSBjb29yZGluYXRlc1xuICAgKiAgIFNwZWNpZmllcyBhIHBvaW50IG9uIHRoZSBzcGhlcmUgdG8gcHJvamVjdCBvbnRvIHRoZSBtYXAuXG4gICAqIEByZXR1cm4ge0FycmF5fSBbeCx5XSBjb29yZGluYXRlcy5cbiAgICovXG4gIHByb2plY3RGbGF0KGxuZ0xhdCwgc2NhbGUgPSB0aGlzLnNjYWxlKSB7XG4gICAgcmV0dXJuIHByb2plY3RGbGF0KGxuZ0xhdCwgc2NhbGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFVucHJvamVjdCB3b3JsZCBwb2ludCBbeCx5XSBvbiBtYXAgb250byB7bGF0LCBsb259IG9uIHNwaGVyZVxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdHxWZWN0b3J9IHh5IC0gb2JqZWN0IHdpdGgge3gseX0gbWVtYmVyc1xuICAgKiAgcmVwcmVzZW50aW5nIHBvaW50IG9uIHByb2plY3RlZCBtYXAgcGxhbmVcbiAgICogQHJldHVybiB7R2VvQ29vcmRpbmF0ZXN9IC0gb2JqZWN0IHdpdGgge2xhdCxsb259IG9mIHBvaW50IG9uIHNwaGVyZS5cbiAgICogICBIYXMgdG9BcnJheSBtZXRob2QgaWYgeW91IG5lZWQgYSBHZW9KU09OIEFycmF5LlxuICAgKiAgIFBlciBjYXJ0b2dyYXBoaWMgdHJhZGl0aW9uLCBsYXQgYW5kIGxvbiBhcmUgc3BlY2lmaWVkIGFzIGRlZ3JlZXMuXG4gICAqL1xuICB1bnByb2plY3RGbGF0KHh5LCBzY2FsZSA9IHRoaXMuc2NhbGUpIHtcbiAgICByZXR1cm4gdW5wcm9qZWN0RmxhdCh4eSwgc2NhbGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbWFwIGNlbnRlciB0aGF0IHBsYWNlIGEgZ2l2ZW4gW2xuZywgbGF0XSBjb29yZGluYXRlIGF0IHNjcmVlblxuICAgKiBwb2ludCBbeCwgeV1cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheX0gbG5nTGF0IC0gW2xuZyxsYXRdIGNvb3JkaW5hdGVzXG4gICAqICAgU3BlY2lmaWVzIGEgcG9pbnQgb24gdGhlIHNwaGVyZS5cbiAgICogQHBhcmFtIHtBcnJheX0gcG9zIC0gW3gseV0gY29vcmRpbmF0ZXNcbiAgICogICBTcGVjaWZpZXMgYSBwb2ludCBvbiB0aGUgc2NyZWVuLlxuICAgKiBAcmV0dXJuIHtBcnJheX0gW2xuZyxsYXRdIG5ldyBtYXAgY2VudGVyLlxuICAgKi9cbiAgZ2V0TG9jYXRpb25BdFBvaW50KHtsbmdMYXQsIHBvc30pIHtcbiAgICBjb25zdCBmcm9tTG9jYXRpb24gPSB0aGlzLnByb2plY3RGbGF0KHRoaXMudW5wcm9qZWN0KHBvcykpO1xuICAgIGNvbnN0IHRvTG9jYXRpb24gPSB0aGlzLnByb2plY3RGbGF0KGxuZ0xhdCk7XG5cbiAgICBjb25zdCBjZW50ZXIgPSB0aGlzLnByb2plY3RGbGF0KFt0aGlzLmxvbmdpdHVkZSwgdGhpcy5sYXRpdHVkZV0pO1xuXG4gICAgY29uc3QgdHJhbnNsYXRlID0gdmVjMl9hZGQoW10sIHRvTG9jYXRpb24sIHZlYzJfbmVnYXRlKFtdLCBmcm9tTG9jYXRpb24pKTtcbiAgICBjb25zdCBuZXdDZW50ZXIgPSB2ZWMyX2FkZChbXSwgY2VudGVyLCB0cmFuc2xhdGUpO1xuICAgIHJldHVybiB0aGlzLnVucHJvamVjdEZsYXQobmV3Q2VudGVyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgbmV3IHZpZXdwb3J0IHRoYXQgZml0IGFyb3VuZCB0aGUgZ2l2ZW4gcmVjdGFuZ2xlLlxuICAgKiBPbmx5IHN1cHBvcnRzIG5vbi1wZXJzcGVjdGl2ZSBtb2RlLlxuICAgKiBAcGFyYW0ge0FycmF5fSBib3VuZHMgLSBbW2xvbiwgbGF0XSwgW2xvbiwgbGF0XV1cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnBhZGRpbmddIC0gVGhlIGFtb3VudCBvZiBwYWRkaW5nIGluIHBpeGVscyB0byBhZGQgdG8gdGhlIGdpdmVuIGJvdW5kcy5cbiAgICogQHBhcmFtIHtBcnJheX0gW29wdGlvbnMub2Zmc2V0XSAtIFRoZSBjZW50ZXIgb2YgdGhlIGdpdmVuIGJvdW5kcyByZWxhdGl2ZSB0byB0aGUgbWFwJ3MgY2VudGVyLFxuICAgKiAgICBbeCwgeV0gbWVhc3VyZWQgaW4gcGl4ZWxzLlxuICAgKiBAcmV0dXJucyB7V2ViTWVyY2F0b3JWaWV3cG9ydH1cbiAgICovXG4gIGZpdEJvdW5kcyhib3VuZHMsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHt3aWR0aCwgaGVpZ2h0fSA9IHRoaXM7XG4gICAgY29uc3Qge2xvbmdpdHVkZSwgbGF0aXR1ZGUsIHpvb219ID0gZml0Qm91bmRzKE9iamVjdC5hc3NpZ24oe3dpZHRoLCBoZWlnaHQsIGJvdW5kc30sIG9wdGlvbnMpKTtcbiAgICByZXR1cm4gbmV3IFdlYk1lcmNhdG9yVmlld3BvcnQoe3dpZHRoLCBoZWlnaHQsIGxvbmdpdHVkZSwgbGF0aXR1ZGUsIHpvb219KTtcbiAgfVxuXG59XG5cbi8qKlxuICogUmV0dXJucyBtYXAgc2V0dGluZ3Mge2xhdGl0dWRlLCBsb25naXR1ZGUsIHpvb219XG4gKiB0aGF0IHdpbGwgY29udGFpbiB0aGUgcHJvdmlkZWQgY29ybmVycyB3aXRoaW4gdGhlIHByb3ZpZGVkIHdpZHRoLlxuICogT25seSBzdXBwb3J0cyBub24tcGVyc3BlY3RpdmUgbW9kZS5cbiAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aCAtIHZpZXdwb3J0IHdpZHRoXG4gKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0IC0gdmlld3BvcnQgaGVpZ2h0XG4gKiBAcGFyYW0ge0FycmF5fSBib3VuZHMgLSBbW2xvbiwgbGF0XSwgW2xvbiwgbGF0XV1cbiAqIEBwYXJhbSB7TnVtYmVyfSBbcGFkZGluZ10gLSBUaGUgYW1vdW50IG9mIHBhZGRpbmcgaW4gcGl4ZWxzIHRvIGFkZCB0byB0aGUgZ2l2ZW4gYm91bmRzLlxuICogQHBhcmFtIHtBcnJheX0gW29mZnNldF0gLSBUaGUgY2VudGVyIG9mIHRoZSBnaXZlbiBib3VuZHMgcmVsYXRpdmUgdG8gdGhlIG1hcCdzIGNlbnRlcixcbiAqICAgIFt4LCB5XSBtZWFzdXJlZCBpbiBwaXhlbHMuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSAtIGxhdGl0dWRlLCBsb25naXR1ZGUgYW5kIHpvb21cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZpdEJvdW5kcyh7XG4gIHdpZHRoLFxuICBoZWlnaHQsXG4gIGJvdW5kcyxcbiAgLy8gb3B0aW9uc1xuICBwYWRkaW5nID0gMCxcbiAgb2Zmc2V0ID0gWzAsIDBdXG59KSB7XG4gIGNvbnN0IFtbd2VzdCwgc291dGhdLCBbZWFzdCwgbm9ydGhdXSA9IGJvdW5kcztcblxuICBjb25zdCB2aWV3cG9ydCA9IG5ldyBXZWJNZXJjYXRvclZpZXdwb3J0KHtcbiAgICB3aWR0aCxcbiAgICBoZWlnaHQsXG4gICAgbG9uZ2l0dWRlOiAwLFxuICAgIGxhdGl0dWRlOiAwLFxuICAgIHpvb206IDBcbiAgfSk7XG5cbiAgY29uc3QgbncgPSB2aWV3cG9ydC5wcm9qZWN0KFt3ZXN0LCBub3J0aF0pO1xuICBjb25zdCBzZSA9IHZpZXdwb3J0LnByb2plY3QoW2Vhc3QsIHNvdXRoXSk7XG4gIGNvbnN0IHNpemUgPSBbXG4gICAgTWF0aC5hYnMoc2VbMF0gLSBud1swXSksXG4gICAgTWF0aC5hYnMoc2VbMV0gLSBud1sxXSlcbiAgXTtcbiAgY29uc3QgY2VudGVyID0gW1xuICAgIChzZVswXSArIG53WzBdKSAvIDIsXG4gICAgKHNlWzFdICsgbndbMV0pIC8gMlxuICBdO1xuXG4gIGNvbnN0IHNjYWxlWCA9ICh3aWR0aCAtIHBhZGRpbmcgKiAyIC0gTWF0aC5hYnMob2Zmc2V0WzBdKSAqIDIpIC8gc2l6ZVswXTtcbiAgY29uc3Qgc2NhbGVZID0gKGhlaWdodCAtIHBhZGRpbmcgKiAyIC0gTWF0aC5hYnMob2Zmc2V0WzFdKSAqIDIpIC8gc2l6ZVsxXTtcblxuICBjb25zdCBjZW50ZXJMbmdMYXQgPSB2aWV3cG9ydC51bnByb2plY3QoY2VudGVyKTtcbiAgY29uc3Qgem9vbSA9IHZpZXdwb3J0Lnpvb20gKyBNYXRoLmxvZzIoTWF0aC5hYnMoTWF0aC5taW4oc2NhbGVYLCBzY2FsZVkpKSk7XG5cbiAgcmV0dXJuIHtcbiAgICBsb25naXR1ZGU6IGNlbnRlckxuZ0xhdFswXSxcbiAgICBsYXRpdHVkZTogY2VudGVyTG5nTGF0WzFdLFxuICAgIHpvb21cbiAgfTtcbn1cbiJdfQ==