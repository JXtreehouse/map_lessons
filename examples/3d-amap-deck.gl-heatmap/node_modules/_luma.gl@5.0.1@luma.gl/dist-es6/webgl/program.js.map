{"version":3,"sources":["../../src/webgl/program.js"],"names":["GL","assertWebGL2Context","isWebGL2","VertexArray","Resource","Texture","Framebuffer","getTransformFeedbackMode","parseUniformName","getUniformSetter","VertexShader","FragmentShader","Buffer","log","uid","assert","LOG_PROGRAM_PERF_PRIORITY","Program","gl","opts","initialize","vertexAttributes","getDefaultArray","Object","seal","_setId","id","vs","fs","defaultUniforms","varyings","bufferMode","SEPARATE_ATTRIBS","transformFeedbackVaryings","handle","getVaryingMap","_compileAndLink","unsetBuffers","useProgram","drawMode","TRIANGLES","vertexCount","offset","start","end","isIndexed","indexType","UNSIGNED_SHORT","isInstanced","instanceCount","vertexArray","transformFeedback","uniforms","samplers","parameters","bind","RASTERIZER_DISCARD","enable","primitiveMode","begin","setUniforms","ext","drawElementsInstanced","isNaN","drawElementsRange","drawElements","drawArraysInstanced","drawArrays","disable","buffers","clear","check","drawParams","_filledLocations","_sortBuffersByLocation","locations","elements","location","length","bufferName","buffer","divisor","layout","instanced","setBuffer","setDivisor","setGeneric","array","type","_checkBuffers","_attributeCount","i","bindBuffer","ELEMENT_ARRAY_BUFFER","uniformName","uniform","uniformSetter","_uniformSetters","sampler","texture","textureIndex","undefined","_textureIndexCounter","_getParameter","ACTIVE_ATTRIBUTES","attributeName","getAttribLocation","getActiveAttrib","ACTIVE_UNIFORMS","index","getActiveUniform","name","getUniformLocation","getUniform","program","result","getTransformFeedbackVarying","varyingName","getFragDataLocation","getAttachedShaders","attachShader","time","_getName","linkProgram","timeEnd","debug","priority","validateProgram","linked","getProgramParameter","LINK_STATUS","Error","getProgramInfoLog","_queryAttributeLocations","_queryUniformLocations","_attributeLocations","_warnedLocations","warn","Array","target","_print","isEnabled","createProgram","deleteProgram","programName","getName","replace","shaderHandles","shaderHandle","getShaderParameter","SHADER_TYPE","VERTEX_SHADER","FRAGMENT_SHADER","pname","getAttributeCount","getAttributeInfo","getAttributeLocation","_uniformCount","getUniformCount","info","getUniformInfo","parsedName","isArray","getUniformDescriptors","uniformDescriptors","descriptor","varyingMap","varying"],"mappings":"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","file":"program.js","sourcesContent":["/* eslint-disable no-inline-comments */\nimport GL from './api';\nimport {assertWebGL2Context, isWebGL2} from './context';\nimport VertexArray from './vertex-array';\nimport Resource from './resource';\nimport Texture from './texture';\nimport Framebuffer from './framebuffer';\nimport {getTransformFeedbackMode} from './transform-feedback';\nimport {parseUniformName, getUniformSetter} from './uniforms';\nimport {VertexShader, FragmentShader} from './shader';\nimport Buffer from './buffer';\nimport {log, uid} from '../utils';\nimport assert from 'assert';\n\nconst LOG_PROGRAM_PERF_PRIORITY = 3;\n\n// const GL_TRANSFORM_FEEDBACK_BUFFER_MODE = 0x8C7F;\n// const GL_TRANSFORM_FEEDBACK_VARYINGS = 0x8C83;\n// MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS : 0x8C80,\n// TRANSFORM_FEEDBACK_BUFFER_START: 0x8C84,\n// TRANSFORM_FEEDBACK_BUFFER_SIZE : 0x8C85,\n// TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN: 0x8C88,\n// MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS: 0x8C8A,\n// MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS: 0x8C8B,\n// INTERLEAVED_ATTRIBS: 0x8C8C,\n// SEPARATE_ATTRIBS : 0x8C8D,\n\nexport default class Program extends Resource {\n\n  constructor(gl, opts = {}) {\n    super(gl, opts);\n    this.initialize(opts);\n    this.vertexAttributes = VertexArray.getDefaultArray(gl);\n    Object.seal(this);\n\n    this._setId(opts.id);\n  }\n\n  initialize({vs, fs, defaultUniforms, varyings, bufferMode = GL.SEPARATE_ATTRIBS} = {}) {\n    // Create shaders if needed\n    this.vs = typeof vs === 'string' ? new VertexShader(this.gl, vs) : vs;\n    this.fs = typeof fs === 'string' ? new FragmentShader(this.gl, fs) : fs;\n\n    assert(this.vs instanceof VertexShader, 'Program: bad vertex shader');\n    assert(this.fs instanceof FragmentShader, 'Program: bad fragment shader');\n\n    this.defaultUniforms = defaultUniforms;\n\n    // Setup varyings if supplied\n    if (varyings) {\n      assertWebGL2Context(this.gl);\n      this.gl.transformFeedbackVaryings(this.handle, varyings, bufferMode);\n      this.varyings = getVaryingMap(varyings, bufferMode);\n    }\n\n    this._compileAndLink();\n\n    return this;\n  }\n\n  reset() {\n    this.unsetBuffers();\n    // TODO - reset uniforms and attributes to initial state\n  }\n\n  use() {\n    this.gl.useProgram(this.handle);\n    return this;\n  }\n\n  // A good thing about webGL is that there are so many ways to draw things,\n  // e.g. depending on whether data is indexed and/or isInstanced.\n  // This function unifies those into a single call with simple parameters\n  // that have sane defaults.\n  draw({\n    drawMode = GL.TRIANGLES,\n    vertexCount,\n    offset = 0,\n    start,\n    end,\n    isIndexed = false,\n    indexType = GL.UNSIGNED_SHORT,\n    isInstanced = false,\n    instanceCount = 0,\n    vertexArray = null,\n    transformFeedback = null,\n    uniforms = {},\n    samplers = {},\n    parameters = {}\n  }) {\n    vertexArray = vertexArray || VertexArray.getDefaultArray(this.gl);\n    vertexArray.bind(() => {\n\n      this.gl.useProgram(this.handle);\n\n      if (transformFeedback) {\n        if (parameters[GL.RASTERIZER_DISCARD]) {\n          // bypass fragment shader\n          this.gl.enable(GL.RASTERIZER_DISCARD);\n        }\n\n        const primitiveMode = getTransformFeedbackMode({drawMode});\n        transformFeedback.begin(primitiveMode);\n      }\n\n      this.setUniforms(uniforms, samplers);\n\n      // TODO - Use polyfilled WebGL2RenderingContext instead of ANGLE extension\n      if (isIndexed && isInstanced) {\n        this.ext.drawElementsInstanced(drawMode, vertexCount, indexType, offset, instanceCount);\n      } else if (isIndexed && isWebGL2(this.gl) && !isNaN(start) && !isNaN(end)) {\n        this.gl.drawElementsRange(drawMode, start, end, vertexCount, indexType, offset);\n      } else if (isIndexed) {\n        this.gl.drawElements(drawMode, vertexCount, indexType, offset);\n      } else if (isInstanced) {\n        this.ext.drawArraysInstanced(drawMode, offset, vertexCount, instanceCount);\n      } else {\n        this.gl.drawArrays(drawMode, offset, vertexCount);\n      }\n\n      // this.gl.useProgram(null);\n\n      if (transformFeedback) {\n        transformFeedback.end();\n\n        if (parameters[GL.RASTERIZER_DISCARD]) {\n          // resume fragment shader\n          this.gl.disable(GL.RASTERIZER_DISCARD);\n        }\n      }\n\n    });\n\n    return this;\n  }\n\n  /**\n   * Attach a map of Buffers values to a program\n   * Only attributes with names actually present in the linked program\n   * will be updated. Other supplied buffers will be ignored.\n   *\n   * @param {Object} buffers - An object map with attribute names being keys\n   *  and values are expected to be instances of Buffer.\n   * @returns {Program} Returns itself for chaining.\n   */\n  /* eslint-disable max-statements */\n  setBuffers(buffers, {clear = true, check = true, drawParams = {}} = {}) {\n    if (clear) {\n      this._filledLocations = {};\n    }\n\n    // indexing is autodetected - buffer with target gl.ELEMENT_ARRAY_BUFFER\n    // index type is saved for drawElement calls\n    drawParams.isInstanced = false;\n    drawParams.isIndexed = false;\n    drawParams.indexType = null;\n\n    const {locations, elements} = this._sortBuffersByLocation(buffers);\n\n    // Process locations in order\n    for (let location = 0; location < locations.length; ++location) {\n      const bufferName = locations[location];\n      const buffer = buffers[bufferName];\n      // DISABLE MISSING ATTRIBUTE\n      if (!buffer) {\n        this.vertexAttributes.disable(location);\n      } else if (buffer instanceof Buffer) {\n        const divisor = buffer.layout.instanced ? 1 : 0;\n        this.vertexAttributes.setBuffer({location, buffer});\n        this.vertexAttributes.setDivisor(location, divisor);\n        drawParams.isInstanced = buffer.layout.instanced > 0;\n        this.vertexAttributes.enable(location);\n        this._filledLocations[bufferName] = true;\n      } else {\n        this.vertexAttributes.setGeneric({location, array: buffer});\n        this.vertexAttributes.disable(location, true);\n        this._filledLocations[bufferName] = true;\n      }\n    }\n\n    // SET ELEMENTS ARRAY BUFFER\n    if (elements) {\n      const buffer = buffers[elements];\n      buffer.bind();\n      drawParams.isIndexed = true;\n      drawParams.indexType = buffer.layout.type;\n    }\n\n    if (check) {\n      this._checkBuffers();\n    }\n\n    return this;\n  }\n  /* eslint-enable max-statements */\n\n  /*\n   * @returns {Program} Returns itself for chaining.\n   */\n  unsetBuffers() {\n    const length = this._attributeCount;\n    for (let i = 1; i < length; ++i) {\n      // this.vertexAttributes.setDivisor(i, 0);\n      this.vertexAttributes.disable(i);\n    }\n\n    // Clear elements buffer\n    this.gl.bindBuffer(GL.ELEMENT_ARRAY_BUFFER, null);\n    return this;\n  }\n\n  /**\n   * Apply a set of uniform values to a program\n   * Only uniforms with names actually present in the linked program\n   * will be updated.\n   * other uniforms will be ignored\n   *\n   * @param {Object} uniformMap - An object with names being keys\n   * @returns {Program} - returns itself for chaining.\n   */\n  /* eslint-disable max-depth */\n  setUniforms(uniforms, samplers = {}) {\n    for (const uniformName in uniforms) {\n      let uniform = uniforms[uniformName];\n      const uniformSetter = this._uniformSetters[uniformName];\n      const sampler = samplers[uniformName];\n\n      if (uniformSetter) {\n        if (uniform instanceof Framebuffer) {\n          uniform = uniform.texture;\n        }\n        if (uniform instanceof Texture) {\n          if (uniformSetter.textureIndex === undefined) {\n            uniformSetter.textureIndex = this._textureIndexCounter++;\n          }\n\n          // Bind texture to index\n          const texture = uniform;\n          const {textureIndex} = uniformSetter;\n\n          texture.bind(textureIndex);\n\n          // Bind a sampler (if supplied) to index\n          if (sampler) {\n            sampler.bind(textureIndex);\n          }\n\n          // Set the uniform sampler to the texture index\n          uniformSetter(textureIndex);\n        } else {\n          // Just set the value\n          uniformSetter(uniform);\n        }\n      }\n    }\n\n    return this;\n  }\n  /* eslint-enable max-depth */\n\n  // setTransformFeedbackBuffers(buffers) {\n  //   for (const buffer of buffers) {\n  //     buffer.bindBase()\n  //   }\n  // }\n\n  /**\n   * ATTRIBUTES API\n   * (Locations are numeric indices)\n   * @return {Number} count\n   */\n  getAttributeCount() {\n    return this._getParameter(GL.ACTIVE_ATTRIBUTES);\n  }\n\n  /**\n   * Returns location (index) of a name\n   * @param {String} attributeName - name of an attribute\n   *   (matches name in a linked shader)\n   * @returns {Number} - // array of actual attribute names from shader linking\n   */\n  getAttributeLocation(attributeName) {\n    return this.gl.getAttribLocation(this.handle, attributeName);\n  }\n\n  /**\n   * Returns an object with info about attribute at index \"location\"/\n   * @param {int} location - index of an attribute\n   * @returns {WebGLActiveInfo} - info about an active attribute\n   *   fields: {name, size, type}\n   */\n  getAttributeInfo(location) {\n    return this.gl.getActiveAttrib(this.handle, location);\n  }\n\n  /**\n   * UNIFORMS API\n   * (Locations are numeric indices)\n   * @return {Number} count\n   */\n  getUniformCount() {\n    return this._getParameter(GL.ACTIVE_UNIFORMS);\n  }\n\n  /*\n   * @returns {WebGLActiveInfo} - object with {name, size, type}\n   */\n  getUniformInfo(index) {\n    return this.gl.getActiveUniform(this.handle, index);\n  }\n\n  /*\n   * @returns {WebGLUniformLocation} - opaque object representing location\n   * of uniform, used by setter methods\n   */\n  getUniformLocation(name) {\n    return this.gl.getUniformLocation(this.handle, name);\n  }\n\n  getUniformValue(location) {\n    return this.gl.getUniform(this.handle, location);\n  }\n\n  // WebGL2\n  /**\n   * @param {GLuint} index\n   * @return {WebGLActiveInfo} - object with {name, size, type}\n   */\n  getVarying(program, index) {\n    const result = this.gl.getTransformFeedbackVarying(program, index);\n    return result;\n  }\n\n  // Retrieves the assigned color number binding for the user-defined varying\n  // out variable name for program. program must have previously been linked.\n  getFragDataLocation(varyingName) {\n    assertWebGL2Context(this.gl);\n    return this.gl.getFragDataLocation(this.handle, varyingName);\n  }\n\n  // @returns {WebGLShader[]} - array of attached WebGLShader objects\n  getAttachedShaders() {\n    return this.gl.getAttachedShaders(this.handle);\n  }\n\n  // PRIVATE METHODS\n\n  _compileAndLink() {\n    const {gl} = this;\n    gl.attachShader(this.handle, this.vs.handle);\n    gl.attachShader(this.handle, this.fs.handle);\n    log.time(LOG_PROGRAM_PERF_PRIORITY, `linkProgram for ${this._getName()}`);\n    gl.linkProgram(this.handle);\n    log.timeEnd(LOG_PROGRAM_PERF_PRIORITY, `linkProgram for ${this._getName()}`);\n\n    // Avoid checking program linking error in production\n    if (gl.debug || log.priority > 0) {\n      gl.validateProgram(this.handle);\n      const linked = gl.getProgramParameter(this.handle, gl.LINK_STATUS);\n      if (!linked) {\n        throw new Error(`Error linking ${gl.getProgramInfoLog(this.handle)}`);\n      }\n    }\n\n    this._queryAttributeLocations();\n    this._queryUniformLocations();\n  }\n\n  _checkBuffers() {\n    for (const attributeName in this._attributeLocations) {\n      if (!this._filledLocations[attributeName] && !this._warnedLocations[attributeName]) {\n        const location = this._attributeLocations[attributeName];\n        // throw new Error(`Program ${this.id}: ` +\n        //   `Attribute ${location}:${attributeName} not supplied`);\n        log.warn(`Program ${this.id}: Attribute ${location}:${attributeName} not supplied`);\n        this._warnedLocations[attributeName] = true;\n      }\n    }\n    return this;\n  }\n\n  _sortBuffersByLocation(buffers) {\n    let elements = null;\n    const locations = new Array(this._attributeCount);\n\n    for (const bufferName in buffers) {\n      const buffer = buffers[bufferName];\n      const location = this._attributeLocations[bufferName];\n      if (location === undefined) {\n        if (buffer.target === GL.ELEMENT_ARRAY_BUFFER && elements) {\n          throw new Error(`${this._print(bufferName)} duplicate GL.ELEMENT_ARRAY_BUFFER`);\n        } else if (buffer.target === GL.ELEMENT_ARRAY_BUFFER) {\n          elements = bufferName;\n        } else if (!this._warnedLocations[bufferName]) {\n          log.log(2, `${this._print(bufferName)} not used`);\n          this._warnedLocations[bufferName] = true;\n        }\n      } else {\n        if (buffer.target === GL.ELEMENT_ARRAY_BUFFER) {\n          throw new Error(`${this._print(bufferName)}:${location} ` +\n            'has both location and type gl.ELEMENT_ARRAY_BUFFER');\n        }\n        locations[location] = bufferName;\n      }\n    }\n    return {locations, elements};\n  }\n\n  // Check that all active attributes are enabled\n  _areAllAttributesEnabled() {\n    const length = this._attributeCount;\n    for (let i = 0; i < length; ++i) {\n      if (!this.vertexAttributes.isEnabled(i)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  _print(bufferName) {\n    return `Program ${this.id}: Attribute ${bufferName}`;\n  }\n\n  _createHandle() {\n    return this.gl.createProgram();\n  }\n\n  _deleteHandle() {\n    this.gl.deleteProgram(this.handle);\n  }\n\n  _getName() {\n    let programName = this.vs.getName() || this.fs.getName();\n    programName = programName.replace(/shader/i, '');\n    programName = programName ? `${programName}-program` : 'program';\n    return programName;\n  }\n\n  _getOptionsFromHandle(handle) {\n    const shaderHandles = this.gl.getAttachedShaders(handle);\n    const opts = {};\n    for (const shaderHandle of shaderHandles) {\n      const type = this.gl.getShaderParameter(this.handle, GL.SHADER_TYPE);\n      switch (type) {\n      case GL.VERTEX_SHADER:\n        opts.vs = new VertexShader({handle: shaderHandle});\n        break;\n      case GL.FRAGMENT_SHADER:\n        opts.fs = new FragmentShader({handle: shaderHandle});\n        break;\n      default:\n      }\n    }\n    return opts;\n  }\n\n  _getParameter(pname) {\n    return this.gl.getProgramParameter(this.handle, pname);\n  }\n\n  // query attribute locations and build name to location map.\n  _queryAttributeLocations() {\n    this._attributeLocations = {};\n    this._attributeCount = this.getAttributeCount();\n    for (let location = 0; location < this._attributeCount; location++) {\n      const name = this.getAttributeInfo(location).name;\n      this._attributeLocations[name] = this.getAttributeLocation(name);\n    }\n    this._warnedLocations = [];\n    this._filledLocations = {};\n  }\n\n  // query uniform locations and build name to setter map.\n  _queryUniformLocations() {\n    const {gl} = this;\n    this._uniformSetters = {};\n    this._uniformCount = this.getUniformCount();\n    for (let i = 0; i < this._uniformCount; i++) {\n      const info = this.getUniformInfo(i);\n      const parsedName = parseUniformName(info.name);\n      const location = this.getUniformLocation(parsedName.name);\n      this._uniformSetters[parsedName.name] =\n        getUniformSetter(gl, location, info, parsedName.isArray);\n    }\n    this._textureIndexCounter = 0;\n  }\n\n  _setId(id) {\n    // If program is not named, name it after shader names\n    if (!id) {\n      const programName = this._getName();\n      // TODO - this.id will already have been initialized\n      this.id = uid(programName);\n    }\n  }\n}\n\n// create uniform setters\n// Map of uniform names to setter functions\nexport function getUniformDescriptors(gl, program) {\n  const uniformDescriptors = {};\n  const length = program.getUniformCount();\n  for (let i = 0; i < length; i++) {\n    const info = program.getUniformInfo(i);\n    const location = program.getUniformLocation(info.name);\n    const descriptor = getUniformSetter(gl, location, info);\n    uniformDescriptors[descriptor.name] = descriptor;\n  }\n  return uniformDescriptors;\n}\n\n// Get a map of buffer indices\nexport function getVaryingMap(varyings, bufferMode) {\n  const varyingMap = {};\n  let index = 0;\n  for (const varying of varyings) {\n    if (bufferMode === GL.SEPARATE_ATTRIBS) {\n      varyingMap[varyings] = {index};\n      index++;\n    } else if (varying === 'gl_NextBuffer') {\n      index++;\n    } else {\n      // Add a \"safe\" offset as fallback unless app specifies it\n      // Could query\n      varyingMap[varyings] = {index, offset: 16};\n    }\n  }\n  return varyingMap;\n}\n"]}