{"version":3,"sources":["../../src/webgl-utils/create-canvas.js"],"names":["log","isBrowser","window","isPageLoaded","document","readyState","pageLoadPromise","Promise","resolve","reject","onload","getPageLoadPromise","createCanvas","width","height","id","insert","canvas","createElement","style","Number","isFinite","then","body","insertBefore","firstChild","getCanvas","Error","getElementById","getCSSSize","clientWidth","clientHeight","getDrawingBufferSize","calculateDrawingBufferSize","useDevicePixelRatio","useDevicePixels","deprecated","cssToDevicePixels","devicePixelRatio","cssSize","Math","floor","resizeCanvas","resizeDrawingBuffer","newBufferSize"],"mappings":"AAAA;;AAEA;AACA,SAAQA,GAAR,QAAkB,UAAlB;;AAEA,IAAMC,YAAY,OAAOC,MAAP,KAAkB,WAApC;;AAEA,IAAIC,eAAeF,aAAaG,SAASC,UAAT,KAAwB,UAAxD;;AAEA,IAAMC,kBAAkBL,YACtB,IAAIM,OAAJ,CAAY,UAACC,OAAD,EAAUC,MAAV,EAAqB;AAC/B,MAAIN,YAAJ,EAAkB;AAChBK,YAAQJ,QAAR;AACA;AACD;AACDF,SAAOQ,MAAP,GAAgB,YAAM;AACpBP,mBAAe,IAAf;AACAK,YAAQJ,QAAR;AACD,GAHD;AAID,CATD,CADsB,GAWtBG,QAAQC,OAAR,CAAgB,EAAhB,CAXF;;AAaA;;;;;AAKA,OAAO,SAASG,kBAAT,GAA8B;AACnC,SAAOL,eAAP;AACD;;AAED;;;;;AAKA,OAAO,SAASM,YAAT,OAAoF;AAAA,wBAA7DC,KAA6D;AAAA,MAA7DA,KAA6D,8BAArD,GAAqD;AAAA,yBAAhDC,MAAgD;AAAA,MAAhDA,MAAgD,+BAAvC,GAAuC;AAAA,qBAAlCC,EAAkC;AAAA,MAAlCA,EAAkC,2BAA7B,WAA6B;AAAA,yBAAhBC,MAAgB;AAAA,MAAhBA,MAAgB,+BAAP,IAAO;;AACzF,MAAMC,SAASb,SAASc,aAAT,CAAuB,QAAvB,CAAf;AACAD,SAAOF,EAAP,GAAYA,EAAZ;AACAE,SAAOE,KAAP,CAAaN,KAAb,GAAqBO,OAAOC,QAAP,CAAgBR,KAAhB,IAA4BA,KAA5B,UAAwC,MAA7D;AACAI,SAAOE,KAAP,CAAaL,MAAb,GAAsBM,OAAOC,QAAP,CAAgBP,MAAhB,IAA6BA,MAA7B,UAA0C,MAAhE;AACA;AACA,MAAIE,MAAJ,EAAY;AACVL,yBAAqBW,IAArB,CAA0B,oBAAY;AACpC,UAAMC,OAAOnB,SAASmB,IAAtB;AACAA,WAAKC,YAAL,CAAkBP,MAAlB,EAA0BM,KAAKE,UAA/B;AACD,KAHD;AAID;AACD,SAAOR,MAAP;AACD;;AAED;;;;AAIA,OAAO,SAASS,SAAT,QAAyB;AAAA,MAALX,EAAK,SAALA,EAAK;;AAC9B,MAAI,CAACZ,YAAL,EAAmB;AACjB,UAAM,IAAIwB,KAAJ,yCAA+CZ,EAA/C,+BAAN;AACD;AACD,SAAOX,SAASwB,cAAT,CAAwBb,EAAxB,CAAP;AACD;;AAED;AACA,OAAO,SAASc,UAAT,CAAoBZ,MAApB,EAA4B;AACjC,SAAO;AACLJ,WAAOI,OAAOa,WADT;AAELhB,YAAQG,OAAOc;AAFV,GAAP;AAID;;AAED;AACA;AACA,OAAO,SAASC,oBAAT,CAA8Bf,MAA9B,EAAsC;AAC3C,SAAO;AACLJ,WAAOI,OAAOJ,KADT;AAELC,YAAQG,OAAOH;AAFV,GAAP;AAID;;AAED;AACA;AACA;AACA;AACA,OAAO,SAASmB,0BAAT,CAAoChB,MAApC,SAGJ;AAAA,oCAFDiB,mBAEC;AAAA,MAFDA,mBAEC,yCAFqB,IAErB;AAAA,oCADDC,eACC;AAAA,MADDA,eACC,yCADiB,IACjB;;AACD,MAAID,wBAAwB,IAA5B,EAAkC;AAChClC,QAAIoC,UAAJ,CAAe,qBAAf,EAAsC,iBAAtC;AACAD,sBAAkBD,mBAAlB;AACD;AACD,MAAMG,oBAAoBF,kBAAkBjC,OAAOoC,gBAAP,IAA2B,CAA7C,GAAiD,CAA3E;;AAEA;AACA;AACA;AACA,MAAMC,UAAUV,WAAWZ,MAAX,CAAhB;AACA,SAAO;AACLJ,WAAO2B,KAAKC,KAAL,CAAWF,QAAQ1B,KAAR,GAAgBwB,iBAA3B,CADF;AAELvB,YAAQ0B,KAAKC,KAAL,CAAWF,QAAQzB,MAAR,GAAiBuB,iBAA5B,CAFH;AAGLC,sBAAkBD;AAHb,GAAP;AAKD;;AAED;;;;;;;;;;AAUA,OAAO,SAASK,YAAT,CAAsBzB,MAAtB,SAGJ;AAAA,MAFDJ,KAEC,SAFDA,KAEC;AAAA,MADDC,MACC,SADDA,MACC;;AACDG,SAAOE,KAAP,CAAaN,KAAb,GAAwBA,KAAxB;AACAI,SAAOE,KAAP,CAAaL,MAAb,GAAyBA,MAAzB;AACD;;AAED;;;;;;;;;;;;;;AAcA,OAAO,SAAS6B,mBAAT,CAA6B1B,MAA7B,SAGJ;AAAA,oCAFDiB,mBAEC;AAAA,MAFDA,mBAEC,yCAFqB,IAErB;AAAA,oCADDC,eACC;AAAA,MADDA,eACC,yCADiB,IACjB;;AACD;AACA,MAAID,wBAAwB,IAA5B,EAAkC;AAChClC,QAAIoC,UAAJ,CAAe,qBAAf,EAAsC,iBAAtC;AACAD,sBAAkBD,mBAAlB;AACD;AACD;AACA,MAAMU,gBAAgBX,2BAA2BhB,MAA3B,EAAmC,EAACkB,gCAAD,EAAnC,CAAtB;AACA;AACA,MAAIS,cAAc/B,KAAd,KAAwBI,OAAOJ,KAA/B,IAAwC+B,cAAc9B,MAAd,KAAyBG,OAAOH,MAA5E,EAAoF;AAClF;AACAG,WAAOJ,KAAP,GAAe+B,cAAc/B,KAA7B;AACAI,WAAOH,MAAP,GAAgB8B,cAAc9B,MAA9B;AACA;AACA;AACA;AACD;AACF","file":"create-canvas.js","sourcesContent":["// Resizing a webgl canvas\n\n/* global window, document */\nimport {log} from '../utils';\n\nconst isBrowser = typeof window !== 'undefined';\n\nlet isPageLoaded = isBrowser && document.readyState === 'complete';\n\nconst pageLoadPromise = isBrowser ?\n  new Promise((resolve, reject) => {\n    if (isPageLoaded) {\n      resolve(document);\n      return;\n    }\n    window.onload = () => {\n      isPageLoaded = true;\n      resolve(document);\n    };\n  }) :\n  Promise.resolve({});\n\n/**\n * Returns a promise that resolves when the page is loaded\n * at this point the DOM can be manipulated, and e.g. a new canvas can be inserted\n * @return {Promise} - resolves when the page is loaded\n */\nexport function getPageLoadPromise() {\n  return pageLoadPromise;\n}\n\n/**\n * Create a canvas\n * @param {Number} width - set to 100%\n * @param {Number} height - set to 100%\n */\nexport function createCanvas({width = 800, height = 600, id = 'gl-canvas', insert = true}) {\n  const canvas = document.createElement('canvas');\n  canvas.id = id;\n  canvas.style.width = Number.isFinite(width) ? `${width}px` : '100%';\n  canvas.style.height = Number.isFinite(height) ? `${height}px` : '100%';\n  // add the canvas to the body element once the page has loaded\n  if (insert) {\n    getPageLoadPromise().then(document => {\n      const body = document.body;\n      body.insertBefore(canvas, body.firstChild);\n    });\n  }\n  return canvas;\n}\n\n/**\n * Gets an already created canvas from the DOM\n * @param {Number} id - DOM element id\n */\nexport function getCanvas({id}) {\n  if (!isPageLoaded) {\n    throw new Error(`createGLContext called on canvas '${id}' before page was loaded`);\n  }\n  return document.getElementById(id);\n}\n\n// Gets current size of canvas in css (logical/window) coordinates\nexport function getCSSSize(canvas) {\n  return {\n    width: canvas.clientWidth,\n    height: canvas.clientHeight\n  };\n}\n\n// Gets current size of canvas drawing buffer in actual pixels\n// This is needed for the gl.viewport call\nexport function getDrawingBufferSize(canvas) {\n  return {\n    width: canvas.width,\n    height: canvas.height\n  };\n}\n\n// Calculate the drawing buffer size that would cover current canvas size and device pixel ratio\n// Intention is that every pixel in the drawing buffer will have a 1-to-1 mapping with\n// actual device pixels in the hardware framebuffer, allowing us to render at the full\n// resolution of the device.\nexport function calculateDrawingBufferSize(canvas, {\n  useDevicePixelRatio = null, // deprecated\n  useDevicePixels = true\n}) {\n  if (useDevicePixelRatio !== null) {\n    log.deprecated('useDevicePixelRatio', 'useDevicePixels');\n    useDevicePixels = useDevicePixelRatio;\n  }\n  const cssToDevicePixels = useDevicePixels ? window.devicePixelRatio || 1 : 1;\n\n  // Lookup the size the browser is displaying the canvas in CSS pixels\n  // and compute a size needed to make our drawingbuffer match it in\n  // device pixels.\n  const cssSize = getCSSSize(canvas);\n  return {\n    width: Math.floor(cssSize.width * cssToDevicePixels),\n    height: Math.floor(cssSize.height * cssToDevicePixels),\n    devicePixelRatio: cssToDevicePixels\n  };\n}\n\n/**\n * Resizes canvas in \"CSS coordinates\" (note these can be very different from device coords,\n * depending on devicePixelRatio/retina screens and size of drawing buffer)\n * and can be changed separately from drawing buffer size.\n * Therefore, normally `resizeDrawingBuffer` should be called after calling `resizeCanvas`.\n *\n * See http://webgl2fundamentals.org/webgl/lessons/webgl-resizing-the-canvas.html\n *\n * @param {Number} width, height - new width and height of canvas in CSS coordinates\n */\nexport function resizeCanvas(canvas, {\n  width,\n  height\n}) {\n  canvas.style.width = `${width}px`;\n  canvas.style.height = `${height}px`;\n}\n\n/**\n * Resize the canvas' drawing buffer to match the canvas CSS size,\n * and by default to also consider devicePixelRatio\n * detects if anything has changed, can be called every frame\n * for best visual results, usually set to either:\n *  canvas CSS width x canvas CSS height\n *  canvas CSS width * devicePixelRatio x canvas CSS height * devicePixelRatio\n *\n * NOTE: Regardless of size, the drawing buffer will always be scaled to the viewport\n * See http://webgl2fundamentals.org/webgl/lessons/webgl-resizing-the-canvas.html\n *\n * @param {Number} width - new width of canvas in CSS coordinates\n * @param {Number} height - new height of canvas in CSS coordinates\n */\nexport function resizeDrawingBuffer(canvas, {\n  useDevicePixelRatio = null, // deprecated\n  useDevicePixels = true\n}) {\n  // Resize the render buffer of the canvas to match canvas client size\n  if (useDevicePixelRatio !== null) {\n    log.deprecated('useDevicePixelRatio', 'useDevicePixels');\n    useDevicePixels = useDevicePixelRatio;\n  }\n  // multiplying with dpr (Optionally can be turned off)\n  const newBufferSize = calculateDrawingBufferSize(canvas, {useDevicePixels});\n  // Only update if the canvas size has not changed\n  if (newBufferSize.width !== canvas.width || newBufferSize.height !== canvas.height) {\n    // Make the canvas render buffer the same size as\n    canvas.width = newBufferSize.width;\n    canvas.height = newBufferSize.height;\n    // Always reset CSS size after setting drawing buffer size\n    // canvas.style.width = `${cssSize.width}px`;\n    // canvas.style.height = `${cssSize.height}px`;\n  }\n}\n"]}