{"version":3,"sources":["../../src/utils/typed-array-utils.js"],"names":["getGLTypeFromTypedArray","getTypedArrayFromGLType","flipRows","scalePixels","GL_BYTE","GL_UNSIGNED_BYTE","GL_SHORT","GL_UNSIGNED_SHORT","GL_INT","GL_UNSIGNED_INT","GL_FLOAT","GL_UNSIGNED_SHORT_4_4_4_4","GL_UNSIGNED_SHORT_5_5_5_1","GL_UNSIGNED_SHORT_5_6_5","ERR_TYPE_DEDUCTION","arrayOrType","type","ArrayBuffer","isView","constructor","Float32Array","Uint16Array","Uint32Array","Uint8Array","Uint8ClampedArray","Int8Array","Int16Array","Int32Array","Error","glType","clamped","data","width","height","bytesPerPixel","temp","bytesPerRow","y","topOffset","bottomOffset","set","subarray","copyWithin","newWidth","Math","round","newHeight","newData","x","c"],"mappings":";;;;;QAgBgBA,uB,GAAAA,uB;QAqBAC,uB,GAAAA,uB;QA6BAC,Q,GAAAA,Q;QAiBAC,W,GAAAA,W;AAnFhB;AACA,IAAMC,UAAU,MAAhB;AACA,IAAMC,mBAAmB,MAAzB;AACA,IAAMC,WAAW,MAAjB;AACA,IAAMC,oBAAoB,MAA1B;AACA,IAAMC,SAAS,MAAf;AACA,IAAMC,kBAAkB,MAAxB;AACA,IAAMC,WAAW,MAAjB;AACA,IAAMC,4BAA4B,MAAlC;AACA,IAAMC,4BAA4B,MAAlC;AACA,IAAMC,0BAA0B,MAAhC;;AAEA,IAAMC,qBAAqB,+CAA3B;;AAEA;AACA;AACO,SAASd,uBAAT,CAAiCe,WAAjC,EAA8C;AACnD;AACA,MAAMC,OAAOC,YAAYC,MAAZ,CAAmBH,WAAnB,IAAkCA,YAAYI,WAA9C,GAA4DJ,WAAzE;AACA,UAAQC,IAAR;AACA,SAAKI,YAAL;AAAmB,aAAOV,QAAP;AACnB,SAAKW,WAAL;AAAkB,aAAOd,iBAAP;AAClB,SAAKe,WAAL;AAAkB,aAAOb,eAAP;AAClB,SAAKc,UAAL;AAAiB,aAAOlB,gBAAP;AACjB,SAAKmB,iBAAL;AAAwB,aAAOnB,gBAAP;AACxB,SAAKoB,SAAL;AAAgB,aAAOrB,OAAP;AAChB,SAAKsB,UAAL;AAAiB,aAAOpB,QAAP;AACjB,SAAKqB,UAAL;AAAiB,aAAOnB,MAAP;AACjB;AACE,YAAM,IAAIoB,KAAJ,CAAUd,kBAAV,CAAN;AAVF;AAYD;;AAED;AACA;;AAEA;AACO,SAASb,uBAAT,CAAiC4B,MAAjC,EAAgE;AAAA,iFAAJ,EAAI;AAAA,0BAAtBC,OAAsB;AAAA,MAAtBA,OAAsB,gCAAZ,IAAY;;AACrE;AACA,UAAQD,MAAR;AACA,SAAKnB,QAAL;AACE,aAAOU,YAAP;AACF,SAAKb,iBAAL;AACA,SAAKM,uBAAL;AACA,SAAKF,yBAAL;AACA,SAAKC,yBAAL;AACE,aAAOS,WAAP;AACF,SAAKZ,eAAL;AACE,aAAOa,WAAP;AACF,SAAKjB,gBAAL;AACE,aAAOyB,UAAUN,iBAAV,GAA8BD,UAArC;AACF,SAAKnB,OAAL;AACE,aAAOqB,SAAP;AACF,SAAKnB,QAAL;AACE,aAAOoB,UAAP;AACF,SAAKlB,MAAL;AACE,aAAOmB,UAAP;AACF;AACE,YAAM,IAAIC,KAAJ,CAAU,oDAAV,CAAN;AAnBF;AAqBD;AACD;;AAEA;AACA;AACA;AACO,SAAS1B,QAAT,QAAkE;AAAA,MAA/C6B,IAA+C,SAA/CA,IAA+C;AAAA,MAAzCC,KAAyC,SAAzCA,KAAyC;AAAA,MAAlCC,MAAkC,SAAlCA,MAAkC;AAAA,kCAA1BC,aAA0B;AAAA,MAA1BA,aAA0B,uCAAV,CAAU;AAAA,MAAPC,IAAO,SAAPA,IAAO;;AACvE,MAAMC,cAAcJ,QAAQE,aAA5B;;AAEA;AACAC,SAAOA,QAAQ,IAAIZ,UAAJ,CAAea,WAAf,CAAf;AACA,OAAK,IAAIC,IAAI,CAAb,EAAgBA,IAAIJ,SAAS,CAA7B,EAAgC,EAAEI,CAAlC,EAAqC;AACnC,QAAMC,YAAYD,IAAID,WAAtB;AACA,QAAMG,eAAe,CAACN,SAASI,CAAT,GAAa,CAAd,IAAmBD,WAAxC;AACA;AACAD,SAAKK,GAAL,CAAST,KAAKU,QAAL,CAAcH,SAAd,EAAyBA,YAAYF,WAArC,CAAT;AACA;AACAL,SAAKW,UAAL,CAAgBJ,SAAhB,EAA2BC,YAA3B,EAAyCA,eAAeH,WAAxD;AACA;AACAL,SAAKS,GAAL,CAASL,IAAT,EAAeI,YAAf;AACD;AACF;;AAEM,SAASpC,WAAT,QAA4C;AAAA,MAAtB4B,IAAsB,SAAtBA,IAAsB;AAAA,MAAhBC,KAAgB,SAAhBA,KAAgB;AAAA,MAATC,MAAS,SAATA,MAAS;;AACjD,MAAMU,WAAWC,KAAKC,KAAL,CAAWb,QAAQ,CAAnB,CAAjB;AACA,MAAMc,YAAYF,KAAKC,KAAL,CAAWZ,SAAS,CAApB,CAAlB;AACA,MAAMc,UAAU,IAAIxB,UAAJ,CAAeoB,WAAWG,SAAX,GAAuB,CAAtC,CAAhB;AACA,OAAK,IAAIT,IAAI,CAAb,EAAgBA,IAAIS,SAApB,EAA+BT,GAA/B,EAAoC;AAClC,SAAK,IAAIW,IAAI,CAAb,EAAgBA,IAAIL,QAApB,EAA8BK,GAA9B,EAAmC;AACjC,WAAK,IAAIC,IAAI,CAAb,EAAgBA,IAAI,CAApB,EAAuBA,GAAvB,EAA4B;AAC1BF,gBAAQ,CAACV,IAAIM,QAAJ,GAAeK,CAAhB,IAAqB,CAArB,GAAyBC,CAAjC,IAAsClB,KAAK,CAACM,IAAI,CAAJ,GAAQL,KAAR,GAAgBgB,IAAI,CAArB,IAA0B,CAA1B,GAA8BC,CAAnC,CAAtC;AACD;AACF;AACF;AACD,SAAO,EAAClB,MAAMgB,OAAP,EAAgBf,OAAOW,QAAvB,EAAiCV,QAAQa,SAAzC,EAAP;AACD","file":"typed-array-utils.js","sourcesContent":["// GL Constants\nconst GL_BYTE = 0x1400;\nconst GL_UNSIGNED_BYTE = 0x1401;\nconst GL_SHORT = 0x1402;\nconst GL_UNSIGNED_SHORT = 0x1403;\nconst GL_INT = 0x1404;\nconst GL_UNSIGNED_INT = 0x1405;\nconst GL_FLOAT = 0x1406;\nconst GL_UNSIGNED_SHORT_4_4_4_4 = 0x8033;\nconst GL_UNSIGNED_SHORT_5_5_5_1 = 0x8034;\nconst GL_UNSIGNED_SHORT_5_6_5 = 0x8363;\n\nconst ERR_TYPE_DEDUCTION = 'Failed to deduce GL constant from typed array';\n\n// Converts TYPED ARRAYS to corresponding GL constant\n// Used to auto deduce gl parameter types\nexport function getGLTypeFromTypedArray(arrayOrType) {\n  // If typed array, look up constructor\n  const type = ArrayBuffer.isView(arrayOrType) ? arrayOrType.constructor : arrayOrType;\n  switch (type) {\n  case Float32Array: return GL_FLOAT;\n  case Uint16Array: return GL_UNSIGNED_SHORT;\n  case Uint32Array: return GL_UNSIGNED_INT;\n  case Uint8Array: return GL_UNSIGNED_BYTE;\n  case Uint8ClampedArray: return GL_UNSIGNED_BYTE;\n  case Int8Array: return GL_BYTE;\n  case Int16Array: return GL_SHORT;\n  case Int32Array: return GL_INT;\n  default:\n    throw new Error(ERR_TYPE_DEDUCTION);\n  }\n}\n\n// Converts GL constant to corresponding TYPED ARRAY\n// Used to auto deduce gl parameter types\n\n/* eslint-disable complexity */\nexport function getTypedArrayFromGLType(glType, {clamped = true} = {}) {\n  // Sorted in some order of likelihood to reduce amount of comparisons\n  switch (glType) {\n  case GL_FLOAT:\n    return Float32Array;\n  case GL_UNSIGNED_SHORT:\n  case GL_UNSIGNED_SHORT_5_6_5:\n  case GL_UNSIGNED_SHORT_4_4_4_4:\n  case GL_UNSIGNED_SHORT_5_5_5_1:\n    return Uint16Array;\n  case GL_UNSIGNED_INT:\n    return Uint32Array;\n  case GL_UNSIGNED_BYTE:\n    return clamped ? Uint8ClampedArray : Uint8Array;\n  case GL_BYTE:\n    return Int8Array;\n  case GL_SHORT:\n    return Int16Array;\n  case GL_INT:\n    return Int32Array;\n  default:\n    throw new Error('Failed to deduce typed array type from GL constant');\n  }\n}\n/* eslint-enable complexity */\n\n// Flip rows (can be used on arrays returned from `Framebuffer.readPixels`)\n// https://stackoverflow.com/questions/41969562/\n// how-can-i-flip-the-result-of-webglrenderingcontext-readpixels\nexport function flipRows({data, width, height, bytesPerPixel = 4, temp}) {\n  const bytesPerRow = width * bytesPerPixel;\n\n  // make a temp buffer to hold one row\n  temp = temp || new Uint8Array(bytesPerRow);\n  for (let y = 0; y < height / 2; ++y) {\n    const topOffset = y * bytesPerRow;\n    const bottomOffset = (height - y - 1) * bytesPerRow;\n    // make copy of a row on the top half\n    temp.set(data.subarray(topOffset, topOffset + bytesPerRow));\n    // copy a row from the bottom half to the top\n    data.copyWithin(topOffset, bottomOffset, bottomOffset + bytesPerRow);\n    // copy the copy of the top half row to the bottom half\n    data.set(temp, bottomOffset);\n  }\n}\n\nexport function scalePixels({data, width, height}) {\n  const newWidth = Math.round(width / 2);\n  const newHeight = Math.round(height / 2);\n  const newData = new Uint8Array(newWidth * newHeight * 4);\n  for (let y = 0; y < newHeight; y++) {\n    for (let x = 0; x < newWidth; x++) {\n      for (let c = 0; c < 4; c++) {\n        newData[(y * newWidth + x) * 4 + c] = data[(y * 2 * width + x * 2) * 4 + c];\n      }\n    }\n  }\n  return {data: newData, width: newWidth, height: newHeight};\n}\n"]}